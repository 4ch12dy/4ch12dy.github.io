<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!--Description-->
  
  <meta name="description" content="给我一点时间和power">
  

  <!--Author-->
  
  <meta name="author" content="4ch12dy">
  

  <!--Open Graph Title-->
  
      <meta property="og:title" content="浅谈SSD与安全擦除"/>
  
  <!--Open Graph Description-->
  
      <meta property="og:description" content="给我一点时间和power" />
  
  <!--Open Graph Site Name-->
  <meta property="og:site_name" content="4ch12dy"/>
  <!--Type page-->
  
      <meta property="og:type" content="article" />
  
  <!--Page Cover-->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- 百度统计 -->
    <script>
	var _hmt = _hmt || [];
	(function() {
  	var hm = document.createElement("script");
  	hm.src = "https://hm.baidu.com/hm.js?c0451e16533956173997b85f7a8de666";
  	var s = document.getElementsByTagName("script")[0]; 
  	s.parentNode.insertBefore(hm, s);
	})();
    </script>
  <!-- Title -->
  
  <title>浅谈SSD与安全擦除 - 4ch12dy</title>


  <link rel="shortcut icon" href="../../../../../favicon.ico">
    <!--font-awesome-->
  <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <!-- Custom CSS/Sass -->
  <link rel="stylesheet" href="../../../../../css/style.css">

</head>


<body>

  <!-- Nav -->
  <header class="site-header">
  <div class="header-inside">
    
    <div class="logo">
      <a href="../../../../../index.html" rel="home">
        
        <img src="http://oct3pmpde.bkt.clouddn.com/timg.jpg" alt="4ch12dy" height="60">
        
      </a>
    </div>
    <a class="header-name" href="../../../../../index.html">
            <span>4ch12dy</span>
            的部落宅
        </a>
    <!-- navbar -->
    <nav class="navbar">
      <!--  nav links -->
      <div class="collapse">
        <ul class="navbar-nav">
          
          
            <li>
              <a href="../../../../../.">
                
                  <i class="fa fa-home "></i>
                
                首页
              </a>
            </li>
          
            <li>
              <a href="../../../../../archives">
                
                  <i class="fa fa-archive "></i>
                
                归档
              </a>
            </li>
          
            <li>
              <a href="../../../../../about">
                
                  <i class="fa fa-user "></i>
                
                关于
              </a>
            </li>
          
            <li>
              <a href="../../../../../project">
                
                  <i class="fa fa-folder-open "></i>
                
                项目
              </a>
            </li>
          
            <li>
              <a href="../../../../../photo">
                
                  <i class="fa fa-photo "></i>
                
                相册
              </a>
            </li>
          
            <li>
              <a href="../../../../../guestbook">
                
                  <i class="fa fa-edit "></i>
                
                留言
              </a>
            </li>
          
            <li>
              <a href="../../../../../atom.xml">
                
                  <i class="fa fa-send "></i>
                
                RSS
              </a>
            </li>
          
        </ul>
      </div>
      <!-- /.navbar-collapse -->
    </nav>
    <div class="button-wrap">
      <button class="menu-toggle">Primary Menu</button>
    </div>
  </div>
</header>


  <!-- Main Content -->
  <div class="content-area">
  <div class="post">
    <!-- Post Content -->
    <div class="container">
      <article>
        <!-- Title date & tags -->
        <div class="post-header">
          <h1 class="entry-title">
            浅谈SSD与安全擦除
            
          </h1>
         
        </div>
         <p class="a-posted-on">
          2017-08-08
          </p>
        <!-- Post Main Content -->
        <div class="entry-content">
          <h2 id="SSD与安全擦除"><a href="#SSD与安全擦除" class="headerlink" title="SSD与安全擦除"></a>SSD与安全擦除</h2><blockquote>
<blockquote>
<p>目录<br>0x01 SSD简介<br>0x02 SSD安全擦除原理及工具<br>0x03 参考</p>
</blockquote>
</blockquote>
<h3 id="0x01-SSD简介"><a href="#0x01-SSD简介" class="headerlink" title="0x01 SSD简介"></a>0x01 SSD简介</h3><h4 id="1-1-SSD的组成结构"><a href="#1-1-SSD的组成结构" class="headerlink" title="1.1    SSD的组成结构"></a>1.1    SSD的组成结构</h4><p>SSD 的关键部件由控制器和存储单元两部分组成。除此之外，还有缓存和主机接口。</p>
<h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>每个 SSD 都有一个控制器(controller)将存储单元连接到电脑。控制器是一个执行固件(firmware)代码的嵌入式处理器。主要功能如下：</p>
<ul>
<li>错误检查和纠正(ECC)</li>
<li>磨损平衡(Wear leveling)</li>
<li>坏块映射(Bad block mapping)</li>
<li>read disturb(读取某个块的数据的时候会影响到相邻块的数据)管理</li>
<li>缓存控制</li>
<li>垃圾回收</li>
<li>加密</li>
</ul>
<h5 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h5><p>SSD固态硬盘，存储介质和机械硬盘完全不同，其依靠三极管的充放电实现，而非磁场。<br>目前，介质主要有三种：SLC，MLC和TLC</p>
<ul>
<li>SLC=Single-LevelCell，即1bit/cell，速度快寿命长，价格超贵（约MLC3倍以上的价格），约10万次擦写寿命 </li>
<li>MLC=Multi-LevelCell，即2bit/cell，速度一般寿命一般，价格一般，约3000—10000次擦写寿命 </li>
<li>TLC=Trinary-LevelCell，即3bit/cell，也有Flash厂家叫8LC，速度慢寿命短，价格便宜，约500次擦写寿命。</li>
</ul>
<p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/smt.jpg?raw=true" alt="0-1"></p>
<p>每cell可存储的比特位表示了存储的能力，可以看出TLC的每cell存储能力最强，一个cell可以存储3比特，但相对的，TLC的寿命最短，即可擦写次数最少。当擦写次数达到寿命值时，读写数据将不再有效，具体的寿命可以参考具体闪存颗粒数据手册。</p>
<p>在机械硬盘上，由于机械硬盘的数据可以直接覆盖，所以LBA和PBA(Physical Block Address)的关系是1:1对应，不会变更，即LBA=PBA。但在SSD上，这种关系就变得复杂了，原因是SSD使用的存储介质NAND闪存有需要先擦除才能再写入，因为读写以页为单位，擦除以块（多个页组成）为单位的特性，导致LBA和PBA的关系不再是固定不变的。<br>NAND闪存的擦除/写入关系请参考下图：</p>
<p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/0-0.png?raw=true" alt="0-0"></p>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>基于 NAND 闪存的 SSD 通常带有一个基于 DRAM 的缓存，其作用与普通的机械式硬盘类似，但是还会存储一些诸如 Wear leveling 数据之类的其他数据。把数据先缓存在 DRAM 中，然后集中写入，从而减少写入次数。特例之一是 SandForce 生产的控制器，它并不含有缓存，但是性能依旧很出色，由于其结构简单，故而可以生产体积更小的 SSD，并且掉电时数据更安全。</p>
<h5 id="主机接口"><a href="#主机接口" class="headerlink" title="主机接口"></a>主机接口</h5><p>主机接口与控制器紧密相关，但是通常与传统的机械式硬盘相差不大，主要有以下几种：</p>
<ul>
<li>SATA</li>
<li>SAS</li>
<li>PCI-E</li>
<li>Fibre Channel</li>
<li>USB</li>
</ul>
<p>主机接口的速度限制了 SSD 所能达到的速度峰值。但是一般这并不是瓶颈所在。</p>
<h4 id="1-2-SSD-技术解析"><a href="#1-2-SSD-技术解析" class="headerlink" title="1.2 SSD 技术解析"></a>1.2 SSD 技术解析</h4><h5 id="FTL（Flash-translation-layer）"><a href="#FTL（Flash-translation-layer）" class="headerlink" title="FTL（Flash translation layer）"></a>FTL（Flash translation layer）</h5><p>前面说过，闪存的读写单位为页，而页的大小一般为4KB或8KB，但我们的操作系统读写数据是按机械硬盘的扇区尺寸进行的（512Byte），更麻烦的是闪存擦除以块作单位，而且未擦除就无法写入，这导致操作系统现在使用的文件系统根本无法管理SSD，需要更换更先进、复杂的文件去解决这个问题，但这样就会加重操作系统的负担。 </p>
<p>为了不加重操作系统的负担，SSD采用软件的方式把闪存的操作虚拟成磁盘的独立扇区操作，这就是FTL。因FTL存在于文件系统和物理介质（闪存）之间，操作系统只需跟原来一样操作LBA即可，而LBA到PBA的所有转换工作，就全交由FTL负责。</p>
<p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/0-1.png?raw=true" alt="0-1"></p>
<p>FTL算法，其实就是一种LBA到PBA的映射。当文件系统发送指令要写入或者更新一个特定的逻辑页时，FTL实际上是把数据写入到一个不同的空闲物理页并更新映射表（LBA和PBA的关联数据），并把这个页上包含的“旧数据”标记为“无效”（更新后的数据已经写入新的PBA，旧地址的数据自然就失效了）。正是因为FTL的存在，操作系统才能把SSD当成HDD那样操作，因此FTL转换的性能也就直接影响SSD的性能表现。</p>
<p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/0-2.png?raw=true" alt="0-2"></p>
<p>我们现在看上图，假设在page0上写入数据(物理地址n）,接下来写入数据到page1(物理地址n+1)。接着page0数据被更新，但是更新后的数据并不是覆盖上去，FTL会把它写入到地址(n+2)上，然后标记(地址n)为“无效”。经过多次这样的操作后，这个块上就会装满了许多“有效”及“无效”的数据。如果要再次写入到这个块，就需要先擦除整个块的数据，当然就需要先把所有“有效”的数据复制到另外的空白块上再进行擦除。这样的操作就是GC（Garbagecollection）垃圾回收。</p>
<h4 id="WL（Wear-leveling）磨损平衡"><a href="#WL（Wear-leveling）磨损平衡" class="headerlink" title="WL（Wear leveling）磨损平衡"></a>WL（Wear leveling）磨损平衡</h4><p>简单说来，磨损平衡是确保闪存的每个块被写入的次数相等的一种机制。</p>
<p>通常情况下，在 NAND 块里的数据更新频度是不同的：有些会经常更新，有些则不常更新。很明显，那些经常更新的数据所占用的块会被快速的磨损掉，而不常更新的数据占用的块磨损就小得多。为了解决这个问题，需要让每个块的编程(擦写)次数尽可能保持一致：这就是需要对每个页的读取/编程操作进行监测，在最乐观的情况下，这个技术会让全盘的颗粒物理磨损程度相同并同时报废。</p>
<p>磨损平衡算法分静态和动态。动态磨损算法是基本的磨损算法：只有用户在使用中更新的文件占用的物理页地址被磨损平衡了。而静态磨损算法是更高级的磨损算法：在动态磨损算法的基础上，增加了对于那些不常更新的文件占用的物理地址进行磨损平衡，这才算是真正的全盘磨损平衡。简单点说来，动态算法就是每次都挑最年轻的 NAND 块来用，老的 NAND 块尽量不用。静态算法就是把长期没有修改的老数据从一个年轻 NAND 块里面搬出来，重新找个最老的 NAND 块放着，这样年轻的 NAND 块就能再度进入经常使用区。概念很简单，但实现却非常的复杂，特别是静态。</p>
<p>尽管磨损均衡的目的是避免数据重复在某个空间写入，以保证各个存储区域内磨损程度基本一致，从而达到延长固态硬盘的目的。但是，它对固态硬盘的性能有不利影响。</p>
<h4 id="GC（Garbagecollection）垃圾回收"><a href="#GC（Garbagecollection）垃圾回收" class="headerlink" title="GC（Garbagecollection）垃圾回收"></a>GC（Garbagecollection）垃圾回收</h4><p>所谓GC就是把一个闪存块里的‘有效’页数据复制到一个‘空白’块里，然后把这个块完全擦除。GC是SSD里的一个非常关键的操作，其效率对性能有决定性影响。闪存块里‘有效’页的数量对GC效率有决定性的影响，因数量越少，需要复制的页就越少， 花费的时间也越少，效率就高了。</p>
<p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/gc_1.jpg?raw=true" alt="0-2"></p>
<p>下图是把X块和Y块里的“有效”页复制到N块里，然后擦除X和Y以作备用的“空白块”</p>
<p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/gc_2.png?raw=true" alt="0-2"></p>
<p>有三种垃圾回收策略：</p>
<ul>
<li>闲置垃圾回收：很明显在进行垃圾回收时候会消耗大量的主控处理能力和带宽造成处理用户请求的性能下降，SSD 主控制器可以设置在系统闲置时候做“预先”垃圾回收(提前做垃圾回收操作)，保证一定数量的”备用空白块”，让 SSD 在运行时候能够保持较高的性能。闲置垃圾回收的缺点是会增加额外的”写入放大”，因为你刚刚垃圾回收的”有效数据”，也许马上就会被更新后的数据替代而变成”无效数据”，这样就造成之前的垃圾回收做无用功了。</li>
<li>被动垃圾回收：每个 SSD 都支持的技术，但是对主控制器的性能提出了很高的要求，适合在服务器里用到，SandForce 的主控就属这类。在垃圾回收操作消耗带宽和处理能力的同时处理用户操作数据，如果没有足够强劲的主控制器性能则会造成明显的速度下降。这就是为啥很多 SSD 在全盘写满一次后会出现性能下降的道理，因为要想继续写入数据就必须要边垃圾回收边做写入。</li>
<li>手动垃圾回收：用户自己手动选择合适的时机运行垃圾回收软件，执行垃圾回收操作。</li>
</ul>
<p>可以想象，如果系统经常进行垃圾回收处理，频繁的将一些区块进行擦除操作，那么 SSD 的寿命反而也会进一步下降。由此把握这个垃圾回收的频繁程度，同时确保 SSD 中的闪存芯片拥有更高的使用寿命，这确实需要找到一个完美的平衡点。所以，SSD 必须要支持 Trim 技术，不然 GC 就显不出他的优势了。</p>
<h4 id="Trim"><a href="#Trim" class="headerlink" title="Trim"></a>Trim</h4><p>Trim 是一个 ATA 指令，当操作系统删除文件或格式化的时候，由操作系统同时把这个文件地址发送给 SSD 的主控制器，让主控制器知道这个地址的数据无效了。</p>
<p>当你删除一个文件的时候，文件系统其实并不会真正去删除它，而只是把这个文件地址标记为“已删除”，可以被再次使用，这意味着这个文件占的地址已经是“无效”的了。这就会带来一个问题，硬盘并不知道操作系统把这个地址标记为“已删除”了，机械盘的话无所谓，因为可以直接在这个地址上重新覆盖写入，但是到了 SSD 上问题就来了。NAND 需要先擦除才能再次写入数据，要得到空闲的 NAND 空间，SSD 必须复制所有的有效页到新的空闲块里，并擦除旧块(垃圾回收)。如果没有 Trim 指令，意味着 SSD 主控制器不知道这个页是“无效”的，除非再次被操作系统要求覆盖上去。</p>
<p>Trim 只是条指令，让操作系统告诉 SSD 主控制器这个页已经“无效”了。Trim 会减少写入放大，因为主控制器不需要复制“无效”的页(没 Trim 就是“有效”的)到空白块里，这同时代表复制的“有效”页变少了，垃圾回收的效率和 SSD 性能也提升了。</p>
<p>Trim 能大量减少伪有效页的数量，它能大大提升垃圾回收的效率。</p>
<p>目前，支持 Trim 需要三个要素，缺一不可：</p>
<ul>
<li>系统： 操作系统必须会发送 Trim 指令，Win7, Win2008R2 , Linux-2.6.33 以上。</li>
<li>固件： SSD 的厂商在固件里要放有 Trim 算法，也就是 SSD 的主控制器必须认识 Trim 指令。</li>
<li>驱动： 控制器驱动必须要支持 Trim 指令的传输，也就是能够将 Trim 指令传输到 SSD 控制器。MS 的驱动，Intel 的 AHCI 驱动目前支持。别的要看之后的更新了。<br>目前，RAID 阵列里的盘明确不支持 TRIM，不过 RAID 阵列支持 GC。</li>
</ul>
<h4 id="OP（Over-provisioning）预留空间"><a href="#OP（Over-provisioning）预留空间" class="headerlink" title="OP（Over-provisioning）预留空间"></a>OP（Over-provisioning）预留空间</h4><p>SSD上的OP指的是用户不可操作的容量，大小为实际容量减去用户可用容量，OP区域一般被用于优化操作如：WL，GC和坏块映射等。<br>OP一般分三层（见下图）。第一层容量固定为SSD标称容量的7.37%，这是因为标称容量采用千进制为单位，而NAND颗粒容量单位为1024进制，两者正好相差约7.37%。这部分空间被默认用于作OP。第二层OP是否存在及容量大小取决于厂商设置。第三层OP是用户在日常使用中可以分配的，像Fusion-IO公司还给其用户提供工具让他们自行调节大小以满足不同的耐用度及性能要求，一般用户也可以自己在初次分区的时候，不把所有的SSD容量都分满来达到相同目的，此处有一点要注意，若非首次分区就留出空间，必须要先进行全盘擦除，否则没有效果。</p>
<p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/op_1.png?raw=true" alt="po1"></p>
<p>虽然OP会减少SSD的可用容量，但有减少WA、提高寿命、性能的正面作用。请看下图：两个相同的64G SSD，左边的分区50G，右边的全部容量分区。格式化后容量分别为：46G和59G左右。</p>
<p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/op_2.png?raw=true" alt="po2"></p>
<p>我们知道在操作系统下,要写入共59G的数据时，左边的盘必须删除13G的‘无效’数据才行。右边的盘不需擦除就能写入所有59G数据，由SSD映射表的操作方式可知，删除后继续写入的数据在物理上会继续写入整个盘（写入OP1和OP2），在LBA上会覆盖被删除数据的地址。也就是说，同样写入59G数据，左边的盘已经包含了13G“无效”数据了。（那些被重映射到预留空间的数据，原地址数据就是“无效”、“过期”的）。所以说图中SSD里LBA上数据“有效”的机会比右边要少，因为LBA容量小(分区小)，所以在做垃圾回收处理时，需要复制的“有效”数据也少了，自然效率就提高了。<br>一般来说，建议在不支持Trim或对SSD的性能有较高要求的时候，如数据库等类的应用，增加一定比例的第三层OP容量（此空间需要先做HDD ERASE，保证没有被使用过），可以很好的起到保持速度，提高寿命的作用。（如必须用SSD组建RAID时，强烈建议留部分OP容量以弥补没有Trim产生的影响。）</p>
<h4 id="WA（Write-Amplification）写入放大"><a href="#WA（Write-Amplification）写入放大" class="headerlink" title="WA（Write Amplification）写入放大"></a>WA（Write Amplification）写入放大</h4><p>WA是闪存及SSD相关的一个极为重要的属性。由于闪存必须先擦除才能再写入的特性，在执行这些操作时，数据都会被移动超过1次。这些重复的操作不单会增加写入的数据量，还会减少闪存的寿命，更吃光闪存的可用带宽而间接影响随机写入性能。<br>举个最简单的栗子：当要写入一个4KB的数据时，最坏的情况是一个块里已经没有干净空间了，但有无效的数据可以擦除，所以主控就把所有的数据读到缓存，擦除块，缓存里更新整个块的数据，再把新数据写回去，这个操作带来的写入放大就是: 实际写4K的数据，造成了整个块（共1024KB）的写入操作，那就是放大了256倍。同时还带来了原本只需要简单一步写入4KB的操作变成：闪存读取 (1024KB)→缓存改（4KB）→闪存擦除（1024KB）→闪存写入（1024KB），共四步操作，造成延迟大大增加，速度变慢。所以说WA是影响 SSD随机写入性能和寿命的关键因素。  </p>
<p>以100%随机4KB来写入，目前的大多数SSD主控，在最坏的情况下WA可以达到100以上。如果是100%持续的从低LBA写入到高LBA的话，WA可以做到1，实际使用中写入放大会介于这两者之间。<br>用户还可以设置一定的OP（预留空间）来减少WA，假设你有个128G的SSD，你只分了64G 的容量使用，那最坏情况下的写入放大就能减少约3倍。<br>许多因素影响SSD的WA。下面列出主要的因素，以及它们如何影响WA。</p>
<ol>
<li>垃圾回收（GC）— 虽然增加了写入放大，但是速度有提升。 这个比较特殊的算法用来移动，合并，擦除闪存块来提升效率。（详见GC章节）</li>
<li>预留空间（OP）— 减少写入放大。（预留空间越大，写入放大越低） 在SSD上划出部分空间留给主控做优化，是用户不能操作的空间。（详见OP章节）</li>
<li>Trim 开启后可以减少写入放大。 一个ATA指令，由操作系统发送给SSD主控，告诉主控哪些数据是无效的并且可以不用做垃圾回收操作。（详见Trim章节）</li>
<li>可用容量减少写入放大。（可用空间越大，写入放大越低） 用户使用中没有用到的空间。（需要有Trim支持，不然不会影响写入放大。）</li>
<li>安全擦除 Secure Erase 减少写入放大， ATA安全擦除命令用来清除在磁盘上的所有用户数据，这个指令会让SSD回到出厂时的性能（最优性能，最少写入放大），但是随着使用时间变长，GC操作恢复后，写入放大又会慢慢增加回来。许多软件使用ATA安全擦除指令来重置磁盘，最著名的为HDDErase。对SSD来说，重置就是（除了OP区域内的部分私有区域外的）全盘擦除操作，瞬间即可完成清除所有数据让SSD回到初始状态。但要注意，每操作一次，全盘寿命P/E次数减1。</li>
<li>持续写入（Sequential writes）减少写入放大。理论上来说，持续写入的写入放大为1，但是某些因素还是会影响这个数值。</li>
<li>静态/动态数据分离（Separating Static and Dynamic Data）减少写入放大。高端SSD主控制器支持静态和动态数据的分离处理，此操作要求SSD主控制器对LBA里经常写入（动态数据，热数据）和不经常写入（静态数据，冷数据）的数据块进行归类，因为如果块里同时包含了静态和动态数据，在做GC操作的时候会为了改写其实没必要的静态数据而增加写入放大，所以把包含静态数据的块归类后，因为不常改写，写入放大就减少了。但是迟早SSD主控会把这些静态的数据转移到别的地方来进行磨损平衡。（因为静态数据占着的数据块一直不改写，编程次数低于平均值的话，会造成颗粒磨损不平衡，违背了磨损平衡，确实非常矛盾的。）</li>
<li>随机写入（Random writes）提高写入放大，不好 随机写入会写入很多非连续的LBA，将会大大提升写入放大。</li>
<li>磨损平衡（WL）直接提高写入放大，不好 确保闪存的每个块被写入的次数相等的一种机制。</li>
</ol>
<h4 id="BBM（Bad-Block-Management）坏块管理"><a href="#BBM（Bad-Block-Management）坏块管理" class="headerlink" title="BBM（Bad Block Management）坏块管理"></a>BBM（Bad Block Management）坏块管理</h4><p>不管磨损平衡算法如何聪明，在运作中都会碰到一个头痛的问题，那就是坏块，所以一个SSD必须要有坏块管理机制。何谓坏块？一个NAND块里包含有不稳定的地址，不能保证读/写/擦的时候数据的准确性。其概念和传统机械式硬盘的坏块相似。</p>
<p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/bbm_1.jpg" alt="bbm1"></p>
<p>坏块分出厂坏块和使用过程中出现的坏块，和机械式硬盘的坏块表一样(P表和G表)，SSD也有坏块表。出厂坏块的话，在坏块上会有标记，所以很容易就能被识别，后期使用中出现的坏块就要靠主控制器的能力了，一般来说，越到NAND生命的后期(P/E数开始接近理论最大值)，坏块就会开始大量出现了。NAND出厂前都会被执行擦除操作，厂商会在出货前会把坏块标记出来(厂商会在坏块的第一个页的SA区上打上标记)。这样坏块管理软件就能靠监测SA区标记来制作坏块表。SA区的意思是页中4096~4319的区域，用户不可访问，主要用来存放ECC算法、坏块信息、文件系统资料等。由于在使用中会产生坏块，所以SSD的每次编程/擦除/复制等操作后都要检查块的状态。对颗粒的ECC要求也要达到厂商的标准以上(主控强不强，看ECC能力也是一个参考)。</p>
<h4 id="ECC（Error-Checking-and-Correction）校验和纠错"><a href="#ECC（Error-Checking-and-Correction）校验和纠错" class="headerlink" title="ECC（Error Checking and Correction）校验和纠错"></a>ECC（Error Checking and Correction）校验和纠错</h4><p>ECC的全称是Error Checking and Correction，是一种用于Nand的差错检测和修正算法。由于NAND Flash的工艺不能保证NAND在其生命周期中保持性能的可靠，因此，在NAND的生产中及使用过程中会产生坏块。为了检测数据的可靠性，在应用NAND Flash的系统中一般都会采用一定的坏区管理机制，而管理坏区的前提是能比较可靠的进行坏区检测。如果操作时序和电路稳定性不存在问题的话，NAND Flash出错的时候一般不会造成整个Block或是Page不能读取或是全部出错，而是整个Page中只有一个或几个bit出错，这时候ECC就能发挥作用了。不同颗粒有不同的基本ECC要求，不同主控制器支持的ECC能力也不同，理论上说主控越强ECC能力越强</p>
<h3 id="0x02-SSD安全擦除原理和工具"><a href="#0x02-SSD安全擦除原理和工具" class="headerlink" title="0x02 SSD安全擦除原理和工具"></a>0x02 SSD安全擦除原理和工具</h3><p>ATA安全擦除命令用来清除在磁盘上的所有用户数据，这个指令会让SSD回到出厂时的性能（最优性能，最少写入放大），但是随着使用时间变长，GC操作恢复后，写入放大又会慢慢增加回来。许多软件使用ATA安全擦除指令来重置磁盘，最著名的为HDDErase。对SSD来说，重置就是（除了OP区域内的部分私有区域外的）全盘擦除操作，瞬间即可完成清除所有数据让SSD回到初始状态。但要注意，每操作一次，全盘寿命P/E次数减1。</p>
<h4 id="使用hdparm进行安全擦除步骤"><a href="#使用hdparm进行安全擦除步骤" class="headerlink" title="使用hdparm进行安全擦除步骤"></a>使用hdparm进行安全擦除步骤</h4><h4 id="Step-1-确保驱动器安全未冻结："><a href="#Step-1-确保驱动器安全未冻结：" class="headerlink" title="Step 1 - 确保驱动器安全未冻结："></a>Step 1 - 确保驱动器安全未冻结：</h4><p>发送以下命令，X为对应的设备（如sda）</p>
<p><code>hdparm -I /dev/X</code></p>
<p>命令输出（确保驱动器”not frozen”）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Security: </div><div class="line">       Master password revision code = 65534</div><div class="line">               supported</div><div class="line">       not     enabled</div><div class="line">       not     locked</div><div class="line">     [ not     frozen ]</div><div class="line">       not     expired: security count</div><div class="line">               supported: enhanced erase</div><div class="line">       2min for SECURITY ERASE UNIT. 2min for ENHANCED SECURITY ERASE UNIT.</div></pre></td></tr></table></figure>
<p>如果命令输出显示为”frozen”，那么不能继续下一步。<br>如果您的驱动器被冻结并启用了密码，请尝试使用BIOS删除密码，并关闭系统电源，看看是否禁用冻结。否则，您可能需要使用不同的主板（使用不同的BIOS）。</p>
<h4 id="Step-2-通过设置用户密码启用安全性："><a href="#Step-2-通过设置用户密码启用安全性：" class="headerlink" title="Step 2 - 通过设置用户密码启用安全性："></a>Step 2 - 通过设置用户密码启用安全性：</h4><p><strong>警告：设置用户密码后，下一次上电后驱动器将被锁定（只有使用正确的密码解锁，不然驱动器将拒绝正常访问）。</strong></p>
<h5 id="Step-2a-设置用户密码："><a href="#Step-2a-设置用户密码：" class="headerlink" title="Step 2a - 设置用户密码："></a>Step 2a - 设置用户密码：</h5><p>任何密码都可以，因为这只能是临时的。安全擦除后，密码将设置为NULL。在这里，我们将使用密码“Eins”。</p>
<p><code>hdparm --user-master u --security-set-pass Eins /dev/X</code></p>
<p>命令输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">security_password=&quot;Eins&quot;</div><div class="line"></div><div class="line">/dev/sdd:</div><div class="line">Issuing SECURITY_SET_PASS command, password=&quot;Eins&quot;, user=user, mode=high</div></pre></td></tr></table></figure>
<h5 id="Step-2b-成功后然后执行"><a href="#Step-2b-成功后然后执行" class="headerlink" title="Step 2b - 成功后然后执行"></a>Step 2b - 成功后然后执行</h5><p><code>hdparm -I /dev/X</code></p>
<p>命令输出(应显示为”enable”)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Security: </div><div class="line">       Master password revision code = 65534</div><div class="line">               supported</div><div class="line">             [ enabled ]</div><div class="line">       not     locked</div><div class="line">       not     frozen</div><div class="line">       not     expired: security count</div><div class="line">               supported: enhanced erase</div><div class="line">       Security level high</div><div class="line">       2min for SECURITY ERASE UNIT. 2min for ENHANCED SECURITY ERASE UNIT.</div></pre></td></tr></table></figure>
<h4 id="Step-3-发送ATA安全擦除命令"><a href="#Step-3-发送ATA安全擦除命令" class="headerlink" title="Step 3 - 发送ATA安全擦除命令:"></a>Step 3 - 发送ATA安全擦除命令:</h4><p><code>time hdparm --user-master u --security-erase Eins /dev/X</code></p>
<p>等待命令完成,此示例输出显示Intel X25-M 80GB SSD花费大约40秒<br>命令输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">security_password=&quot;Eins&quot;</div><div class="line"></div><div class="line"> /dev/sdd:</div><div class="line">Issuing SECURITY_ERASE command, password=&quot;Eins&quot;, user=user</div><div class="line">0.000u 0.000s 0:39.71 0.0%      0+0k 0+0io 0pf+0w</div></pre></td></tr></table></figure>
<h4 id="Step-4-驱动器已经被擦除，-验证安全性是否禁用"><a href="#Step-4-驱动器已经被擦除，-验证安全性是否禁用" class="headerlink" title="Step 4 - 驱动器已经被擦除， 验证安全性是否禁用:"></a>Step 4 - 驱动器已经被擦除， 验证安全性是否禁用:</h4><p>成功擦除后，驱动器安全性应自动设置为禁用（因此不再需要访问密码）。通过运行以下命令验证这一点：</p>
<p><code>hdparm -I /dev/X</code></p>
<p>命令输出（应显示为禁用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Security: </div><div class="line">       Master password revision code = 65534</div><div class="line">               supported</div><div class="line">     [ not     enabled ]</div><div class="line">       not     locked</div><div class="line">       not     frozen</div><div class="line">       not     expired: security count</div><div class="line">               supported: enhanced erase</div><div class="line">       2min for SECURITY ERASE UNIT. 2min for ENHANCED SECURITY ERASE UNIT.</div></pre></td></tr></table></figure>
<h3 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h3><ul>
<li><a href="http://rick_stone.leanote.com/post/%E8%AF%B4%E8%B5%B7%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88%E4%BA%8C%EF%BC%89" target="_blank" rel="external">http://rick_stone.leanote.com/post/%E8%AF%B4%E8%B5%B7%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88%E4%BA%8C%EF%BC%89</a></li>
<li><a href="http://www.jinbuguo.com/storage/ssd_intro.html" target="_blank" rel="external">http://www.jinbuguo.com/storage/ssd_intro.html</a></li>
<li><a href="https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase" target="_blank" rel="external">https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase</a></li>
</ul>

        </div>
      </article>
    </div>
    <!-- Pre or Next -->
    
	<div class="container" >
           <ul class="pager">
    	     
      	     <li class="previous">
              <a href="/2017/08/10/一种用户层与kext内核扩展交互方式/一种用户层与kext内核扩展交互方式/" rel="prev">下一篇</a>
             </li>
           
           
              <li class="next">
              <a href="/2017/08/07/iOS越狱检测/iOS越狱检测/" rel="prev">上一篇</a>
            </li>
           
          </ul>
       </div>
　　　　<!-- Comments -->
    <div class="container">
      
<section id="comment">
  <!-- <h1 class="title">Comments</h1> -->

  
</section>


    </div>
   
　　　　
  </div>
</div>


  <!-- Footer -->
  <!-- Footer -->
<footer class="site-info">
  <p>
    <span>4ch12dy &copy; 2019</span>
    
      <span class="split">|</span>
      <span>th是个小屁孩的技术小屋</span>
    
  </p>
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  本站总访问量<span id="busuanzi_value_site_pv"></span>次
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</footer>


  <!-- After footer scripts -->
  <!-- scripts -->
<script src="../../../../../js/app.js"></script>



</body>

</html>
