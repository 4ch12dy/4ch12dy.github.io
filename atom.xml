<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>4ch12dy</title>
  
  <subtitle>当梦想全都被take away</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/"/>
  <updated>2019-04-16T07:06:10.822Z</updated>
  <id>https://github.com/4ch12dy/4ch12dy.github.io.git/</id>
  
  <author>
    <name>4ch12dy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>符号执行解决代码混淆实践</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/15/antiOLLVM/antiOLLVM/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/15/antiOLLVM/antiOLLVM/</id>
    <published>2019-04-15T06:42:12.000Z</published>
    <updated>2019-04-16T07:06:10.822Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/08/正则表达式/正则表达式/</id>
    <published>2019-04-08T08:32:33.000Z</published>
    <updated>2019-04-08T12:10:01.468Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19g5uWKzmM02BNsQow4uQlMAu3P5SlufjzQhFkBmb/KyNUQFa/jw5kMAtdsmLi1+K/VC1dx+x9OfRLGpLP7m7RwE/+JIsaiCsOEnNJ0clP7Nj3GbvxUnW3pZca6UIrhwprHhL+Gku3BUQZ2CPK2osTaqiUOz73G6CN8K6XbqReyEAfwyFLk7TKMNKHEl1E32kBq/ThmB6+3OL0yGgRNgIn7/RDKouWB8oQQUvdfhn1KBz/+s8yBKfO2yKKgXatfNXJKN80jhRhPcmoveUCip6xutEfW3sDcatPVnWWAmikErgR+j3lXrbfIMP8D+swjju51pniyk81aC+K51Dmyn7p2GU3KRi30lPLRukOS/q/fQkK95sb3Y0pq5xo4L7Y4ITI5o3sXXjt0OMIHDeKWMPcY5utKMWqxwt5Ud4ReFW1z+Db+JfvupYeB/YlytgpfocfqerzNBh5B1z9+tERwM4EfnMluP90tNKZQzV092HElRqkUt+bIDIkFrAfo+WJLzf1tJKyc3LCLTeGyskglkuZFUQAv+cbxaBEzmoj/LaRO/WfXkXDYTV2x3AtXaN+H4UMOHlf4h1PTNMk3IwdUV0L6g4JzbugkXP5BN81To5b1F1XHlRzJQEN3iNkNY1pm6RLv3vJ1GxUohzuTfohtCDdd6A2bsXHt38oPKQOJcahdwYrfpfUUCyDbFtv3Dcoo+fKBm72hQeP5/NqR8zVEL+BsPpWWBW17xi98OPwrPZcPLrtxrPX6gFa/tbwcURVKUJGQnJtMcALlxuQYm4w1b4Kob4WUQkD5uwoTjde+vCLSNxko0eylzkopAWcNaqytcskTGk1+yKpEBOXdVhxWQKpXfyTgaSa2sn++cYt6ZYvADI6361Jd0r1k8wdwzJZ6K7aCaPTTRkwIkjN7Rsnhhqp9fiT9QWHVHKCR7wkmW7PsabXFOZDyaZTtMuzZJcHwUQdNBhh0WhLofbBRulqQKjwbqK/bqhdv2MiTMLz7lPIARDF5aKiV1pnUAc6I1BXuk0mT0k1uba63r1tgizGUh++MxOPdagHC3ZBPfQAT/q/gRmZnoamdLr7YCpgVvFpRmul9LyNpnFwvgGbZADkDTIyCPsF7BS4VSJNR8d8AmkfpQ3S8D+Y/0j32s0uyKtOFodNYNC5aGY8vMydgztHnWiesYdcQmOO44de01tlRp1uEzL+Ba11wVrqBG+z1663Hm5sLh5wbWHhoNcg4HduinwlothG3trMyEcAOnUqMk1pQVl4KJzHcB3mohIxX4SUAZKvOI/WI58OmdmPELbWiXsJ4JvriVCgdxr38Vz9PmCGINIfHeaEChzYMRaOfDQCz2t3kjUC73vGl/udwukmE8SUCFiw5reBMaVZRVcztvNvRd0qcw72iTzuD0UDk2HOCxYkCUht7Ofk5Ev5AJ52rjDX2FPH/2wHv0um63N6/wlCVb9FmNPYBpFC+MYaaaf639uzFZNoLnfKo8i+x97LyxysIgUw08cNG2j/xrwp0uOAwJwY6wYqH5oV4Zf7LKAoKBDak8+9N0mKUkuo9ISd7+6l6HToYzYRV79bma3HHcUWKgCjKCcLOIWUl3trivqAE3LbeA+Ulv5JGINlrg9ZWMvabAUG2pGmWp68GEDspalEsY9YgAWQAOH8cLyif33w9Og1l41kc0eqBiDTw9zbwAle5mWXNbULkDdIhhCqrJ04oqPl/jB8v+6URpfmQm+uTU/HbsaKOyE/4vYjkW2nMj+ZdlZbizlp5Ina71rq6T4n+Z9Sh0jYC3E/z1C9gIZplMvooMa4VrbiJaWAyMa+6qhpB1VLxqqm3fYx0TdNbAWDxiXBAWNtIwyks89YYZiqjNHD0s5yac16eRyGicB+NFQwlDiIr+2ro1U3C2RL2a4F5ho0jySgRs7dTM8iC8AtxWuBzT9b3/qEBj0EAbJ1CXA6J6KYa1QUw3QhACxpmrXFOrVp17Ib7ayLgvVkTkoQTuiv/FVVrpH4/m9t5XHX3T7MpgrStDfx6GUTwn+czAomlRjSxNQ2d5xMOJHNbLLQ2dyrFJXZfynIABPqkiMh8Q7L6YrjnHrNfbtDSENQkzH1y82TVZHhSHb9Gm3jtIt7rGrCySIvOfHh++5tWsrkRtje4YdDZ2iX1iOt5FLCKT/I+CPwQjB+U6wQlLS16Z6GDStDouN9pqCLNMAD7JGZLNqtLgXuuMt6iDwkVe3kfSVRBfxczxuMiZHxrGfLfyj2wNNtvypG+5TDC4mhkcxgzI4ZfP+026FCT88xe90laCeVqd1hx15zZANbC+gOgt6yJdGr7/RV+9vMYlz8UJEhMR9ZfeapP6cL8d7VJlY/jnlrRwEOkGUQQGAzc1zc8VvU/GIprCU55FNEdkKY6oUIdjre0he7yLswNfKJ98qfDmQO6FazQ1zZfKNFaUqIjuJ0n8B8IjKu4wbo8CN7I++hqPjNNKCrT59u7VEgdxt5Xw3pXAvrG+gGb2tgTnUFQZ03gAB6LD6iTXH5PKtP0Y6Os/a3ROkKu0qBhkYLR4W7JgMgPXoVYkv2DmQ0cMG1a4EN17hxBjNVo/Vgi1WEw3V0WHzbp4lsBb7DehZt3/bvfRfKqsi0RKjor5FlJXCXhj2E+RIJOyXYbkhyyVjPz5RcRRK5BDMCMZb1MKfIDeMJyb/QBwFt1PGpDY3J7SMySsjR435l5V8hoMjMvc51f88Oj0eiXcvnAv49OHZsQxUXVW8NHAYhdVgsx/1zcOMTOkpWnu//WMij/57m7MtFRXffHkYFoN0UtH2o9wEBMleljZwETeCTPVqc5cId4FA38UwKnocE7kpqStDkzbGICiBBvbGTPKXuOZnke8SOMLu8YRpWuT/21xXJhA/AhFXG66wGZOxOjvN293EV5gM0bpx0+bU63Gei+BiJ5eFY5xf1JiaB4JqpqWayo5uuL/ks65a6r0DZBEhhjUgUGlz6pP5m7m+SBZy5Z2PXuAMUxMqg6Jc4fqe4ah4+E+MfJsmNDeuRxdZvFGwUA8GLM/BO8cvdw1MSY4F1nh1G7c74Yd8lF/0EXS9bvMGIJw3hLM1f8CXPoSGTagP+K82I7SPtet6KFLxt02O3f0OPvqvRYIgf8Z54K5qBUgH/aknj8kt1I64GMWSbLUiKOwoOEc4nSjm8AGa22H7oST2XQsW7h+FCKFzH6BSRYhhDRvQuRwJ1piy46DQQFcuFvxlPNnY85KW9dKPDzbW3RuizPqKrwpoGNbx8lBSeqbQiSKRCVSu37atQuufIiIyZwEicJ8dyc4hQ2G4icVglZS2rcLLlSDlRbcJvPGlh+MJYUaDtbv3Gh6XVXyCcEnEDJyesnrng8p9dceptiE5knPDyVBm+Du4ebrVrTLef9kvwa5afpgVxDakuKctqcRwTHjHcg5CdabOrX8FkkOQdBApTnMlAOFHqiudro8takYfGFEARP6D03xu3ucBXO4yYI3Y2y8Fki6y5hojgXrAMOq+OFpFP93+Gcw8Xwh3HQkGtG16blXGCHMFm9XOvD9G/UkQAlBXhMW1pUgNSj0ltq91gkvJ4OCaIoqNsTsQoemV+Jsa39A2Ca/WQaLvcJlE/Gej0KRrvWi9HX8/pf33/apvzH5KzN6J7sgZOS/FfFeaGi2CcRwWmkdFtPfaghH8/VRxrVrjykOP2bGQok8v/mWEi4H8DunlcXTZnI9XIJb2EALwayzQ0FHEJ8n+Jx4WpPqDCfY2C5YA97fCgP4SmVpde+lhADkU2Vgv5VukjnFmrm7MGqegOJL0YSnBSXgN5WzfwwiqYQs43fVkw/RY6OwErPaw9JH6I1acygd/K1T9Vfm5FH4Ppzp72KLysS7wfN8LblL3ZfOiim6MtoIPeGHyiBEYxoFKHVe6IQppIT2rB/XLYQTJI/cvQzE5tvCDqiBSl+ZUspY1IcxIP7T8+qfxcvtKNYtcyq/ifIZZxVnfH0L2Qms4s1ACkqfi/si2shf+XGMb7HpTRQEsD9BztV9CbCZSxi0uUxtW1nyRnC42v78bbTvPNGMNeoD9pGPqrp0XHO9OfGZJ0Z9ECwDWXciqdK9S3ZPZ+Bf9dwMJkX3geDqpK4KIB5FIigWwSimuyXLh9Cg5HAhGB/b17+kgdDjYFoVw8QRlONap2wK9m5qPo/MNWixGqNzpJl0f2KUAxiQlH3GkW0A/2WDgW7h8E11fnDyr1zCh7ZnWI5rt2kC4DahIZhfIPQJsXKOpQOfJ8O3dSNmGMsMjZYp1AaomQ4vDV9jlpz7iEJjGGhJCaidwQedo6/DspNvci1qLZp/q242W+chz12EN/bXOq/lev+UTRBbbkHF6D45uapFpcbDd20sCeiGO3Vf6ObmkuiOHM78WSRVFmXequ8pOjibD2ycXcD4dZD/5hF4yJg+UqK+eYsNK5o/mLOairjhpP88dfvH0HwBsCPUhKmN4xL6Era/gH0+xBpKUWSO0bpH99M80lvhD/6bxHDD9Ew9PbMmdmCNCbQh7Ja7HL7N1c5q7p4AY8O8h1x90kAZAtH18X9YNv04VEqhLX1ua8bwKuDh3EtvL9NWiXj+LdQlAME0PIihXEF8cCDSMXDysa7+6//Iejj1gDaXK8BpNKp8/iF21wJ8YhpvvsjOA+mGT9sqcDL3P6yc/pB5Gu611r3Oc8+vkVsro5Iu0DGiPw+n/c8vJ9ykbzaqzFz+yORDDlvDmQY76GPgBI840L0OS3P856lX1TV7mscRg8AUcvDqa7wcZQccUnxEsryVUXmKQvYhdc3zpWCEEANHsx8Qz/FcE948KivRrZe5IyBxF1tH2X+vmc0HlY+P2iNra5hDQPVyWKqvT9SF5pxGSe0jx3rehMLdIjtHn9TFwPK3C2A/1KnBnSLs+9zkViQj5gpHTVUI8A1CawOb1LRUACBrCXy0xR7M/sghpcEcA7ykJpZuX7xFaJ1uYSVMX+jIuuQumFeqXZcTyWDvGLMtQFzSlIhnF3holbsX/dxsxvSFxIpPW6CJKKJMQFnpkdwJLnAUErCR9i8rDHfs6T8HfIj7AEarUAm0fSFOKzrxzevqd0RdlJMbj/9YaSMR1DTZwOpxfPTFTw3fh87zFumJAR6s/JYfehek7mj6kZn3NLmH3kAb7xVI06fe6WM7FJWL1j/x9AOgvN7/NYA9pD7p2dPUkqrwF2y0VN2KuPVcAPu1nUD6IltOLudLMeJhXdNe0stZijT9VypgDoCUjQaW9sieDLsCSkzNoxSN+ICrpYTkXEDgP8mLsBsS6+Llbo/QMSl7xDX+E0lL+q71dCmDNB6piH5B+c26cW8j2yZZkiu+H2DWM7l2ngRQo3rIEyBAnVoDOPF41Y7XAOh+aAm8Hy7na317O5zeXkXy95Vp6JnfHXY+/FSspL9dQEUFonc3U5V+aOcidDJjqUZndgqQJEkB+F71o9oVj1afjb+YCOkKyQrbWvmN6qDTVW7DRTp2Sl9FRM1aWLogZv78w23R3T8j8Qj3okOSLMaTLybS24x14q2cM8upv7VGENWth48LYLN/DPLQdRu+0hEMQ6CbIj8pUALzkmZL2wv53PAKous6i82pj4TpN4hl8fp+9vlzCXMtqLwsaL0Al2deCZZRT8ktGTN15wDnUatAUlTCgY2lHuy10CzRsXJVJBsDDS0Rz2ffMUFMRj1KlnHw3aztmGKwsSL1U1X22UTlSAF6XFG/H1rjyPy7ZfSGZBzNZwwL4lYd52Cs4X5k5X4Yu+IxXJHaXU6NJj90AJlZcDlXu/cAzZSb9eTzLVTbKmKu7ptaiH/+ktpHjkjIHzd5qFyxmyp73GEe4ATck2VOYxJsuOsSFy/5PtfI7sqvOdX19XNuIJ2BJyDYtZU/DYTrwb51NtmjjGRB98GP2qiG4sDBf7FwjEFShFgZSxruQ8iEIT/Jl8715RH75Kgta96EatIIODikV+1g9OJm4BzP1RtBo99H7sMx8qiuOMHfGW3VjGkxhRmUYAqp/kwRhW98A6ZOTHRgSMqcAdZ4SJJcRvGo8Bf/U17UT/yQlN4lOaS43YiO2HCzZL3hJiln3FQo4RrjCAqW1kJ8VoOI2Y5rD+Nc7YYTml7bvD1gu0LY8bvLiGtCHgF4Uf++weXbfMHY6Bnn/qKNmTTv3Jv+pGaISQTQTV8KwLARJPMFyFYo8Jl/xsptl7RTiz/dDXb57lSojT100V6GeqyZG0IKKFKrTgxKCthQ7DmBcJBV5JZUqyRKJTJ7eetnDaCr+tUS86tHhflamtTXu4vD/rT1IJeg65wtM7urwpAkm9xYfz8fJccWysUvrJIld6UeR6bOdP5iW5GPO0yrabF6IwjX/mXZ7YXlD6DO2X27q9O+QRo/oaBhzp9r+ApzLKieINflfJmAw3JwvIuZrqSYw5itzSJr2qvN44cRUtWBtJqypEDe4nRwOU5S803aKJuOiexDAfcEcq0eLdMZKdSvq+E92plYSzow3gTB6lvlacav3JqZLWwj0d0QKjilumIub5A2XCC3nrvfbb3drf7khFZtgDv3sSp+X97vjoNzTmYke8TEOgvlzFWBojmFnB87M0w231isyrMiNCl0We/Ikg2WjIVlS0AefUgWGHBk0elBB6B43TuM5/9rTyLwAqqW7MxvW5fdZKMp8NZeBbvCw81Sh7IqZJ5VI8JHB2z6Dq3qfro2pp/mibG4T7bypci47Y6z2wviPUrURZaeol6gB6HgX1bH9+4PlqFAuxrwkyudWqqoYtJHNoY9DaYY88LOCTP0qn9IdjrzHMtZ/3kuGdEEpeQEzd81Zl2nPHFnqrPl/IMDR63uqPMpnbOC5/adK2sQCT8Py9tI8yonUbpGT2gtj1P7Eazvn6lRXZmvOKyKwXupIQec+2O/hsWnQ0vwtrJBepGqtRz334/ichvUpPlU/gwRY+/1rko0w6/3m9PKG57CXOOcvyyfnAAXLQQcOq9oLk/2ApshEW9SDPkt1lM/ewQwOAgKXP08su82NrXTTzuMkyRnnePAcGgHjGeBxv1IWj2CIT+ftJzF+WL0OgzgOApFMS3TstNssbqsPAfq5PvQdwPnTRyuyXE42/jDUsvWnJ4F8cgDuEso3kKX2d6gdgF6HbHayTjV46NiCQEsHF01deri5qvZsGe9yk9vqZqemPqwE2SBcImu2lqFB+4l2BA/oLldkbTbzUwAVkRhJlBpUPUB2AlP23L0H+8LyudusK5V6JBeIfu1CaAGAaBEJad++biyPvnKTxxi00RkiyGLMLRl7fB0ugNxv056xo4l25bEIKLmALCF8C0OPau08l8p9+4SkMQTCc9VbymaVgcWkr7EiJ6vqpdrEQuF6ZqXPVoKeHwfTCNfkNqJm7HAUV2mRXN30yKfPOOQ+DZtCei+m3u6DiZjGzN4CvQRE+nvEJTDwo+Q9Mme+b7vJh61xcHgS+8ZVfKeUVV6AS4FSr2C0zcmKDQaOwv/hxItjsSPXMcWfYtIjBSq0dy6zKyqLtbcz33oVapOO/thunZq4+HBMUvnbmtqYdnethYDqIlXgfEABID8Dk1op/3Jr531xLh7pCFWnn5Wlo+aUiVhu+gFTjpLJ7qmALZEIffIXLsq1hsC9JRV6tZAwwZD8z3eNZJZpvLYWnR1W5mGe8s9aICaaWD6M3vlwlHOecR+Uglv/mWxZdWbetQWToVNomlR6UObiXORat3HKpFCSF5Z9aT4Z1i8MrkzzqR8pnW7s42fYIEHeDsBpOziFdyhmQ4JlV8L2yyvrI4pKJogtrwIpHEfg94xkp5fDydvRaldAJyJzKTvOI+XPYtWR/9CIyTJwo4A8/q34Iq17XnbYTKQSZPhQXm74GB/vMqvwx3FF1ar5d3JFSHHWxSxqIZ4JoRFDHJYPO0hT+1UHiOedkLTfRz8SLUB4t/CqNIijUCEHthdqsVtmSr1j0j4zVfzvByLygsZ39iTBBHBeYiWsRWwE77R7tUb/0dPModSzdGQEO6wYAzuzVnhtHdsLP7TotIlYtd5Zw2S/p/FRf7rFb5RoGxVwHmAZnWNBNGIbuYkdd9Us+TVRbFOxNGTIyfoaJB2QgnK0ueHacEYz5ws0wkJbUvVtXTf82st/ZJp9DMI/cW0nFGh6TqYB6TQm0OJblzRZ8GNxGZNEHYVLBp3RX4ZXI0c3GDW+I4c7OPz1fZJBW/qQlUmBKuDjEYCOJkFRqbGX8D0EMERqIP2XjMSCQnMiA/jJxy6d7u12LnpVOwAgiEy4Zy86N932rD6kheVxCnZxVg1dFet0avfAOGcCupkXmOItpW+mnaOudm3XrytUif8RUxahMYUrlna3jiFMOLcUcjRSulnA+8PoMAa/8zPe0eZuzSpTV2lyzawkHayvONHHL9CAr7LbpahMlucP318lELs6LA5jvhgO7SDt/+NVKFRI2g3Tmr8R0hxMSgBxvx7DHSWG9RoR2mIL7uSBn3C1E7bm2KMCGxawb6iA/GIIZtWxhvokjtGprx7XNNrWkGbKVliElaH1iGnep7R3WjBLBKOWZidKK0i95Cs/mGq7WCOBW/rOIRXgvJ+x1msvmTM4VG+RD8Dc+IneM2iWGQfneK7h317a+Q3smGb8MRd2kILh7XWwz//IjXW0ouXirzrQo6kCT1Z3vzhc8Bzsh968v9JPZL+TOmZu6Lyqei/Y8ldE/fFOkiKUD71/v1mSJ2vldeLzsEJABU+wSqvRQhZfmR0cRiYiUktJvBXNtj7NSFs1IonL3Qkfk1EAyMcPtOENBWN+mkVXf7H/VYNpW5KC+O6AzFlNXrLNP1tJ53DGJ5V4dUHflbFc7jqwbvrERrVNXhVR+jByfKu7Kcd/wWYDmj8jrYUUiPUmVomn4rwwGgATOufQBL/U7cftJH+9j5yblC4X2aAXsKpiqM6DUo/sLrpwj50A2M23HpzkZuZb9AOUoxs9F9x6J76IKsgrYQtQFhX3Op02F2mNKkJWqWG/qAFSjArISw4vY+461g+4Pur3rpk9lRhk4f5jY2J/U95NHDAmA+uNconP2nU2R7PQw1sUO1M8axsIQUM1upzfcUY7gQz3cQnffxxKHIHXiBNZiIXx9wlrMkQ61eNtYKfzZo2WiqpuLUQyZ2In1jDjyomZw2yFMot3dIaVuJBGS+3uJ2L/YzQR7cDuDxwirDo8XHgrSBPF2jmvb68FCP/cq54ULfoFxgpzLSuEjb+Fa9c0Ezl8U4KZzicGPiSNbTeQ0yW6k1I4fIHVgRBP4vDzf8N2qtbxL+M2YpH1AQN8fymuhA/J8qu+bUmb1ct3/8xmVQA8NXPpDJrShaNkzHHE8qsoyQ/W+i/496Q+S4Hd790aClc9hWxU8dY+bItVxy312lYnkHU3E6jDk55aWsCstwymWcNydNOR9OyFRBY+yxqnnmbFvMu2jbPIx72gjXQ4/x2dtK5zhxoUr4h5W50a2Ms6tNbvcrDvR8kdbxteWh+7KjQH6jEQyB1J4YrwDN92rfa0M2+Bfp4L+A3zKXGHYETrtDL5HtWHNcLP7vBBrwDNJDXxdvvep4xtnf2nFEVWkdPc99ym+IDxg702e5XMzNGtxw1OTiDy2oII9o4WfdxA2bR+ezPsaq+FCj8qIVLjCcHpM5neCpXYAURIe99FQ5yCTXRuqL6Nvwp4/DUJw+80eLttDjlVlnUrCfOZXNyPsR9sY7E9sQw8+l7nUSCMdDsD8sinTn2OLhlHupTd8iR5XmmwdGnX++og90HoWKVH1dRb67A5YIvbBroLCU6cO6OMJ0/Vk5nIYZHwIidRDez4Db2PVV/5tOVzoX5USpHq5YexcZrHLJVgS+PivKInkBQxzUpEc0dgKuAvfckgIppflFGzHxznqQRrKnx3nyyKmTpl3FGO3vEO44BXXi6+6+2KmrsQjo0ltYNerlYsMQFua7RjXycZuAl5F4Uym1PSoBQv3oEgGutU3GcmdorGydtkGFUCXWgetOSLtkVUC8AeC333VHYoDGmdhWVsLDAtZnQypB3jssWV9wbv/zAkdH5w8x8/ZpIGI7uGPQnHpCLYZq7Av27GRKbwo2WkxQWZKQpBJwqB1TQiV2XOS9bxVabl0/lho7zG9kvKuOu/9+TnrrfDRHWulk4b8wJ70p1oDfGoG12rCz96+pJvXek2TnzIyvxBVmOf94KaIgRnoE3ow1Fxz/VggbRQb9r1U6+TtUaJgn6SvdaLXpdE0DhOBKXu6JXn3Z1NOggxtxy+SdC2kmDhMcjcYuSfbrBt52/uqOymElPM9N2faRK+2pUyEAGj/yRpnPAZh+W5wzzGI6wO0ygbetJI6U+NDw/Ob/mkRVCQQcvSixxAQ/X/gsopk4qPti/GZ3Ve9DRQwiOc3PsYVunENs/jj+pSNbju4fjnurag7vt2HQ40TDaH3XMZP6DLCaGzPPVsIsSId1yEjp/V636XYzjvgciGn7q1Dd/0Ssd0nKhFNj3Cic9yfoPVh5AqTzts9qpGBQxwOtPaiO1HVPoKScCub/b9KyJfg1Yo3PRcQGqgI3Kelx4gVdcawxPrNH0RqWPkM51dAwUEQaF+aBIrGkf3T88Q9dqK8Hvoz3K3xkB27SWsxfry/TgOLWr9IGN+CkqW9tEfD85ubu2vCdSZ8/762/BBYuOYA4RLaAfRnC6tzRXE+dcYJHz8nQP5AR2LOJ3dWz0B6roHYcO7IROENT4PluihCSNgEgSdkvYnRGjS1oq9TXHRbXk4jnIkjJYwrH1u9/gEsJqKvqiHmTjRBYOumrsIB7lkZE5wrMN6iv74Iebh8W89zd3yIbGhUreidj8m334z1P8160UptkdVBzWe+B6d2HEK41juKLbTOETv9nzDspFi37RhUo8K14pq+3QyeJTPfx8f5SE/4Zqc9RQ1ivl168yxpHvUWQmKXsw72XyRZt7yOe44aji53lV/ucMjZiLvraJFiKQA0Vc8HOT4TT8AQJrRWtGZvuPmFDnD2smKjEGs1ZwyebxE6zl+QyBgPhPiqpycrCv5LeuQPv8QmdYBclAYYFGy/ZbiwoQh3jy1tVYKNEZnF/nxJK1gvgdWR6bqIhlVmnYResLTFvIlV3D78NfVmOrVNShILxqXZLV+neDoE2IY5FoAgXgjo7eq/5GVGnPoI0eOmkmKjuYweQM352KsFIAKFTEeaPUZsqj1HocA7ECsE5u07bWAa9YuHDgujOJXRUkENHDDOHQ4EV3W7+inw0ywN8JrDMtKRooCmCgl/UCtbHXcK7xZ3qKmCAYg8mf1hhCfl0ZS+yWvtm3TmWprdHWb6NuLM5cYkIiUe9vgFT8W/6CSf7pMsGbgkT3a2Qv0Ao581oLplUhLqS29dE3VHPKUz59/JrVZNwXh/X/kqdGrmJpDOFsGV5h4MPLSWVkZECyvh83oQr2Fx0wmVY9aG9RqWkomMDmGKbP3sUpXJu+r1irOEaBp5MggTtIUh5GXJxsvsOD4sQkhziKi7xeX0mjD7TNefvxvF8AsPbJDKkrDQ77rgZ47uPfVqWv6h/fTNDSwdxkQI30v102iEXgsTCd1DxuRReaTWz7BQfP2jG0JahOTO1tw1arrcl3IGTRmi85ZTj19SXS4hRvsCX4YA9Sh3ZhJ6MCrGDMl7oD/OcF0XMhhYda9joGj9yJvH//K3Mfp6xYoOHb4QjfviSFQWq8T6vOu6QmXKse5OE5qvXv1jXKPex1wl/XAXJDlm3lvC5kzF22AOT6rEp1joZ9HSJaeR7p5QQ5llh5WML0vcvfWrD0WAhN3NjBU/SuOgz+SsXIMOB8sVV/ICJREU+KCgP9X1r7kzaG28CIavSWllJlZDPk/bYoKP2EjqbwQQ7s9hoxeBI2Uwr498Lf0oSLNQwicj8EzIfr3RgLFtY8YKvza7UQ6MZ/auq46daDNZXW/f8PDoTs1YVeNXqx3+hPLPbDA/n5mw/v7k11tUHkPiVHUrujDFkFq3Pm3TZA2gsqTcz4L8qOmNCHRCT/HtoT2Lww1P+b1L5l3R5B/aarPhIrTfKIUP1lzIijB8siOA6YJO57UZI2VJNHOK/9J1A4V+ZGkVVbJDu/RcBAkXmQ717zURHlNbMzdLJ+RiyGQ016vxHtupLjlDHMVdR0pWmOmGHwM6pTtiry4AuDSk/fCcuETjvYUtdmoz4pOT5ASdBpQYvd6ahBRp0Hn3qndYiQT+z03SR/DRU0tXEmFqDG46TTWCaaF/KZOQcuMfGPmWutcKAkt/AN5M1UvCBzW3SAKIceQROskiSmf2kd9kJZ7RXnA8yOzXPFcaUX9CXnTLEXE5QxPX5H6tHzOKWfPFHL38saBB1LquSQFuNMzqhq06QgbxOknp34fMkFbzdx4Omx15mRmQPlGtyKOHomu6vQKjFEWf5u0ix/mT58SK6AOFWNmuJI+XArnF4ITlaW0NfHEl9yOQVvhdJUpUWw7MCguCq70z3T0GBVh1dkRR1nYDYTCkgi/pYcUxumcptVXgs7h7fEoQsGKTTjIH0AaNdzw0iH/yKG3SSIWsKGs5Rbn98aHuJXuTBrqVH8swu9B6Fmr+Fdrcpoy2XIZwM5Hcxr+f5ApKEZzlop2fMNaX2s6x/qyjfrGoKkvkcdP7OmLFQWCzaHBRLpM2FIiJWrQV5eSDueDM0wfXalAzkXasiVTVlLB61EPLBsvzeeb3IVfP39mbhVGRlTWdFDXSbb91K5aL7fWs+obEmlNhyOk1ff7qAgMKTmglbwBap/VWiGiAyNXC+S4bHF5C0zutjqNHeJk61V3HpzCp369HXSshN3vtCKGBNIOew2FYV015lAomBiJJnh/iPuXHQ1XP50KfTQcxGofZaB1svtFQ5ciJXs1jXrAsX56Hman4tAKeN0WqUreAqg3CyhpmKheZTbv7bueNsLQont1PoJgKKIXtdS3HKuhlzWEkeakJFPDeei06Zz9GFIFHWsVdQQ4Jh2tKTrNEfTLJq30/ZmQCTvGAUOR4fAsr2z3u/3SF5szq17UE/cmcu7ilSN+k60gzn3oyM32XM/qRQFuq36kD211/459KBgDKfvBOT854Y57wPn3Ns4NSj8KYVcwgWXFBAGogGM0GhhubYu9oBXTTFRnlKG6ICyJDfMTDf/6iMs5IMgny7e0Pa3a3UCITqcOt4SrP8RfFXa5fi8smkNPXYGb2L9eF++TFF2bMC7LG5s7dTcaYq9PPaphX9DL3hyO5TA8KsVhsmyNMXeX6SMid6mkf+4lVo9E57iw+Nui8EsqIDUQ4AGJHdf+y/Htc5GYaSKL2d5qAsO8dsf3hpJBrf+WR39DIB5oo59JrVIZ1IMAeMJEfNuE585ND8bpwUKp/ExyOpe9IpXC4ORKZhv8ziEWQPym55OE+/zBOB+Z2waFlxggKMA8B3zfv3UEVEo3nR3mrLqmR4md1K+KWpKqLc7lq6LuKe1e/xft4pXin3ZgihnzfpgLFTeTaFZ2zlgBvOE3ev53rAwvW8fJbuboG4nvjnd02NdgY5lRGf6cs26tVOUDnhixJVOwUrZZinWzdILAjM4nS+J8AT9jRdjlbN/x/64ipUBx5Egsxepl0FDKRelT9Jg2C7uJPQnz9UUVNZscbduhFL3ZLyR/lUKDeCo3z4AGj11cv77SageAr/mi9jGY3k3P/X2oEg+omV53UA9fKp+KwSsKzLhNodALI1Qq8iDU4Vc/4zKXVxmrzbSeD02t5uYvCV9e4+UL68fkOI3bl+aWJ84vXn/eTsZcnJgUJSX0B+pmI8glC3bA0aE9m3ykyBHYrb5LeFXzEPd1hoUAI0f8ryIwDTGxl9rBsPZIQEbA8BFHZje1SWh0HpuPcUU9LDUh61tgKNueXTAwOgoDlprn1//qlIC3FY2pk+VrJopp2g4JaYdm7dTmwszM4gYZgOubnuumozdm3eZpisIDRQS4dwnnlyNZufds/J3rWKPninnr3nHEIptAbp25brbSPJmbV4HCS+qgULqWq1ExpU13NbRccsN+0U/n/nUmISl37asN5CXv3HlrcQ9FT7ht+vE3j7b9UE2oms8WUXQh4cZPA6yZGhZk2NoWVUe1eJPkDZcBRARX5wfUlTlaHjNdwkIIwzi7yV7mw11zKHRYK69JApcxq9jJlRDJIOuhPkIGyQswk40jbRM/lcDRFVSgmRIrWeeyHDhF0CKnX8Du7EueRZLQIWmmUKsV9ULoLRayllBYPpwVsvYqIydIdS6SRCm0KfomM6lk1rxQdHxersJ+K2M/rdykHYp2VCND6SUuMJXDqEVUxv/zQ00ULzEbujIEgAjibtz+rz+Q6X1EMQiG/gIvgPCjl4O/0XnXEigdvMfzfZnuziJPTMcfHQ0b9eOok4qz7xvE5e4KCeVxQWiJhqzDcARGYHPus+YeqD6VybOfNQWI82TkY28vrwY5tYaLh0tTMEXXUtNnQsQswTOCZrv+jWH1kekKglz5UY6UYUFyYaboFWYtrNgx0MmTzx42gjFzXDjgXim4tqBhscddaaA56ARbi8Uv9Dc4W7/I+owucPJEljamnML6keaQJIeKcuMKP6XyS2JccjhhxzNLjwIzcJhwPzuNMk4R23yaaS1Mzut0lPS1Oedf9jq+pl1DVCPfUGr/iRxdSdoO73kmZgPwhJdeWXUKRorekfggKC8C188IMqi8XdSerCJ6XgqjH0K6P3z5KOQ4E1iUp0JlTO3hbk5/ZrmYF7yGL+wbizDx3P1HP+mlgtB0SekdewOFIqrgiP+1WlAQJ2GNorfAXOl6bUh/GtleCyDOH0sKQAbJ8Kn8N+NPJN5pUmWyfPot8YV7obrumFixt4JExFqIJ9xQCkV1W5aX/FaZwYBbQFg+ePeEYN0PHICBItdxd3f2zgPZrACzg24g9aIn76deZ/sFPI3q/lwezNGGQzd0M21LYVSLk5LYhW9wbtc/pvQTQ70Ss2i2YNqa4qhhlDx/x5Ow2d2TJ8+q3HsGbndAGw2aaRdtBBaRlKZxfu+ugUdrlK3XJi0dFuIpVIoHlsbJ/DBrGIX9CI+mQ/EvJfFbRHe2YDsP/VPfmWjz08eGMNzuXwFzaBkpCmrKl5lNcUhLSw62BohfWIdZLgXEZQu8/hAzd36UeSRswA3dbu/UqPKnbMDdkdzJZmNObxFtBUS/pzQA6yVZKYCpA+ICkWKHqg4gCrMRD2YqQcniXdV52tyhcdLLlgj+Z8i4bK1dwifQsyY76dYuqkZAANxhd6zqEOHLQSnNSaqqqo9UBdXoCJgiy3rLD75GI9uoj7g66gA96MiQ/QW+vds1lMpzuJGNKOtpBmFap281a6fDfb0wbz9Tmq+zLjnZYucirCEjebg5dqdl3lruNPs2K/HS9+yndqziW8Vrbaq7bbEbP2cXEYIySacbMAzzcJuw5Pu2XHB5KiF67qSazMNBckKl5qMtBkdTlMo74kn1wS4qLe00+g4dqJPKuGAJQTj3RnyfQYocfAY33kc2khpLSru28RBk9kweEkpipxegmNGu7tE8Ug7UzXpvesDjou8IHdibDnmwQRlJCS50YWRDNEQYLxcbQTToTrneJAvOLEnci+5HU85fn8Dl6gJljUCnAwrsOHoCpOEc39ovaMVuAJS5ADw5CLB0KuV5IudAmk3kNPs0ggKAfX6ua9RRN01Z2tBisLJhAazVrmqaiuroNBsFRmk6ntLeXWukXuIksVlzKvQGiY93FV+aA7daLOTJNrNISYtw990xdIyV5E9iXHlE9h2irbcbzI8ugMclC7BCH3S6G6coabAsKr/BzCMNwEMNTtCa2C15uBB4cf1PTdDIo76SINMy4bohzyIouUCY5BmjOR3jQUbi6SGOPwzgTspD6JyMnet7mUBvh4Ti439XXgW9xmxnt1BDFB/ylQ7xcWxhE6fXq4y57CSWfZkf+CL10TILIfwirar4wNfObMXRDlO/eHWQbfccnpU8TijUeh/F0d38KI+QR8Jl2LM04Z2xrlLFjQdNBtW6uVGAzxwlJgcjoaBWsSL5Ys52+hCYaTIiSCpKZ47yxER10N12muWWbP3nfPMY5JUuVJb/OywD5/lbtwDDra4wdNa/DY7IBDffx+Qpk8+v8MR/Qvuh2MMQXDLvKzgp5FTyQAoTAb0rMQRn7xdeS+TYFuiQwRArRoV6+96zUEgn8wUidueQk32JGCmB47EYHNR1Hwl9q5eieAv/4ysPxXOL5YJxjcNGU3eYRRlECfZdOc/ZHrbnMdz/WlkYv6+8VEF2kxUv48Y2TGUxc2JH1AwEr+9MUiIgMOyFJbX7HPjlD/RXeEnHhsGDh4s6N83YXoc0JlBzhYafT4kmmeyFEm//EZe7vGTYwpki6ETFC9dQC0/nERhvlSuFi06qrvLyELw4r7Qul05qLkZyW8nbpsYa0sAmt6wuBIXhtAQax0lKPy3ceundjbOO9UoaCc04xYYwCF8Iy80+6ioNYtYUXArhANS18BmkDK1Gc3TVxlOEF0TSD+8eQi5wGUmAah01HgLw1O8/PptRVXfRLhEZgGjkzgRrvYQ5xoGYP49saIljb68Stu0p7pdeONAbKRal7ZArezIpAYI1+tpFaLCoWkqxj9v6rTKAH9JixjXirY77P8jQaSIO2LAJg8VISfnBvh9Dmn3i+Ok7vedZ0xcaBObQ9bKNRY80/x+mwHzfpLfm+w6C2hxTYaUjMV8xSL9FzRG9ojGzoPlED0I0uF+Y67LtiVwYZse+0PpkmY90EIFcJoiJi3fg9ujRXNlCGLxnrlnkJYFn9R9Wi92Vucmp3J9mSyZgUPP5utHeu/ymIWiBCqlzWIFiRq7VOrBB1A7JOEgIEf9LXh6sZk1VitUoSH8BL6TPPx8pnzYaeHAQytRDDAszTuMHqHa7cCGTTrWDvA8SfcpSpl8gD/TkBl6E50mOv4tFLSMJ/13Dt2jERUuUQK26lWr/3u3RKGNoYDd7ag3zM+phIQmYdp94JK+gPZ7022lI0Y4bX4XkImBjbq9QXMMwRActmZ9VFbEyYbQGSGb5p+7xtfYUTVFspuXukAac9o3bSMEaep5ca3D3HQivPDl3Y/VnVYUER1xEb7b7dL7PK0howljrl1BAjqrK+kRktj9g/oiYLLLfq83leAtJbToIxZJtaHqP34rogUh6yci/CjV8UHjWBwrrkdfuLpr17HTZMwiS8myTKtVtnP1lfyqOqTyWZmCtcobSvjhh5thz8YGrPuAtJ0YDuR1z0+ZlgaGDU/mS3Vv9Hw4W4zQ2wjG75G1WdcClsujbYTcwGzUh+09Ccjrxn5y30WuIcR7KZ4FSrOsfLw0EUKYhBUGfDWPgPoBC0Z1JrQzadBftmCiSUZwqbDP+eSyV5dLWq6jqc0tNmm7LRmfFy90fqJXi8pl+vk2inwX+I9ha9r22WIy/p6MMMVJVFWfBuHgbePmyTA+tzMPBQNRgSclM5GlrXnCo9bhLXwo7fwow0hAe9Or91KJNnizDg7uIcGZrgoH1C989JjWGZWUMnpp8n+MyfnauePoWStB56nkfm7vyLmrQGmEt8kxtDTsK48LKtRvzLdQ2LtddR89n3hsx7p+CQUKbX2n0Uj32hdT8PRgke0iLzK1wWySXan9KrFUTA4HKzKFPyqOeuERO0ecvYJz4LSKXeg2CB1YaMIi3v1ooY09UoPHoGuSQEsvrHzHDrDQjD9wtcfzmVIJTznzrVSndOvxklNJMf5IryNyXSZeYcYY/v+i3+MNFnyHVMujv1mYYdgEqMekjNFhmFw9AioW64rGyeNsfoET/47Ce3307iKLKsCT98zGdpKGOh4r/W0iUo2oaSidBVZpFFmSpDEpoi2T1ZDvqrzAD7Mi2YQyitb5WBgbmQaaHXQlnpksijJSu8KSSGNYM2POGkl2UKvz60qHPl7f4mhdOnq/IWj/hP2iuQv9hWNnm7hYF//50U2fYMq7D39QddwjjiWHHbZiWVxy0gIAaq9mwC8so/+FH96H4UTgxb6zRp3rVB5Cxj8k6o1bUgXCKj2sxa+j+HPYsa1ZXkoXpHMxIM3uPThr0ZYFSkaegf9+AXCKaBh6XWx+LEUDUlb1bBJ7nNKy9qO1fjJKXp4s+amA4OAEgGpWBq9gsYR5v36mzqu3nPsjPs2Siyf4CBdcKRLX9+/guVpL4WpuzwaZesnmYUxyQXeOJMLvmHZHeVFR2a6VpZmY3JSZMumqHASdSpinkEp2YHjqrAy9FsZ84CITibkdFSmCNLrL8LM1iYTRpfClYbljwi2kQKu4Uo8Eu/ltIjGOsnAicbnMfMoQeWJqPyiwa7oR8gubiPMqpGjBHNm51nfZ5bX60DZTyy3V1GgYGHzMnS4Nm5cEnw5ZcdgkI8k6XCGH4jl0q+9+6l2G4965t5Um56/KDHSLt/bCyLtpu0pcu9+BbyPngSX0uujRu2xu5WMQxqPWZCi+b3LCpD3KGBmEg0FVyMJzV/J004RNtAW+n7odLsVDOZmLkK/Dab/1pBSubkpXmqffi2M4pBrakkqaKI0NxUctLOjSxHZ+hc6ZwFqi9T5Z3T+wOhRHTRCXsDFVkmvDCJAEJoN4xRKo4znuOV7fA6YETo4YIowCdeROSQmQph9oeRLqlODz+mwkDiyqvIRuMJu3+EA9E7UsvbWBB0Sb/T0nI2PrXSPQ0w6YH1falF4EwRt07GjMq+ECShdYEWwUOVYTbspgK2uu+OLuOb8NK9RHwoFz6ng5byrFb5pqo9n68g+kZ96OFPt3ajUXoMuWNrPt/EEac7LPSJZ6HOXZg+fY1Lecfx6h8wkq9M+ozTPPHyO01LlD8OAqP76L4O1OIbcegz6bK5RXhwGljgA16TTOhphj8RaZ4y3eT2RBEaQIjIPlD5ajfQjxdj8Mv0i6OihdTGyaBbUoxixpkXZqTXRfhtCvSQ9kWpbrOS+TWSjQ+erQdpe10JBhJD7AEqWhxiD+L+zzmeJpr3VG+zmy4/BMuxFzxXiZASzjkngkPMRhXKLYEUbwN4A3dBYYASm7CIPHjJI2brCTEaMf2Q+ZMNeafZtTU+iuJbG5jxtr4QZsggQOPip7rcXY4bMHEu7U2ib4nNy1QwhFXxXDdOjU9PzoGslFuBvQYjn1wK3hmvOj87KJVQ3UHlQWu6dwMU42DkhyDQOvTmj5cbJFrmq1W212M1Wf4iyduze3xB1qmYxltldX1ToOR0ED5yodRvZacU/VUCPmzY6wYFL9f+g3r4IyoWlMSxxYXuiKKKDahPpRyW2Iswd0FX1Rxjz4CLbvO1sH0UxLPenwy3oeMzARXuKXopBJRZXBoAbwzkqEvDeLnpEtCOrdK6qMhyJUGxmRKlCYAMrr84p2f+kfg6RGiGfniqoCBwz5Ku3EjvJIMJ04XOZscU71VWqGI3PpS7sN7iXTWEf3r3V27AWs8oj6ppWpxrxELGBtsRtlOW3+QEIxL8+CZjtj0tufR8E6/r84LGiTafqnzRING2+3ZxlD0dQEN7oLnCByqzur2O1zPSirmpx7nd3/dVDBN0FWOjRPGYwWxB8GOnRHSJyPMbxkhBLWbOtJnnr1IZ8tGWFqEOU6BDJP/OqIitoa7zAHrQiY/XfuAAKeQ/vEZ/amZjiSO7N9Q6VUcEAm1X79dPALdPjMMgWepZLyPd4auligdjh119BMyneu6e06ROYsYHg0c9YuquTSpgmRQGMz+ssJxbXAizVEvALOJAPsenQ09xPKDnvWHwOfl08enMToi8Rp+0hmu8KilQ2U6m0OnkUcNcVnWAU5fIL3jfwWxFl+b8YWOMw8GVGBm8wuK20bgTU5EyQN24akZuB5VDrzqGF9+pDdIcks6NuXKWN9sO2MEJICoq7MAHD2gftrUwPytbOKUrTJVtQgLOH7M4dgpIhyef5hbBprymGW21dgXiZOla44DnFGJJCb9YAf4+mvMoEvmFWoWTBdJefQmsBw5zPL4YzpXMreS7mAIbCwW0VTVaJ69QHSVhFrSa9kJqpyRaH+KAsrvxpkzRiVhgQfwI7+isNm5SP6okgvi3Q02C0ew9Z1I2ehf0iOLpJ7QMmPgvJfDPN7EoUOTAvn4EFpFXKoTmPBDmX3n/zMMljoQu0PKrbea3B7Iqp4sq6U6sHIwhfptgkWEUtakXyGqTp/kAeCq7iRoKWjCBYJ2yUS+/wqYIH7Ud8X4yBMwdNp2MHm7ivIILRz63WvOK6PKcI0gijOQe+1wxKrzf0RV0IXU0R6xEmY0V5DWi3D9vfNh4qgQTOEo4q6B/zc9kB/uYHmlM9XIpDxlIgTumvP6vqvE/4gU38LTNPXP31ZokisLFSyuBEEK2nkzKBqGqIC//u9u2rWSthwZCeTujcci8CI3FzYOX2oqO1ar3Auh+e1OwYhmbTWGETo6kDSlMufVYshYxKULNr/Y4DzgSF11N/oUx4wbu6bfr/5OnmhXOjTWuUfQhV3ZygLg9v7OUz2a54kH8/3sto9qZR8MHzJF/URUF7L36hjYUbw9Vng0LRkxUPoH86ZbYQH31nZ/nZNjflEKu1mSr8vBcQE3dW4Z/xMnBfwo9H3b8oJnHTEbK63GCpoizVVdi0+t/jntxO1x9vZEJIVBtyRrN93glzkNNiRpjy9Bfx3Q28R/msWXXgJl4w3cSOdQgiEyqOk6Ha4K/KaA0rcBetw0ZpgYb9CyJOr2r9gGKhkkEYI8vrn3P0ZGsrU2/TRkH/8nergRy8RQ6C3/TXlQiMSVUX4hrnIqf9IYnJTuhGUv7fv5WW1kV0HjgUUFnrzDwmHI9UNhUY4puOgNx8liXjqj9ZMPHf48s1AdXa1p6PhZiLB9PjH2xkSTfZH1lhcSK2HRLwZMFbTAa1PK50DaMeFkJ7rVjGYzQD9AQg/qiWHc7t003M9Ffa2ptw7FsisHNTD7uT7iUL37f3qivw9lZSnBCiWGqTyY/IjLvaiN/1uMIfvSE9/wTDnbuTrrbLcHmYHaiobSd+DwtTsNWjykcKfTDyB9R2KoCGmucBjVw+ORJ9Cf/hZDTYPjdg+XzBRZgKUT9eViV/cT4kyEaBK6dbAA9zBps+38m8QG+xrc0P116oMrfA4NFD7UVl4rtM5fkp6fIZHl5EDHG6GDU7D2T2EYMpdbBiN/fxFU2V1VrdWBS28aFDKVcIFVofkOzzw4sYcKxoTJcw5obV7xEgQha0738i7gXMpy/lWw5PBDxbxSVIgE0zit6KTYwonSSchD/cxcEM9sff42qxeWIh30BrELgZEXe4OZSW/C8hiv6m1QqqKVJ4dPGGLd4uSKwiDId90Bm5GZQGZJemVy1Kkqyfhxp+OGrPEeTr3BjqrNtcR8f6uoPiu1eH555ebaAUvcwFKOz3GIaJPbrFg06DEyvlL3DMevc9vNWUt6d/LWviT5i9JLK2k8beo+bPM4Zx6KOhDmKC1nmvJN+G1Qp5gzv3ucLvcSACvtPhgaRse4qwOiS9OuMGS+CUYSEoh8J5ep0TZURH2A0ZMBJ891ymVp5EXypP55zcly5cchthuXQOXTzCakFpflDpfx5ltNZTns78GcIG8eJ4jb25SACZWY3MdFBTySkoaEQI0Rh3lvGTQSOtx/T2BMjYTtt4AICNM5L9PTE4aqxkC43cgk1SCSl7T+zoDeSmC0BvrZ1dHN2HnXRikewssxMFc/Ug28azV+fbmPsT6xi41eFcNIn8JxbXX86rsJf4QFan4NY27TOa4kRdIyProDov7K2+4/6b+6lgLGW0W0qww+Ds8pAJ8QB/A5sy6yI/fq6M4WQ/jAGrJc2VbnkugHL6BoxF/fYk+GQZYN+Ki/7JTqQ99VnlzVWXSHkUWC7uTS0O4lnvq5Jp+NPl7O/fMgg8CceWVxvdT7gCHOCiHjPRcWS134TR2+iUliKVNtsGLvB/n3IdW7UUlzKrZIAy+He1S7HaRxA+1fDvUGcWBB63iCJqt8cJQSx66sGYEqZ1+G2yOETIvTd9NW/FnckdCHY5aX9hbCG30s/EM02zqqp6R/M3IuG9qglV1hASv4J6Ysv9ktZ4DyAou23ktnls76j59nG8X0MZKZUOMLy42uotRk7AbZolDT+YVq06gvJO3x2qhvGzaANyDZ1Oqq5zkwRIjVwaBCz3tqlO9R13knZtMQXRAvYFDyZyAK9jThVZk49PaZAVHi31wE965JMxW+rPKTgfrTw7HbfPgW6CjC3Q09ht7hD7LpKLraJ1EHaGVwfzVR/sT+gHnO9bKfqBWrBLmIKp5NvpB+SWf6TonUXP0QIOfmhfIRC+tUui1vngnFOiNnz7FtnAhCXtyzm2ryVU0x7eTs73Tp683CpYUPTps2ZI/y4GRabpneqEvyWIdP9FqvCztvmHzkboj1GHwGeOBay8WHI8LMZQr8QSvxIjm+p6UYFP231uHcBHn++mRnxZRjePqFCnA582JG21DO4LGSK1ojvNpPNYDUEmPy/laTCO70LRHfeuzcc3PwJ9crBVMAAcTcBAgQ3oq0J/xUFhHpb/gXDljQEiTj9iXa+FvfnXBIK4Jq4NJQ9fTik/q3OPecaHc1sraXzmR42KY216Qw4P51pMRlzqxHBHcNSWDj5bzd7pjZoJMuz0YVdrBTPnNmGUU6TnS7CtgAY1NdFIrsxArx2yN/mtC5ybs+cFFTYA4Ih9wvnwNMDR2baceMzdRpgO6R6ErpxwcoUXQ3KPAmAqfuIu//IafWYUMHbkrt5tER+Op/bAqZsiOVevqIDDCxRG1sDS+UA/Q1QlPLFCW7KEW68YOzvGEN5lKzqyuAF8bOCSMzDTE1a0w0/f3f5TLXATISo5a3iTMzpgfr/jIS16LHcJN8wckMT5YIAduOtT4CuoPW3ivQp8u62Go4kLYsxakHFGJt2m93ky3UTy321KiI64KeJRlXztNpsIghHBTko8qq6RaVykXtf7rZh8bpEggepm/RCm7POnGrgluRhZw9zchyfycljXGIKfWdwm2cACrp1B77NXDswmMRzWQiMCd/GjWqrXsij/d/PrmNPME/FmeTXtB3f5W5ZlP+UYJsG+zI1B4upWbb8vIGZmZAX2s4gU2mK63/qqWcKBKiAVeQu/+xZMrGai9EJ2xpixVivHoMNzPv5xFkbqePqsFPEtllfhskOpQ3c2X0LWO5JofM6FgqoiuC+G4+vwro1rmZmSjaL1V7X7Vr/+BKcBrjBOki3uWw8WLsa1lASmtTpFVzRUevqRbXvAgRu17Uaqi8MMs9fNWJVMpytxOh2quktfy16U98b7ak01h+i/R8NlzaghLO8pQtOw60rfkkDJZc4M/mFZfDhwTNaoV80Fi9lQ+jCZ/UxbqWa/uOobjMMu1xBom7XUmwdSaNJqyT5UeCVSph6wv3vbG1/rSNy57SWXWbjsMvnI29BWHtk73Lu83b0Q+gU1CWuaeFSNwmjyBsVZYAzUjbgcFwjoIqHHYIjTd2j5wWnFp1WHLmTZ8lY9/BMY7W0jg2NGfn+1S5WAFKVKWl1x1NK0avAlptwQnkv9a//ZCUgxpTAyW9C8KAwFgh0n50GxUcgVfVQ5TnpO5mcaWCi7AhhgslJMfI847WY1NEiXxHhkxZ1wKYguEOSLnqQ1i8UEmvwIBsnAFpLQUO37GHj/EzdkSZ45KxrkAPlgET1uIbE8AAsP5PvwyHyfoOGOmA2Ogw+h1wILUzWKKnznBbmOPQ9+1ttDr62Ogjb6DES7cShmoaoVcokYbBHFGyl6XfplsgHspnmNEC332d8eKWasmqxrTzojCmTyKwVlDmDR8Ajb5QHpjGvPA6d//2sRlY/W3LFZXrWg2hmFo59+rUTTUqFHkQ/CJoR9IJX6Fr78iRHSrhpjE3AapYnfMsJ0eC4fwX9HPw7CatnddmGK8Y+eRgrsX7Tiy41+qhhOq/GSIgu4axBoIlYS1xfTTL/qvu4tyNeMYKGFKAa26NdM7+csC5oiHh4IlK+ROIwzU2N9rVV0o9o6yCS30DcODC7xc/+Ja47gS8eeAqU/m5wvfh9romHgCZazjmun3Hw1sONfvwLbr1iJkhxPs33KDaFCfjL4BHX97eWaIXYdC4vEk8fLOSwUdNzeIzW/hjR1sbGC1+jE2yhHkrVdnyvB040r4VbwM9avufcWBwV3appum9U9Fc/46MZgIH2Tok7HYPEJXxnWBlT6dWi2MR7IKLR4uZRjp6c1XB+QqVzPUaijsQjZZRLf/q1S4KqoBpB/k5631cBinoD3Gm9rgWI2IB3muh8ZJUCsx/QY1OBlomrPSbbz00QiaLmOQJ3Hu+asjXghO+ttuIMofeUD/vrNtrIGbDBtQ3GV696hzeELpo9HN+abg4uusMx0bot78ai7FLbj87kH2og5YdZaVwVXaCezRJ/pBX5TXS7MTZeWkIBWIalXXuTIVNIm83kYqJVvsJLOSRB0gyqhmk3sfiWV8IyO0wLfHJAlQCMWv9oVFBvSaCf/y3wE7/lRkQeZbJ/JFXFDzlA9n9vxPFKUk6TUJXFZGNlYU+uroYBIlNBNYExDfnXD5/WEWusKL0KStrh/XDnP5ykVBK+k6scCuRyW53miMUVDhgQVrsxr564Nt1fvTGc+4LqbnwU+QET8pd+FaVRvpqJvlaOgRgyPBd7wT59jqaC36C3YnSVwaJTaY5jiFun3fS6Rx4MFdUFzFrz/4W9nQ7zhiCDbS/CdLnD0I5XmLUQUBKsBI4IeyR5vOoOmhakZXWt/80UB+4gcC2BefwGoA/EMNXD/R6xeH+demLiplHp+KTtbLsdN29n8wgNSk0tFU+PLx3skNDSOR5004l2N6F8Uq7U3qDaVd7wlXFTfA2MMPfNMOLXLYQFax1mFAwD7rxXAA+KnvbwaYzIegodguqxEqvs/2U+9YlPXfqcz4ram20VgjQCZXBGjKTQvJTn44iiQ/oGPKOubCtCxaxrltCHKH5lpxQ0eXIKH47D2RR1K7AAMis17AnMXytnjHsLd+cYYGVvRrtp4BOMM5hSaKstHsvL03io8U3lTyZHDxw8BRTSD+ieGdxkmDhRvZWYw9jcnIxtL7iZz9RGRpHXOnYXG6RXgACOqyb6Bgc1H6rNM1ioU0UcnBzpjSTsHq2tNMaPnCS8SVEzMRk29shiSzUoq31cdk1tCtKjOPK4YQLLl8FMz+bm+FPe9YmWc9axk3uR1W/BGKrdNM7Tih+ZrG1lLcBidTEBRYvkqutWwvLSBasSqJ5317h77UKDJuB/nIBBY4CMNh5KEsci0L//X1Soh7dpjB3ebv8fQ36ZZJeTfuFj5n56iCM2/YjjETgcLmul77pCpAXG9U5rbW1R2VTX4qqYn95dJ9m04eUQmLIzHF7X+zBVEkQSGtIad+W95RefMVwk/g3GaRpnDBl9kHnE5P1lleoGW+pKs5j2ue7zCO4MiNJslUQ9cB2k7m5d0nXMJ6MTPTdlLjDIh2aVqWj0+FKuk0PgsSVIwNmSxxppVxQjlU3zAGz4xItUML0LKWOjEnSYBFpEkQhw6d1ILZ6TxiusCWUEY85ODKYGxoshPTPKlO68qUj+Nk8mD2lzW++5WQc+6dJgRmPKWaorvnlZJ1g89xCNc493nxo4HRsepo8Q3Dfz86IZNJ7LpHMWzvXA10SMF8MhnYR6CHLpvCaWeoBCQKUuJeeBJq1kdKEwbChuJqSGLwknm5z3hg1XipW1p/Osd2jf8W0+GotNpUNSmOFiJKCek9CL1jV13U+4/Mbz2UUokF+cUFDqtwAxR3EA0ip0mSIaO601H2j3B6NOLaIM7gdapZ2k5sEfxqatr0bO776xdhFgFRgpNdLeh1y+nQKC7ZGdIngRULxKyqv6VRYEwIRsso3dZV41I/ZTXIVHIsAN5eil4Wx1IikAadpOHemrrObQxSmGpxiBW73tCnZMknrFOvoOnYXqhb5PZnwXuzQwivO0nIKtVaBQM0g1XtcNv8OboI3V67WVqghzPAW1E9pndqy5g04toUqliPFeOko1p9GfbRGCiNZkDSUsGzmDBZQWZRpwvhlptRNlhfxQFR2RxpY/Cp1z76vRkvV/pwZr4pqpk6VyX54zvXSYw9jEU7N9udlnxec1HsUnEFYJCPidwhXlFOnRphOKLEm5nMi0y9jAzsqXMRzuK3O0iycA1tB0AAIlqUa0SNpfRsH6Jt87FC6lX8yYKEHLQrEEXohU1nOXz7gdlsjmGoFCJN2mmwIixvQmTSksr2Z5nSfGN4Ka2BpNLSZB+nyxQakf+vrXWFFXIVvyTz29Sc8nWf/ScRCZZrCwnjozWYbNoAUJULyuJdX39xbQjD1LIwB0nKr6OvwTPOUdfENRbAL01Cz0x3tsGiayEwZIjiq+/8yfdevFRqWVR6mtEW2M+Pq1g+jluJ+SwxR6GfGK81o1DKdzxYjomXegr8i/nD9ZI+UJM1m0LaeqrCEqokMMrVkZwoQsz4sjrrdA5r4bWxbjtNRqTh4jAStuXhuUYvub0hUdR+5duAR7qj6/DVAUKo1Nd3LStheWJ/vxiamZ+nCM84pY4Lm5o7VJf9YkNgB79kw+a8yARbXkDs22MHP1KysWoZa9mcumPN1IV33S49hRgxWQVAiU9flwhbfqqaM4N8lrrv1vaSdZ04Sy08FbtGIrLC7mMG4VCnaq/lus8yfI6Dg12rZhyt+jBEZXdvvZeER2VIzzTwORqqZRzW5wdX9GrARhZQTAlcNtNHp63c6PsBNxiR4oFK4lFqBeN7nx1vEEImM+48YFGxjMN2U/Sj5d6lFXu8BousPTyxwUtvwQmdUlzca9L/MS+Kc9eK1WOJKnsIhPUAna3nePYHrLEnLgocE5FF+fE3Bti2jnMkyo7DJI2EBVy/HObsssJhHVDfVEpv1QhIrMYSsUL5PQV5vKzZ6lIK7Mc8qacz6vIqqepy7dseDGyB+6BxvtzS+oCw5UXtf6BI21k8YufFzS1boLrnUYHbNDQuhsAFrjZC7Gy/nqo2PmknVV+m+BiTqU6Dld9IdXk8eaNpdayzUXrrO2oWSAYp+1swp1ciTgxffrIo1F0P0sJmT7Su0oZf0wRnwu7aBh9RfBmRPFbmealinzwCdlKoTtpAuVYFo1I7igqp67mSNNsQ6N6/T9eYBGQcGNJf1wvv35UPpIyDcKwLtGS3/h4/VNJJpRU9MHblubVl+WKa3NTV92Cs0LUfWHobS04SldYOyQDVuYItEyLhqNOeZkr6WDUEiS8ex6m9Hje2dnty/hNPomdbaF2yjnyxeD1dDJhMhcLWf13Kso/Wyi9KLt8wIoiLBXzrSNVelfTz3OYyX3ECyTeeD5PZv6muahcT8QHfiOwhFJgBDyCP54KbqNvzjXIal2FobdgNiUPrIgW6b3KPFV3YGsmxScvpt4wSYUltugW4fuwoXn1nbB3sWiEPcdiaLqK1OdsWCZZ26uK9bpeg0hJ9WjbmK4V4gGTlO1xfHyw4tZnzTk2kQgwqwXGMV5bYlmqb1Uzdj/WVadDFMRFkZOLG/FWcHTDd3TtvtWnui/TglI5ez+1LRJG77Fe+fccKcBi1uj9uwM5yjnvzzSIJqjNmadG4pz7adw5kPov5hjCEZsJi3aqmv146rVIfZS9lkJIKDkXg81xrzAf3RCZ6cnu/jpMcIpGN/Yvj8D6xQgn61MeWcGjH86E3rh+afONBObnrDciv1FieM6tP0sdtzMxQeYQIsJzRdqw2RoOwOD7L/cHoeHRWWteqnDT6F9c5xC2k+N4NO7ZNQlalh4oFUGmXfBrr7WlXCZjwsEty7F8/perjILXhSOvTIFB7NIT+yTHM1dmszK4110m4hfRafA+XArErNTu</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>angr learning note</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/03/angr-learning-note/angr-learning-note/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/03/angr-learning-note/angr-learning-note/</id>
    <published>2019-04-03T06:29:25.000Z</published>
    <updated>2019-04-09T09:23:23.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="angr学习笔记"><a href="#angr学习笔记" class="headerlink" title="angr学习笔记"></a>angr学习笔记</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>macOS平台上面安装angr的时候还是折腾了一会，刚开始网上都说angr对python3不兼容，然后用python2去安装，但是<code>pip install angr</code>却有问题，然后看官方的文档才发现angr现在主要支持python3，python2不再支持了，反正最新版的angr安装不了(virtualenv需要python3)，要用python2的话，可以安装以前版本的。</p><blockquote><p>It is built for Python 3: Python 2 support is not feasable due to the looming EOL and the small size of our team.</p></blockquote><p>既然官方都这么说了，没理由不安装python3版本的，<code>pip3 install angr</code>一把梭吧。然后又报错了</p><pre><code class="bash">SystemExit: error: [Errno 2] No such file or directory: &#39;libunicorn.dylib&#39;</code></pre><p>明显是在安装unicorn的时候没安装成功，导致找不到其动态库。angr文档中也提及到了这个问题</p><blockquote><p>Building <code>unicorn</code> from source requires Python 2, so will fail inside a virtualenv where <code>python</code> gets you Python 3. If you encounter errors with <code>pip install angr</code>, you may need to first install <code>unicorn</code> separately, pointing it to your Python 2: <code>UNICORN_QEMU_FLAGS=&quot;--python=/path/to/python2&quot; pip install unicorn  # Python 2 is probably /usr/bin/python on your macOS system</code></p></blockquote><p>意思是unicorn兼容python2的，我本机之前已经安装了python2的unicorn，按照文档做还是不行，既然angr依赖unicorn，不如手动安装python3的unicorn。去unicorn的项目中发现可以绑定python3。</p><pre><code class="bash">$ cd bindings/python$ sudo make install3$ python3 -c &quot;import unicorn; print(unicorn.__version__)&quot;1.0.0</code></pre><p>通过这样，我的python3环境中也安装了unicorn。这时候再执行<code>pip3 install angr</code>这下一路畅通，安装完成。</p><p>迫不及待尝试导入angr试下，结果又报错了</p><pre><code>angr.state_plugins.unicorn_engine | failed loading &quot;angr_native.dylib&quot;, unicorn support disabled (dlopen(/usr/local/lib/python3.7/site-packages/angr/lib/angr_native.dylib, 6): Library not loaded: libpyvex.dylib  Referenced from: /usr/local/lib/python3.7/site-packages/angr/lib/angr_native.dylib  Reason: image not found)</code></pre><p>这个错误很明显，就是<code>angr_native.dylib</code>中加载<code>libpyvex.dylib</code>的时候找不到该动态库。看了下<code>angr_native.dylib</code>的macho格式里load command中加载<code>libpyvex.dylib</code>部分，发现是在其当前目录下去查找<code>libpyvex.dylib</code>和<code>libunicorn.1.dylib</code>。关于这个问题其实官方文档中也提及到这个问题</p><pre><code class="bash">PYVEX=`python3 -c &#39;import pyvex; print(pyvex.__path__[0])&#39;`UNICORN=`python3 -c &#39;import unicorn; print(unicorn.__path__[0])&#39;`ANGR=`python3 -c &#39;import angr; print(angr.__path__[0])&#39;`install_name_tool -change libunicorn.1.dylib &quot;$UNICORN&quot;/lib/libunicorn.dylib &quot;$ANGR&quot;/lib/angr_native.dylibinstall_name_tool -change libpyvex.dylib &quot;$PYVEX&quot;/lib/libpyvex.dylib &quot;$ANGR&quot;/lib/angr_native.dylib</code></pre><p>就是通过重新指定加载<code>libunicorn.dylib</code>和<code>libpyvex.dylib</code> 的位置。执行完脚本以后，angr算是安装完成了。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>直接上例子来学习，官方的fauxware例子</p><p>C源码如下</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;char *sneaky = &quot;SOSNEAKY&quot;;int authenticate(char *username, char *password){    char stored_pw[9];    stored_pw[8] = 0;    int pwfile;    // evil back d00r    if (strcmp(password, sneaky) == 0) return 1;    pwfile = open(username, O_RDONLY);    read(pwfile, stored_pw, 8);    if (strcmp(password, stored_pw) == 0) return 1;    return 0;}int accepted(){    printf(&quot;Welcome to the admin console, trusted user!\n&quot;);}int rejected(){    printf(&quot;Go away!&quot;);    exit(1);}int main(int argc, char **argv){    char username[9];    char password[9];    int authed;    username[8] = 0;    password[8] = 0;    printf(&quot;Username: \n&quot;);    read(0, username, 8);    read(0, &amp;authed, 1);    printf(&quot;Password: \n&quot;);    read(0, password, 8);    read(0, &amp;authed, 1);    authed = authenticate(username, password);    if (authed) accepted();    else rejected();}</code></pre><p>简单解释下程序就是程序有一个后门，当输入的password为SOSNEAKY即可通过。下面我们用angr来求解出成功的输入</p><pre><code class="python">import angrfilename = &#39;the/filepath/of/fauxware&#39;proj = angr.Project(filename, auto_load_libs=False)st = proj.factory.entry_state()while True:    succ = st.step()    if len(succ.successors) == 2:        break    st = succ.successors[0]st1, st2 = succ.successorsprint(st1, st2)print(st1.posix.dumps(0))print(st2.posix.dumps(0))</code></pre><p>下面解释下这个python代码</p><p><code>proj = angr.Project(filename, auto_load_libs=False)</code>加载一个二进制文件，然后得到一个程序开始处的状态<code>st = proj.factory.entry_state()</code>下面从这个状态开始，一直运行直到出现分支。最后获取此时的两个状态。打印出满足条件的输入值。</p><pre><code>&lt;SimState @ 0x400692&gt; &lt;SimState @ 0x400699&gt;b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00&#39;b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80@\x80\x80\x00\x00&#39;</code></pre><p>可以看出st1也就是成功授权的输入为SOSNEAKY。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="factory"><a href="#factory" class="headerlink" title="factory"></a>factory</h5><p>该对象提供了大多数的功能，能够将二进制对象分解为很方便处理的对象。</p><ul><li><p>blocks</p><p><code>project.factory.block()</code>给定一个地址，返回其basic block，这里的block与llvm中的block一致。获取了block就能进一步对其指令等操作。</p><pre><code class="python">block = proj.factory.block(proj.entry)block.pp() # 打印block反汇编代码block.instructions # 指令个数block.instruction_addrs # 指令地址list</code></pre></li><li><p>states</p><p>angr里面很重要的一个对象，代表了程序的一个实例镜像，是模拟执行某个时刻的状态。</p><pre><code class="python">state = proj.factory.entry_state()&lt;SimState @ 0x401670&gt;</code></pre><p>既然是程序模拟运行过程中的某个状态，那么SimState就包含了程序内存，寄存器，文件系统等数据。而且这些数据是可以被修改。</p><pre><code class="python"># 访问寄存器和内存&gt;&gt;&gt; state.regs.rip        # get the current instruction pointer&lt;BV64 0x401670&gt;&gt;&gt;&gt; state.regs.rax&lt;BV64 0x1c&gt;&gt;&gt;&gt; state.mem[proj.entry].int.resolved  # interpret the memory at the entry point as a C int&lt;BV32 0x8949ed31&gt;# 修改寄存器和内存&gt;&gt;&gt; state.regs.rsi = state.solver.BVV(3, 64)&gt;&gt;&gt; state.regs.rsi&lt;BV64 0x3&gt;&gt;&gt;&gt; state.mem[0x1000].long = 4&gt;&gt;&gt; state.mem[0x1000].long.resolved&lt;BV64 0x4&gt;</code></pre><p>这些数据都是bitvectors，所以需要一个转换</p><pre><code class="python">&gt;&gt;&gt; bv = state.solver.BVV(0x1234, 32)       # create a 32-bit-wide bitvector with value 0x1234&lt;BV32 0x1234&gt;                               # BVV stands for bitvector value&gt;&gt;&gt; state.solver.eval(bv)                # convert to python int0x1234</code></pre><p><code>mem</code>有几点需要注意：</p><ul><li><code>.type</code>有<code>char, short, int, long, size_t, uint8_t, uint16_t</code>等</li><li><code>.resolved</code>得到bitvector；<code>.concrete</code>得到int值</li></ul></li><li><p>simulation managers</p><p>state代表了某个时刻的程序状态，那么simulation managers就代表了程序如何进入下一个state。</p><pre><code class="python">&gt;&gt;&gt; simgr = proj.factory.simulation_manager(state)&lt;SimulationManager with 1 active&gt;&gt;&gt;&gt; simgr.active[&lt;SimState @ 0x401670&gt;]</code></pre><p>这里我们用state去初始化了simulation managers得到了一组state。<code>.active</code>返回当前state。</p><pre><code class="python">&gt;&gt;&gt; simgr.step()&gt;&gt;&gt; simgr.active[&lt;SimState @ 0x1020300&gt;]&gt;&gt;&gt; simgr.active[0].regs.rip                 # new and exciting!&lt;BV64 0x1020300&gt;&gt;&gt;&gt; state.regs.rip                           # still the same!&lt;BV64 0x401670&gt;</code></pre><p>通过上面的方法去执行程序，这样会得到下一个state，此时active的state已经变了，step方法会执行到下一个basic block。之前的state仍然保留不变。</p></li></ul><h4 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h4><p>…</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://docs.angr.io/core-concepts/" target="_blank" rel="external">https://docs.angr.io/core-concepts/</a></li><li><a href="https://www.secpulse.com/archives/83197.html" target="_blank" rel="external">https://www.secpulse.com/archives/83197.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;angr学习笔记&quot;&gt;&lt;a href=&quot;#angr学习笔记&quot; class=&quot;headerlink&quot; title=&quot;angr学习笔记&quot;&gt;&lt;/a&gt;angr学习笔记&lt;/h3&gt;&lt;h4 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="re" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/re/"/>
    
    
      <category term="angr" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/angr/"/>
    
  </entry>
  
  <entry>
    <title>applepie writeup分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/02/applepie/applepie/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/02/applepie/applepie/</id>
    <published>2019-04-02T06:02:40.000Z</published>
    <updated>2019-04-02T10:54:02.233Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>源码解读macOS/iOS Heap</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3macos-heap/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3macos-heap/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/04/01/深入理解macos-heap/深入理解macos-heap/</id>
    <published>2019-04-01T07:30:31.000Z</published>
    <updated>2019-04-02T05:50:15.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码解读macOS-iOS-Heap"><a href="#源码解读macOS-iOS-Heap" class="headerlink" title="源码解读macOS/iOS Heap"></a>源码解读macOS/iOS Heap</h3><blockquote><p>关于linux的堆管理已经有很多人写了很多相关的分析，但在mac平台的堆相关的资料却很少。本文由tctf的一道mac平台pwn题目引起，是我对macOS/iOS的堆管理的一些理解，希望有所帮助。</p></blockquote><h4 id="从malloc说起"><a href="#从malloc说起" class="headerlink" title="从malloc说起"></a>从malloc说起</h4><p><code>malloc</code>是我们经常使用的函数，这里也是<code>libmalloc.dylib</code>暴露出来的接口，另外苹果开源了<a href="https://opensource.apple.com/source/libmalloc/" target="_blank" rel="external">libmalloc代码</a>。所以接下来我们就从源码的角度深入下去。</p><pre><code class="c">void *malloc(size_t size){    void *retval;    retval = malloc_zone_malloc(default_zone, size);    if (retval == NULL) {        errno = ENOMEM;    }    return retval;}</code></pre><p>这里实际调用了<code>malloc_zone_malloc</code>函数，传入了<code>default_zone</code>全局变量</p><pre><code class="c">static virtual_default_zone_t virtual_default_zone__attribute__((section(&quot;__DATA,__v_zone&quot;)))__attribute__((aligned(PAGE_MAX_SIZE))) = {    NULL,    NULL,    default_zone_size,    default_zone_malloc,    default_zone_calloc,    default_zone_valloc,    default_zone_free,    default_zone_realloc,    default_zone_destroy,    DEFAULT_MALLOC_ZONE_STRING,    default_zone_batch_malloc,    default_zone_batch_free,    &amp;default_zone_introspect,    10,    default_zone_memalign,    default_zone_free_definite_size,    default_zone_pressure_relief,    default_zone_malloc_claimed_address,};static malloc_zone_t *default_zone = &amp;virtual_default_zone.malloc_zone;</code></pre><p>这里初始化了一个默认的zone，正如名字一样<code>virtual_default_zone</code>其实是一个虚假的zone，接下来是调用<code>malloc_zone_malloc</code></p><pre><code class="c">void *malloc_zone_malloc(malloc_zone_t *zone, size_t size){    MALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (uintptr_t)zone, size, 0, 0);    void *ptr;    if (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) {        internal_check();    }    if (size &gt; MALLOC_ABSOLUTE_MAX_SIZE) {        return NULL;    }    ptr = zone-&gt;malloc(zone, size);        // if lite zone is passed in then we still call the lite methods    if (malloc_logger) {        malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE, (uintptr_t)zone, (uintptr_t)size, 0, (uintptr_t)ptr, 0);    }    MALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (uintptr_t)zone, size, (uintptr_t)ptr, 0);    return ptr;}</code></pre><p>这里调用的<code>ptr = zone-&gt;malloc(zone, size);</code>就是<code>default_zone_malloc</code>函数</p><pre><code class="c">static void *default_zone_malloc(malloc_zone_t *zone, size_t size){    zone = runtime_default_zone();    return zone-&gt;malloc(zone, size);}</code></pre><p>这里的<code>runtime_default_zone()</code>很重要，其实这里才是去真正的初始化zone</p><pre><code class="c">runtime_default_zone   // inline----inline_malloc_default_zone  //inline--------_malloc_initialize_once  //inline ------------_malloc_initialize()</code></pre><p>下面看<code>_malloc_initialize</code>函数，去掉了一些不相干代码</p><pre><code class="c">static void_malloc_initialize(void *context __unused){    MALLOC_LOCK();    unsigned n;    malloc_zone_t *zone = NULL;    ...    zone = create_scalable_zone(0, malloc_debug_flags);    malloc_zone_register_while_locked(zone);    malloc_set_zone_name(zone, DEFAULT_MALLOC_ZONE_STRING);        initial_default_zone = zone;    if (n != 0) { // make the default first, for efficiency        unsigned protect_size = malloc_num_zones_allocated * sizeof(malloc_zone_t *);        malloc_zone_t *hold = malloc_zones[0];        if (hold-&gt;zone_name &amp;&amp; strcmp(hold-&gt;zone_name, DEFAULT_MALLOC_ZONE_STRING) == 0) {            malloc_set_zone_name(hold, NULL);        }        mprotect(malloc_zones, protect_size, PROT_READ | PROT_WRITE);        malloc_zones[0] = malloc_zones[n];        malloc_zones[n] = hold;        mprotect(malloc_zones, protect_size, PROT_READ);    }    ...}</code></pre><p>这里主要看<code>create_scalable_zone</code>函数，所以默认的zone实际上就是scalable zone</p><pre><code class="c">malloc_zone_t *create_scalable_zone(size_t initial_size, unsigned debug_flags) {    return (malloc_zone_t *) create_scalable_szone(initial_size, debug_flags);}szone_t *create_scalable_szone(size_t initial_size, unsigned debug_flags){    szone_t *szone;    /* get memory for the zone. */    szone = mvm_allocate_pages(SZONE_PAGED_SIZE, 0, 0, VM_MEMORY_MALLOC);    if (!szone) {        return NULL;    }    ...    // Query the number of configured processors.    // Uniprocessor case gets just one tiny and one small magazine (whose index is zero). This gives    // the same behavior as the original scalable malloc. MP gets per-CPU magazines    // that scale (way) better.    unsigned int max_mags = mag_max_magazines();    uint32_t num_magazines = (max_mags &gt; 1) ? MIN(max_mags, TINY_MAX_MAGAZINES) : 1;    rack_init(&amp;szone-&gt;tiny_rack, RACK_TYPE_TINY, num_magazines, debug_flags);    rack_init(&amp;szone-&gt;small_rack, RACK_TYPE_SMALL, num_magazines, debug_flags);#if CONFIG_LARGE_CACHE    // madvise(..., MADV_REUSABLE) death-row arrivals above this threshold [~0.1%]    szone-&gt;large_entry_cache_reserve_limit = (size_t)(memsize &gt;&gt; 10);    /* &lt;rdar://problem/6610904&gt; Reset protection when returning a previous large allocation? */    int32_t libSystemVersion = NSVersionOfLinkTimeLibrary(&quot;System&quot;);    if ((-1 != libSystemVersion) &amp;&amp; ((libSystemVersion &gt;&gt; 16) &lt; 112) /* CFSystemVersionSnowLeopard */) {        szone-&gt;large_legacy_reset_mprotect = TRUE;    } else {        szone-&gt;large_legacy_reset_mprotect = FALSE;    }#endif    // Initialize the security token.    szone-&gt;cookie = (uintptr_t)malloc_entropy[0];    szone-&gt;basic_zone.version = 10;    szone-&gt;basic_zone.size = (void *)szone_size;    szone-&gt;basic_zone.malloc = (void *)szone_malloc;    szone-&gt;basic_zone.calloc = (void *)szone_calloc;    szone-&gt;basic_zone.valloc = (void *)szone_valloc;    szone-&gt;basic_zone.free = (void *)szone_free;    szone-&gt;basic_zone.realloc = (void *)szone_realloc;    szone-&gt;basic_zone.destroy = (void *)szone_destroy;    szone-&gt;basic_zone.batch_malloc = (void *)szone_batch_malloc;    szone-&gt;basic_zone.batch_free = (void *)szone_batch_free;    szone-&gt;basic_zone.introspect = (struct malloc_introspection_t *)&amp;szone_introspect;    szone-&gt;basic_zone.memalign = (void *)szone_memalign;    szone-&gt;basic_zone.free_definite_size = (void *)szone_free_definite_size;    szone-&gt;basic_zone.pressure_relief = (void *)szone_pressure_relief;    szone-&gt;basic_zone.claimed_address = (void *)szone_claimed_address;    /* Set to zero once and for all as required by CFAllocator. */    szone-&gt;basic_zone.reserved1 = 0;    /* Set to zero once and for all as required by CFAllocator. */    szone-&gt;basic_zone.reserved2 = 0;    /* Prevent overwriting the function pointers in basic_zone. */    mprotect(szone, sizeof(szone-&gt;basic_zone), PROT_READ);    szone-&gt;debug_flags = debug_flags;    _malloc_lock_init(&amp;szone-&gt;large_szone_lock);    szone-&gt;cpu_id_key = -1UL; // Unused.    CHECK(szone, __PRETTY_FUNCTION__);    return szone;}</code></pre><p>这个函数分配并且初始化了szone，设置了<code>szone_malloc</code>、<code>szone_free</code>等函数</p><p>所以后面在调用<code>malloc</code>和<code>free</code>的时候实际上调用的是<code>szone_malloc</code>、<code>szone_free</code>。<code>szone_malloc</code>的实现涉及到苹果关于堆设计中最重要的部分，这里先不展开讲解。可以看出苹果设计的这种结构很方便扩展，事实上的确如此，不仅是scalable zone，还可以注册WebKit Malloc、GFXMallocZone、QuartzCore。由对应zone的<code>malloc_zone_*</code>进行实际的内存分配工作。</p><p>下面是程序第一次调用malloc的栈帧，可以看出与我们分析的调用顺序一致</p><pre><code class="c"> *  frame #0: 0x00007fff60bd72af libsystem_malloc.dylib`create_scalable_szone    frame #1: 0x00007fff60bd6e71 libsystem_malloc.dylib`_malloc_initialize + 1482    frame #2: 0x00007fff60c0facb libsystem_platform.dylib`_os_once_callout + 18    frame #3: 0x00007fff60bd68a5 libsystem_malloc.dylib`default_zone_malloc + 77    frame #4: 0x00007fff60bd6807 libsystem_malloc.dylib`malloc_zone_malloc + 103    frame #5: 0x00007fff60bd6783 libsystem_malloc.dylib`malloc + 24    frame #6: 0x00007fff60a9831d libsystem_c.dylib`arc4_init + 109    frame #7: 0x00007fff60a98479 libsystem_c.dylib`arc4random_buf + 37    frame #8: 0x00007fff5f94644e libobjc.A.dylib`_read_images + 396    frame #9: 0x00007fff5f945473 libobjc.A.dylib`map_images_nolock + 1197    frame #10: 0x00007fff5f959279 libobjc.A.dylib`map_images + 68    ....</code></pre><h4 id="scalable-zone"><a href="#scalable-zone" class="headerlink" title="scalable zone"></a>scalable zone</h4><p>szone包含两个racks，分别是tiny和small rack</p><table><thead><tr><th>rack</th><th>32位机器</th><th>64位机器</th></tr></thead><tbody><tr><td>tiny</td><td>&lt;= 496B</td><td>&lt;= 1008B</td></tr><tr><td>small</td><td>&lt;= 128KB</td><td>&lt;=128KB</td></tr></tbody></table><p>大于127KB的就由large allocator分配，直接采用分配页大小的方式。这里不详细讨论。</p><ul><li>有几个处理器，rack就有几个magazine</li><li>每个magazine有多个regions，tiny(1MB)、small(8MB)</li><li>每个region被分为quantum，tiny(16B，64520 Q/region)、small(512B，16319 Q/region)</li></ul><p>具体可以从后面结构体中看出来其包含关系。</p><h5 id="malloc-gt-szone-malloc-gt-szone-malloc-should-clear"><a href="#malloc-gt-szone-malloc-gt-szone-malloc-should-clear" class="headerlink" title="malloc-&gt;szone_malloc-&gt;szone_malloc_should_clear"></a>malloc-&gt;szone_malloc-&gt;szone_malloc_should_clear</h5><pre><code class="c">MALLOC_NOINLINE void *szone_malloc_should_clear(szone_t *szone, size_t size, boolean_t cleared_requested){    void *ptr;    msize_t msize;    if (size &lt;= SMALL_THRESHOLD) {        // tiny size: &lt;=1008 bytes (64-bit), &lt;=496 bytes (32-bit)        // think tiny        msize = TINY_MSIZE_FOR_BYTES(size + TINY_QUANTUM - 1);        if (!msize) {            msize = 1;        }        ptr = tiny_malloc_should_clear(&amp;szone-&gt;tiny_rack, msize, cleared_requested);    } else if (size &lt;= szone-&gt;large_threshold) {        // small size: &lt;=15k (iOS), &lt;=64k (large iOS), &lt;=128k (macOS)        // think small        msize = SMALL_MSIZE_FOR_BYTES(size + SMALL_QUANTUM - 1);        if (!msize) {            msize = 1;        }        ptr = small_malloc_should_clear(&amp;szone-&gt;small_rack, msize, cleared_requested);    } else {        // large: all other allocations        size_t num_kernel_pages = round_page_quanta(size) &gt;&gt; vm_page_quanta_shift;        if (num_kernel_pages == 0) { /* Overflowed */            ptr = 0;        } else {            ptr = large_malloc(szone, num_kernel_pages, 0, cleared_requested);        }    }    return ptr;}</code></pre><p>上面可以清楚看出会根据其申请内存大小从tiny、small、large三种方式分配。这里以tiny为例</p><h5 id="tiny-malloc-should-clear"><a href="#tiny-malloc-should-clear" class="headerlink" title="tiny_malloc_should_clear"></a>tiny_malloc_should_clear</h5><pre><code class="c">void *tiny_malloc_should_clear(rack_t *rack, msize_t msize, boolean_t cleared_requested){    void *ptr;    mag_index_t mag_index = tiny_mag_get_thread_index() % rack-&gt;num_magazines;    magazine_t *tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);    MALLOC_TRACE(TRACE_tiny_malloc, (uintptr_t)rack, TINY_BYTES_FOR_MSIZE(msize), (uintptr_t)tiny_mag_ptr, cleared_requested);#if DEBUG_MALLOC    if (DEPOT_MAGAZINE_INDEX == mag_index) {        malloc_zone_error(rack-&gt;debug_flags, true, &quot;malloc called for magazine index -1\n&quot;);        return (NULL);    }    if (!msize) {        malloc_zone_error(rack-&gt;debug_flags, true, &quot;invariant broken (!msize) in allocation (region)\n&quot;);        return (NULL);    }#endif    SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);#if CONFIG_TINY_CACHE    ptr = tiny_mag_ptr-&gt;mag_last_free;    if (tiny_mag_ptr-&gt;mag_last_free_msize == msize) {        // we have a winner        tiny_mag_ptr-&gt;mag_last_free = NULL;        tiny_mag_ptr-&gt;mag_last_free_msize = 0;        tiny_mag_ptr-&gt;mag_last_free_rgn = NULL;        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);        CHECK(szone, __PRETTY_FUNCTION__);        if (cleared_requested) {            memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize));        }#if DEBUG_MALLOC        if (LOG(szone, ptr)) {            malloc_report(ASL_LEVEL_INFO, &quot;in tiny_malloc_should_clear(), tiny cache ptr=%p, msize=%d\n&quot;, ptr, msize);        }#endif        return ptr;    }#endif /* CONFIG_TINY_CACHE */    while (1) {        ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);        if (ptr) {            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            CHECK(szone, __PRETTY_FUNCTION__);            if (cleared_requested) {                memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize));            }            return ptr;        }        if (tiny_get_region_from_depot(rack, tiny_mag_ptr, mag_index, msize)) {            ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);            if (ptr) {                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);                CHECK(szone, __PRETTY_FUNCTION__);                if (cleared_requested) {                    memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize));                }                return ptr;            }        }        // The magazine is exhausted. A new region (heap) must be allocated to satisfy this call to malloc().        // The allocation, an mmap() system call, will be performed outside the magazine spin locks by the first        // thread that suffers the exhaustion. That thread sets &quot;alloc_underway&quot; and enters a critical section.        // Threads arriving here later are excluded from the critical section, yield the CPU, and then retry the        // allocation. After some time the magazine is resupplied, the original thread leaves with its allocation,        // and retry-ing threads succeed in the code just above.        if (!tiny_mag_ptr-&gt;alloc_underway) {            void *fresh_region;            // time to create a new region (do this outside the magazine lock)            tiny_mag_ptr-&gt;alloc_underway = TRUE;            OSMemoryBarrier();            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            fresh_region = mvm_allocate_pages_securely(TINY_REGION_SIZE, TINY_BLOCKS_ALIGN, VM_MEMORY_MALLOC_TINY, rack-&gt;debug_flags);            SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);            // DTrace USDT Probe            MAGMALLOC_ALLOCREGION(TINY_SZONE_FROM_RACK(rack), (int)mag_index, fresh_region, TINY_REGION_SIZE);            if (!fresh_region) { // out of memory!                tiny_mag_ptr-&gt;alloc_underway = FALSE;                OSMemoryBarrier();                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);                return NULL;            }            ptr = tiny_malloc_from_region_no_lock(rack, tiny_mag_ptr, mag_index, msize, fresh_region);            // we don&#39;t clear because this freshly allocated space is pristine            tiny_mag_ptr-&gt;alloc_underway = FALSE;            OSMemoryBarrier();            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            CHECK(szone, __PRETTY_FUNCTION__);            return ptr;        } else {            SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);            yield();            SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);        }    }    /* NOTREACHED */}</code></pre><p>这里的<code>if (tiny_mag_ptr-&gt;mag_last_free_msize == msize)</code>是判断申请大小是否和缓存的大小相同，如果相同，则直接把该内存返回给程序。反之则从<code>ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);</code>free list中去获取刚好大于该大小的free list。这里的free list是按quantum的倍数递增的一个链表。若还是不能满足则去freelist中由合并得到的较大block中去分配。还不能满足则去region剩余部分申请。最后还不满足则申请新的一个region。申请失败则返回NULL。</p><h5 id="free-gt-malloc-zone-free-gt-szone-free"><a href="#free-gt-malloc-zone-free-gt-szone-free" class="headerlink" title="free-&gt;malloc_zone_free-&gt;szone_free"></a>free-&gt;malloc_zone_free-&gt;szone_free</h5><pre><code class="c">voidszone_free(szone_t *szone, void *ptr){    region_t tiny_region;    region_t small_region;#if DEBUG_MALLOC    if (LOG(szone, ptr)) {        malloc_report(ASL_LEVEL_INFO, &quot;in szone_free with %p\n&quot;, ptr);    }#endif    if (!ptr) {        return;    }    /*     * Try to free to a tiny region.     */    if ((uintptr_t)ptr &amp; (TINY_QUANTUM - 1)) {        malloc_zone_error(szone-&gt;debug_flags, true, &quot;Non-aligned pointer %p being freed\n&quot;, ptr);        return;    }    if ((tiny_region = tiny_region_for_ptr_no_lock(&amp;szone-&gt;tiny_rack, ptr)) != NULL) {        if (TINY_INDEX_FOR_PTR(ptr) &gt;= NUM_TINY_BLOCKS) {            malloc_zone_error(szone-&gt;debug_flags, true, &quot;Pointer %p to metadata being freed\n&quot;, ptr);            return;        }        free_tiny(&amp;szone-&gt;tiny_rack, ptr, tiny_region, 0);        return;    }    /*     * Try to free to a small region.     */    if ((uintptr_t)ptr &amp; (SMALL_QUANTUM - 1)) {        malloc_zone_error(szone-&gt;debug_flags, true, &quot;Non-aligned pointer %p being freed (2)\n&quot;, ptr);        return;    }    if ((small_region = small_region_for_ptr_no_lock(&amp;szone-&gt;small_rack, ptr)) != NULL) {        if (SMALL_META_INDEX_FOR_PTR(ptr) &gt;= NUM_SMALL_BLOCKS) {            malloc_zone_error(szone-&gt;debug_flags, true, &quot;Pointer %p to metadata being freed (2)\n&quot;, ptr);            return;        }        free_small(&amp;szone-&gt;small_rack, ptr, small_region, 0);        return;    }    /* check that it&#39;s a legal large allocation */    if ((uintptr_t)ptr &amp; (vm_page_quanta_size - 1)) {        malloc_zone_error(szone-&gt;debug_flags, true, &quot;non-page-aligned, non-allocated pointer %p being freed\n&quot;, ptr);        return;    }    free_large(szone, ptr);}</code></pre><p>同样，free的时候会先判断该内存是否属于tiny，small，large。则选取对应的free函数。这里以tiny为例</p><pre><code class="c">voidfree_tiny(rack_t *rack, void *ptr, region_t tiny_region, size_t known_size){    msize_t msize;    boolean_t is_free;    mag_index_t mag_index = MAGAZINE_INDEX_FOR_TINY_REGION(tiny_region);    magazine_t *tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);    MALLOC_TRACE(TRACE_tiny_free, (uintptr_t)rack, (uintptr_t)ptr, (uintptr_t)tiny_mag_ptr, known_size);    // ptr is known to be in tiny_region    if (known_size) {        msize = TINY_MSIZE_FOR_BYTES(known_size + TINY_QUANTUM - 1);    } else {        msize = get_tiny_meta_header(ptr, &amp;is_free);        if (is_free) {            free_tiny_botch(rack, ptr);            return;        }    }#if DEBUG_MALLOC    if (!msize) {        malloc_report(ASL_LEVEL_ERR, &quot;*** free_tiny() block in use is too large: %p\n&quot;, ptr);        return;    }#endif    SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);#if CONFIG_TINY_CACHE    // Depot does not participate in CONFIG_TINY_CACHE since it can&#39;t be directly malloc()&#39;d    if (DEPOT_MAGAZINE_INDEX != mag_index) {        if (msize &lt; TINY_QUANTUM) {                      // to see if the bits fit in the last 4 bits            void *ptr2 = tiny_mag_ptr-&gt;mag_last_free; // Might be NULL            msize_t msize2 = tiny_mag_ptr-&gt;mag_last_free_msize;            region_t rgn2 = tiny_mag_ptr-&gt;mag_last_free_rgn;            /* check that we don&#39;t already have this pointer in the cache */            if (ptr == ptr2) {                free_tiny_botch(rack, ptr);                return;            }            if ((rack-&gt;debug_flags &amp; MALLOC_DO_SCRIBBLE) &amp;&amp; msize) {                memset(ptr, SCRABBLE_BYTE, TINY_BYTES_FOR_MSIZE(msize));            }            tiny_mag_ptr-&gt;mag_last_free = ptr;            tiny_mag_ptr-&gt;mag_last_free_msize = msize;            tiny_mag_ptr-&gt;mag_last_free_rgn = tiny_region;            if (!ptr2) {                SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);                CHECK(szone, __PRETTY_FUNCTION__);                return;            }            msize = msize2;            ptr = ptr2;            tiny_region = rgn2;        }    }#endif /* CONFIG_TINY_CACHE */    // Now in the time it took to acquire the lock, the region may have migrated    // from one magazine to another. I.e. trailer-&gt;mag_index is volatile.    // In which case the magazine lock we obtained (namely magazines[mag_index].mag_lock)    // is stale. If so, keep on tryin&#39; ...    region_trailer_t *trailer = REGION_TRAILER_FOR_TINY_REGION(tiny_region);    mag_index_t refreshed_index;    while (mag_index != (refreshed_index = trailer-&gt;mag_index)) { // Note assignment        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);        mag_index = refreshed_index;        tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]);        SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr);    }    if (tiny_free_no_lock(rack, tiny_mag_ptr, mag_index, tiny_region, ptr, msize)) {        SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr);    }    CHECK(szone, __PRETTY_FUNCTION__);}</code></pre><p>free的时候先将该内存缓存到<code>mag_last_free</code>，若之前<code>mag_last_free</code>为NULL，那么该内存暂时不会被free，仅仅是缓存到<code>mag_last_free</code>。反之，则会将<code>mag_last_free</code>之前的内存free。在free的时候会尝试向前向后合并。合并完成后设置其前后chunk指针等metadata后将其放入对应的free list大小之中。这里需要有注意以下几点</p><ul><li>最近free的内存会被缓存，不会立即合并</li><li>在被free的块metadata是被保护的<ul><li>前后指针按16字节大小对齐</li><li>指针前4位为checksum</li></ul></li></ul><p>关于free块checksum计算如下：</p><pre><code class="c">static MALLOC_INLINE uintptr_tfree_list_checksum_ptr(rack_t *rack, void *ptr){    uintptr_t p = (uintptr_t)ptr;    return (p &gt;&gt; NYBBLE) | ((free_list_gen_checksum(p ^ rack-&gt;cookie) &amp; (uintptr_t)0xF) &lt;&lt; ANTI_NYBBLE); // compiles to rotate instruction}</code></pre><p>指针p与cookie异或然后计算checksum后左移到最高字节或上指针p右移4位得到checksumed后的指针。</p><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>代码如下</p><pre><code class="c">#include &lt;stdio.h&gt;int main(int argc, char *argv[]) {    void *p1,*p2,*p3,*p4;    p1 = malloc(24);    p2 = malloc(24);    p3 = malloc(24);    p4 = malloc(24);    memset(p1,0xaa,24);    memset(p2,0xbb,24);    memset(p3,0xcc,24);    free(p1);    free(p3);    free(p2);    free(p4);}</code></pre><p>free(p1)，直接将p1缓存，所以内存值不变</p><pre><code class="c">(lldb) x/24gx p10x1002001f0: 0xaaaaaaaaaaaaaaaa 0xaaaaaaaaaaaaaaaa0x100200200: 0xaaaaaaaaaaaaaaaa 0x00007fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0xcccccccccccccccc 0xcccccccccccccccc0x100200240: 0xcccccccccccccccc 0x0000000000000000</code></pre><p>free(p3)，p3放入缓存，p1放入大小为32字节的freelist，p1previous指针8字节设为NULL，next指针指向设为下一个free block，紧接着后面为该block大小，2*quantum=32字节</p><pre><code>(lldb) x/24gx p10x1002001f0: 0x0000000000000000 0x10000000100201080x100200200: 0xaaaaaaaaaaaa0002 0x00027fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0xcccccccccccccccc 0xcccccccccccccccc0x100200240: 0xcccccccccccccccc 0x0000000000000000</code></pre><p>free(p2)，p2放入缓存，p3放入大小为32字节的freelist，p3previous指针8字节设为NULL，next指针指向设为下一个p1</p><pre><code>(lldb) x/24gx p10x1002001f0: 0x3000000010020023 0x10000000100201080x100200200: 0xaaaaaaaaaaaa0002 0x00027fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0x0000000000000000 0x200000001002001f0x100200240: 0xcccccccccccc0002 0x00020000000000000x100200250: 0x0000000000000000 0x00000000000000000x100200260: 0x0000000000000029 0x0000000000000000</code></pre><p>free(p4)，p2向前向后合并，合并p1，p3。指向p1，大小为6*quantum=96字节。previous指针8字节设为NULL，next指针指向设为下一个大小为3Q的block</p><pre><code>(lldb) x/24gx p10x1002001f0: 0x0000000000000000 0x50000000100200480x100200200: 0xaaaaaaaaaaaa0006 0x00027fff5f94d99c0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb0x100200220: 0xbbbbbbbbbbbbbbbb 0x00000000000000000x100200230: 0x0000000000000000 0x10000000100201080x100200240: 0xcccccccccccc0002 0x00060000000000000x100200250: 0x0000000000000000 0x00000000000000000x100200260: 0x0000000000000029 0x0000000000000000</code></pre><p>上面可以看出previous和next指针前4位都包含checksum。与上面描述的一致。</p><h4 id="libmalloc中一些结构体"><a href="#libmalloc中一些结构体" class="headerlink" title="libmalloc中一些结构体"></a>libmalloc中一些结构体</h4><h5 id="szone-s-magazine-zone-h"><a href="#szone-s-magazine-zone-h" class="headerlink" title="szone_s // magazine_zone.h"></a>szone_s // magazine_zone.h</h5><pre><code class="c">typedef struct szone_s {      // vm_allocate()&#39;d, so page-aligned to begin with.    malloc_zone_t basic_zone; // first page will be given read-only protection    uint8_t pad[PAGE_MAX_SIZE - sizeof(malloc_zone_t)];    unsigned long cpu_id_key; // unused    // remainder of structure is R/W (contains no function pointers)    unsigned debug_flags;    void *log_address;    /* Allocation racks per allocator type. */    struct rack_s tiny_rack;    struct rack_s small_rack;    /* large objects: all the rest */    _malloc_lock_s large_szone_lock MALLOC_CACHE_ALIGN; // One customer at a time for large    unsigned num_large_objects_in_use;    unsigned num_large_entries;    large_entry_t *large_entries; // hashed by location; null entries don&#39;t count    size_t num_bytes_in_large_objects;#if CONFIG_LARGE_CACHE    int large_entry_cache_oldest;    int large_entry_cache_newest;    large_entry_t large_entry_cache[LARGE_ENTRY_CACHE_SIZE]; // &quot;death row&quot; for large malloc/free    boolean_t large_legacy_reset_mprotect;    size_t large_entry_cache_reserve_bytes;    size_t large_entry_cache_reserve_limit;    size_t large_entry_cache_bytes; // total size of death row, bytes#endif    /* flag and limits pertaining to altered malloc behavior for systems with     * large amounts of physical memory */    unsigned is_largemem;    unsigned large_threshold;    unsigned vm_copy_threshold;    /* security cookie */    uintptr_t cookie;    /* The purgeable zone constructed by create_purgeable_zone() would like to hand off tiny and small     * allocations to the default scalable zone. Record the latter as the &quot;helper&quot; zone here. */    struct szone_s *helper_zone;    boolean_t flotsam_enabled;} szone_t;</code></pre><h5 id="malloc-zone-t-malloc-h"><a href="#malloc-zone-t-malloc-h" class="headerlink" title="malloc_zone_t // malloc.h"></a>malloc_zone_t // malloc.h</h5><pre><code class="c">typedef struct _malloc_zone_t {    /* Only zone implementors should depend on the layout of this structure;    Regular callers should use the access functions below */    void    *reserved1;    /* RESERVED FOR CFAllocator DO NOT USE */    void    *reserved2;    /* RESERVED FOR CFAllocator DO NOT USE */    size_t     (* MALLOC_ZONE_FN_PTR(size))(struct _malloc_zone_t *zone, const void *ptr); /* returns the size of a block or 0 if not in this zone; must be fast, especially for negative answers */    void     *(* MALLOC_ZONE_FN_PTR(malloc))(struct _malloc_zone_t *zone, size_t size);    void     *(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size); /* same as malloc, but block returned is set to zero */    void     *(* MALLOC_ZONE_FN_PTR(valloc))(struct _malloc_zone_t *zone, size_t size); /* same as malloc, but block returned is set to zero and is guaranteed to be page aligned */    void     (* MALLOC_ZONE_FN_PTR(free))(struct _malloc_zone_t *zone, void *ptr);    void     *(* MALLOC_ZONE_FN_PTR(realloc))(struct _malloc_zone_t *zone, void *ptr, size_t size);    void     (* MALLOC_ZONE_FN_PTR(destroy))(struct _malloc_zone_t *zone); /* zone is destroyed and all memory reclaimed */g    const char    *zone_name;    /* Optional batch callbacks; these may be NULL */    unsigned    (* MALLOC_ZONE_FN_PTR(batch_malloc))(struct _malloc_zone_t *zone, size_t size, void **results, unsigned num_requested); /* given a size, returns pointers capable of holding that size; returns the number of pointers allocated (maybe 0 or less than num_requested) */    void    (* MALLOC_ZONE_FN_PTR(batch_free))(struct _malloc_zone_t *zone, void **to_be_freed, unsigned num_to_be_freed); /* frees all the pointers in to_be_freed; note that to_be_freed may be overwritten during the process */    struct malloc_introspection_t    * MALLOC_INTROSPECT_TBL_PTR(introspect);    unsigned    version;    /* aligned memory allocation. The callback may be NULL. Present in version &gt;= 5. */    void *(* MALLOC_ZONE_FN_PTR(memalign))(struct _malloc_zone_t *zone, size_t alignment, size_t size);    /* free a pointer known to be in zone and known to have the given size. The callback may be NULL. Present in version &gt;= 6.*/    void (* MALLOC_ZONE_FN_PTR(free_definite_size))(struct _malloc_zone_t *zone, void *ptr, size_t size);    /* Empty out caches in the face of memory pressure. The callback may be NULL. Present in version &gt;= 8. */    size_t     (* MALLOC_ZONE_FN_PTR(pressure_relief))(struct _malloc_zone_t *zone, size_t goal);    /*     * Checks whether an address might belong to the zone. May be NULL. Present in version &gt;= 10.     * False positives are allowed (e.g. the pointer was freed, or it&#39;s in zone space that has     * not yet been allocated. False negatives are not allowed.     */    boolean_t (* MALLOC_ZONE_FN_PTR(claimed_address))(struct _malloc_zone_t *zone, void *ptr);} malloc_zone_t;</code></pre><h5 id="rack-t-magazine-rack-h"><a href="#rack-t-magazine-rack-h" class="headerlink" title="rack_t // magazine_rack.h"></a>rack_t // magazine_rack.h</h5><pre><code class="c">typedef struct rack_s {    /* Regions for tiny objects */    _malloc_lock_s region_lock MALLOC_CACHE_ALIGN;    rack_type_t type;    size_t num_regions;    size_t num_regions_dealloc;    region_hash_generation_t *region_generation;    region_hash_generation_t rg[2];    region_t initial_regions[INITIAL_NUM_REGIONS];    int num_magazines;    unsigned num_magazines_mask;    int num_magazines_mask_shift;    uint32_t debug_flags;    // array of per-processor magazines    magazine_t *magazines;    uintptr_t cookie;    uintptr_t last_madvise;} rack_t;</code></pre><h5 id="magazine-t-magazine-zone-h"><a href="#magazine-t-magazine-zone-h" class="headerlink" title="magazine_t // magazine_zone.h"></a>magazine_t // magazine_zone.h</h5><pre><code class="c">typedef struct magazine_s { // vm_allocate()&#39;d, so the array of magazines is page-aligned to begin with.    // Take magazine_lock first,  Depot lock when needed for recirc, then szone-&gt;{tiny,small}_regions_lock when needed for alloc    _malloc_lock_s magazine_lock MALLOC_CACHE_ALIGN;    // Protection for the crtical section that does allocate_pages outside the magazine_lock    volatile boolean_t alloc_underway;    // One element deep &quot;death row&quot;, optimizes malloc/free/malloc for identical size.    void *mag_last_free;    msize_t mag_last_free_msize;    // msize for mag_last_free#if MALLOC_TARGET_64BIT    uint32_t _pad;#endif    region_t mag_last_free_rgn; // holds the region for mag_last_free    free_list_t mag_free_list[MAGAZINE_FREELIST_SLOTS];    uint32_t mag_bitmap[MAGAZINE_FREELIST_BITMAP_WORDS];    // the first and last free region in the last block are treated as big blocks in use that are not accounted for    size_t mag_bytes_free_at_end;    size_t mag_bytes_free_at_start;    region_t mag_last_region; // Valid iff mag_bytes_free_at_end || mag_bytes_free_at_start &gt; 0    // bean counting ...    size_t mag_num_bytes_in_objects;    size_t num_bytes_in_magazine;    unsigned mag_num_objects;    // recirculation list -- invariant: all regions owned by this magazine that meet the emptiness criteria    // are located nearer to the head of the list than any region that doesn&#39;t satisfy that criteria.    // Doubly linked list for efficient extraction.    unsigned recirculation_entries;    region_trailer_t *firstNode;    region_trailer_t *lastNode;#if MALLOC_TARGET_64BIT    uintptr_t pad[320 - 14 - MAGAZINE_FREELIST_SLOTS -            (MAGAZINE_FREELIST_BITMAP_WORDS + 1) / 2];#else    uintptr_t pad[320 - 16 - MAGAZINE_FREELIST_SLOTS -            MAGAZINE_FREELIST_BITMAP_WORDS];#endif} magazine_t;</code></pre><h5 id="tiny-region-t-magazine-zone-h"><a href="#tiny-region-t-magazine-zone-h" class="headerlink" title="tiny_region_t //magazine_zone.h"></a>tiny_region_t //magazine_zone.h</h5><pre><code class="c">/* * Layout of a tiny region */typedef uint32_t tiny_block_t[4]; // assert(TINY_QUANTUM == sizeof(tiny_block_t))typedef struct tiny_header_inuse_pair {    uint32_t header;    uint32_t inuse;} tiny_header_inuse_pair_t;typedef struct region_trailer {    struct region_trailer *prev;    struct region_trailer *next;    boolean_t recirc_suitable;    volatile int pinned_to_depot;    unsigned bytes_used;    mag_index_t mag_index;} region_trailer_t;#define NUM_TINY_BLOCKS 64520typedef struct tiny_region {    tiny_block_t blocks[NUM_TINY_BLOCKS];    region_trailer_t trailer;    // The interleaved bit arrays comprising the header and inuse bitfields.    // The unused bits of each component in the last pair will be initialized to sentinel values.    tiny_header_inuse_pair_t pairs[CEIL_NUM_TINY_BLOCKS_WORDS];    uint8_t pad[TINY_REGION_SIZE - (NUM_TINY_BLOCKS * sizeof(tiny_block_t)) - TINY_METADATA_SIZE];} * tiny_region_t;</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><p><a href="http://phrack.org/issues/63/5.html" target="_blank" rel="external">http://phrack.org/issues/63/5.html</a></p></li><li><p><a href="https://www.synacktiv.com/ressources/Sthack_2018_Heapple_Pie.pdf" target="_blank" rel="external">https://www.synacktiv.com/ressources/Sthack_2018_Heapple_Pie.pdf</a></p></li><li><p><a href="https://papers.put.as/papers/macosx/2016/Summercon-2016.pdf" target="_blank" rel="external">https://papers.put.as/papers/macosx/2016/Summercon-2016.pdf</a></p></li><li><p><a href="https://www.cocoawithlove.com/2010/05/look-at-how-malloc-works-on-mac.html" target="_blank" rel="external">https://www.cocoawithlove.com/2010/05/look-at-how-malloc-works-on-mac.html</a></p></li><li><p>&lt;&lt;<a href="https://repo.zenk-security.com/Magazine%20E-book/The%20Mac%20Hacker&#39;s%20Handbook.pdf" target="_blank" rel="external">the Mac Hacker’s Handbook</a>&gt;&gt; 第8章Exploiting Heap Overflows</p></li><li><p><a href="https://opensource.apple.com/source/libmalloc/" target="_blank" rel="external">https://opensource.apple.com/source/libmalloc/</a> 源代码</p></li><li><p><a href="http://www.mindfiresolutions.com/mindfire/Mac_Memory_Manager.pdf" target="_blank" rel="external">http://www.mindfiresolutions.com/mindfire/Mac_Memory_Manager.pdf</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;源码解读macOS-iOS-Heap&quot;&gt;&lt;a href=&quot;#源码解读macOS-iOS-Heap&quot; class=&quot;headerlink&quot; title=&quot;源码解读macOS/iOS Heap&quot;&gt;&lt;/a&gt;源码解读macOS/iOS Heap&lt;/h3&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="OS" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/OS/"/>
    
    
      <category term="heap" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>TCTF-Elements</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/27/TCTF-Elements/TCTF-Elements/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/27/TCTF-Elements/TCTF-Elements/</id>
    <published>2019-03-27T07:13:30.000Z</published>
    <updated>2019-03-28T07:06:17.336Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TCTF-Elements"><a href="#TCTF-Elements" class="headerlink" title="TCTF-Elements"></a>TCTF-Elements</h4><blockquote><p>这道题其实是一个数学问题，当时没有做出来，解题过程中走了很多弯路，踩了很多坑，不过也补了很多知识。</p></blockquote><h4 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h4><p>下面是main函数伪代码</p><pre><code class="c">signed __int64 __fastcall main(__int64 a1, char **a2, char **a3){  char v3; // bl  const __int32_t **v4; // rax  char *v5; // rcx  size_t v6; // rcx  signed __int64 result; // rax  char *v8; // r12  signed __int64 v9; // r14  char v10; // bl  signed __int64 v11; // rax  const unsigned __int16 *v12; // rcx  signed __int64 v13; // rdx  __int64 v14; // rsi  unsigned __int16 v15; // bx  signed __int64 v16; // rsi  __m128i v17; // xmm0  char *v18; // rax  double v19; // xmm2_8  double v20; // xmm0_8  double v21; // xmm2_8  double v22; // xmm3_8  double v23; // [rsp+20h] [rbp-148h]  double v24; // [rsp+28h] [rbp-140h]  double v25; // [rsp+30h] [rbp-138h]  char s[8]; // [rsp+40h] [rbp-128h]  char v27; // [rsp+6Bh] [rbp-FDh]  fgets(s, 256, stdin);  v3 = s[0];  if ( s[0] )  {    v4 = __ctype_tolower_loc();    v5 = &amp;s[1];    do    {      *(v5 - 1) = (*v4)[v3];      v3 = *v5++;    }    while ( v3 );  }  v6 = strlen(s);  result = 0LL;  if ( v6 &gt;= 0x2C &amp;&amp; (*(_QWORD *)s &amp; 0xFFFFFFFFFFLL) == 530015415398LL &amp;&amp; v27 == 125 )  {    v27 = 0;    v8 = strtok(&amp;s[5], &quot;-&quot;);    v9 = 0LL;    if ( v8 )    {      while ( strlen(v8) == 12 )      {        v10 = *v8;        v11 = 0LL;        if ( *v8 )        {          v12 = *__ctype_b_loc();          v13 = 1LL;          v11 = 0LL;          do          {            v14 = v10;            v15 = v12[v10];            if ( (char)v14 &lt;= 102 &amp;&amp; v15 &amp; 0x400 )            {              v16 = v14 - 87;            }            else            {              if ( !(v15 &amp; 0x800) )                goto LABEL_31;              v16 = v14 - 48;            }            v11 = v16 | 16 * v11;            if ( v13 &gt; 11 )              break;            v10 = v8[v13++];          }          while ( v10 );        }        if ( !v9 &amp;&amp; v11 != 62791383142154LL )          break;        v17 = (__m128i)_mm_sub_pd(                         (__m128d)_mm_unpacklo_epi32((__m128i)(unsigned __int64)v11, (__m128i)xmmword_400BD0),                         (__m128d)xmmword_400BE0);        *(&amp;v23 + v9++) = COERCE_DOUBLE(_mm_shuffle_epi32(v17, 78)) + *(double *)v17.m128i_i64;        v18 = strtok(0LL, &quot;-&quot;);        v8 = v18;        if ( v9 &gt; 2 || !v18 )        {          if ( v24 &lt;= v23 || v25 &lt;= v24 || v23 + v24 &lt;= v25 )            break;          v19 = v24 * v24 + v23 * v23 - v25 * v25;          v20 = sqrt(4.0 * v23 * v23 * v24 * v24 - v19 * v19) * 0.25;          v21 = (v20 + v20) / (v23 + v24 + v25) + -1.940035480806554e13;          if ( v21 &lt; 0.00001 &amp;&amp; v21 &gt; -0.00001 )          {            v22 = v23 * v24 * v25 / (v20 * 4.0) + -4.777053952827391e13;            if ( v22 &lt; 0.00001 &amp;&amp; v22 &gt; -0.00001 )              puts(&quot;Congratz, input is your flag&quot;);          }          return 0LL;        }      }    }LABEL_31:    result = 0xFFFFFFFFLL;  }  return result;}</code></pre><p>这个题整个逻辑很清晰，前面一部分对输入的字符串做了一些格式和字符数量判断。</p><p>分析可得到需要输入以下格式<code>flag{xxxxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxx}</code></p><p>这里通过<code>-</code>分割成三个部分，其中第一部分是已知的<code>391bc2164f0a</code>，后面就是程序验证逻辑</p><pre><code class="c">          if ( v24 &lt;= v23 || v25 &lt;= v24 || v23 + v24 &lt;= v25 )            break;          v19 = v24 * v24 + v23 * v23 - v25 * v25;          v20 = sqrt(4.0 * v23 * v23 * v24 * v24 - v19 * v19) * 0.25;          v21 = (v20 + v20) / (v23 + v24 + v25) + -1.940035480806554e13;          if ( v21 &lt; 0.00001 &amp;&amp; v21 &gt; -0.00001 )          {            v22 = v23 * v24 * v25 / (v20 * 4.0) + -4.777053952827391e13;            if ( v22 &lt; 0.00001 &amp;&amp; v22 &gt; -0.00001 )              puts(&quot;Congratz, input is your flag&quot;);          }</code></pre><p>当时一看其实就知道是一个三角形相关的运算，整理可得以下表达式</p><p>$c&gt;b,b&gt;a,a+b&gt;c$</p><p>$p=\frac{\sqrt{4a^2b^2-(a^2+b^2-c^2)^2)}}{2(a+b+c)}-1.940035480806554e13$</p><p>$q=\frac{abc}{(\sqrt{4a^2b^2-(a^2+b^2-c^2)^2})}-4.777053952827391e13$</p><p>$-0.00001&lt;p&lt;0.00001,-0.00001&lt;q&lt;0.00001 $</p><p>但并没有看出来是三角形内外圆的半径公式，所以想着直接上约束求解器z3</p><pre><code class="python">from z3 import *x = Real(&#39;x&#39;)y = Real(&#39;y&#39;)z = Real(&#39;z&#39;)m = Real(&#39;m&#39;)n = Real(&#39;n&#39;)p = Real(&#39;p&#39;)q = Real(&#39;q&#39;)solver = Solver()m = x*x+y*y-z*zn = (4.0*x*x*y*y-m*m)**0.5*0.25p = 2*n/(x+y+z) + (-1.940035480806554296875E13)q = x*y*z/(4.0*n) + (-4.777053952827391e13)solver.add(z &gt; y)solver.add(y &gt; x)solver.add(x + y &gt; z)solver.add(p &gt; -100,p&lt;100)solver.add(q &gt; -100,q&lt;100)solver.add(x == 6.2791383142154e13)if solver.check() == sat:    print(solver.model())else:    print(&#39;unsolve&#39;)</code></pre><p>结果求解了很久z3解不出来，后来才知道z3不能求解该类问题。z3文档中有提及只能解决非线性多项式约束，导致花了很长时间在思考是不是脚本的问题。然后用wolframalpha去求解也没有结果（目前还不清楚原因</p><p>下来思考了很久才知道是求解三角形的内外半径，通过内外圆的性质得到如下公式</p><p>$$Rr=\frac{abc}{2(a+b+c)}$$</p><p>$$tan\frac{C}{2} = \frac{2r}{a+b-c} = \frac{sinC}{1+cosC}$$</p><p>这里$sinC,cosC,R,r,c$都是已知的</p><p>所以联立能得到$$a=7.0802074077033E13,b=9.5523798483318E13 $$</p><p>得到对应的浮点数表示4064e4798769,56e0de138176</p><pre><code class="assembly">movq    xmm0, raxpunpckldq xmm0, xmmword ptr cs:qword_400BD0subpd   xmm0, cs:xmmword_400BE0pshufd  xmm1, xmm0, 4Ehaddpd   xmm1, xmm0movlpd  [rsp+r14*8+168h+var_148], xmm1</code></pre><p>在这里需要逆向求解出rax的值，即flag后面两部分。刚开始在这里卡了一下，感觉求解不出来。后面观察到qword_400BD0和xmmword_400BE0这两个数十分特殊</p><pre><code>qword_400BD0=0x4530000043300000xmmword_400BE0=0x45300000000000004330000000000000</code></pre><p>punpckldq指令会将qword_400BD0和rax分成两部分组合，这里恰好qword_400BD0为浮点数的阶数部分，rax为尾数部分</p><p>然后再分别与4530000000000000，4330000000000000相减。特殊在于这两个数阶数和上面对应相等，尾数部分为0，倒是相减结果又变回原始值。</p><p>所以其实这里的变换等于没有变换。</p><p>所以三个边长分别等于391bc2164f0a,4064e4798769,56e0de138176</p><p>最后的flag=flag{391bc2164f0a-4064e4798769-56e0de138176}</p><h4 id="补充：浮点数表示、运算、指令"><a href="#补充：浮点数表示、运算、指令" class="headerlink" title="补充：浮点数表示、运算、指令"></a>补充：浮点数表示、运算、指令</h4><p>浮点数有单精度和双精度之分，float占4个字节，double占8个字节</p><p>在表示小数的时候采用类比科学计数法的方法，把二进制小数转换为2为底的指数表示$V=(-1)^s<em>M</em>2^E$</p><p>e等于向左或向右移动到1为止的个数</p><p>比如：12.25   对应二进制：1100.01 这里需要向右移动三位$1.10001*2^3$</p><p>下面以float表示12.25这个数，分为三部分，符号位（1位）、指数（8位）、尾数（23位）</p><p>符号位0，指数3，尾数10001(第一位默认为1不需要表示)</p><p>由于指数也有负指数，所以其实还需要一位表示符号位， IEEE规定，小于01111111的指数位为负数</p><p>其实这里可以理解为首位表示符号位，这样的话采用如下计算出float指数部分表示<code>10000000+11-1=10000010</code></p><p>最后12.15单精度浮点数表示为：<code>0 10000010 10001000000000000000000</code> </p><p>十六进制：<code>0x41440000</code> 内存中小端表示：<code>00 00 44 41</code></p><table><thead><tr><th style="text-align:center">Float/Double</th><th style="text-align:center">符号位</th><th style="text-align:center">指数</th><th style="text-align:center">尾数</th><th style="text-align:left">示例</th><th style="text-align:left">16进制</th></tr></thead><tbody><tr><td style="text-align:center">Float</td><td style="text-align:center">1位</td><td style="text-align:center">8位</td><td style="text-align:center">23位</td><td style="text-align:left">0 10000010 10001000000000000000000</td><td style="text-align:left">41440000</td></tr><tr><td style="text-align:center">Double</td><td style="text-align:center">1位</td><td style="text-align:center">11位</td><td style="text-align:center">52位</td><td style="text-align:left">0 10000000010 1000100000000000000000000000 000000000000000000000000</td><td style="text-align:left">4028800000000000</td></tr></tbody></table><p>特殊的数表示：当全指数尾数全为0时，表示最小的数，这里定义为0；当指数全为1，尾数全为0时，表示最大的数，这里定义为无穷。</p><p>在线转换<a href="http://www.binaryconvert.com/" target="_blank" rel="external">http://www.binaryconvert.com/</a> </p><p>浮点数在进行加减运算的时候需要先对阶然后尾数部分运算</p><p>浮点数指令查询<a href="https://asm.inightmare.org/opcodelst/index.php" target="_blank" rel="external">https://asm.inightmare.org/opcodelst/index.php</a></p><p>这里解释下<code>pshufd  xmm1, xmm0, 4Eh</code>指令</p><p><code>pshufd</code>可以按照指定的方式重新排列数据</p><p>这里4E二进制<code>01 00 11 10</code></p><table><thead><tr><th>寄存器</th><th>值</th></tr></thead><tbody><tr><td>xmm0</td><td>42cc8d80 00000000 41e842c9 e1400000</td></tr><tr><td>4E</td><td>01               00                 11               10</td></tr><tr><td>xmm1</td><td>41e842c9 e1400000 42cc8d80 00000000</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;TCTF-Elements&quot;&gt;&lt;a href=&quot;#TCTF-Elements&quot; class=&quot;headerlink&quot; title=&quot;TCTF-Elements&quot;&gt;&lt;/a&gt;TCTF-Elements&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这道题其实是一个数学问题，
      
    
    </summary>
    
      <category term="ctf" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/ctf/"/>
    
    
      <category term="tctf" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/tctf/"/>
    
      <category term="re" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>idapython learning note</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/07/idapython-learning-note/idapython-learning-note/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/07/idapython-learning-note/idapython-learning-note/</id>
    <published>2019-03-07T11:42:24.000Z</published>
    <updated>2019-04-08T11:25:34.497Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
      <category term="IDA" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/IDA/"/>
    
    
  </entry>
  
  <entry>
    <title>1amb4ck</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/05/1amb4ck/1amb4ck/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/05/1amb4ck/1amb4ck/</id>
    <published>2019-03-05T15:26:30.000Z</published>
    <updated>2019-03-06T02:47:23.041Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Welcome to my blog, enter password to read.
    
    </summary>
    
      <category term="me" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/me/"/>
    
    
  </entry>
  
  <entry>
    <title>XNU系统调用深度解析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/01/30/XNU%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/XNU%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/01/30/XNU系统调用深度解析/XNU系统调用深度解析/</id>
    <published>2019-01-30T05:53:00.000Z</published>
    <updated>2019-03-05T15:30:52.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XNU系统调用深度解析"><a href="#XNU系统调用深度解析" class="headerlink" title="XNU系统调用深度解析"></a>XNU系统调用深度解析</h3><blockquote><p>从一个函数分析到系统调用的内核实现</p></blockquote><h4 id="由一段POC而起"><a href="#由一段POC而起" class="headerlink" title="由一段POC而起"></a>由一段POC而起</h4><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;mach/i386/kern_return.h&gt;#include &lt;mach/mach_traps.h&gt;#include &lt;servers/bootstrap.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;time.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;typedef struct quartz_register_client_s quartz_register_client_t;struct quartz_register_client_s {        mach_msg_header_t header;        uint32_t body;        mach_msg_port_descriptor_t ports[4];        char padding[12];};typedef struct quartzcore_mach_msg quartzcore_mach_msg_t;struct quartzcore_mach_msg{        mach_msg_header_t header;        char msg_body[712];};uint64_t get_filesize(const char *fn){        struct stat st;        stat(fn, &amp;st);        uint64_t fsize = st.st_size;        return fsize;};int main(int argc, const char * argv[]) {        mach_port_t p = MACH_PORT_NULL, bs_port = MACH_PORT_NULL;        task_get_bootstrap_port(mach_task_self(), &amp;bs_port);        const char *render_service_name = &quot;com.apple.CARenderServer&quot;;        kern_return_t (*bootstrap_look_up)(mach_port_t, const char *, mach_port_t *) = dlsym(RTLD_DEFAULT, &quot;bootstrap_look_up&quot;);        kern_return_t kr = bootstrap_look_up(bs_port, render_service_name, &amp;p);        if (kr != KERN_SUCCESS) {                return -1;        }        printf(&quot;[*] Get service of %s successully!\n&quot;, render_service_name);        quartz_register_client_t msg_register;        memset(&amp;msg_register, 0, sizeof(msg_register));        msg_register.header.msgh_bits =        MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE) |        MACH_MSGH_BITS_COMPLEX;        msg_register.header.msgh_remote_port = p;        msg_register.header.msgh_local_port = mig_get_reply_port();        msg_register.header.msgh_id = 40202;  // _XRegisterClient        msg_register.body = 4;        msg_register.ports[0].name = mach_task_self();        msg_register.ports[0].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[0].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[1].name = mach_task_self();        msg_register.ports[1].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[1].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[2].name = mach_task_self();        msg_register.ports[2].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[2].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[3].name = mach_task_self();        msg_register.ports[3].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[3].type = MACH_MSG_PORT_DESCRIPTOR;        kr = mach_msg(&amp;msg_register.header, MACH_SEND_MSG | MACH_RCV_MSG,                                    sizeof(quartz_register_client_t), sizeof(quartz_register_client_t),                                    msg_register.header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);        if (kr != KERN_SUCCESS) {                return -1 ;        }        mach_port_t context_port = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x1c);        uint32_t conn_id = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x30);        printf(&quot;[*] context_port: 0x%x, conn_id: 0x%x\n&quot;,context_port,conn_id);        char *crash_log = &quot;crash.data&quot;; //size is 736.        FILE *fp = fopen(crash_log, &quot;rb&quot;);        if(fp == NULL){                printf(&quot;fopen error!\n&quot;);        }        uint64_t fsize = get_filesize(crash_log);        void *msg_buf = malloc(fsize);        memset(msg_buf, 0, fsize);        fread(msg_buf, fsize, 1, fp);        quartzcore_mach_msg_t qc_mach_msg = {0};        qc_mach_msg.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0) | MACH_MSGH_BITS_COMPLEX;        qc_mach_msg.header.msgh_remote_port = context_port;        qc_mach_msg.header.msgh_id = 40002;        memset(qc_mach_msg.msg_body, 0x0, sizeof(qc_mach_msg.msg_body));        *(uint32_t *)(qc_mach_msg.msg_body + 0) = 0x1;  // Ports count        memcpy(qc_mach_msg.msg_body+4+12, msg_buf+0x1c+0xc, 736-0x1c-0xc);        *(uint32_t *)(qc_mach_msg.msg_body + 4 + 12 + 4) = conn_id;        kr = mach_msg(&amp;qc_mach_msg.header, MACH_SEND_MSG,736, 0, 0, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);        if (kr != KERN_SUCCESS) {                printf(&quot;[-] Send message failed: 0x%d\n&quot;, kr);                return -1 ;        }        return 0;}</code></pre><p>里面的macho函数<code>mach_msg()</code>到底后面执行到哪里？于是展开一段追踪</p><p>从ida的导入表中可以看到这个函数实现在libSystem.B.dylib 顺便说下，这个动态库实际上只是一层封装，里面导入了/usr/lib/system下面的动态库。</p><pre><code class="assembly">* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 2.1    frame #0: 0x00007fff79299694 libsystem_kernel.dylib`mach_msglibsystem_kernel.dylib`mach_msg:-&gt;  0x7fff79299694 &lt;+0&gt;: pushq  %rbp    0x7fff79299695 &lt;+1&gt;: movq   %rsp, %rbp    0x7fff79299698 &lt;+4&gt;: pushq  %r15    0x7fff7929969a &lt;+6&gt;: pushq  %r14Target 0: (CVE-2019-6231-poc) stopped.</code></pre><p>调试可以看出mach_msg实现在libsystem_kernel.dylib之中</p><pre><code class="assembly">(lldb) dislibsystem_kernel.dylib`mach_msg:-&gt;  0x7fff79299694 &lt;+0&gt;:   pushq  %rbp    0x7fff79299695 &lt;+1&gt;:   movq   %rsp, %rbp    0x7fff79299698 &lt;+4&gt;:   pushq  %r15    0x7fff7929969a &lt;+6&gt;:   pushq  %r14    0x7fff7929969c &lt;+8&gt;:   pushq  %r13    0x7fff7929969e &lt;+10&gt;:  pushq  %r12    0x7fff792996a0 &lt;+12&gt;:  pushq  %rbx    0x7fff792996a1 &lt;+13&gt;:  subq   $0x28, %rsp    0x7fff792996a5 &lt;+17&gt;:  movl   %ecx, %r13d    0x7fff792996a8 &lt;+20&gt;:  movl   %esi, %ebx    0x7fff792996aa &lt;+22&gt;:  movq   %rdi, %r14    0x7fff792996ad &lt;+25&gt;:  movl   0x10(%rbp), %eax    0x7fff792996b0 &lt;+28&gt;:  movl   %ebx, %r12d    0x7fff792996b3 &lt;+31&gt;:  andl   $0xfffffbbf, %r12d        ; imm = 0xFFFFFBBF     0x7fff792996ba &lt;+38&gt;:  movl   %eax, (%rsp)    0x7fff792996bd &lt;+41&gt;:  movl   %r12d, %esi    0x7fff792996c0 &lt;+44&gt;:  movl   %edx, %r15d    0x7fff792996c3 &lt;+47&gt;:  movl   %r8d, -0x2c(%rbp)    0x7fff792996c7 &lt;+51&gt;:  movl   %r9d, -0x30(%rbp)    0x7fff792996cb &lt;+55&gt;:  callq  0x7fff79299170            ; mach_msg_trap    ...</code></pre><pre><code class="c">mach_msg_return_t __cdecl mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify){  mach_msg_return_t result; // eax  mach_msg_option_t v8; // er12  result = mach_msg_trap();  if ( !result )    return 0;  if ( !(option &amp; 0x40) &amp;&amp; result == 268435463 )  {    do      result = mach_msg_trap();    while ( result == 268435463 );  }  v8 = option;  if ( !_bittest(&amp;v8, 0xAu) &amp;&amp; result == 268451845 )  {    do      result = mach_msg_trap();    while ( result == 268451845 );  }  return result;}</code></pre><p>通过调式和ida反汇编mach_msg函数可以看出，最终会调用mach_msg_trap这个函数，再跟一下</p><pre><code class="assembly">* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 3.1    frame #0: 0x00007fff79299170 libsystem_kernel.dylib`mach_msg_traplibsystem_kernel.dylib`mach_msg_trap:-&gt;  0x7fff79299170 &lt;+0&gt;:  movq   %rcx, %r10    0x7fff79299173 &lt;+3&gt;:  movl   $0x100001f, %eax          ; imm = 0x100001F     0x7fff79299178 &lt;+8&gt;:  syscall     0x7fff7929917a &lt;+10&gt;: retq   Target 0: (CVE-2019-6231-poc) stopped.</code></pre><p>这个函数后面会调用0x100001f系统调用，可以小结得到系统库封装了最底层的实现，最终通过系统调用进入内核。在用户层到这里已经就到头了，无法再跟进。</p><h4 id="XNU内核系统调用流程"><a href="#XNU内核系统调用流程" class="headerlink" title="XNU内核系统调用流程"></a>XNU内核系统调用流程</h4><p>系统调用发生在内核之中，那么最开始处理系统调用的地方又在哪？通过<a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_blank" rel="external">intel官方文档</a>可以找到</p><pre><code>SYSCALL invokes an OS system-call handler at privilege level 0.It does so by loading RIP from the IA32_LSTAR MSR</code></pre><p>也就是内核需要将系统调用处理函数入口放到<code>IA32_LSTAR</code> <a href="https://en.wikipedia.org/wiki/Model-specific_register" target="_blank" rel="external">model specific register</a>. 在内核源码中对应在<code>osfmk/i386/mp_desc.c</code>的<code>cpu_syscall_init(cpu_data_t *cdp)</code>函数之中</p><pre><code class="c">/* * Set MSRs for sysenter/sysexit and syscall/sysret for 64-bit. */voidcpu_syscall_init(cpu_data_t *cdp){#if MONOTONIC    mt_cpu_up(cdp);#else /* MONOTONIC */#pragma unused(cdp)#endif /* !MONOTONIC */    wrmsr64(MSR_IA32_SYSENTER_CS, SYSENTER_CS);     wrmsr64(MSR_IA32_SYSENTER_EIP, DBLMAP((uintptr_t) hi64_sysenter));    wrmsr64(MSR_IA32_SYSENTER_ESP, current_cpu_datap()-&gt;cpu_desc_index.cdi_sstku);    /* Enable syscall/sysret */    wrmsr64(MSR_IA32_EFER, rdmsr64(MSR_IA32_EFER) | MSR_IA32_EFER_SCE);    /*     * MSRs for 64-bit syscall/sysret     * Note USER_CS because sysret uses this + 16 when returning to     * 64-bit code.     */    wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall));    wrmsr64(MSR_IA32_STAR, (((uint64_t)USER_CS) &lt;&lt; 48) | (((uint64_t)KERNEL64_CS) &lt;&lt; 32));    /*     * Emulate eflags cleared by sysenter but note that     * we also clear the trace trap to avoid the complications     * of single-stepping into a syscall. The nested task bit     * is also cleared to avoid a spurious &quot;task switch&quot;     * should we choose to return via an IRET.     */    wrmsr64(MSR_IA32_FMASK, EFL_DF|EFL_IF|EFL_TF|EFL_NT);}</code></pre><p><code>wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall));</code>也就是系统调用会由<code>hi64_syscall</code>函数处理。这个函数实现在<code>xnu/osfmk/x86_64/idt64.s</code>之中</p><pre><code class="assembly">Entry(hi64_syscall)Entry(idt64_syscall)    swapgs     /* Use RAX as a temporary by shifting its contents into R11[32:63]      * The systemcall number is defined to be a 32-bit quantity, as is      * RFLAGS.      */    shlq    $32, %rax    or     %rax, %r11.globl EXT(dblsyscall_patch_point)EXT(dblsyscall_patch_point)://    movabsq    $0x12345678ABCDEFFFULL, %rax     /* Generate offset to the double-mapped per-CPU data shadow      * into RAX      */    leaq    EXT(idt64_hndl_table0)(%rip), %rax    mov    16(%rax), %rax    mov     %rsp, %gs:CPU_UBER_TMP(%rax)  /* save user stack */    mov     %gs:CPU_ESTACK(%rax), %rsp  /* switch stack to per-cpu estack */    sub    $(ISF64_SIZE), %rsp    /*     * Synthesize an ISF frame on the exception stack     */    movl    $(USER_DS), ISF64_SS(%rsp)    mov    %rcx, ISF64_RIP(%rsp)        /* rip */    mov    %gs:CPU_UBER_TMP(%rax), %rcx    mov    %rcx, ISF64_RSP(%rsp)        /* user stack --changed */    mov    %r11, %rax    shrq    $32, %rax        /* Restore RAX */    mov    %r11d, %r11d        /* Clear r11[32:63] */    mov    %r11, ISF64_RFLAGS(%rsp)    /* rflags */    movl    $(SYSCALL_CS), ISF64_CS(%rsp)    /* cs - a pseudo-segment */    mov    %rax, ISF64_ERR(%rsp)        /* err/rax - syscall code */    movq    $(HNDL_SYSCALL), ISF64_TRAPFN(%rsp)    movq    $(T_SYSCALL), ISF64_TRAPNO(%rsp)    /* trapno */    swapgs    jmp    L_dispatch            /* this can only be 64-bit */</code></pre><p>继续跟下去，会得到如下执行流程</p><pre><code>syscall--&gt;hi64_syscall-&gt;L_dispatch--&gt;ks_dispatch--&gt;ks_dispatch_user--&gt;L_dispatch_U64--&gt;L_dispatch_64bit--&gt;L_common_dispatch--&gt;hndl_syscall</code></pre><pre><code class="assembly">/* * 64bit Tasks * System call entries via syscall only: * *    r15     x86_saved_state64_t *    rsp     kernel stack * *    both rsp and r15 are 16-byte aligned *    interrupts disabled *    direction flag cleared */Entry(hndl_syscall)    TIME_TRAP_UENTRY    movq    %gs:CPU_ACTIVE_THREAD,%rcx    /* get current thread     */    movl    $-1, TH_IOTIER_OVERRIDE(%rcx)    /* Reset IO tier override to -1 before handling syscall */    movq    TH_TASK(%rcx),%rbx        /* point to current task  */    /* Check for active vtimers in the current task */    TASK_VTIMER_CHECK(%rbx,%rcx)    /*     * We can be here either for a mach, unix machdep or diag syscall,     * as indicated by the syscall class:     */    movl    R64_RAX(%r15), %eax        /* syscall number/class */    movl    %eax, %edx    andl    $(SYSCALL_CLASS_MASK), %edx    /* syscall class */    cmpl    $(SYSCALL_CLASS_MACH&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_mach_scall64)    cmpl    $(SYSCALL_CLASS_UNIX&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_unix_scall64)    cmpl    $(SYSCALL_CLASS_MDEP&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_mdep_scall64)    cmpl    $(SYSCALL_CLASS_DIAG&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_diag_scall64)    /* Syscall class unknown */    sti    CCALL3(i386_exception, $(EXC_SYSCALL), %rax, $1)    /* no return */</code></pre><p><code>hndl_syscall</code>这个函数会系统调用分为<code>hndl_unix_scall64</code> 、<code>hndl_mach_scall64</code>、<code>hndl_mdep_scall64</code>、<code>hndl_diag_scall64</code>四类分别处理</p><p>这里以<code>hndl_unix_scall64</code>为列</p><pre><code class="assembly">Entry(hndl_unix_scall)        TIME_TRAP_UENTRY    movq    %gs:CPU_ACTIVE_THREAD,%rcx    /* get current thread     */    movq    TH_TASK(%rcx),%rbx        /* point to current task  */    incl    TH_SYSCALLS_UNIX(%rcx)        /* increment call count   */    /* Check for active vtimers in the current task */    TASK_VTIMER_CHECK(%rbx,%rcx)    sti    CCALL1(unix_syscall, %r15)    /*     * always returns through thread_exception_return     */</code></pre><p>这里调动了<code>unix_syscall</code>函数，这个函数在bsd/dev/i386/systemcalls.c之中实现，里面进行了一些权限检查</p><p>以及根据系统调用表去调用对应的实现</p><pre><code class="c">  thread = current_thread();  uthread = get_bsdthread_info(thread);  // regs is derrived from r15 ...  code = regs-&gt;rax &amp; SYSCALL_NUMBER_MASK;  callp = (code &gt;= NUM_SYSENT) ? &amp;sysent[63] : &amp;sysent[code];  // ...  vt = (void *)uthread-&gt;uu_arg;  // ...  memcpy(vt, args_start_at_rdi ? &amp;regs-&gt;rdi : &amp;regs-&gt;rsi,        args_in_regs * sizeof(syscall_arg_t));  // ...  error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0]));</code></pre><p>目前执行的流程如下</p><pre><code>hi64_syscallL_dispatch_U64L_dispatch_64bitL_common_dispatchhndl_syscall // rdx, pushed in hi64_syscallhndl_unix_scall64unix_syscall64error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0])); // now we&#39;re there</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.binss.me/blog/interrupt-and-exception/" target="_blank" rel="external">https://www.binss.me/blog/interrupt-and-exception/</a></p><p><a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html" target="_blank" rel="external">https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html</a></p><p><a href="https://gist.github.com/yrp604/23e86dce9ca12bf514ef" target="_blank" rel="external">https://gist.github.com/yrp604/23e86dce9ca12bf514ef</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;XNU系统调用深度解析&quot;&gt;&lt;a href=&quot;#XNU系统调用深度解析&quot; class=&quot;headerlink&quot; title=&quot;XNU系统调用深度解析&quot;&gt;&lt;/a&gt;XNU系统调用深度解析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;从一个函数分析到系统调用的内核实现&lt;/p&gt;
      
    
    </summary>
    
      <category term="iOSRE" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOSRE/"/>
    
    
      <category term="XNU" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/XNU/"/>
    
      <category term="Kernel" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>LLDB调试器栈符号化</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/10/03/LLDB%E8%B0%83%E8%AF%95%E5%99%A8%E6%A0%88%E7%AC%A6%E5%8F%B7%E5%8C%96/%E5%BC%BA%E5%8C%96%E4%BD%A0%E7%9A%84lldb%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/10/03/LLDB调试器栈符号化/强化你的lldb调试器/</id>
    <published>2018-10-03T05:27:59.000Z</published>
    <updated>2019-02-21T10:07:17.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="强化你的lldb调试器"><a href="#强化你的lldb调试器" class="headerlink" title="强化你的lldb调试器"></a>强化你的lldb调试器</h3><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>lldb作为苹果iOS和macOS的调试器在正向开发中十分强大，不过对于逆向人员来说却不是很友好。尤其是那些符号表被strip以后的执行文件。去定位追溯一个函数的执行流程时，查看当前的栈帧只有一堆内存地址，如果要定位是哪个函数通常的流程就是找到当前模块的内存偏移，然后栈上的地址逐一减去改偏移然后去ida中查找改地址，最后才能定位到函数名。流程琐碎且都是重复工作，花费大量时间去定位符号信息。因此我想做一个能自动恢复栈帧符号的命令。只要输入改命令就能显示函数的调用情况。</p><h3 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h3><p>但是符号表都已经被strip了怎么才能恢复符号呢？我的想法就是macho可执行文件中其实是有很大一部分段储存的OC函数信息，里面肯定是有类名和方法名的，我们要做的就是通过栈中的地址，遍历所有的类以及方法，找到最佳的类方法即可。判断原则就是找到距离栈地址最近且小于等于栈地址的类方法。然后记录类名和方法名即可。</p><p>正好lldb提供了python的接口，可以开发自定义的命令。</p><h3 id="And-what"><a href="#And-what" class="headerlink" title="And what ?"></a>And what ?</h3><p>虽然有python接口，但是lldb里面集成了一个OC的解释器，其语法要求特别严格，按照通常开发的写法会有很多错误，经过不断的调试和修复bug，一个开发版基于lldb python栈符号恢复命令开发完成。git地址在<a href="https://github.com/4ch12dy/xia0LLDB">这里</a></p><p>这里面还有的搜索算法以及异常处理还需要优化，以及对于block这类函数还不能恢复，不过对于大多数的场景目前还是可用。具体效果可以如下：</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/b_bt.jpg?raw=true" alt="https://github.com/4ch12dy/xia0LLDB/blob/master/resource/b_bt.jpg?raw=true"></p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/b_sbt.jpg?raw=true" alt="https://github.com/4ch12dy/xia0LLDB/blob/master/resource/b_sbt.jpg?raw=true"></p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>现已支持恢复block结构符号解析，通过提供的ida脚本，得到一个json格式的block符号文件，然后在lldb命令行中输入<code>sbt -f block-json-file-path</code>即可加载该文件。效果如下：</p><h4 id="原始的bt命令结果"><a href="#原始的bt命令结果" class="headerlink" title="原始的bt命令结果"></a>原始的bt命令结果</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/orig_bt.png?raw=true" alt="orig_bt"></p><h4 id="sbt命令（没有加载block符号文件）"><a href="#sbt命令（没有加载block符号文件）" class="headerlink" title="sbt命令（没有加载block符号文件）"></a>sbt命令（没有加载block符号文件）</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/sbt-noblockfile.png?raw=true" alt="sbt-noblockfile"></p><h4 id="sbt命令（带有block符号文件）"><a href="#sbt命令（带有block符号文件）" class="headerlink" title="sbt命令（带有block符号文件）"></a>sbt命令（带有block符号文件）</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/sbt-blockfile.png?raw=true" alt="sbt-blockfile"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;强化你的lldb调试器&quot;&gt;&lt;a href=&quot;#强化你的lldb调试器&quot; class=&quot;headerlink&quot; title=&quot;强化你的lldb调试器&quot;&gt;&lt;/a&gt;强化你的lldb调试器&lt;/h3&gt;&lt;h3 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;he
      
    
    </summary>
    
      <category term="iOSRE" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOSRE/"/>
    
    
      <category term="LLDB" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLDB/"/>
    
      <category term="python" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>unicorn</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/09/13/unicorn/unicorn/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/09/13/unicorn/unicorn/</id>
    <published>2018-09-13T06:39:03.000Z</published>
    <updated>2019-04-16T03:03:09.532Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      something you can not kown 
    
    </summary>
    
      <category term="re" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/re/"/>
    
    
      <category term="unicorn" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/unicorn/"/>
    
  </entry>
  
  <entry>
    <title>C++类结构以及vtable分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/12/02/C++%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8Avtable%E5%88%86%E6%9E%90/C++%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8Avtable%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/12/02/C++类结构以及vtable分析/C++类结构以及vtable分析/</id>
    <published>2017-12-02T10:07:00.000Z</published>
    <updated>2019-03-01T02:51:19.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-类结构以及vtable分析"><a href="#C-类结构以及vtable分析" class="headerlink" title="C++类结构以及vtable分析"></a>C++类结构以及vtable分析</h3><blockquote><p>通过实验自己对一些C++数据结构的理解</p></blockquote><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;// 基类class Shape {   public:      void setWidth(int w)      {         width = w;      }      void setHeight(int h)      {         height = h;      }   protected:      int width;      int height;};// 派生类class Rectangle: public Shape{   public:      int getArea()      {          return (width * height);       }};int main(void){   Rectangle Rect;   Rect.setWidth(5);   Rect.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;   return 0;}</code></pre><p>上面的代码编译完成后，在ida中反汇编如下</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // ST08_8  unsigned int v4; // eax  char v6; // [rsp+10h] [rbp-20h]  int v7; // [rsp+1Ch] [rbp-14h]  __int64 (__fastcall *v8)(_QWORD); // [rsp+20h] [rbp-10h]  __int64 v9; // [rsp+28h] [rbp-8h]  v7 = 0;  Shape::setWidth((Shape *)&amp;v6, 5);  Shape::setHeight((Shape *)&amp;v6, 7);  v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;);  v4 = Rectangle::getArea((Rectangle *)&amp;v6);  v9 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4);  v8 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v9);  return 0;}</code></pre><p>Rect内存布局</p><pre><code>(lldb) x/20b $rbp-0x200x7ffeefbff560: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x000x7ffeefbff568: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00</code></pre><p>能得到的结论是，在编译完后，子类Rectangle的方法调用都编译成父类Shape方法调用，这是在编译时就决定了的。把子类对象和参数合并作为参数传入父类方法。这里仅仅是对子类对象另个偏移值做操作。</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  void *v3; // ST10_8  __int64 v4; // ST08_8  unsigned int v5; // eax  __int64 v6; // ST38_8  v3 = (void *)operator new(8uLL);  memset(v3, 0, 8uLL);  Shape::setWidth((Shape *)v3, 5);  Shape::setHeight((Shape *)v3, 7);  v4 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;);  v5 = Rectangle::getArea((Rectangle *)v3);  v6 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v4, v5);  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v6);  return 0;}</code></pre><p>这里将 Rectangle Rect改为Rectangle *Rect = new Rectangle()在堆上申请内存可以看出，在类初始化的时候，仅仅申请了一块8字节空间，正好是两个int的大小，仅此而已。</p><h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;// 基类class Shape {public:   // 提供接口框架的纯虚函数   virtual int getArea() = 0;   void setWidth(int w)   {      width = w;   }   void setHeight(int h)   {      height = h;   }protected:   int width;   int height;};// 派生类class Rectangle: public Shape{public:   int getArea()   {       return (width * height);    }};class Triangle: public Shape{public:   int getArea()   {       return (width * height)/2;    }};int main(void){   Rectangle Rect;   Triangle  Tri;   Rect.setWidth(5);   Rect.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total Rectangle area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;   Tri.setWidth(5);   Tri.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total Triangle area: &quot; &lt;&lt; Tri.getArea() &lt;&lt; endl;    return 0;}</code></pre><p>上面的代码编译完成后，在ida中反汇编如下</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // ST20_8  unsigned int v4; // eax  __int64 v5; // ST10_8  unsigned int v6; // eax  char v8; // [rsp+28h] [rbp-48h]  char v9; // [rsp+38h] [rbp-38h]  int v10; // [rsp+4Ch] [rbp-24h]  __int64 (__fastcall *v11)(_QWORD); // [rsp+50h] [rbp-20h]  __int64 v12; // [rsp+58h] [rbp-18h]  __int64 (__fastcall *v13)(_QWORD); // [rsp+60h] [rbp-10h]  __int64 v14; // [rsp+68h] [rbp-8h]  v10 = 0;  Rectangle::Rectangle((Rectangle *)&amp;v9);  Triangle::Triangle((Triangle *)&amp;v8);  Shape::setWidth((Shape *)&amp;v9, 5);  Shape::setHeight((Shape *)&amp;v9, 7);  v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Rectangle area: &quot;);  v4 = Rectangle::getArea((Rectangle *)&amp;v9);  v12 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4);  v11 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v12);  Shape::setWidth((Shape *)&amp;v8, 5);  Shape::setHeight((Shape *)&amp;v8, 7);  v5 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Triangle area: &quot;);  v6 = Triangle::getArea((Triangle *)&amp;v8);  v14 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, v6);  v13 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v14);  return 0;}</code></pre><p>这里与实验一明显不同在于，在初始化一个对象的时候会调用其构建方法。其反汇编代码如下</p><pre><code class="c++">__int64 *__fastcall Rectangle::Rectangle(Rectangle *this){  __int64 *result; // rax  Shape::Shape(this);  result = &amp;`vtable for&#39;Rectangle + 2;  *(_QWORD *)this = &amp;`vtable for&#39;Rectangle + 2;  return result;}</code></pre><p>这里发现里面还调用了父类的构建方法，父类构建方法反汇编代码如下</p><pre><code class="c++">__int64 *__fastcall Shape::Shape(Shape *this){  __int64 *result; // rax  result = &amp;`vtable for&#39;Shape + 2;  *(_QWORD *)this = &amp;`vtable for&#39;Shape + 2;  return result;}</code></pre><p>其实这两个构建方法就是对传入对象this指针赋值操作，在经过Shape::Shape(this)后其实this指针的64字节大小值为父类Shape的虚函数表地址。然后又被重新赋值为Rectangle自己的虚函数表地址。</p><p>这里的虚函数表地址，本质就是_DATA段的一个数据结构。</p><p>Rect的内存布局为</p><pre><code>(lldb) x/20b $rbp-0x380x7ffeefbff548: 0x20 0x21 0x00 0x00 0x01 0x00 0x00 0x000x7ffeefbff550: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x00</code></pre><p>这里可以看到前64字节为虚函数表地址，后面两个32字节分别是其width和height</p><p>去ida中查看该地址</p><pre><code class="c++">__data:0000000100002110 ; `vtable for&#39;Rectangle__data:0000000100002110 __ZTV9Rectangle dq 0                    ; DATA XREF: __got:__ZTV9Rectangle_ptr↑o__data:0000000100002110                                         ; offset to this__data:0000000100002118                 dq offset __ZTI9Rectangle ; `typeinfo for&#39;Rectangle__data:0000000100002120                 dq offset __ZN9Rectangle7getAreaEv ; Rectangle::getArea(void)</code></pre><p>就是_DATA段中的数据结构，现在我们可以清晰的理解C++类在内存的数据结构了。</p><h3 id="一点理解"><a href="#一点理解" class="headerlink" title="一点理解"></a>一点理解</h3><p>C++这个语言特性非常多，如果不能理解其本质很容易造成bug。这里想把C++和OC做一个简单的对比，C++的很多实现都是在编译时就确定的，C++中的类我更愿意理解成为C中的结构体。而OC这语言，大多都是在运行时才能确定，方法转化为消息处理。在可执行文件中也有专门的段存储其复杂的类数据结构，也因为这样，OC在运行时可以做很多hack操作，比如hook其方法实现等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;C-类结构以及vtable分析&quot;&gt;&lt;a href=&quot;#C-类结构以及vtable分析&quot; class=&quot;headerlink&quot; title=&quot;C++类结构以及vtable分析&quot;&gt;&lt;/a&gt;C++类结构以及vtable分析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过实
      
    
    </summary>
    
      <category term="C++" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/C/"/>
    
    
      <category term="C++" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>IDA7.0 Mac 插件编译指南v1</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/30/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/30/IDA-Mac-插件编写指南/IDA-Mac-插件编写指南/</id>
    <published>2017-11-30T06:25:09.000Z</published>
    <updated>2019-02-21T09:59:22.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先说两句"><a href="#先说两句" class="headerlink" title="先说两句"></a>先说两句</h3><p>前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因此插件同样为64位的dylib。不仅这样，SDK上某些接口也发生了改变，导致很多优秀的插件不得不重新改动源码，很多在IDA7上编译也存在问题。下面我将以IDA的官方插件findcrypt2来说明IDA7的插件编译细节。编译IDA插件是个麻烦事，主要在于网上相关的资料很少，唯一的几篇也是年代久远，Makefile里面很多编译参数都有变化，目前来说，没有一个完整的文章来介绍如何在Mac平台下编译IDA插件的指南。希望这边文章能够对有这需求的人有所帮助。</p><h3 id="搭建xcode环境"><a href="#搭建xcode环境" class="headerlink" title="搭建xcode环境"></a>搭建xcode环境</h3><p>在Mac上完全可以用xcode来帮助我们编译IDA插件，其实更常见的是用Makefile编译，但原理一样，所以这里就以xcode来介绍。</p><p>我们知道IDA的插件的文件格式为dylib动态库，因此在创建xcode项目时在Framework&amp;Libarry中选择Libarry</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/xcode_step_1.jpg?raw=true" alt="xcode_step_1"></p><p>然后再选择为Dynamic动态库，并导入C++标准库</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/xcode_step_2.jpg?raw=true" alt="xcode_step_2"></p><p>接下来项目中自动会生成两个文件。暂时不用管，我们把findcrypt2的源码放入该项目，最后如下图所示</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/project_1.jpg?raw=true" alt="project_1"></p><p>这时你的项目中像ida.hpp这类的头文件肯定会提示找不到，还需要进一步设置。</p><h3 id="Build-setting"><a href="#Build-setting" class="headerlink" title="Build setting"></a>Build setting</h3><p>这里我们将设置头文件和库的搜索路径等等。</p><p>首先设置目标架构为x86_64</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/arch_s.jpg?raw=true" alt="arch_s"></p><p>然后设置头文件和库的搜索路径，依据你IDA及sdk路径改成对应路径</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/search_s.jpg?raw=true" alt="search_s"></p><p>经过上面的设置，此时xcode应该能找到头文件了，这时还需要设置连接的静态库</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/link_s.jpg?raw=true" alt="link_s"></p><p>这里连接的库为-lida64，表示我们编译的是解析64位的插件，若要编译解析32位的插件，这里为-lida即可。</p><p>最后我们还需要设置编译参数</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/macros_s.jpg?raw=true" alt="macros_s"></p><p>其中<code>__EA64__</code>在编译64位插件时才有。</p><p>这时候build一下，如果一切顺利，应该就不会报错了。</p><h3 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h3><p>IDA7相以前版本而言，插件的后缀名统一为dylib格式，之前32位为pmc，64位为pmc64。这里将编译好的插件改为<strong>findcrypt264.dylib</strong>表示为64位插件，则对应的32位插件名为<strong>findcry.dylib</strong></p><p>下面测试下效果，我们打开IDA去解析一个含有md4加密的macho文件，运行插件测试能否识别出其中的加密算法。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/test.jpg?raw=true" alt="test"></p><p>上图我们可以看到这里成功找到一处md4加密，反汇编窗口中正是md4加密中用到的常量数组。我顺便为插件注册了<strong>Ctrl-Alt-z</strong>的快捷键，若没有快捷键，可以在插件的导航栏里点击对应的插件即可。</p><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>附上该插件，完。</p><p><a href="https://raw.githubusercontent.com/4ch12dy/4ch12dy.github.io/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/findcrypt264.dylib" target="_blank" rel="external">findcrypt264.dylib_for_ida7_made_by_x1a0</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html" target="_blank" rel="external">http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html</a></p></li><li><p><a href="http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/" target="_blank" rel="external">http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/</a></p></li><li><p><a href="https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile">https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile</a></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先说两句&quot;&gt;&lt;a href=&quot;#先说两句&quot; class=&quot;headerlink&quot; title=&quot;先说两句&quot;&gt;&lt;/a&gt;先说两句&lt;/h3&gt;&lt;p&gt;前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因
      
    
    </summary>
    
      <category term="IDA" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/IDA/"/>
    
    
      <category term="ida" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ida/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI踩坑笔记</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/28/Android_JNI_%E6%8E%89%E5%9D%91%E7%AC%94%E8%AE%B0%20/JNI/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/28/Android_JNI_掉坑笔记 /JNI/</id>
    <published>2017-11-28T09:00:20.000Z</published>
    <updated>2017-11-29T03:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。</p></blockquote></blockquote><h3 id="坑1–jni方法签名分号问题"><a href="#坑1–jni方法签名分号问题" class="headerlink" title="坑1–jni方法签名分号问题"></a>坑1–jni方法签名分号问题</h3><p>这是一个很常见的问题，第一次写jni中方法签名的时候很容易遇到这个错误，比如下面这个签名</p><pre><code class="c++">jmethodID equals_id = env-&gt;GetMethodID(string_c, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;);</code></pre><p>切记当参数或者返回值不是基本类型的时候一定要在末尾加上分号。</p><pre><code class="c++">jmethodID iterator_id = env-&gt;GetMethodID(list_c,&quot;iterator&quot;,&quot;()Ljava/util/Iterator;&quot;);</code></pre><p>这类错误常见描述为方法找不到错误。如果遇到类方法找不到切记先检查方法签名是否正确。</p><h3 id="坑2–原生方法包含默认2个参数"><a href="#坑2–原生方法包含默认2个参数" class="headerlink" title="坑2–原生方法包含默认2个参数"></a>坑2–原生方法包含默认2个参数</h3><p>这个坑当然是对jni使用不熟练造成的，未了解其特性，所以对于初学者来说容易犯。看一个原生函数</p><pre><code class="c++">static jboolean nativeFunction(JNIEnv *env, jobject content, jobject someObj){...}</code></pre><p>第一个保留参数为<code>JNIEnv</code>虚拟机环境变量，第二个为调用该原生方法的java类对象即上下文。这里多说一句，第二个参数的上下文需根据该方法为静态方法还是实例方法，若为静态方法，则这里上下文为类引用；若为实例方法，则上下文为该类的对象引用。若把类引用当做对象引用，在查找方法id时则会出现方法找不到错误。</p><p>由于很多时候不声明这两个参数同样能正确运行（无其他参数时）导致忽略了第二个参数的存在，以为第二个上下文参数为传入的对象引用。</p><p>这类错误常见描述为当你在某处调用这个对象的方法时，会提示找不到该方法。因为这个对象根本不是你传入的对象。</p><h3 id="坑3—jni调用父类方法的正确姿势"><a href="#坑3—jni调用父类方法的正确姿势" class="headerlink" title="坑3—jni调用父类方法的正确姿势"></a>坑3—jni调用父类方法的正确姿势</h3><p>这里就以一个正确的调用父类方法的流程来讲，起因是当我在查找<code>Exception</code>这个类的<code>getStackTrace</code></p><p>方法时提示方法找不到错误，调了会才发现这个方法是在其父类<code>Throwable</code>中，所以正确的写法为：</p><pre><code class="c++">    jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;);    jclass throwable_c = env-&gt;FindClass(&quot;java/lang/Throwable&quot;);    jmethodID getStackTrace_id = env-&gt;GetMethodID(throwable_c, &quot;getStackTrace&quot;,&quot;()[Ljava/lang/StackTraceElement;&quot;);</code></pre><p>那么怎么调用呢？用<code>CallNonvirtual&lt;XXX&gt;Method</code>去调用父类中的方法，一个调用例子：</p><pre><code class="c++">jobjectArray stes = (jobjectArray)env-&gt;CallNonvirtualObjectMethod(excep, throwable_c, getStackTrace_id);</code></pre><p>这里需要传入三个参数，第一个为子类的对象引用，第二个为父类类引用，第三个为方法id。</p><h3 id="坑4—其他小坑"><a href="#坑4—其他小坑" class="headerlink" title="坑4—其他小坑"></a>坑4—其他小坑</h3><p>写jni代码时最大的麻烦在于要写很多代码去定位java中的类和方法，java中一个很简单的调用，在jni层写时或许要写很大一堆，这也不奇怪，因为没有了Android虚拟机，这些本来由虚拟机做的事必须得手动去完成。在写jni层代码时，还有一些小的错误，比如<code>jstring</code>与<code>char*</code>的转换，<code>LOGE()</code>函数中参数为<code>char*</code>的字符串。当然还有一些java与C语言类型对应的问题就不多说了，自己翻下<code>jni.h</code>头文件就能找到。</p><p>还有个AndroidStudio的bug在于不能正确的解析jni等头文件，虽然不影响编译，但没有了代码提示以及显示红色看着也挺难受的。网上找到一个解决办法，在对应的<code>build.gradle</code>文件中在<code>defaultConfig{}</code>加入下面的脚本：</p><pre><code class="c">        sourceSets.main{            jni.srcDirs  &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-mips/usr/include&#39;            jniLibs.srcDir &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-arm/usr/lib&#39;        }</code></pre><p>无非是手动指定了jni相关的文件路径。</p><p>关于下面两类写法：</p><pre><code class="c++">jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;);</code></pre><pre><code class="c">jclass exception_c = (*env)-&gt;FindClass(env, &quot;java/lang/Exception&quot;);</code></pre><p>原因在于C++和C的两种写法，可以在文件中宏定义为C++的即可。</p><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>说了这些坑，当然我都踩过，由于刚接触Android jni特性。所以踩了很多坑，尤其是Android不像iOS那样容易debug，多了一层虚拟机导致很多错误不好调式。说到这，还要吐槽下AndroidStudio的gradle这个项目管理器，各种版本或者莫名奇怪的错误，虽然Xcode同样不是很好用，但相比之下，Xcode省心多了。</p><p>继续踩坑去了…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARM64基础知识整理</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/21/ARM64%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/ARM64%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/21/ARM64基础知识整理/ARM64基础知识整理/</id>
    <published>2017-10-21T10:07:00.000Z</published>
    <updated>2019-03-08T07:07:58.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ARM64基础知识整理"><a href="#ARM64基础知识整理" class="headerlink" title="ARM64基础知识整理"></a>ARM64基础知识整理</h3><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><h5 id="参数寄存器-X0-X7"><a href="#参数寄存器-X0-X7" class="headerlink" title="参数寄存器 (X0-X7)"></a>参数寄存器 (X0-X7)</h5><p>参数寄存器，在函数调用的时候传参使用。X0-X7分别对应8个参数，多于8个的参数保存在栈中。</p><h5 id="其他特殊寄存器"><a href="#其他特殊寄存器" class="headerlink" title="其他特殊寄存器"></a>其他特殊寄存器</h5><table><thead><tr><th style="text-align:center">X29(FP)</th><th style="text-align:center">栈帧寄存器  类比x64中rbp</th></tr></thead><tbody><tr><td style="text-align:center">X30(LR)</td><td style="text-align:center">链接寄存器，保存函数返回地址，x64该地址保存在栈中</td></tr><tr><td style="text-align:center">SP</td><td style="text-align:center">栈顶寄存器，类比x64中</td></tr><tr><td style="text-align:center">PC</td><td style="text-align:center">指向下一条指令</td></tr><tr><td style="text-align:center">寄存器</td><td style="text-align:center">描述</td></tr><tr><td style="text-align:center">CPSR</td><td style="text-align:center">状态寄存器</td></tr></tbody></table><h4 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h4><ul><li><code>mov</code></li></ul><pre><code class="assembly">  mov x0, x1; copies x1 into x0  mov x1, 0x4141; loads the value 0x4141 in x1</code></pre><ul><li><code>str/ldr</code></li></ul><pre><code class="assembly">str x0, [x29]; store x0 at the address in x29ldr x0, [x29]; load the value from the address in x29 into x0</code></pre><ul><li><code>stp/ldp</code></li></ul><pre><code class="assembly">stp x29, x30, [sp]; store x29 at sp and x30 at sp+8</code></pre><ul><li><code>b/br</code></li></ul><pre><code class="assembly"> br x0; jump to the address stored in x0</code></pre><ul><li><code>ret</code></li></ul><pre><code>Unlike it’s x86 equivalent which pops the return address from stack, it looks for the return address in the x30 register and jumps there.</code></pre><h4 id="Indexing-modes"><a href="#Indexing-modes" class="headerlink" title="Indexing modes"></a>Indexing modes</h4><ul><li>Immediate offset : <code>[base, #offset]</code> - Index an offset directly and don’t mess with anything else</li></ul><pre><code class="assembly">ldr x0, [sp, 0x10]; load x0 from sp+0x10</code></pre><ul><li>Pre-indexed : <code>[base, #offset]!</code> - Almost the same as above, except that base+offset is written back into base.</li></ul><pre><code class="assembly">ldr x0, [sp, 0x10]!; load x0 from sp+0x10 and then increase sp by 0x10</code></pre><ul><li>Post-indexed : <code>[base], #offset</code> - Use the base directly and then write base+offset back into the base</li></ul><pre><code class="assembly">ldr x0, [sp], 0x10; load x0 from sp and then increase sp by 0x10</code></pre><h4 id="函数调用demo分析"><a href="#函数调用demo分析" class="headerlink" title="函数调用demo分析"></a>函数调用demo分析</h4><pre><code class="assembly">__text:000000010004F0D4                 SUB             SP, SP, #0x70__text:000000010004F0D8                 STP             X24, X23, [SP,#0x60+var_30]__text:000000010004F0DC                 STP             X22, X21, [SP,#0x60+var_20]__text:000000010004F0E0                 STP             X20, X19, [SP,#0x60+var_10]__text:000000010004F0E4                 STP             X29, X30, [SP,#0x60+var_s0]__text:000000010004F0E8                 ADD             X29, SP, #0x60__text:000000010004F0EC                 MOV             X19, X0__text:000000010004F0F0                 ADRP            X8, #___stack_chk_guard_ptr@PAGE__text:000000010004F0F4                 LDR             X8, [X8,#___stack_chk_guard_ptr@PAGEOFF]__text:000000010004F0F8                 LDR             X8, [X8]__text:000000010004F0FC                 STR             X8, [SP,#0x60+var_38]__text:000000010004F100                 ADRP            X8, #classRef_Fabric@PAGE__text:000000010004F104                 LDR             X20, [X8,#classRef_Fabric@PAGEOFF]__text:000000010004F108                 NOP__text:000000010004F10C                 LDR             X0, [X8,#classRef_Crashlytics@PAGEOFF] ; void *__text:000000010004F110                 ADRP            X8, #selRef_class@PAGE__text:000000010004F114                 LDR             X1, [X8,#selRef_class@PAGEOFF] ; char *__text:000000010004F118                 BL              _objc_msgSend...__text:000000010004F2F4                 LDP             X29, X30, [SP,#0x60+var_s0]__text:000000010004F2F8                 LDP             X20, X19, [SP,#0x60+var_10]__text:000000010004F2FC                 LDP             X22, X21, [SP,#0x60+var_20]__text:000000010004F300                 LDP             X24, X23, [SP,#0x60+var_30]__text:000000010004F304                 ADD             SP, SP, #0x70__text:000000010004F308                 RET</code></pre><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">栈值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">sp=sp-0x70</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x60</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x50</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x40</td><td style="text-align:center">X24/X23</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">sp-0x30</td><td style="text-align:center">X22/X21</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">sp-0x20</td><td style="text-align:center">X20/X19</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">X29 –&gt; sp-0x10</td><td style="text-align:center">X29/X30</td><td style="text-align:center">保存前栈基址和返回地址</td></tr><tr><td style="text-align:center">sp=sp</td><td style="text-align:center"></td><td style="text-align:center">调用前的栈顶地址</td></tr></tbody></table><h4 id="Arm32"><a href="#Arm32" class="headerlink" title="Arm32"></a>Arm32</h4><p><img src="https://azeria-labs.com/downloads/cheatsheetv1.2-1920x1080.png" alt="arm32"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.jianshu.com/p/2f4a5f74ac7a" target="_blank" rel="external">https://www.jianshu.com/p/2f4a5f74ac7a</a></li><li><a href="https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start" target="_blank" rel="external">https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start</a></li><li><a href="https://blog.perfect.blue/ROPing-on-Aarch64" target="_blank" rel="external">https://blog.perfect.blue/ROPing-on-Aarch64</a></li><li><a href="https://azeria-labs.com/assembly-basics-cheatsheet/" target="_blank" rel="external">https://azeria-labs.com/assembly-basics-cheatsheet/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ARM64基础知识整理&quot;&gt;&lt;a href=&quot;#ARM64基础知识整理&quot; class=&quot;headerlink&quot; title=&quot;ARM64基础知识整理&quot;&gt;&lt;/a&gt;ARM64基础知识整理&lt;/h3&gt;&lt;h4 id=&quot;Register&quot;&gt;&lt;a href=&quot;#Register&quot;
      
    
    </summary>
    
      <category term="assembly" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/assembly/"/>
    
    
      <category term="ARM64" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ARM64/"/>
    
  </entry>
  
  <entry>
    <title>X86指令编码笔记</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/11/x86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/11/x86指令编码笔记/X86指令编码笔记/</id>
    <published>2017-10-11T03:46:13.000Z</published>
    <updated>2019-02-21T10:03:24.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。</p></blockquote><h3 id="x86指令编码格式"><a href="#x86指令编码格式" class="headerlink" title="x86指令编码格式"></a>x86指令编码格式</h3><p>很多时候我们都是查阅指令参考页去了解一个指令的含义，但这并不能理解指令的编码格式。而只有学会看懂opcode表的时候才是王道。</p><p>x86是一种CISC指令集，CISC的全称是“Complex Instruction Set Computer”，表示的是一种复杂的指令集，其中一个最重要的复杂性在于在这个指令集中，指令是不定长的，要使得CPU在这种不定长的指令集里面确定每一条指令的含义，就需要一种特定的指令格式，下图显示了<code>Intel 64</code>和<code>IA-32</code>架构下的指令格式，当然，这两种架构所采用的都是x86指令编码：</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F.png?raw=true" alt="指令编码格式"></p><p>从上面可以看出，x86指令格式中，由6部分组成，但在这之中只有opcode是必须的，其余都是可选。我们稍后就介绍这些组成部分。</p><h3 id="指令prefix"><a href="#指令prefix" class="headerlink" title="指令prefix"></a>指令prefix</h3><p>prefix简单的说来就是调整内存操作数属性，增强指令的作用等。</p><ul><li><p><code>lock</code> 和 <code>repeat</code></p><p>其中，LOCK prefix保证该条指令对共享内存的访问是独占的；而repeat prefixes 表示这条指令会重复执行多次，直到某个条件满足位置。其中第二种repeat prefix只能用在对string的操作，或者对I/O的操作上。</p></li><li><p><code>operand-size override</code> （<strong>66H </strong>— 改变默认操作数大小）</p><p>这个prefix主要是在解析指令的操作数的时候，可以在十六位或者三十二位的操作数大小间进行切换。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/operand_size_override.png?raw=true" alt="operand_size_override"></p></li><li><p><code>address-size override</code> （<strong>67H</strong> — 改变默认操作数地址大小）</p><p>这个prefix主要是在进行指令寻址的时候，可以在十六位或者三十二位的地址大小中进行切换。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/address_override.png?raw=true" alt="address_override"></p></li><li><p><code>segment override</code>，<code>branch hints</code> 和 <code>bound</code></p><p>其中，segment override prefix会在执行这条指令的时候将默认的段寄存器给换掉；branch hints prefix主要应用在条件跳转指令（Jcc）中，可以协助CPU进行指令的prefetch；而bound prefix主要是用intel MPX硬件特性上。</p><p>​</p><p>| 2E          | 3E          | 26          | 64          | 65          | 36          |<br>| ———– | ———– | ———– | ———– | ———– | ———– |<br>| CS register | DS register | ES register | FS register | GS register | SS register |</p></li></ul><h4 id="REX-prefix—开启-64-位计算的基石"><a href="#REX-prefix—开启-64-位计算的基石" class="headerlink" title="REX prefix—开启 64 位计算的基石"></a>REX prefix—开启 64 位计算的基石</h4><p>REX prefix 是不定值，它的取值范围是：40 - 4F （共 16 个）</p><table><thead><tr><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>W</td><td>R</td><td>X</td><td>B</td></tr></tbody></table><ul><li>W: operand width 标志位，当 W = 0 时使用 default operand size,当 W = 1 时使用 64 位 operand size</li><li>R: 用来扩展 ModRM.reg 域</li><li>X: 用来扩展 SIB.index 域</li><li>B: 用来扩展 SIB.base, ModRM.r/m 以及 Opcode.reg</li></ul><h5 id="寄存器编码表"><a href="#寄存器编码表" class="headerlink" title="寄存器编码表"></a>寄存器编码表</h5><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/register_table.png?raw=true" alt="register_table"></p><p>下面来分析这条指令：</p><p><code>mov eax,ebx</code></p><p>正常编码为：<code>89 d8</code>  下面看看在不同的<code>REX.W</code>和<code>66H prefix</code>下的不同：</p><ul><li><p><code>48 89 d8</code>——————&gt; <code>mov rax,rbx</code></p></li><li><p><code>66 48 89 d8</code>—————&gt; <code>mov rax,rbx</code></p></li><li><p><code>66 40 89 d8</code>—————&gt; <code>mov ax, bx</code></p><p>​</p></li></ul><p>第 1 条指令编码使用 REX prefix 扩展访问 64 位寄存器，<strong>REX.W = 1</strong></p><p>第 2 条指令编码加上了 <strong>66H prefix</strong> 同时还有 REX prefix（<strong>REX.W = 1</strong>），此时一般会认为产生了冲突：是使用 64 位还是 16 位 operand size 呢？<br>实际上，很简单！<strong>48H 位于 66H 后面，66H 将被覆盖！</strong>也就是说：66H prefix 将会被忽略，REX prefix 产生了作用！因此：指令的 <strong>operand size 是 64 位</strong>的。</p><p>第 3 条指令编码也同样使用了 <strong>66H prefix </strong>和 <strong>REX prefix</strong>，但是 <strong>REX.W = 0</strong> 意味着不改变原来的 operand size！<br>在这种情况下，<strong>REX prefix 不会与 66H prefix 产生冲突</strong>，最终的作用于 66H prefix，因此 <strong>operand size 是 16 位</strong>的。</p><h3 id="opcode"><a href="#opcode" class="headerlink" title="opcode"></a>opcode</h3><p>整个编码中opcode是必须的，因为代表着这条指令的含义，整个指令的核心，且prefix与Opcode共享00~FF的空间。</p><p>一个opcode可以由一个byte组成，我们称之为<code>1-byte opcode</code>，当然，与之对应的，就有<code>2-bytes opcode</code>和<code>3-bytes opcode</code>。其中，后两者一般会有一个被称为<code>escape opcode</code>的byte进行引导，该byte的数值是<code>0FH</code>。所以，一般情况下，<code>2-bytes opcode</code>就是<code>0FH</code>后面再加一个byte，而<code>3-bytes opcode</code>就是<code>0FH</code>后面再加两个bytes。</p><h3 id="ModR-M"><a href="#ModR-M" class="headerlink" title="ModR/M"></a>ModR/M</h3><p>ModRM在指令中非常重要，是理解x86平台opcode的关键，决定着寻址模式。</p><p>由一个byte组成，其格式如下：</p><table><thead><tr><th>7 6</th><th>5 4 3</th><th>2 1 0</th></tr></thead><tbody><tr><td>mod</td><td>reg</td><td>R/M</td></tr></tbody></table><p><strong>1、mod：寻址模式。</strong><br>　　2位组成4种寻址模式，总的来说，只有两种寻址模式，就是：内存寻址模式和寄存器寻址模式。</p><ul><li>mod = 11指出寄存器寻址模式，mod = 00 ~ 10 时指出内存寻址模式：</li></ul><ul><li>mod = 00，定义 [register] 间接寻址，无displacement值。</li><li>mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。</li><li>mod = 10，定义 [register + disp32]，有32位displacement偏移值。</li></ul><p><strong>2、reg：寄存器ID值</strong><br>　　3位组成8个寄存器ID值，从 000 ~ 111，对应于 RAX、RCX、RDX、RBX、RSP、RBP、RSI以及RDI。这个ID值可以被REX prefix扩充为4位，范围从 0000 ~ 1111可表示16个寄存器。</p><p>reg域的另一含义是对Opcode的补充，对分为一组Opcode的进行选择（Group属性）。</p><p><strong>3、r/m：意即register / memory。</strong></p><p>​     提供对registers或memory的寻址，也用来表示寄存器ID，当是registers时是寄存器ID值。当是memory时是寄存器间接寻址中的寄存器ID值。当mod != 11 时，r/m 表示 [rax] ~ [rdi]，REX prefix用来扩充寄存器ID值。</p><blockquote><p>注意:</p><p>(1) 如果像这条指令：mov eax, [eax+ecx<em>2+0x0c] 在这条指令里eax是base寄存器，ecx是Index寄存器，2是scale，还有一个displacement ,这种内存寻址是base+index</em>scale+disp。这需要SIB字节来进行确定，那么ModRM必须要有一个手段来引出后续的SIB字节。在 [rax] ~ [rdi] 的范围里，Intel选择了原来应属于 [rsp] 的值用来引出SIB，一是因为 [rsp] 并不常用吧。二是因为 rsp 设计为 stack top指针，专用于stack top指针。<br>　　原来属于 [rsp] 的领域对应的，r/m是100，这个领域被 [SIB] 替代了，事实上在16位机器原本是没有SIB字节的，base+index*scale+disp这种寻址是后来才增加的。16位的ModRM上是没有SIB引导域。</p><p>(2)如果内存寻址中没有base和index，只有disp的话，如：mov ebx, [0x11223344]，这种直接寻址方式，在设计上ModRM还必须为提供这个模式。<br>　　Intel又作出修改，选择了原来属于 [rbp] 模式的领域提供给 [disp]，选择 [rbp] 让给 [disp]，是因为 rbp 原本意图就是设计为 stack基址指针。[rbp] 寻址一般都要加上一个偏移量，也就是基于stack frame指针的偏移量，即 [ebp + disp] 这种寻址模式在 mod = 01 或 mod = 10 中给出。</p></blockquote><h3 id="SIB"><a href="#SIB" class="headerlink" title="SIB"></a>SIB</h3><p>SIB意即：Scale – Index – Base，用来定义base+index*scale+disp这种寻址模式。同样按2-3-3比例组合。</p><table><thead><tr><th>7-6</th><th>5-4-3</th><th>2-1-0</th></tr></thead><tbody><tr><td>scale</td><td>index</td><td>base</td></tr></tbody></table><p>index 域指出index寄存器的ID值，范围从 000 ~ 111。base 域指出base寄存器的ID 值，从 000 ~ 111。Index与base经过 REX prefix可以扩展为0000 ~ 1111。</p><h3 id="Displacement-和-Immediate"><a href="#Displacement-和-Immediate" class="headerlink" title="Displacement 和 Immediate"></a>Displacement 和 Immediate</h3><p>某些指令会在最后要求有一个用于计算内存地址的值，或者一个立即数。很明显，不多说。</p><h3 id="综合起来，看下面的例子："><a href="#综合起来，看下面的例子：" class="headerlink" title="综合起来，看下面的例子："></a>综合起来，看下面的例子：</h3><ul><li><p><code>49 8b 7d 00</code></p><p>49=0100 1001对应REX prefix,默认64为size模式</p><p>8b= mov opcode</p><p>7d=01 111 101—&gt;ModR/M   mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。rdi ,r13</p><p>00=Displacement = 0</p><p>所以指令= mov rdi,QWORD PTR [r13+0]—&gt;mov rdi,[r13]</p><p>​</p></li></ul><h3 id="参考及索引"><a href="#参考及索引" class="headerlink" title="参考及索引"></a>参考及索引</h3><p><a href="http://ref.x86asm.net/coder32.html" target="_blank" rel="external">http://ref.x86asm.net/coder32.html </a>—-&gt; 查阅opcode</p><p><a href="http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png" target="_blank" rel="external">http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png</a> —&gt;quick look</p><p><a href="http://sparksandflames.com/files/x86InstructionChart.html" target="_blank" rel="external">Intel x86 Assembler Instruction Set Opcode Table</a></p><p><a href="http://www.mouseos.com/x64/index.html" target="_blank" rel="external">http://www.mouseos.com/x64/index.html</a></p><p><a href="https://bbs.pediy.com/thread-78121.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-78121.htm</a></p><p><a href="http://ytliu.info/blog/2016/12/10/x86zhi-ling-bian-ma-de-na-xie-shi-er/" target="_blank" rel="external">X86指令编码的那些事儿</a></p><p><a href="http://subler.github.io/note/compiler/x86_instruction_encode.html" target="_blank" rel="external">http://subler.github.io/note/compiler/x86_instruction_encode.html</a></p><p><a href="https://www.onlinedisassembler.com/odaweb/strcpy_x86" target="_blank" rel="external">onlineDisassembler</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;x86指令编码格式&quot;&gt;&lt;a href=&quot;#x86指令编码格式&quot; class=&quot;headerlink&quot; title=&quot;x86指令编码格式
      
    
    </summary>
    
      <category term="misc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/misc/"/>
    
    
      <category term="x86" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/x86/"/>
    
  </entry>
  
  <entry>
    <title>一种用户层与kext内核扩展交互方式</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/一种用户层与kext内核扩展交互方式/一种用户层与kext内核扩展交互方式/</id>
    <published>2017-08-10T07:59:00.000Z</published>
    <updated>2017-08-10T10:34:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。<br>简单说下rootKit原理：<br>利用kext驻留在内核，完成实际的各种功能：<br><code>sys_ptrace</code>过滤 <code>PT_DENY_ATTACH</code>反调试<br>hook系统调用防止<code>sys_kil</code>（很强大有木有）<br>隐藏自身进程，文件监控，网络监控，提权等等<br>可谓是相当可怕。这些功能都可以通过一个用户进程来控制，所以这里必须有一种机制来提供kext与用户层的交互方式，这就是本文重点。</p></blockquote></blockquote><h3 id="0x01-一个例子进入kext开发"><a href="#0x01-一个例子进入kext开发" class="headerlink" title="0x01 一个例子进入kext开发"></a>0x01 一个例子进入kext开发</h3><p>在这之前，简单的用一个例子来学习下kext开发。下面关于xcode中的操作都很明显，故忽略。</p><p>打开xcode创建一个Generic Kernel Extension工程，完成之后会出现一个kext模板，如下</p><pre><code>#include &lt;mach/mach_types.h&gt;#include &lt;libkern/libkern.h&gt;kern_return_t TestExtension_stop(kmod_info_t *ki, void *d);kern_return_t TestExtension_start(kmod_info_t * ki, void *d){    printf(&quot;hello kext!\n&quot;);    return KERN_SUCCESS;}kern_return_t TestExtension_stop(kmod_info_t *ki, void *d){    printf(&quot;bye kext!\n&quot;);    return KERN_SUCCESS;}</code></pre><p>其中这两个函数分别在内核扩展加载和卸载时调用，比如上面我们只是打印一行hello kext，这句话就会在这个kext加载是打印出来（在系统日志中查看）你可能会有疑惑，系统如何知道是这两个函数的，这个是在工程中设置的，你可以改变成任何函数都是OK的。</p><p>简单编译一下，然后找到编译后的kext文件，输入命令改变权限</p><p><code>sudo chown -R root:wheel TestExtension.kext</code></p><p>再输入  </p><p><code>sudo kextload TestExtension.kext</code></p><p>加载内核扩展，如果一切没错的话，这时你在系统日志中就会出现hello kext这句话。同理你可以输入下面的命令</p><p><code>sudo kextunload TestExtension.kext</code></p><p>来卸载该内核扩展，你同样会看到bye kext这句话。</p><h3 id="0x02-用户层与内和扩展间的交互"><a href="#0x02-用户层与内和扩展间的交互" class="headerlink" title="0x02 用户层与内和扩展间的交互"></a>0x02 用户层与内和扩展间的交互</h3><p>下面要介绍的是一种类似于socket机制的交互机制，通常kext在加载的时候会建立一个socket服务器，然后用户层程序去打开这个socket（使用<code>PF_SYSTEM</code>协议）。接下来kext就会处理来至用户端的命令。下面同样通过一个例子来表明他们之间的交互，这里分为kext和客户端两部分。</p><h4 id="kext-示例代码"><a href="#kext-示例代码" class="headerlink" title="kext 示例代码"></a>kext 示例代码</h4><pre><code>#include &lt;sys/systm.h&gt;#include &lt;mach/mach_types.h&gt;#include &lt;mach/kern_return.h&gt; #include &lt;sys/kern_control.h&gt;//#include &lt;SOMEWHERE YOU CAN GET STRNCPY IN THE KERNEL FROM&gt;char name[] = &quot;com.example.mymodule&quot; ;//标识这个kextstruct kern_ctl_ref _ctlref ; kern_return_t start(kmod_info_t *info, void *data){    int err ;    struct kern_ctl_reg ctlreg ;    bzero(&amp;ctlreg, sizeof(ctlreg)) ;    //控制信息    ctlreg.ctl_id = 0 ; /* 请求分配一个动态id */    ctlreg.ctl_unit = 0 ;    strncpy(ctlreg.ctl_name, name, sizeof(ctlreg.ctl_name));    //回调函数    ctlreg.ctl_connect_func = connect ;    ctlreg.ctl_disconnect_func = disconnect ;    ctlreg.ctl_send_func = send ;    ctlreg.ctl_getopt_func = getopt ;    ctlreg.ctl_setopt_func = setopt ;    //注册内核控制    err = ctl_register(&amp;ctlreg, &amp;_ctlref) ;    if (err) return KERN_FAILURE ;    return KERN_SUCCESS ;}</code></pre><p>下面解释下其中的<code>kern_ctl_ref</code>数据结构</p><pre><code>struct kern_ctl_reg{    /* 控制信息 */    char        ctl_name[MAX_KCTL_NAME];    u_int32_t    ctl_id;    u_int32_t    ctl_unit;    /* 控制设置 */    u_int32_t    ctl_flags;    u_int32_t    ctl_sendsize;    u_int32_t    ctl_recvsize;    /* 回调函数 */    ctl_connect_func    ctl_connect;//建立连接时调用    ctl_disconnect_func    ctl_disconnect;//断开连接时调用    ctl_send_func    ctl_send;//处理从client到kernel的数据发送    ctl_setopt_func    ctl_setopt; //当client调用setsockopt时调用    ctl_getopt_func    ctl_getopt;//当client调用getsockopt时调用};</code></pre><h4 id="client-示例代码"><a href="#client-示例代码" class="headerlink" title="client 示例代码"></a>client 示例代码</h4><pre><code>#include &lt;socket.h&gt;#include &lt;string.h&gt;#include &lt;sys/kern_control.h&gt;#include &lt;sys/ioctl.h&gt;char name[] = &quot;com.example.mymodule&quot; ;//标识这个kextstatic int g_socket = -1;u_int32_t getctlidbybame(int sock, char *name) ;//建立连接int socket_ctl(char *name){    int g_sock = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) ;    if (g_sock == 0) return 0 ;    u_int32_t id = getctlidbyname(g_sock, name) ;    sockaddr_ctl addr ;    addr.sc_len = sizeof(addr) ;    addr.sc_family = AF_SYSTEM ;    addr.sc_sysaddr = AF_SYS_CONTROL ;    addr.sc_id = id ;    addr.sc_unit = 0 ; /* allocate dynamically */    int err ;    err = connect(g_sock, (struct sockaddr*)&amp;addr, sizeof(addr)) ;    if (err) return 0 ;    return sock ;}u_int32_t getctlidbybame(int sock, char *name){    struct ctl_info info ;    memset(&amp;info, 0, sizeof(info)) ;    strncpy(info.ctl_name, name, strlen(name)) ;    int err = ioctl(sock, CTLIOCGINGO, &amp;info) ;    if (err) return 0 ; /* should do something stronger here! */    return info.ctl_id ;}int main(int argc, const char *argv[]){        socket_ctl(name);}//发送数据void execute_cmd(int cmd, char *args){    char data[32] = { 0 };    size_t data_len = 0;    int retv;    if(args != NULL) {        memcpy(data, args, strlen(args));    }    data_len = strlen(data) + 1;    retv = setsockopt(g_socket, SYSPROTO_CONTROL, cmd, (void *)data, (socklen_t)data_len);    if(retv != 0) {        printf(&quot;[ERROR] Kernel command execution failed:\n&quot;);        printf(&quot;\t%s (%d)\n&quot;, strerror(errno), errno);        return;    }}//接收数据void get_data(){    char *data = malloc(32);    socklen_t data_len = 32;    int retv = getsockopt(g_socket, SYSPROTO_CONTROL, 0, data, &amp;data_len);    if(retv != 0) {        printf(&quot;[ERROR] getsockopt()\n&quot;);        return;    }    size_t r = recv(g_socket, data, data_len, 0);    if(r == 0) {        printf(&quot;[ERROR] recv()\n&quot;);        return;    }}</code></pre><p>代码不是很复杂，先通过kext名去获取一个id建立一个socket，然后通过这个socket去发送和接受kext的数据。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>在这个rootKit框架中还有很多可以挖掘的东西，里面hook系统调用来达到反kill等功能很是实用，以及一些内核操作手段都值得学习和借鉴，待续…</p><h3 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h3><ul><li><a href="http://www.tanhao.me/pieces/1515.html/" target="_blank" rel="external">http://www.tanhao.me/pieces/1515.html/</a></li><li><a href="https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html" target="_blank" rel="external">https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html</a></li><li><a href="https://github.com/enzolovesbacon/inficere">https://github.com/enzolovesbacon/inficere</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。&lt;br&gt;简单说下rootKit原理：&lt;br&gt;利用kext驻留在内核，完成实际的各种功能：&lt;br&gt;&lt;code&gt;sys
      
    
    </summary>
    
      <category term="kext/iokit" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/kext-iokit/"/>
    
    
      <category term="kext" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"/>
    
  </entry>
  
  <entry>
    <title>初-LLVM的代码混淆</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/初-LLVM的代码混淆/初-LLVM的代码混淆/</id>
    <published>2017-06-25T07:09:13.000Z</published>
    <updated>2019-02-21T09:55:50.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><blockquote><blockquote><p>断断续续的学习了一段时间的LLVM，记录下学习进度，随着后面的学习待更新</p></blockquote></blockquote><ul><li>LLVM简介</li><li>一个基于LLVM简单的代码混淆例子</li><li>参考链接</li></ul><h2 id="0x01-LLVM简介"><a href="#0x01-LLVM简介" class="headerlink" title="0x01 LLVM简介"></a>0x01 LLVM简介</h2><p>LLVM(low level virtual machine)是一个先进的编译器框架，它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。<br>LLVM的主要架构如下：</p><ul><li>前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。</li><li>Pass：Pass是LLVM优化工作的一个节点，一个节点做些事，一起加起来就构成了LLVM完整的优化和转化。</li><li>后端：后端用来生成实际的机器码，一般情况下不会关注这一部分。</li></ul><h3 id="LLVM框架："><a href="#LLVM框架：" class="headerlink" title="LLVM框架："></a>LLVM框架：</h3><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-0.png?raw=true" alt="0-0"><br>这里与传统的编译器不同，LLVM采用了一种统一的中间表示：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-1.png?raw=true" alt="0-1"></p><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p>首先下载LLVM  </p><pre><code>$ cd where-you-want-llvm-to-live$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</code></pre><p>我们选择clang作为LLVM前端，然后下载clang  </p><pre><code>$ cd where-you-want-llvm-to-live$ cd llvm/tools$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</code></pre><p>下载编译运行库</p><pre><code>$ cd where-you-want-llvm-to-live$ cd llvm/projects$ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</code></pre><p>最后编译LLVM源码</p><pre><code>$ mkdir build$ cd build$ cmake -DCMAKE_BUILD_TYPE:String=Release ../llvm/$ make</code></pre><p>编译时间可能有点长，编译完成之后进行安装</p><pre><code>$sudo make install</code></pre><p>接下来就是LLVM的使用，先创建一个hello.c源文件</p><pre><code>#include &lt;stdio.h&gt;int main(){    printf(&quot;hello LLVM\n&quot;);    return 0;}</code></pre><h2 id="0x02-一个基于LLVM简单的代码混淆例子"><a href="#0x02-一个基于LLVM简单的代码混淆例子" class="headerlink" title="0x02 一个基于LLVM简单的代码混淆例子"></a>0x02 一个基于LLVM简单的代码混淆例子</h2><p>Pass是LLVM中一个很重要的部分，每个Pass都是做优化或者转换的工作，LLVM的优化和转换工作就是由很多个Pass一起完成的。我们通过继承指定的类以及实现相关的虚函数来实现具体的Pass，具体的类型主要有以下几种：  </p><ul><li>ImmutablePass</li><li>MoudlePass</li><li>CallGraphSCCPass</li><li>FuncationPass</li><li>LoopPass</li><li>RegionPass</li><li>BasicBlockPass</li><li>MachineFunctionPass</li></ul><p>下面这个例子来介绍一下pass的编写并达到简单的混淆。从这里下载这个模板<a href="https://github.com/NULL-ME/NULL-ME.github.io/tree/master/articlePic/LLVM/skeleton">llvm-pass-skeleton</a></p><p>下面是完整代码：</p><pre><code>#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;#include &quot;llvm/IR/Intrinsics.h&quot;#include &quot;llvm/IR/Instructions.h&quot;using namespace llvm;namespace {  struct SkeletonPass : public FunctionPass {    static char ID;    SkeletonPass() : FunctionPass(ID) {}    // virtual bool runOnFunction(Function &amp;F) {    //   errs() &lt;&lt; &quot;I saw a function called &quot; &lt;&lt; F.getName() &lt;&lt; &quot;!\n&quot;;    //   return false;    // }    bool runOnFunction(Function &amp;F) override {            Function *tmp = &amp;F;            // 遍历函数中的所有基本块            for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) {                // 遍历基本块中的每条指令                for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) {                    // 是否是add指令                    if (inst-&gt;isBinaryOp()) {                        if (inst-&gt;getOpcode() == Instruction::Add) {                            ob_add(cast&lt;BinaryOperator&gt;(inst));                        }                    }                }            }            return false;        }        // a+b === a-(-b)        bool ob_add(BinaryOperator *bo) {            BinaryOperator *op = NULL;            if (bo-&gt;getOpcode() == Instruction::Add) {                // 生成 (－b)                op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo);                // 生成 a-(-b)                op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo);                op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap());                op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap());            }            // 替换所有出现该指令的地方            bo-&gt;replaceAllUsesWith(op);        }  };}char SkeletonPass::ID = 0;// Automatically enable the pass.// http://adriansampson.net/blog/clangpass.htmlstatic void registerSkeletonPass(const PassManagerBuilder &amp;,                         legacy::PassManagerBase &amp;PM) {  PM.add(new SkeletonPass());}static RegisterStandardPasses  RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible,                 registerSkeletonPass);</code></pre><p>通过继承<code>FunctionPass</code>重写虚函数<code>runOnFunction</code>来到达我们代码混淆的目的，再看关键的混淆部分，如下面注释那样，找到函数中的add指令，并将其改为sub指令。如<code>a+b</code>经过混淆为<code>a-(-b)</code></p><pre><code>bool runOnFunction(Function &amp;F) override {            Function *tmp = &amp;F;            // 遍历函数中的所有基本块            for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) {                // 遍历基本块中的每条指令                for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) {                    // 是否是add指令                    if (inst-&gt;isBinaryOp()) {                        if (inst-&gt;getOpcode() == Instruction::Add) {                            ob_add(cast&lt;BinaryOperator&gt;(inst));                        }                    }                }            }            return false;        }</code></pre><p>代码很简单，这里就不多说。我们使用</p><pre><code>$clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.* something.c</code></pre><p>来运行这个pass编译成目标可执行文件<br>现在我们创建一个addTest.c文件来测试是否代码混淆</p><pre><code>#include &lt;stdio.h&gt;int func(int a,int b){    return a + b;}int main(){    int c;    c = func(6,9);    printf(&quot;%d\n&quot;,c);    return c;}</code></pre><p>先按照一般的编译源代码，查看关键汇编代码：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-2.png?raw=true" alt="0-2"><br>然后运行我们的pass进行编译<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-3.png?raw=true" alt="0-3"><br>很明显，汇编代码发生了改变，当然这里仅仅是一个简单的混淆，感兴趣的可以研究下<a href="https://github.com/obfuscator-llvm">obfuscator-llvm</a>这个项目。</p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><p><a href="http://www.tuicool.com/articles/2meqIjq" target="_blank" rel="external">深入剖析 iOS 编译 Clang / LLVM</a><br><a href="http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/" target="_blank" rel="external">http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-目录&quot;&gt;&lt;a href=&quot;#0x00-目录&quot; class=&quot;headerlink&quot; title=&quot;0x00 目录&quot;&gt;&lt;/a&gt;0x00 目录&lt;/h2&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;断断续续的学习了一段时间的LLVM，记录下学习进
      
    
    </summary>
    
      <category term="LLVM" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/LLVM/"/>
    
    
      <category term="LLVM" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLVM/"/>
    
      <category term="obfuscation" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/obfuscation/"/>
    
  </entry>
  
  <entry>
    <title>pwnhub-CTF re150</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/</id>
    <published>2017-05-28T01:16:13.000Z</published>
    <updated>2019-02-21T10:03:11.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度的，这里记录下其中的一道逆向题。题目在<a href="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/re150?raw=true">这里</a></p><h2 id="0x01-简单分析"><a href="#0x01-简单分析" class="headerlink" title="0x01 简单分析"></a>0x01 简单分析</h2><p>拿到题目后试着在虚拟机里运行了一下，看下有什么提示<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-0.png?raw=true" alt="0-0"></p><p>然后转去hopper搜下相关字符串，并没有发现<code>error</code>相关字符串，syclover也没有相关<code>printf</code>等函数输出，看来只能上gdb调试看看。</p><p>发现程序里面有多处花指令以及隐藏了程序入口。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-1.png?raw=true" alt="0-0"></p><p>由上图可以发现syclover直接由<code>int 0x80</code>系统调用中断输出到屏幕，下面是一个循环解密，后面可知解密的正是程序的入口。</p><p>由<code>__libc_start_main</code>函数可得第一个参数即为<code>main</code>函数地址<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-2.png?raw=true" alt="0-0"><br>这里作为对比，可以看下hopper中对<code>0x8048320</code>main函数的解析<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-3.png?raw=true" alt="0-0"><br>完全不知道是什么有木有？所以拿到题如果放到IDA之类的反汇编工具根本看不出什么线索</p><p>接下来所做的事就是获取输入的字符串然后进行加密，然后与程序里的字符串加密比较，具体看后面的代码。</p><h2 id="0x02-修复程序"><a href="#0x02-修复程序" class="headerlink" title="0x02 修复程序"></a>0x02 修复程序</h2><p>根据上面的分析，我们将程序进行修复</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;elf.h&gt;#define ENTRY 0x08048320#define FILE_OFF 0x320#define COUNT 0x432int main(int argc,char *argv[]){    Elf32_Ehdr ehdr;    unsigned char buf[COUNT] = {0};    assert(argc == 2);    int fd = open(argv[1],O_RDWR);//打开文件    assert(fd&gt;0);    assert(lseek(fd,0,SEEK_SET)!=-1);// 读取elf头    assert(read(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr));     ehdr.e_entry = ENTRY;//修改入口地址      assert(lseek(fd,0,SEEK_SET)!=-1);//回写elf头    assert(write(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr));      //解密    assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//读取被加密的代码    assert(read(fd,buf,COUNT) == COUNT);    int i = 0;    while(i&lt;COUNT){        buf[i] = (buf[i]^66)&lt;&lt;5 | (buf[i]^66)&gt;&gt;3;         i++;         }    assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//写入正确代码    assert(write(fd,buf,COUNT) == COUNT);</code></pre><h2 id="0x03-分析算法计算flag"><a href="#0x03-分析算法计算flag" class="headerlink" title="0x03 分析算法计算flag"></a>0x03 分析算法计算flag</h2><pre><code>#!/usr/bin/python# -*- coding: UTF-8 -*-from __future__ import print_function  import sysdef getflag():    print(&quot;[i]start to encrypt key&quot;)    key = [0x73,0x8d,0xf2,0x4c,0xc7,0xd4,0x7b,0xf7,0x18,0x32,0x71,0x0d,0xcf,0xdc,0x67,0x4f,0x7f,0x0b,0x6d]    encryptKey = []    print(&quot;encryptKey=[&quot;, end=&quot;&quot;)    for idx in range(len(key)):        encryptKey.append(key[idx] ^ 0x20)        print(&quot;%x &quot; % encryptKey[idx], end=&quot;&quot;)    print(&quot;]&quot;)      flag = []    print(&quot;[i]find the flag&quot;)    for i in range(len(encryptKey)):        count = 0x00        while(count &lt;= 0x7f):            one = count &gt;&gt; (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d))            two = count &lt;&lt; (0x8 - (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d)))            if((((one | two) ^ i) &amp; 0xff) == encryptKey[i]):                flag.append(count)                break            count = count + 1    print(&quot;flag = &quot;,end=&quot;&quot;)    for i in range(len(flag)):        print(&quot;%c&quot; % flag[i], end=&quot;&quot;)   if __name__ == &#39;__main__&#39;:    key = getflag()</code></pre><p>最后运行程序得到flag</p><pre><code>[i]start to encrypt keyencryptKey=[53 ad d2 6c e7 f4 5b d7 38 12 51 2d ef fc 47 6f 5f 2b 4d ][i]find the flagflag = SYC{&gt;&gt;Wh06m1&gt;&gt;R0Ot}</code></pre><p>测试：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-4.png?raw=true" alt="0-0"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;p&gt;第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度
      
    
    </summary>
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/CTF/"/>
    
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CTF/"/>
    
      <category term="writeup" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>一道高中数学题的思考？</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/04/math/math/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/04/math/math/</id>
    <published>2017-05-04T12:37:59.000Z</published>
    <updated>2019-02-21T10:01:58.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><blockquote><p> 突然在邮件中收到Quora中这样一个问题”What does X equal in $\sqrt{x+15} + \sqrt{x} = 15$? “ 凭着曾经对数学的热爱，我点了进去。顺便学习了点知识。</p></blockquote><h2 id="0x01-你会怎么解决？"><a href="#0x01-你会怎么解决？" class="headerlink" title="0x01 你会怎么解决？"></a>0x01 你会怎么解决？</h2><p>不得不承认，这种题型在初高中时候还是蛮常见的，在我的脑海里，也别无他法，一步一步去根号解方程吧。但都知道，同时平方带来就是可能会升高次数，有时候拿到答案还是挺繁琐的，至少计算上来说是这样的。</p><h2 id="0x02-方法1-平方法"><a href="#0x02-方法1-平方法" class="headerlink" title="0x02 方法1 平方法"></a>0x02 方法1 平方法</h2><p>通常解决这个问题的方法是将方程的两边平方并简化，并保持平方，直到方程中没有平方根</p><p>$\sqrt{x+15} + \sqrt{x} = 15$ </p><p>$(\sqrt{x+15} + \sqrt{x})^2 = 15^2$ </p><p>$x+15 + 2\sqrt{(x+15)x} + x = 225$ </p><p>$2\sqrt{(x+15)x} = 210 - 2x$  </p><p>$\sqrt{(x+15)x} = 105 - x$  </p><p>$(\sqrt{(x+15)x})^2 = (105 - x)^2$  </p><p>$x^2 + 15x = 11025 - 210x +x^2$  </p><p>$225x = 11025$  </p><p>$ x = 49$<br>思维过程很清楚，但明显计算上有点繁琐。  </p><h2 id="0x03-方法2-拼凑法"><a href="#0x03-方法2-拼凑法" class="headerlink" title="0x03 方法2 拼凑法"></a>0x03 方法2 拼凑法</h2><p>不一定可靠，但一定最快。大多情况下，都是开方后是整数。所以每个完全平方数的序列（$1^22^23^3…6^27^28^2… =&gt; 1 4 9 16 25 36 49 64 …$）</p><p>哪两个数相差15呢？很明显64 - 49 = 15，也许你觉得这很不靠谱，其实至少对于开方是整数的结果来说是很快的，觉得慢主要是你还不熟练。因为并不是一个一个的去试验，因为相邻之差是递增且快。类似二叉树来查找会很快得出结果。  </p><p>$\sqrt{49 + 15} + \sqrt{49} = 15$  </p><p>$7 + 8 = 15$<br>最快，但不一定可靠。</p><h2 id="0x04-方法3-平方差法"><a href="#0x04-方法3-平方差法" class="headerlink" title="0x04 方法3 平方差法"></a>0x04 方法3 平方差法</h2><p>暂且称作平方差法吧，这个方法是我最推荐的，既快又准。<br>原式：$\sqrt{x+15} + \sqrt{x} = 15$  (1)</p><p>设 $\sqrt{x+15} - \sqrt{x} = k$  </p><p>又 $(\sqrt{x+15} - \sqrt{x})(\sqrt{x+15} + \sqrt{x})= 15k$ </p><p>解得： $k = 1$    </p><p>所以 $\sqrt{x+15} - \sqrt{x} = 1$ （2）</p><p>然后<code>（1）+ (2)</code>:   $2\sqrt{x+15} = 16$  </p><p>解得: $x = 49$  </p><p>多么棒的一个方法 I love it！  </p><h2 id="0x05-我与数学"><a href="#0x05-我与数学" class="headerlink" title="0x05 我与数学"></a>0x05 我与数学</h2><p>从小数学就比语文好的我，数学确实给了我很多自信，想破头皮的去思考一个一个的题。一如既往的热爱，以致于高考只填了一个专业–数学。由于种种原因，没能选上，去来到了计算机相关的专业。计算机科学同样是一个迷人的世界，那种理解本质，控制计算机的运行是让人着迷的。在反馈上来说，计算机比做数学得到的反馈更真实，快速。做数学题的时候总是找不到方向，得到的反馈少且慢，容易让人沮丧，想必这也是大多人讨厌数学的原因之一吧。虽然现在更热爱计算机，但心底里仍然有一个数学的种子。以至于很多时候看到感兴趣的题也会拿上纸笔算一算，知乎上也关注了相关话题，还有一个自己特别骄傲的回答，关于高中数列的，具体情况移步<a href="https://www.zhihu.com/question/30050677" target="_blank" rel="external">高考数学数列放缩总结技巧有哪些？</a><br>相信不管是现在还是将来，数学都是我最深处的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 突然在邮件中收到Quora中这样一个问题”What do
      
    
    </summary>
    
      <category term="misc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/misc/"/>
    
    
      <category term="math" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/math/"/>
    
  </entry>
  
</feed>
