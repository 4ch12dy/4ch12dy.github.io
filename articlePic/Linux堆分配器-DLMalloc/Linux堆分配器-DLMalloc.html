<!DOCTYPE HTML>

    <html lang="zh-Hans">
  
<head>
  <meta charset="utf-8">
  
  <title>4chendy</title>
  <meta name="author" content="4chendy">
  
  <meta name="description" content="一个不断努力的少年！">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="4chendy"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <meta http-equiv="Content-Language" content="zh-Hans"/>
  

  <link href="/img/favicon.png" rel="icon">
  
    <link rel="apple-touch-icon" href="/img/apple-icon.ico">
    <link rel="apple-touch-icon-precomposed" href="/img/apple-icon.ico">
    

  <link rel="alternate" href="/dark-tech/atom.xml" title="4chendy" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  
  <!-- Chinese readability improment -->
  <style type="text/css">
    article {font-weight: 400;letter-spacing: .01rem;}
    article .entry{line-height:2;}
  </style>
  
  
  <style type="text/css">
  /* Tim Pietrusky advanced checkbox hack (Android <= 4.1.2) */
body{ -webkit-animation: bugfix infinite 1s; }
@-webkit-keyframes bugfix { from {padding:0;} to {padding:0;} }
</style>

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48887175-1', 'auto');
  ga('send', 'pageview');

</script>



  
    <!-- 360 Font and Baidu CDN in China -->
    
      <link href='http://fonts.useso.com/css?family=Open+Sans:300,400|Playball' rel='stylesheet' type='text/css'>
    
  <link href='http://apps.bdimg.com/libs/fontawesome/4.1.0/css/font-awesome.css' rel='stylesheet' type='text/css'>
  <script src="http://libs.baidu.com/jquery/1.11.1/jquery.min.js"></script>
  



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>


<body>
  <header id="header" class="inner"><div class="padding">
	<div class="alignleft logo">
	  <h1><a href="/">4chendy</a></h1>
	</div>
	<nav id="main-nav" class="alignright">
		<input type="checkbox" id="toggle" />
		<label for="toggle" class="toggle" data-open="Main Menu" data-close="Close Menu" onclick><i class="fa fa-bars"></i></label>
	  <ul class="menu">
	    
	      <li><a href="/">Home</a></li>
	    
	      <li><a href="/archives">Archives</a></li>
	    
	      <li><a href="/about">About</a></li>
	    
	      <li><a href="/fuckshit">f**kshit</a></li>
	    
	    
	    	<li><a href="/dark-tech/atom.xml" target="_blank" title="bruce tan blog rss" class="rss-top"><i class="fa fa-rss"></i></a></li>
	    
	  </ul>
	</nav>
	<div class="clearfix"></div>
</div>
</header>
  <div id="page-heading-wrap">
  	<div class="inner">
      <div class="padding">
    		
          <h2>一个不断努力的少年！</h2>
        
      </div>
  	</div>
  </div>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper" class="padding"><article class="page">
  
  
    <div class="post-content">
  
      
      <div class="entry">
        
          <hr>
<p>title: 深入理解Linux堆分配器-DLMalloc<br>date: 2017-04-24 12:16</p>
<h2 id="tags-linux-heap-malloc-free"><a href="#tags-linux-heap-malloc-free" class="headerlink" title="tags: [linux,heap,malloc,free]"></a>tags: [linux,heap,malloc,free]</h2><h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><p>当学习漏洞利用到一定阶段的时候，就需要对操作系统层面有一定的了解了。无疑Linux的堆管理一直是不能甚解。因此这篇文章将对Linux的DLMalloc进行详细的介绍，以此对操作系统的堆管理有一个清晰整体的认识。</p>
<h2 id="0x01-目录"><a href="#0x01-目录" class="headerlink" title="0x01 目录"></a>0x01 目录</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>DLMalloc</div><div class="line"><span class="number">2.</span>内存Chunk</div><div class="line"><span class="number">3.</span>Bin</div></pre></td></tr></table></figure>
<h2 id="0x02-DLMalloc"><a href="#0x02-DLMalloc" class="headerlink" title="0x02 DLMalloc"></a>0x02 DLMalloc</h2><p>Doug Lea’s Malloc (dlmalloc)是一个GNU C库的内存分配器，它能够通过calloc(),malloc(), free()和realloc()等动态分配和释放的函数来管理内存。</p>
<p>明显内存分配器在操作系统中是相当重要的，主要在需要满足下列的特点：</p>
<ul>
<li>稳定性(stability)</li>
<li>性能(performance)</li>
<li>避免碎片化(avoidance of fragmentation)</li>
<li>低空间开销(low space overhead）</li>
</ul>
<p>根据上面的内存特点，将有助于后面对chunk以及Bin等的理解。</p>
<h2 id="0x03-内存chunk"><a href="#0x03-内存chunk" class="headerlink" title="0x03 内存chunk"></a>0x03 内存chunk</h2><p>1.什么是chunk？<br>chunk是堆中一些连续的内存块，可以用作分配，释放，拆分，合并。不存在两个连续的释放chunk，这是在于相邻的chunk会合并。</p>
<p>2.数据结构</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span></span> &#123;</div><div class="line">	INTERNAL_SIZE_T prev_size; <span class="comment">//当前chunk前一个chunk的大小，仅在前一个									  为freed才使用</span></div><div class="line">	INTERNAL_SIZE_T size;      <span class="comment">//当前chunk的大小</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span></span> * fd;  <span class="comment">//如果当前为释放chunk，指向双向free 									   list中前一个chunk</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span></span> * bk;  <span class="comment">//如果当前为释放chunk，指向双向free 									   list中后一个chunk</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据上面的描述我们可以知道，chunk在分配时和释放时数据结构是不同的，看下面的图例:</p>
<ul>
<li>allocate chunk</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">chunk   --&gt;+---------------------------------------+</div><div class="line">           |     <span class="type">前一个chunk</span>大小                     |</div><div class="line">           <span class="type">+---------------------------------------+</span></div><div class="line">           |     当前chunk大小                 |<span class="type">A</span>|<span class="type">M</span>|<span class="type">P</span>|</div><div class="line"> <span class="type">mem</span>    --&gt;+---------------------------------------+</div><div class="line">           |     <span class="type">malloc</span>返回用户的开始地址，储存用户数据  |</div><div class="line">           <span class="type">.                                       .</span></div><div class="line">           .                                       .</div><div class="line">           .                                       .</div><div class="line">           +---------------------------------------+</div><div class="line">nextchunk-&gt;|     <span class="type">前一个chunk</span>大小                     |</div><div class="line">           <span class="type">+---------------------------------------+</span></div><div class="line">                       ...        </div><div class="line">```   </div><div class="line"></div><div class="line">*  freed chunk</div></pre></td></tr></table></figure>
<p>chunk   –&gt;+—————————————+<br>           |     前一个chunk大小                     |<br>           +—————————————+<br>           |     当前chunk大小                |A| |P|<br> mem    –&gt;+—————————————+<br>           |     fd指向free list中下一个chunk        |<br>           +—————————————+<br>           |     bk指向free list中后一个chunk        |<br>           +—————————————+<br>           .     用户数据 可能为0                    .<br>           .                                       .<br>nextchunk-&gt;+—————————————+<br>           |     前一个chunk大小                     |<br>           +—————————————+<br>                       …<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line"><span class="number">3.</span>更多细节</div><div class="line">因为chunk是按照<span class="number">8</span>字节对齐的，所以当前块中的size低三位将用作相关标志，从右到左A M P分别代表：是否在主heap？是否通过mmap()分配？前一个chunk是否在使用？</div><div class="line">然后可以想到有一个最小chunk的存在，其大小为<span class="number">16</span>字节()。</div><div class="line"></div><div class="line"><span class="number">4.</span>特殊chunk</div><div class="line"></div><div class="line">top chunk:指可能内存边界的末端，也被称作wilderness chunk。如果其他bin都不满足malloc的情况下，就会从top chunk里去一部分去满足分配请求，剩余的则作为新的top chunk，并且top chunk不在任何一个bin中。随着被分离和合并top chunk会增大和减小。</div><div class="line"></div><div class="line">last_remainder:和top chunk一样，不在任何一个bin中，但最终可能会合并到一个bin中。可以看英文原文解释：The last_remainder chunk is <span class="keyword">the</span> <span class="built_in">result</span> <span class="keyword">of</span> allocation requests <span class="keyword">for</span> small chunks that have no exact fit <span class="keyword">in</span> <span class="keyword">any</span> <span class="keyword">of</span> <span class="keyword">the</span> bins. If <span class="keyword">the</span> request is larger than <span class="keyword">the</span> last_remainder chunk but smaller than <span class="keyword">a</span> block <span class="keyword">in</span> <span class="keyword">a</span> bin, <span class="keyword">then</span> <span class="keyword">the</span> chunk is <span class="built_in">split</span> again. The last_remainder chunk is <span class="keyword">the</span> <span class="built_in">result</span> <span class="keyword">of</span> having <span class="built_in">to</span> <span class="built_in">split</span> <span class="keyword">a</span> larger chunk <span class="keyword">into</span> <span class="literal">two</span>, <span class="literal">one</span> part <span class="keyword">of</span> <span class="keyword">it</span> is handed out <span class="built_in">from</span> <span class="keyword">the</span> allocation, <span class="keyword">and</span> <span class="keyword">the</span> other because <span class="keyword">the</span> last_remainder chunk.</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">## 0x04 Bin</span></div><div class="line">chunk一旦被释放后就会被存储在叫做Bin的链表中，Bin有不同大小的链表，方便与下次查找到最适当的chunk。通常来说有small-bin，large-bin，fast-bin。</div><div class="line"></div><div class="line">这里我主要介绍fsatbin和normalbin</div><div class="line"></div><div class="line">(<span class="number">1</span>)fastbin：是一种单链表bin，不同系统定义了一个最大值，当chunk大小小于等于这个最大值时，就会被释放到fastbin中，正如名字那样，为了更快的free和malloc，这个链表是无序的，是后进先出（LIFO），并且不与其他chunk合并。</div><div class="line"></div><div class="line">(<span class="number">2</span>)normalbin:是一种双向链表bin，当chunk大小大于fastbin的大小时就会被放入这个bin，并且有着各种大小的normalbin(减少碎片)，bin内部的chunk按大小组织起来。释放后会于相邻的chunk合并。</div><div class="line"></div><div class="line"><span class="comment">## 0x05 free()源代码分析及相关细节</span></div><div class="line"></div><div class="line">`free(void *mem)<span class="comment">--&gt;__libc_free(void *mem)`</span></div></pre></td></tr></table></figure></p>
<p>void<br>__libc_free (void <em>mem)<br>{<br>  mstate ar_ptr;<br>  mchunkptr p;                          /</em> chunk corresponding to mem */</p>
<p>  void (<em>hook) (void </em>, const void <em>)<br>    = atomic_forced_read (<strong>free_hook);<br>  if (</strong>builtin_expect (hook != NULL, 0))<br>    {<br>      (</em>hook)(mem, RETURN_ADDRESS (0));<br>      return;<br>    }</p>
<p>  if (mem == 0)                              /<em> free(0) has no effect </em>/<br>    return;</p>
<p>  p = mem2chunk (mem);</p>
<p>  if (chunk_is<em>mmapped (p))                       /<em> release mmapped memory. </em>/<br>    {<br>      /<em> See if the dynamic brk/mmap threshold needs adjusting.<br>         Dumped fake mmapped chunks do not affect the threshold.  </em>/<br>      if (!mp</em>.no_dyn_threshold<br>          &amp;&amp; chunksize<em>nomask (p) &gt; mp</em>.mmap_threshold<br>          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX<br>          &amp;&amp; !DUMPED_MAIN_ARENA<em>CHUNK (p))<br>        {<br>          mp</em>.mmap<em>threshold = chunksize (p);<br>          mp</em>.trim<em>threshold = 2 * mp</em>.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn<em>thresholds, 2,<br>                      mp</em>.mmap<em>threshold, mp</em>.trim_threshold);<br>        }<br>      munmap_chunk (p);<br>      return;<br>    }</p>
<p>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, 0); //跳转到_int_free<br>}<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">我们先不关注其他的，只需要知道会调用_int_free就就可以了</div><div class="line"></div><div class="line"></div><div class="line">`__libc_free<span class="function"><span class="params">(<span class="literal">void</span> *mem)</span>--&gt;</span>_int_free (mstate av, mchunkptr p, int have_lock)`</div></pre></td></tr></table></figure></p>
<p>static void<br>_int_free (mstate av, mchunkptr p, int have_lock)<br>{<br>  INTERNAL_SIZE_T size;        /<em> 当前chunk的大小 </em>/<br>  mfastbinptr <em>fb;             /</em> 相关的fastbin <em>/<br>  mchunkptr nextchunk;         /</em> 下一个相邻的chunk <em>/<br>  INTERNAL_SIZE_T nextsize;    /</em> 下一个chunk的大小 <em>/<br>  int nextinuse;               /</em> 下一个chunk正在使用时为真 <em>/<br>  INTERNAL_SIZE_T prevsize;    /</em> 前一个chunk的大小 <em>/<br>  mchunkptr bck;               /</em> 指向free链表中向后一个chunk <em>/<br>  mchunkptr fwd;               /</em> 指向free链表中向前一个chunk */</p>
<p>  const char *errstr = NULL;<br>  int locked = 0;</p>
<p>  size = chunksize (p);</p>
<p>  /<em> Little security check which won’t hurt performance: the<br>     allocator never wrapps around at the end of the address space.<br>     Therefore we can exclude some size values which might appear<br>     here by accident or by “design” from some intruder.  </em>/<br>  //一些安全检查<br>  if (<strong>builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)<br>      || </strong>builtin_expect (misaligned_chunk (p), 0))<br>    {<br>      errstr = “free(): invalid pointer”;<br>    errout:<br>      if (!have_lock &amp;&amp; locked)<br>        <strong>libc_lock_unlock (av-&gt;mutex);<br>      malloc_printerr (check_action, errstr, chunk2mem (p), av);<br>      return;<br>    }<br>  /<em> We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT.  </em>/<br>   //检查是否满足大于等于最小大小<br>  if (</strong>glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))<br>    {<br>      errstr = “free(): invalid size”;<br>      goto errout;<br>    }</p>
<p>  check_inuse_chunk(av, p); //检查当前chunk是否在使用</p>
<p>  /<em><br>    如果满足，则将该chunk放入fastbin以便malloc时能够快速找到和使用
  </em>/<br>  if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())</p>
<p>#if TRIM_FASTBINS<br>      /<em><br>        If TRIM_FASTBINS set, don’t place chunks<br>        bordering top into fastbins
      </em>/<br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</p>
<p>#endif<br>      ) {</p>
<pre><code>if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))
                      &lt;= 2 * SIZE_SZ, 0)
    || __builtin_expect (chunksize (chunk_at_offset (p, size))
                         &gt;= av-&gt;system_mem, 0))
  {
    /* We might not have a lock at this point and concurrent modifications
       of system_mem might have let to a false positive.  Redo the test
       after getting the lock.  */
    if (have_lock
        || ({ assert (locked == 0);
              __libc_lock_lock (av-&gt;mutex);
              locked = 1;
              chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ
                || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;
          }))
      {
        errstr = &quot;free(): invalid next size (fast)&quot;;
        goto errout;
      }
    if (! have_lock)
      {
        __libc_lock_unlock (av-&gt;mutex);
        locked = 0;
      }
  }

free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);

set_fastchunks(av);
unsigned int idx = fastbin_index(size);
fb = &amp;fastbin (av, idx);

/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */
mchunkptr old = *fb, old2;
unsigned int old_idx = ~0u;
do
  {
    /* Check that the top of the bin is not the record we are going to add
       (i.e., double free).  */
    if (__builtin_expect (old == p, 0))
      {
        errstr = &quot;double free or corruption (fasttop)&quot;;
        goto errout;
      }
    /* Check that size of fastbin chunk at the top is the same as
       size of the chunk that we are adding.  We can dereference OLD
       only if we have the lock, otherwise it might have already been
       deallocated.  See use of OLD_IDX below for the actual check.  */
    if (have_lock &amp;&amp; old != NULL)
      old_idx = fastbin_index(chunksize(old));
    p-&gt;fd = old2 = old;
  }
while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);

if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0))
  {
    errstr = &quot;invalid fastbin entry (free)&quot;;
    goto errout;
  }
</code></pre><p>  }</p>
<p>  /<em><br>    Consolidate other non-mmapped chunks as they arrive.
  </em>/<br>  //检查是否是通过mmap()分配的内存<br>  else if (!chunk_is_mmapped(p)) {<br>    if (! have_lock) {<br>      __libc_lock_lock (av-&gt;mutex);<br>      locked = 1;<br>    }</p>
<pre><code>nextchunk = chunk_at_offset(p, size);//返回下一个chunk的地址

/* Lightweight tests: check whether the block is already the
   top block.  */
//检查下一个是否为top-chunk
if (__glibc_unlikely (p == av-&gt;top))
  {
    errstr = &quot;double free or corruption (top)&quot;;
    goto errout;
  }
/* Or whether the next chunk is beyond the boundaries of the arena.  */
if (__builtin_expect (contiguous (av)
                      &amp;&amp; (char *) nextchunk
                      &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0))
  {
    errstr = &quot;double free or corruption (out)&quot;;
    goto errout;
  }
/* Or whether the block is actually not marked used.  */
if (__glibc_unlikely (!prev_inuse(nextchunk)))
  {
    errstr = &quot;double free or corruption (!prev)&quot;;
    goto errout;
  }

nextsize = chunksize(nextchunk);
if (__builtin_expect (chunksize_nomask (nextchunk) &lt;= 2 * SIZE_SZ, 0)
    || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))
  {
    errstr = &quot;free(): invalid next size (normal)&quot;;
    goto errout;
  }

free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);

/* 与后面chunk一个合并 */
if (!prev_inuse(p)) {
  prevsize = prev_size (p);
  size += prevsize;
  p = chunk_at_offset(p, -((long) prevsize));
  unlink(av, p, bck, fwd);//将后一个chunk从双向链表上取下来
}

if (nextchunk != av-&gt;top) {
  /* get and clear inuse bit */
  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);

  /* 与前面chunk一个合并*/
  if (!nextinuse) {
    unlink(av, nextchunk, bck, fwd);//将前一个chunk从双向链表上取下来
    size += nextsize;
  } else
    clear_inuse_bit_at_offset(nextchunk, 0);

  /*
    Place the chunk in unsorted chunk list. Chunks are
    not placed into regular bins until after they have
    been given one chance to be used in malloc.
  */

  bck = unsorted_chunks(av);
  fwd = bck-&gt;fd;
  if (__glibc_unlikely (fwd-&gt;bk != bck))
    {
      errstr = &quot;free(): corrupted unsorted chunks&quot;;
      goto errout;
    }
  p-&gt;fd = fwd;
  p-&gt;bk = bck;
  if (!in_smallbin_range(size))
    {
      p-&gt;fd_nextsize = NULL;
      p-&gt;bk_nextsize = NULL;
    }
  bck-&gt;fd = p;
  fwd-&gt;bk = p;

  set_head(p, size | PREV_INUSE);
  set_foot(p, size);

  check_free_chunk(av, p);
}

/*
  如果当前chunk正好与topchunk相邻，则合并到topchunk
*/

else {
  size += nextsize;
  set_head(p, size | PREV_INUSE);
  av-&gt;top = p;
  check_chunk(av, p);
}

/*
  If freeing a large space, consolidate possibly-surrounding
  chunks. Then, if the total unused topmost memory exceeds trim
  threshold, ask malloc_trim to reduce top.

  Unless max_fast is 0, we don&apos;t know if there are fastbins
  bordering top, so we cannot tell for sure whether threshold
  has been reached unless fastbins are consolidated.  But we
  don&apos;t want to consolidate on each free.  As a compromise,
  consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD
  is reached.
*/

if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) {
  if (have_fastchunks(av))
    malloc_consolidate(av);

  if (av == &amp;main_arena) {
</code></pre><p>#ifndef MORECORE_CANNOT<em>TRIM<br>        if ((unsigned long)(chunksize(av-&gt;top)) &gt;=<br>            (unsigned long)(mp</em>.trim<em>threshold))<br>          systrim(mp</em>.top_pad, av);</p>
<p>#endif<br>      } else {<br>        /<em> Always try heap_trim(), even if the top chunk is not<br>           large, because the corresponding heap might go away.  </em>/<br>        heap_info *heap = heap_for_ptr(top(av));</p>
<pre><code>    assert(heap-&gt;ar_ptr == av);
    heap_trim(heap, mp_.top_pad);
  }
}

if (! have_lock) {
  assert (locked);
  __libc_lock_unlock (av-&gt;mutex);
}
</code></pre><p>  }<br>  /<em><br>    If the chunk was allocated via mmap, release via munmap().
  </em>/</p>
<p>  else {<br>    munmap_chunk (p);<br>  }<br>}<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这里重点看看<span class="selector-tag">unlink</span>()宏定义</div></pre></td></tr></table></figure></p>
<p>#define unlink( P, BK, FD ) {<br>    BK = P-&gt;bk;<br>    FD = P-&gt;fd;<br>    FD-&gt;bk = BK;  //可能会造成任意写<br>    BK-&gt;fd = FD;<br>}</p>
<p>```</p>
<p><a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#__libc_free" target="_blank" rel="external">glibc/malloc.c源码</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://phrack.org/issues/57/8.html#article" target="_blank" rel="external">Vudo malloc tricks</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/html/malloc.html" target="_blank" rel="external">A Memory Allocator</a></li>
<li><a href="http://phrack.org/issues/57/9.html#article" target="_blank" rel="external">Once upon a free()</a></li>
</ol>

        
      </div>
      <footer>
        
          
          
          <div class="share">
  

    
      <div class="bdsharebuttonbox"><a href="#" class="bds_twi" data-cmd="twi" title="Share to Twitter"></a><a href="#" class="bds_fbook" data-cmd="fbook" title="Share to Facebook"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="Share to Wechat"></a><a href="#" class="bds_mail" data-cmd="mail" title="分享到邮件分享"></a><a href="#" class="bds_copy" data-cmd="copy" title="分享到复制网址"></a><a href="#" class="bds_sqq" data-cmd="sqq" title="Share to QQ Friends"></a><a href="#" class="bds_linkedin" data-cmd="linkedin" title="Share to linkedin"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a></div>
	  <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","bdysc","tqq","bdxc","kaixin001","tqf","tieba","douban","tsohu","bdhome","sqq","thx","qq","ibaidu","taobao","hi","baidu","sohu","t163","qy","meilishuo","mogujie","diandian","huaban","leho","share189","duitang","hx","tfh","fx","youdao","sdo","qingbiji","ifeng","people","xinhua","ff","mail","kanshou","isohu","yaolan","wealink","xg","ty","iguba","fbook","twi","deli","s51","s139","linkedin","copy","print"],"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{},"image":{"viewList":["twi","fbook","tsina","weixin","mail","copy","sqq","linkedin","youdao","qzone","renren","douban"],"viewText":"Share to","viewSize":"24"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
    

    

    
  
</div>
          

        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>



<nav id="pagination" >
    
    
    <div class="clearfix"></div>
</nav>

<section id="comment">
  <h2 class="title">comment</h2>

  

  <!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:"datablog"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
  </script>
  <!-- 多说公共JS代码 end -->

  
</section>

</div></div>
    <aside id="sidebar" class="alignright"><div class="padding">
	
	  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" autocomplete="off" name="q" maxlength="20" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:github.com/NULL-ME/NULL-ME.github.io.git">
  </form>
</div>
	
	  
	
	  
<div class="widget recent-post">
  <h3 class="title">recent article</h3>
  <ul class="entry">
    
      <li>
        <a href="/2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/">Protostar-堆溢出学习-滥用堆metadata重定向程序执行</a>
      </li>
    
      <li>
        <a href="/2017/04/23/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/">深入理解Linux堆分配器-DLMalloc</a>
      </li>
    
      <li>
        <a href="/2017/04/21/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/">Protostar-堆溢出学习-UAF(use after free)</a>
      </li>
    
      <li>
        <a href="/2017/04/19/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/">Protostar-堆溢出学习-strcpy堆指针造成任意地址GOT表写</a>
      </li>
    
      <li>
        <a href="/2017/04/18/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/">Protostar-堆溢出学习-覆盖堆函数指针劫持代码流</a>
      </li>
    
  </ul>
</div>

	
	  
<div class="widget tagcloud">
  <h3 class="title">Tag-Cloud</h3>
  <div class="entry">
    <a href="../../tags/BSD/" style="font-size: 10px;">BSD</a> <a href="../../tags/C/" style="font-size: 10px;">C++</a> <a href="../../tags/Crackme/" style="font-size: 10px;">Crackme</a> <a href="../../tags/DLMalloc/" style="font-size: 10px;">DLMalloc</a> <a href="../../tags/GOT表/" style="font-size: 10px;">GOT表</a> <a href="../../tags/IPC/" style="font-size: 10px;">IPC</a> <a href="../../tags/Linux/" style="font-size: 20px;">Linux</a> <a href="../../tags/Protostar/" style="font-size: 20px;">Protostar</a> <a href="../../tags/UAF/" style="font-size: 10px;">UAF</a> <a href="../../tags/cve/" style="font-size: 10px;">cve</a> <a href="../../tags/dyld/" style="font-size: 10px;">dyld</a> <a href="../../tags/format/" style="font-size: 10px;">format</a> <a href="../../tags/free/" style="font-size: 10px;">free</a> <a href="../../tags/gdb/" style="font-size: 10px;">gdb</a> <a href="../../tags/heap/" style="font-size: 10px;">heap</a> <a href="../../tags/iOS/" style="font-size: 10px;">iOS</a> <a href="../../tags/linux/" style="font-size: 13.33px;">linux</a> <a href="../../tags/macOS内核/" style="font-size: 10px;">macOS内核</a> <a href="../../tags/mach/" style="font-size: 10px;">mach</a> <a href="../../tags/mach-o/" style="font-size: 10px;">mach-o</a> <a href="../../tags/macos内核/" style="font-size: 10px;">macos内核</a> <a href="../../tags/malloc/" style="font-size: 10px;">malloc</a> <a href="../../tags/metadata/" style="font-size: 10px;">metadata</a> <a href="../../tags/printf/" style="font-size: 10px;">printf</a> <a href="../../tags/strcpy/" style="font-size: 10px;">strcpy</a> <a href="../../tags/stub/" style="font-size: 10px;">stub</a> <a href="../../tags/vm/" style="font-size: 13.33px;">vm</a> <a href="../../tags/vtable/" style="font-size: 10px;">vtable</a> <a href="../../tags/xnu/" style="font-size: 10px;">xnu</a> <a href="../../tags/堆溢出/" style="font-size: 16.67px;">堆溢出</a> <a href="../../tags/栈溢出/" style="font-size: 16.67px;">栈溢出</a> <a href="../../tags/看雪/" style="font-size: 10px;">看雪</a> <a href="../../tags/调试/" style="font-size: 10px;">调试</a>
  </div>
</div>

	
	  <iframe width="100%" height="120" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=10&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=5594792135&verifier=676ff25e&dpc=1"></iframe>
	
	  <div class="widget category">
	<h3 class="title">Link</h3>
	<ul class="entry">
		
        	<li><a href="https://www.google.com/">Google</a></li>
      	
        	<li><a href="https://github.com/">Github</a></li>
      	
        	<li><a href="https://null-me.github.io/">4ch12dy</a></li>
      	
	</ul>
</div>
	
</div></aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="padding">
	<div class="alignleft">
	  
	  Copyright&copy;2013-2017 <a href=" / ">4chendy</a>
	  
	  | Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  and Theme by <a href="https://github.com/hijiangtao/dark-tech/" target="_blank">Dark-Tech</a> | <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000257487'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1000257487' type='text/javascript'%3E%3C/script%3E"));</script>
	</div>

	<div class="alignright">
		
		
			<a href="https://github.com/https://github.com/NULL-ME" target="_blank" title="4chendy Github"><i class="fa fa-github-square"></i></a>	
		
		
			<a href="https://twitter.com/https://twitter.com/4chendy" target="_blank" title="4chendy Twitter"><i class="fa fa-twitter-square"></i></a>	
		
		
			<a href="http://www.weibo.com/http://weibo.com/hijiangtao" target="_blank" title="4chendy Weibo"><i class="fa fa-weibo"></i></a>	
		
		
		
		
			<a href="/dark-tech/atom.xml" target="_blank" title="4chendy RSS"><i class="fa fa-rss-square"></i></a>
		
	</div>

	<div class="clearfix"></div>
</div>

<div class="scroll-top"><i class="fa fa-arrow-circle-up"></i></div>
</footer>
  

<script type="text/javascript">
var duoshuoQuery = {short_name:"datablog"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>



<script src="//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/3.0.4/jquery.imagesloaded.js"></script>
<script src="/js/gallery.js"></script>



<script type="text/javascript">
$(window).scroll(function() {

    if($(this).scrollTop() > 400) {
        $('.scroll-top').fadeIn(200);
    } else {
        $('.scroll-top').fadeOut(200);
    }
});

$('.scroll-top').bind('click', function(e) {
    e.preventDefault();
    $('body,html').animate({scrollTop:0},200);
});
</script>

</body>
</html>
