[{"title":"Mach-o动态链接","date":"2017-04-10T03:12:19.000Z","path":"2017/04/10/mach-o动态链接/mach-o动态链接/","text":"0x00 序可执行文件很少是独立的，除了极少数的一些静态链接的可执行文件以外，大多的都是动态链接，这就需要依赖一些预先存在的库，这些库可以是操作系统提供的动态共享库，也可以是第三方的库。所以在可执行文件中充满了大量对外部库的符号的引用，这些空洞就需要动态链接器来完成所谓的符号绑定。macOS中是内核执行LC_DYLINKER加载命令时启动的，通常为/usr/lib/dyld接管刚创建进程的控制权。本文就来分析其符号的动态链接过程。 0x01 符号的加载过程以下面这个简单的C语言程序为例。 12345void main(int argc, char *argv[]) &#123; printf(\"first printf\"); printf(\"second printf\");&#125; 对应的汇编代码 1234567891011121314151617-&gt; 0x100000f40 &lt;+0&gt;: pushq %rbp 0x100000f41 &lt;+1&gt;: movq %rsp, %rbp 0x100000f44 &lt;+4&gt;: subq $0x20, %rsp 0x100000f48 &lt;+8&gt;: leaq 0x4b(%rip), %rax ; \"first printf\" 0x100000f4f &lt;+15&gt;: movl %edi, -0x4(%rbp) 0x100000f52 &lt;+18&gt;: movq %rsi, -0x10(%rbp) 0x100000f56 &lt;+22&gt;: movq %rax, %rdi 0x100000f59 &lt;+25&gt;: movb $0x0, %al 0x100000f5b &lt;+27&gt;: callq 0x100000f7a ; symbol stub for: printf 0x100000f60 &lt;+32&gt;: leaq 0x40(%rip), %rdi ; \"second printf\" 0x100000f67 &lt;+39&gt;: movl %eax, -0x14(%rbp) 0x100000f6a &lt;+42&gt;: movb $0x0, %al 0x100000f6c &lt;+44&gt;: callq 0x100000f7a ; symbol stub for: printf 0x100000f71 &lt;+49&gt;: movl %eax, -0x18(%rbp) 0x100000f74 &lt;+52&gt;: addq $0x20, %rsp 0x100000f78 &lt;+56&gt;: popq %rbp 0x100000f79 &lt;+57&gt;: retq 和大多数的Linux系统一样，mach-o符号的动态绑定也采用了打桩机制，简单的说就是在遇到外部符号的时候就会先跳转到stub区 第一次printf会先进入dyld_stub_binder区去找到printf函数的地址，我们用lldb调试观察DATA段la_symbol_ptr区地址值 会发现正好地址在dyld_stub_binder区 验证: 第二次printf我们在观察DATA段la_symbol_ptr区地址值 我们会发现当第二次再次调用printf函数时，还是会先跳转到stub区，但此时la_symbol_ptr中的值却变为了printf的真实地址，而不是dyld_stub_binder。这样就完成了一次延时绑定，后面就直接调用。 0x02 stub桩机制总结综上分析，我们可以发现所有的外部函数引用都会在DATA段la_symbol_ptr区中产生一个占位符，其初始值为dyld_stub_binder区中对应的编号地址。当第一个调用时，就会进入符号的动态链接过程，一旦找到其地址后，就会将DATA段la_symbol_ptr区中的占位符改为找到后的地址。这样就完成了只需要一个符号绑定。 stub桩机制的巧妙之处也在此，首先当产生一个外部符号调用时，直接跳到对应的stub桩位置，然后由里面保存的地址来判断是第一次调用还是已经找到符号的地址。就像桩这个名字含义一样，一个占位符的思想。","tags":[{"name":"mach-o","slug":"mach-o","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/mach-o/"},{"name":"dyld","slug":"dyld","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/dyld/"},{"name":"stub","slug":"stub","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/stub/"}]},{"title":"gdb常用调试命令总结","date":"2017-03-21T03:06:59.000Z","path":"2017/03/21/gdb常用调试命令总结/gdb/","text":"0x01 序最近在做TCTF上一道Linux下的逆向题，对GDB的调试很多命令相关做一个小总结，可能不是很系统，只是记一些比较常用的，后面可能会不定期更新。 0x02 命令行参数有时候，我们需要调试的程序需要有命令行参数，很多朋友都不知道怎么设置调试的程序的命令行参数。其实，有两种方法： gdb命令行的 –args 参数 gdb环境中 set args命令 show args查看程序参数 0x03 多线程调试多线程调试可能是问得最多的。其实，重要就是下面几个命令： info thread 查看当前进程的线程。thread 切换调试的线程为指定ID的线程。break file.c:100 thread all 在file.c文件第100行处为所有经过这里的线程设置断点。set scheduler-locking off|on|step，这个是问得最多的。在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。 off 不锁定任何线程，也就是所有线程都执行，这是默认值。 on 只有当前被调试程序会执行。 step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。 0x04 断点 break *0x000000 下断点 info breakpoints 查看断点 delete break 1 删除断点 break [where] if [condition] 条件断点 enable 恢复失效的断点 disable 使断点失效 clear 清除断点 break 21 在第21行设置断点 break main 在main函数处设置断点 break test 在函数test处设置断点 0x05 x命令也许，你很喜欢用p命令。所以，当你不知道变量名的时候，你可能会手足无措，因为p命令总是需要一个变量名的。x命令是用来查看内存的，在gdb中 “help x” 你可以查看其帮助。 x/x 以十六进制输出 x/d 以十进制输出 x/c 以单字符输出 x/i 反汇编 – 通常，我们会使用 x/10i $ip-20 来查看当前的汇编（$ip是指令寄存器） x/s 以字符串输出 x/5i $pc 查看汇编代码 x/4wx 0x000000 查看内存 0x06 command命令有一些朋友问我如何自动化调试。这里向大家介绍command命令，简单的理解一下，其就是把一组gdb的命令打包，有点像字处理软件的“宏”。下面是一个示例：12345678910(gdb) break funcBreakpoint 1 at 0x3475678: file test.c, line 12.(gdb) command 1Type commands for when breakpoint 1 is hit, one per line.End with a line saying just \"end\".&gt;print arg1&gt;print arg2&gt;print arg3&gt;end(gdb) 当我们的断点到达时，自动执行command中的三个命令，把func的三个参数值打出来。 0x07 其他 step / s 下一步，直接执行下一条程序 continue / cont 下一段，如果遇到函数，不会进入函数，逐过程，有点类似VS里面的F10 run 运行 finish 结束调试 print / p 显示某个变量的值 p *array@len 输出数组 p i 输出i的值 0x08 附表寄存器宽度表12345|63..32|31..16|15-8|7-0| |AH.|AL.| |AX.....| |EAX............||RAX...................|","tags":[{"name":"gdb","slug":"gdb","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/gdb/"},{"name":"linux","slug":"linux","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/linux/"},{"name":"调试","slug":"调试","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/调试/"}]},{"title":"详解virtual table","date":"2017-03-06T17:51:44.000Z","path":"2017/03/07/C++ Virtual table/详解virtual table/","text":"详解virtual tableC++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。 关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家 一个清晰的剖析。 当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。 言归正传，让我们一起进入虚函数的世界。 虚函数表 对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。 在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了 这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。 这里我们着重看一下这张虚函数表。在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。 听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。 假设我们有这样的一个类： 1234567891011class Base &#123;public:virtual void f() &#123; cout &lt;&lt; \"Base::f\" &lt;&lt; endl; &#125;virtual void g() &#123; cout &lt;&lt; \"Base::g\" &lt;&lt; endl; &#125;virtual void h() &#123; cout &lt;&lt; \"Base::h\" &lt;&lt; endl; &#125;&#125;; 按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程： 123456789101112131415typedef void(*Fun)(void);Base b;Fun pFun = NULL;cout &lt;&lt; \"虚函数表地址：\" &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;cout &lt;&lt; \"虚函数表 — 第一个函数地址：\" &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl;// Invoke the first virtual functionpFun = (Fun)*((int*)*(int*)(&amp;b));pFun(); 实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3) 虚函数表地址：0012FED4 虚函数表 — 第一个函数地址：0044F148 Base::f 通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下： 12345(Fun)*((int*)*(int*)(&amp;b)+0); // Base::f()(Fun)*((int*)*(int*)(&amp;b)+1); // Base::g()(Fun)*((int*)*(int*)(&amp;b)+2); // Base::h() 这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示： 注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“\\0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。 下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。 一般继承（无虚函数覆盖）下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系： 请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：对于实例：Derive d; 的虚函数表如下：我们可以看到下面几点： 虚函数按照其声明顺序放于表中。 父类的虚函数在子类的虚函数前面。我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。 一般继承（有虚函数覆盖）覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。 为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子： 我们从表中可以看到下面几点， 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 没有被覆盖的函数依旧。这样，我们就可以看到对于下面这样的程序， 123Base *b = new Derive();b-&gt;f(); 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 多重继承（无虚函数覆盖）下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。 对于子类实例中的虚函数表，是下面这个样子： 我们可以看到： 每个父类都有自己的虚表。 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的） 这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。 多重继承（有虚函数覆盖） 下面我们再来看看，如果发生虚函数覆盖的情况。 下图中，我们在子类中覆盖了父类的f()函数。 下面是对于子类实例中的虚函数表的图： 我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如： 12345678910111213141516171819Derive d;Base1 *b1 = &amp;d;Base2 *b2 = &amp;d;Base3 *b3 = &amp;d;b1-&gt;f(); //Derive::f()b2-&gt;f(); //Derive::f()b3-&gt;f(); //Derive::f()b1-&gt;g(); //Base1::g()b2-&gt;g(); //Base2::g()b3-&gt;g(); //Base3::g() 安全性每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。 一、通过父类型的指针访问子类自己的虚函数我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数： 123Base1 *b1 = new Derive();b1-&gt;f1(); //编译出错 任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点） 二、访问non-public的虚函数另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。 如： 1234567891011121314151617181920212223class Base &#123;private:virtual void f() &#123; cout &lt;&lt; \"Base::f\" &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;&#125;;typedef void(*Fun)(void);void main() &#123;Derive d;Fun pFun = (Fun)*((int*)*(int*)(&amp;d)+0);pFun();&#125; 结束语C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。 文章转载：http://www.cppblog.com/dawnbreak/archive/2009/03/10/76084.aspx","tags":[{"name":"C++","slug":"C","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/C/"},{"name":"vtable","slug":"vtable","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/vtable/"}]},{"title":"cve-2016-1757","date":"2017-03-05T03:12:19.000Z","path":"2017/03/05/CVE-2016-1757/cve-2016-1757/","text":"","tags":[{"name":"cve","slug":"cve","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/cve/"},{"name":"IPC","slug":"IPC","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/IPC/"},{"name":"vm","slug":"vm","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/vm/"}]},{"title":"Mach vm*API","date":"2017-03-04T17:51:44.000Z","path":"2017/03/05/Mach vm*API/exec函数流程/","text":"exec函数流程 mach_vm_* mach_vm_cllocate 1mach_vm_allocate(vm_map_t map,mach_vm_address_t *address,mach_vm_size_t size,int flags); 在map中分配size个字节大小的内存，根据flags的不同会有不同的处理方式。address是一个I/O的参数（例如：获取分配后的内存大小）。如果flags的值不是VM_FLAGS_ANYWHERE，那么内存将被分配到address指向的地址。 mach_vm_region123456789kern_return_tmach_vm_region( vm_map_t map, mach_vm_offset_t *address, /* IN/OUT */ mach_vm_size_t *size, /* OUT */ vm_region_flavor_t flavor, /* IN */ vm_region_info_t info, /* OUT */ mach_msg_type_number_t *count, /* IN/OUT */ mach_port_t *object_name) /* OUT */ 获取map指向的任务内，address地址起始的VM region（虚拟内存区域）的信息。目前标记为flavor只有VM_BASIC_INFO_64。获得的info的数据结构如下。12345678910struct vm_region_basic_info_64 &#123; vm_prot_t protection; vm_prot_t max_protection; vm_inherit_t inheritance; boolean_t shared; boolean_t reserved; memory_object_offset_t offset; vm_behavior_t behavior; unsigned short user_wired_count;&#125;; mach_vm_protect1234567kern_return_tmach_vm_protect( mach_port_name_t task, mach_vm_address_t address, mach_vm_size_t size, boolean_t set_maximum, vm_prot_t new_protection) 对address到address+size这一段的内存设置内存保护策略,new_protection就是最后设置成为的保护机制。 mach_vm_write123456kern_return_tmach_vm_write( vm_map_t map, mach_vm_address_t address, pointer_t data, __unused mach_msg_type_number_t size) 对address指向的内存改写内容。 mach_vm_read1234567kern_return_t mach_vm_read( vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, vm_offset_t *data, mach_msg_type_number_t *dataCnt); 对address指向的内存读取内容. mach_port_* mach_port_allocate12345kern_return_t mach_port_allocate( ipc_space_t task, mach_port_right_t right, mach_port_name_t *name); task指要分配端口的任务(mach_task_self())，right指分配给该端口的权限，name指代分配端口名的地址Ports有如下权限，Ports可以在不同的task之间传递，通过传递可以赋予其他task对ports的操作权限。例如POC中使用的就是在父进程与子进程之间传递Port得到了对内存操作的权限。 1234567#define MACH_PORT_RIGHT_SEND ((mach_port_right_t) 0)#define MACH_PORT_RIGHT_RECEIVE ((mach_port_right_t) 1)#define MACH_PORT_RIGHT_SEND_ONCE ((mach_port_right_t) 2)#define MACH_PORT_RIGHT_PORT_SET ((mach_port_right_t) 3)#define MACH_PORT_RIGHT_DEAD_NAME ((mach_port_right_t) 4)#define MACH_PORT_RIGHT_LABELH ((mach_port_right_t) 5)#define MACH_PORT_RIGHT_NUMBER ((mach_port_right_t) 6) mach_port_insert_right123456kern_return_t mach_port_insert_right( ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly); 参考 http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/ https://developer.apple.com","tags":[{"name":"vm","slug":"vm","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/vm/"},{"name":"macOS内核","slug":"macOS内核","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/macOS内核/"},{"name":"mach","slug":"mach","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/mach/"}]},{"title":"macOS内核知识点整理","date":"2016-12-05T16:34:52.000Z","path":"2016/12/06/macOS内核框架/macOS内核架构-功能/","text":"Darwin结构 沙盒结构 XNU源码树 目录 包含的内容 bsd 内核的BSD组件 config 各种框架的导出符号 iokit I/OKit驱动程序运行时子系统 libkern 内核主运行时库API osfmk 内核的Mach组件 pexpert 平台相关的服务（PPC,i386） security BSD MAC框架 BSD子目录 子目录 包含的内容 bsm/security Basic Security Module(审计子系统) conf 机器相关的Makefile crypto 对称加密算法和散列算法的实现 dev BSD设备（/dev目录项） hfs macOS默认文件系统（HFS/HFS+） i386/machine Intel/PPC架构的私有头文件 kern 内核的主要代码 libkern 内核运行时导出的库（CRC,字符串函数等） man 一些有用的man手册 net*/netinet 网络子系统（套接字）和IP协议栈 nfs 用于远程文件系统的NFSv3协议栈 sys 内核头文件 vfs 虚拟文件系统交换（Virtual Filesystem Switch） vm BSD的虚拟内存处理程序 osfmk子目录 子目录 包含的内容 chud Computer Hardware Understanding Development(为macOS诊断工具提供内核支持) conf 机器相关的Makefile console 控制台初始化,串口,引导视频和内核崩溃 ddb 内核调试器（已弃用） default_pager VM分页器 device Mach对I/OKit和设备的支持 i386/ppc/x86_64 CPU特定的实现 ipc IPC,port和消息 kdp KDP(调试器)支持 mach,machine Mach通用头文件和机器相关的内核头文件 man 唯一涉及到Mach调用的man手册 pmc/profiling PMC性能检测 UserNotification 内核到用户态的通知 vm 虚拟内存的实现和头文件 the xnu Kernal of following component Mach servers layer BSD primary systerm programming interface provide The I/OKit runtime environment for drivers libkernal in* kernel library libsaan in* kernel library that is normally used only during early systerm startup the platform expert hardware abstraction module kernel extension various I/OKit family,the majority of loadable device drivers,and some non* I/O Kit extention MachIf the xnu kernel is the core of Mac OS X, then Mach may be considered the core of xnu. hardware abstraction to some extent processor management including symmetric mutiprocessing * and scheduling Preemptive multitasking, including support for tasks and threads Virtual memory management, including low-level paging, memory protection, sharing, and inheritance$Low-level IPC mechanisms that are the basis for all messaging in the kernel Real-time support that allows time-sensitive applications (e.g., media applications such asGarageBand and iTunes) to have latency-bounded access to processor resources Kernel debugging support Console I/O BSD BSD-style process model Signals User IDs, permissions, and basic security policies POSIX APIs Asynchronous I/O APIs (AIO) BSD-style system calls TCP/IP stack, BSD sockets, and firewalling Network Kernel Extensions (NKEs), a type of kernel extension for making the BSD networking architecture fit into xnu[11] The virtual file system (VFS) layer and numerous file systems, including a file-system-independent VFS-level journaling mechanism System V and POSIX interprocess communication mechanisms In-kernel cryptographic framework A system notification mechanism based on FreeBSD’s kqueue/kevent mechanism, which is a system-wide service enabling notifications between applications, and from the kernel to applications The fsevents file system change notification mechanism that is used by the Spotlight search technology Access control lists (ACLs) and the kauth authorization framework Various synchronization primitives The I/O Kit Extensive programming interfaces, including interfaces for applications and user* space drivers to communicate with the I/O Kit Numerous device families such as ATA/ATAPI, FireWire, Graphics, HID, Network, PCI, and USB Object* oriented abstractions of devices Plug-and-play and dynamic device management (“hot-plugging”) Power management Preemptive multitasking, threading, symmetric multiprocessing, memory protection, and data management Dynamic matching and loading of drivers for multiple bus types A database for tracking and maintaining detailed information on instantiated objects (the I/O Registry) A database of all I/O Kit classes available on a system (the I/O Catalog)Interfaces for applications and user-space drivers to communicate with the I/O Kit Driver stacking The libkern Library Dynamic allocation, construction, and destruction objects, with support for a variety of built-in object types such as Arrays, Booleans, and Dictionaries Atomic operations and miscellaneous functions such as bcmp(), memcmp(), and strlen() Functions for byte-swapping Provisions for tracking the number of current instances for each class Mechanisms that help alleviate the C++ fragile base-class problem The libsa Librarylibsa is an in-kernel support library essentially an in* kernel linkerused during early system startup for loading kernel extensions,sa=stand-alone,Mac OS X kernel extensions are normally loaded on demand through the kexTD user-space daemon (/usr/libexec/kextd). During early stages of bootstrapping, kextd is not yet available. libsa provides a subset of kextd’s capabilities to the kernel. Examples of specific functionality implemented by libsa for loading, linking, and recording kernel extension object files include the following: Simple memory allocation Binary searching Sorting Miscellaneous string* handling functions  Symbol remangling A dependency graph package used while determining kernel extension dependencies Decompression of compressed kernels and verification of checksums The Platform ExpertNubs[In the context of the I/O Kit, a nub is an object that defines an access point and communication channel for a physical device or a logical service. A physical device could be a bus, a disk drive or partition, a graphics card, and so on. Examples of logical services include arbitration, driver matching, and power management.] Constructing device trees Parsing certain boot arguments Identifying the machine, which includes determining processor and bus clock speeds  Accessing power management information Retrieving and setting system time Retrieving and setting console information Halting and restarting the machine Accessing the interrupt controller Creating the system serial number string Saving kernel panic information Initializing a “user interface” to be used in case of kernel panics Reading and writing the nonvolatile memory (NVRAM) Reading and writing the parameter memory (PRAM) task and thread任务是一个包含一个或多个可执行线程的任务组，这些线程共享资源和内存空间。Mach的任务是将一对一映射到Unix BSD层的进程。XNU内核也是一个包含多个线程的任务。","tags":[{"name":"xnu","slug":"xnu","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/xnu/"},{"name":"macos内核","slug":"macos内核","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/macos内核/"},{"name":"BSD","slug":"BSD","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/BSD/"}]},{"title":"看雪iOSCrackme破解报告","date":"2016-08-04T17:51:44.000Z","path":"2016/08/05/iOSCrackme/iOSCrackme/","text":"看雪iOSCrackme破解报告0x01.首先，利用classdump把crackme的头文件导出来，可以看到头文件只有6个，根据屏幕上的check按钮，很容易在控制器中找到如下函数 0x02.然后将可执行文件拉入IDA分析，直接跳到check这个函数。可以猜测这个函数应该就是加密函数。下面重点对这个函数进行详细分析。 0x03.在分析之前，先在手机屏幕上直接点击check，无反应。然后输入一定字符后再点击check，仍然没有反应。没有一点的错误提示，看来只能一步一步看汇编了。在IDA中先大概看下流程图的结构，拉到最底下，发现貌似成功的界面 不管怎样，先试试直接跳转到该地址，看能不能弹出成功的界面？: / 修改为B 0x0000C1AC 然后再屏幕上点击check，成功弹出welcome to kanxue的界面！再接再厉,看看中间都经历了什么步骤。 0x04.下面进入汇编，第一阶段，根据strlen函数很容易知道，这是在对用户输入的字符串进行长度判断，若不满足情况，直接跳到失败代码。name为14位，serialnumber为8位 既然是逆向工程，所以先分析下在弹出这个界面前的代码都在做写些什么,r11为我们输入的serialnumber然后可以发现如果栈中的值和serialnumber8次匹配成功就会弹出成功的界面。 0x05.一段插曲，不知道是程序自身的原因还是手机的问题，在一步步向下调试的时候，发现内存非法访问，为什么会出现这个问题呢？向上找的时候，发现这样一条指令MOV PC, PC按理说，根据arm处理器流水线的处理机制，PC会指向当前的下面两条指令，所以执行这条语句后应该会跳到VDUP.8 Q9, R1指令. 但是实际情况却是把拆成四条指令，并把r0的值变为了0，导致r2变化，从而非法访问了r2地址的内存。 所以为了让r0的值不改变,之前都是通过每次动态修register write $r0的值，导致每次调试都要在那两处下个断点，浪费了很多时间。后来直接把静态修改重新打包安装到手机，lsls r0 r0改为nop代替，同理下面还有一处，作相应的修改。 0x06.回到我们之前的分析，现在开始加密阶段，首先进入的是下面的一个循环 r0的值为栈中的某个地址，d18-d19的值为00-0f，然后循环了16次，每次都对d18-d19加一，所以循环结束后在栈中生成了一个16*16大小的矩阵，且值为00-ff. 0x07.接着往下面分析，又是一个循环。循环了256次，可以猜测应该是对上面的矩阵进行变换，分析可以发现这个循环通过r9(0xaaaaaaab)和r1相乘结果来对矩阵中的值进行交换。 在循环的结束的下一条地址下个断点，打印对应的内存，验证了我们的猜想。 我们之前的分析中好像还没有和我们输入的name和serialnumber有什么联系。接着分析，这个循环终于对name进行了存取操作，通过四次循环把name的前四位取出来与之前的矩阵加密后又放回到name的前四位。 内存图： 下面这一段有点繁琐，各种跳转，但是并不复杂，就是通过判断加密后的name的长度然后复制到栈中地址r8处。 接着又是一个循环，分析可知是对r8即刚才复制加密name后的内存进行每四位反序变换。 内存图： keep going！这一段不是很复杂，就是把刚才变换后的首地址r8向下的64个字节复制到内存栈中[sp 0x50]处。后来得知从这个地址到r8后的内存就是整个栈变化的结束，后面的四个循环并没有进行栈的存操作，只是将这块内存的值取出来加密。 内存图： 下面的四个循环很相似，都是将那块内存每次提取80个字节进行加密。刚好有80*4=320与内存块的字节数相同。 然后将这之后的寄存器值与对应的值相加spintf按%08x%08x%08x%08x%08x的格式写入栈。 最后对栈进行了5次存储，与后面分析可知这段内存就会与serialnumber进行匹配。 0x07.根据上面的步骤写出代码，注册机为一个命令行程序，运行程序会提示如数14位的字母和数字的字符串，然后根据此就会生成对应的serialnumber。效果图如下： 在手机中输入生成的name和serialnumber弹出成功的界面！","tags":[{"name":"Crackme","slug":"Crackme","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Crackme/"},{"name":"看雪","slug":"看雪","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/看雪/"},{"name":"iOS","slug":"iOS","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/iOS/"}]}]