[{"title":"macOS内核架构&功能知识点整理","date":"2016-12-05T16:34:52.000Z","path":"2016/12/06/macOS内核架构-功能/macOS内核架构-功能/","text":"xnu源码macOS内核架构&amp;功能知识点整理 XNU源码树 目录 包含的内容 bsd 内核的BSD组件 config 各种框架的导出符号 iokit I/OKit驱动程序运行时子系统 libkern 内核主运行时库API osfmk 内核的Mach组件 pexpert 平台相关的服务（PPC,i386） security BSD MAC框架 BSD子目录 子目录 包含的内容 bsm/security Basic Security Module(审计子系统) conf 机器相关的Makefile crypto 对称加密算法和散列算法的实现 dev BSD设备（/dev目录项） hfs macOS默认文件系统（HFS/HFS+） i386/machine Intel/PPC架构的私有头文件 kern 内核的主要代码 libkern 内核运行时导出的库（CRC,字符串函数等） man 一些有用的man手册 net*/netinet 网络子系统（套接字）和IP协议栈 nfs 用于远程文件系统的NFSv3协议栈 sys 内核头文件 vfs 虚拟文件系统交换（Virtual Filesystem Switch） vm BSD的虚拟内存处理程序 osfmk子目录 子目录 包含的内容 chud Computer Hardware Understanding Development(为macOS诊断工具提供内核支持) conf 机器相关的Makefile console 控制台初始化,串口,引导视频和内核崩溃 ddb 内核调试器（已弃用） default_pager VM分页器 device Mach对I/OKit和设备的支持 i386/ppc/x86_64 CPU特定的实现 ipc IPC,port和消息 kdp KDP(调试器)支持 mach,machine Mach通用头文件和机器相关的内核头文件 man 唯一涉及到Mach调用的man手册 pmc/profiling PMC性能检测 UserNotification 内核到用户态的通知 vm 虚拟内存的实现和头文件 the xnu Kernal of following component Mach servers layer BSD primary systerm programming interface provide The I/OKit runtime environment for drivers libkernal in* kernel library libsaan in* kernel library that is normally used only during early systerm startup the platform expert hardware abstraction module kernel extension various I/OKit family,the majority of loadable device drivers,and some non* I/O Kit extention MachIf the xnu kernel is the core of Mac OS X, then Mach may be considered the core of xnu. hardware abstraction to some extent processor management including symmetric mutiprocessing * and scheduling Preemptive multitasking, including support for tasks and threads Virtual memory management, including low-level paging, memory protection, sharing, and inheritance$Low-level IPC mechanisms that are the basis for all messaging in the kernel Real-time support that allows time-sensitive applications (e.g., media applications such asGarageBand and iTunes) to have latency-bounded access to processor resources Kernel debugging support Console I/O BSD BSD-style process model Signals User IDs, permissions, and basic security policies POSIX APIs Asynchronous I/O APIs (AIO) BSD-style system calls TCP/IP stack, BSD sockets, and firewalling Network Kernel Extensions (NKEs), a type of kernel extension for making the BSD networking architecture fit into xnu[11] The virtual file system (VFS) layer and numerous file systems, including a file-system-independent VFS-level journaling mechanism System V and POSIX interprocess communication mechanisms In-kernel cryptographic framework A system notification mechanism based on FreeBSD’s kqueue/kevent mechanism, which is a system-wide service enabling notifications between applications, and from the kernel to applications The fsevents file system change notification mechanism that is used by the Spotlight search technology Access control lists (ACLs) and the kauth authorization framework Various synchronization primitives The I/O Kit Extensive programming interfaces, including interfaces for applications and user* space drivers to communicate with the I/O Kit Numerous device families such as ATA/ATAPI, FireWire, Graphics, HID, Network, PCI, and USB Object* oriented abstractions of devices Plug-and-play and dynamic device management (“hot-plugging”) Power management Preemptive multitasking, threading, symmetric multiprocessing, memory protection, and data management Dynamic matching and loading of drivers for multiple bus types A database for tracking and maintaining detailed information on instantiated objects (the I/O Registry) A database of all I/O Kit classes available on a system (the I/O Catalog)Interfaces for applications and user-space drivers to communicate with the I/O Kit Driver stacking The libkern Library Dynamic allocation, construction, and destruction objects, with support for a variety of built-in object types such as Arrays, Booleans, and Dictionaries Atomic operations and miscellaneous functions such as bcmp(), memcmp(), and strlen() Functions for byte-swapping Provisions for tracking the number of current instances for each class Mechanisms that help alleviate the C++ fragile base-class problem The libsa Librarylibsa is an in-kernel support library essentially an in* kernel linkerused during early system startup for loading kernel extensions,sa=stand-alone,Mac OS X kernel extensions are normally loaded on demand through the kexTD user-space daemon (/usr/libexec/kextd). During early stages of bootstrapping, kextd is not yet available. libsa provides a subset of kextd’s capabilities to the kernel. Examples of specific functionality implemented by libsa for loading, linking, and recording kernel extension object files include the following: Simple memory allocation Binary searching Sorting Miscellaneous string* handling functions  Symbol remangling A dependency graph package used while determining kernel extension dependencies Decompression of compressed kernels and verification of checksums The Platform ExpertNubs[In the context of the I/O Kit, a nub is an object that defines an access point and communication channel for a physical device or a logical service. A physical device could be a bus, a disk drive or partition, a graphics card, and so on. Examples of logical services include arbitration, driver matching, and power management.] Constructing device trees Parsing certain boot arguments Identifying the machine, which includes determining processor and bus clock speeds  Accessing power management information Retrieving and setting system time Retrieving and setting console information Halting and restarting the machine Accessing the interrupt controller Creating the system serial number string Saving kernel panic information Initializing a “user interface” to be used in case of kernel panics Reading and writing the nonvolatile memory (NVRAM) Reading and writing the parameter memory (PRAM) task and thread任务是一个包含一个或多个可执行线程的任务组，这些线程共享资源和内存空间。Mach的任务是将一对一映射到Unix BSD层的进程。XNU内核也是一个包含多个线程的任务。","tags":[{"name":"xnu","slug":"xnu","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/xnu/"},{"name":"macos内核","slug":"macos内核","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/macos内核/"},{"name":"BSD","slug":"BSD","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/BSD/"}]},{"title":"看雪iOSCrackme破解报告","date":"2016-08-04T17:51:44.000Z","path":"2016/08/05/iOSCrackme/iOSCrackme/","text":"看雪iOSCrackme破解报告0x01.首先，利用classdump把crackme的头文件导出来，可以看到头文件只有6个，根据屏幕上的check按钮，很容易在控制器中找到如下函数 0x02.然后将可执行文件拉入IDA分析，直接跳到check这个函数。可以猜测这个函数应该就是加密函数。下面重点对这个函数进行详细分析。 0x03.在分析之前，先在手机屏幕上直接点击check，无反应。然后输入一定字符后再点击check，仍然没有反应。没有一点的错误提示，看来只能一步一步看汇编了。在IDA中先大概看下流程图的结构，拉到最底下，发现貌似成功的界面 不管怎样，先试试直接跳转到该地址，看能不能弹出成功的界面？: / 修改为B 0x0000C1AC 然后再屏幕上点击check，成功弹出welcome to kanxue的界面！再接再厉,看看中间都经历了什么步骤。 0x04.下面进入汇编，第一阶段，根据strlen函数很容易知道，这是在对用户输入的字符串进行长度判断，若不满足情况，直接跳到失败代码。name为14位，serialnumber为8位 既然是逆向工程，所以先分析下在弹出这个界面前的代码都在做写些什么,r11为我们输入的serialnumber然后可以发现如果栈中的值和serialnumber8次匹配成功就会弹出成功的界面。 0x05.一段插曲，不知道是程序自身的原因还是手机的问题，在一步步向下调试的时候，发现内存非法访问，为什么会出现这个问题呢？向上找的时候，发现这样一条指令MOV PC, PC按理说，根据arm处理器流水线的处理机制，PC会指向当前的下面两条指令，所以执行这条语句后应该会跳到VDUP.8 Q9, R1指令. 但是实际情况却是把拆成四条指令，并把r0的值变为了0，导致r2变化，从而非法访问了r2地址的内存。 所以为了让r0的值不改变,之前都是通过每次动态修register write $r0的值，导致每次调试都要在那两处下个断点，浪费了很多时间。后来直接把静态修改重新打包安装到手机，lsls r0 r0改为nop代替，同理下面还有一处，作相应的修改。 0x06.回到我们之前的分析，现在开始加密阶段，首先进入的是下面的一个循环 r0的值为栈中的某个地址，d18-d19的值为00-0f，然后循环了16次，每次都对d18-d19加一，所以循环结束后在栈中生成了一个16*16大小的矩阵，且值为00-ff. 0x07.接着往下面分析，又是一个循环。循环了256次，可以猜测应该是对上面的矩阵进行变换，分析可以发现这个循环通过r9(0xaaaaaaab)和r1相乘结果来对矩阵中的值进行交换。 在循环的结束的下一条地址下个断点，打印对应的内存，验证了我们的猜想。 我们之前的分析中好像还没有和我们输入的name和serialnumber有什么联系。接着分析，这个循环终于对name进行了存取操作，通过四次循环把name的前四位取出来与之前的矩阵加密后又放回到name的前四位。 内存图： 下面这一段有点繁琐，各种跳转，但是并不复杂，就是通过判断加密后的name的长度然后复制到栈中地址r8处。 接着又是一个循环，分析可知是对r8即刚才复制加密name后的内存进行每四位反序变换。 内存图： keep going！这一段不是很复杂，就是把刚才变换后的首地址r8向下的64个字节复制到内存栈中[sp 0x50]处。后来得知从这个地址到r8后的内存就是整个栈变化的结束，后面的四个循环并没有进行栈的存操作，只是将这块内存的值取出来加密。 内存图： 下面的四个循环很相似，都是将那块内存每次提取80个字节进行加密。刚好有80*4=320与内存块的字节数相同。 然后将这之后的寄存器值与对应的值相加spintf按%08x%08x%08x%08x%08x的格式写入栈。 最后对栈进行了5次存储，与后面分析可知这段内存就会与serialnumber进行匹配。 0x07.根据上面的步骤写出代码，注册机为一个命令行程序，运行程序会提示如数14位的字母和数字的字符串，然后根据此就会生成对应的serialnumber。效果图如下： 在手机中输入生成的name和serialnumber弹出成功的界面！","tags":[{"name":"Crackme","slug":"Crackme","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/Crackme/"},{"name":"看雪","slug":"看雪","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/看雪/"},{"name":"iOS","slug":"iOS","permalink":"https://github.com/NULL-ME/NULL-ME.github.io.git/tags/iOS/"}]}]