<!DOCTYPE HTML>

    <html lang="zh-Hans">
  
<head>
  <meta charset="utf-8">
  
  <title>4chendy</title>
  <meta name="author" content="4chendy">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="4chendy"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <meta http-equiv="Content-Language" content="zh-Hans"/>
  

  <link href="/img/favicon.png" rel="icon">
  
    <link rel="apple-touch-icon" href="/img/apple-icon.ico">
    <link rel="apple-touch-icon-precomposed" href="/img/apple-icon.ico">
    

  <link rel="alternate" href="/dark-tech/atom.xml" title="4chendy" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  
  <!-- Chinese readability improment -->
  <style type="text/css">
    article {font-weight: 400;letter-spacing: .01rem;}
    article .entry{line-height:2;}
  </style>
  
  
  <style type="text/css">
  /* Tim Pietrusky advanced checkbox hack (Android <= 4.1.2) */
body{ -webkit-animation: bugfix infinite 1s; }
@-webkit-keyframes bugfix { from {padding:0;} to {padding:0;} }
</style>

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48887175-1', 'auto');
  ga('send', 'pageview');

</script>



  
    <!-- 360 Font and Baidu CDN in China -->
    
      <link href='http://fonts.useso.com/css?family=Open+Sans:300,400|Playball' rel='stylesheet' type='text/css'>
    
  <link href='http://apps.bdimg.com/libs/fontawesome/4.1.0/css/font-awesome.css' rel='stylesheet' type='text/css'>
  <script src="http://libs.baidu.com/jquery/1.11.1/jquery.min.js"></script>
  



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>


<body>
  <header id="header" class="inner"><div class="padding">
	<div class="alignleft logo">
	  <h1><a href="/">4chendy</a></h1>
	</div>
	<nav id="main-nav" class="alignright">
		<input type="checkbox" id="toggle" />
		<label for="toggle" class="toggle" data-open="Main Menu" data-close="Close Menu" onclick><i class="fa fa-bars"></i></label>
	  <ul class="menu">
	    
	      <li><a href="/">Home</a></li>
	    
	      <li><a href="/archives">Archives</a></li>
	    
	      <li><a href="/about">About</a></li>
	    
	      <li><a href="/fuckshit">f**kshit</a></li>
	    
	    
	    	<li><a href="/dark-tech/atom.xml" target="_blank" title="bruce tan blog rss" class="rss-top"><i class="fa fa-rss"></i></a></li>
	    
	  </ul>
	</nav>
	<div class="clearfix"></div>
</div>
</header>
  <div id="page-heading-wrap">
  	<div class="inner">
      <div class="padding">
    		
          <h2></h2>
        
      </div>
  	</div>
  </div>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper" class="padding">
  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/">Protostar-堆溢出学习-滥用堆metadata重定向程序执行</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-04-26T13:24:19.000Z">2017-04-26</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/" target="_blank">4chendy</a>

                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            0x00 序
 学习最后一个堆溢出漏洞，在这之前，强烈建议先阅读下我之前对linux堆管理DLMalloc的分析这是一个滥用堆metadata导致free()函数造成任意地址写的一个漏洞利用。下面一步一步的分析

0x01 C语言源代码1234567891011121314151617181920212223242526272829#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;void winner()&amp;#123;  printf(&quot;that wasn&#39;t too bad now, was it? @ %d\n&quot;, time(NULL));&amp;#125;int main(int argc, char **argv)&amp;#123;  char *a, *b, *c;  a = malloc(32);  b = malloc(32);  c = malloc(32);  strcpy(a, argv[1]);  strcpy(b, argv[2]);  strcpy(c, argv[3]);  free(c);  free(b);  free(a);  printf(&quot;dynamite failed?\n&quot;);&amp;#125;
0x02 简单分析&amp;amp;思考在这个程序中虽然我们知道有堆溢出的问题，可是堆上并没有什么逻辑上的漏洞，没有可利用的指针？没有UAF漏洞？那怎么才能执行到winner()函数呢？似乎是不可能的事。但通过之前对linux堆管理的分析，可知free()函数中的unlink()函数能够造成一个任意地址写的可能，再像之前那样来修改GOT表，不就是可以执行winner
          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/04/23/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/">深入理解Linux堆分配器-DLMalloc</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-04-23T04:16:00.000Z">2017-04-23</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/" target="_blank">4chendy</a>

                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/04/23/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/04/23/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            0x00 序
 当学习漏洞利用到一定阶段的时候，就需要对操作系统层面有足够的认识。无疑Linux的堆管理一直是不能甚解。因此这篇文章将对Linux的DLMalloc进行详细的介绍，以此对操作系统的堆管理有一个清晰整体的认识，当我在学习的过程中，好像没有发现一篇中文文章来详细介绍相关内容，所以本文仅仅是我通过学习和实践得到的理解，若有不对，请指出。

0x01 目录1.DLMalloc2.内存Chunk3.Bin4.malloc源码free()函数分析
0x02 DLMallocDoug Lea’s Malloc (dlmalloc)是一个GNU C库的内存分配器，它能够通过calloc(),malloc(), free()和realloc()等动态分配和释放的函数来管理内存。明显内存分配器在操作系统中是相当重要的，主要在需要满足下列的特点：

稳定性(stability)
性能(performance)
避免碎片化(avoidance of fragmentation)
低空间开销(low space overhead）根据上面的内存特点，将有助于后面对chunk以及Bin等的理解。

0x03 内存chunk1.什么是chunk？chunk是堆中一些连续的内存块，可以用作分配，释放，拆分，合并。不存在两个连续的释放chunk，这是在于相邻的chunk会合并。
2.数据结构
123456struct malloc_chunk &amp;#123;	INTERNAL_SIZE_T prev_size; //当前chunk前一个chunk的大小，仅在前一个为freed才使用	INTERNAL_SIZE_T size;      //当前chunk的大小	struct malloc_chunk * fd;  //如果当前为释放chunk，指向双向free list中前一个chunk	st
          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/04/23/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/04/21/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/">Protostar-堆溢出学习-UAF(use after free)</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-04-21T03:12:19.000Z">2017-04-21</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/" target="_blank">4chendy</a>

                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/04/21/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/04/21/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            0x00 序
下面看一个堆中常见的漏洞-UAF(use after free)

0x01 C语言源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;struct auth &amp;#123;  char name[32];  int auth;&amp;#125;;struct auth *auth;char *service;int main(int argc, char **argv)&amp;#123;  char line[128];  while(1) &amp;#123;      printf(&quot;[ auth = %p, service = %p ]\n&quot;, auth, service);      if(fgets(line, sizeof(line), stdin) == NULL) break;            if(strncmp(line, &quot;auth &quot;, 5) == 0) &amp;#123;          auth = malloc(sizeof(auth));          memset(auth, 0, sizeof(auth));          if(strlen(line + 5) &amp;lt; 31) &amp;#123;              strcpy(auth-&amp;gt;name, line + 5);          &amp;#125;      &amp;#125;      if(strncmp(
          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/04/21/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/04/19/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/">Protostar-堆溢出学习-strcpy堆指针造成任意地址GOT表写</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-04-19T03:12:19.000Z">2017-04-19</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/" target="_blank">4chendy</a>

                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/04/19/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/04/19/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            0x00 序
 现在我们来学习一下利用堆溢出修改GOT表达到代码劫持的列子。

0x01 C语言源代码123456789101112131415161718192021222324252627282930313233#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;struct internet &amp;#123;  int priority;  char *name;&amp;#125;;void winner()&amp;#123;  printf(&quot;and we have a winner @ %d\n&quot;, time(NULL));&amp;#125;int main(int argc, char **argv)&amp;#123;  struct internet *i1, *i2, *i3;  i1 = malloc(sizeof(struct internet));  i1-&amp;gt;priority = 1;  i1-&amp;gt;name = malloc(8);  i2 = malloc(sizeof(struct internet));  i2-&amp;gt;priority = 2;  i2-&amp;gt;name = malloc(8);  strcpy(i1-&amp;gt;name, argv[1]);  strcpy(i2-&amp;gt;name, argv[2]);  printf(&quot;and that&#39;s a wrap folks!\n&quot;);&amp;#125;
0x02 简单的分析&amp;amp;思考如果之前没有相关的漏洞利用经验的话，一时还是想不到怎么去利用这个堆溢出漏洞。但这里有两个strcpy，肯定是要去覆盖和修改某个
          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/04/19/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/04/18/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/">Protostar-堆溢出学习-覆盖堆函数指针劫持代码流</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-04-18T03:12:19.000Z">2017-04-18</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/" target="_blank">4chendy</a>

                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/04/18/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/04/18/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            0x00 序
 学习了栈溢出相关的漏洞利用技巧，下面进入堆溢出相关。和栈溢出一样，从最简单的堆溢出开始，看看是如何利用堆溢出去控制程序的执行流程的。

0x01 C语言源代码C代码
12345678910111213141516171819202122232425262728293031323334353637383940#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;struct data &amp;#123;  char name[64];&amp;#125;;struct fp &amp;#123;  int (*fp)();&amp;#125;;void winner()&amp;#123;  printf(&quot;level passed\n&quot;);&amp;#125;void nowinner()&amp;#123;  printf(&quot;level has not been passed\n&quot;);&amp;#125;int main(int argc, char **argv)&amp;#123;  struct data *d;  struct fp *f;  d = malloc(sizeof(struct data));  f = malloc(sizeof(struct fp));  f-&amp;gt;fp = nowinner;  printf(&quot;data is at %p, fp is at %p\n&quot;, d, f);  strcpy(d-&amp;gt;name, argv[1]);    f-&amp;gt;fp();&amp;#125;
0x02 简单分析&amp;amp;思考先在堆上分配了一个data和fp的结构体，然后使fp指向nowinner函数，然后打
          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/04/18/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/04/17/Protostar-栈溢出系列学习-format 0/Protostar-栈溢出系列学习-format 0/">Protostar-栈溢出学习-printf格式%n任意地址写</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-04-17T03:12:19.000Z">2017-04-17</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/" target="_blank">4chendy</a>

                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/04/17/Protostar-栈溢出系列学习-format 0/Protostar-栈溢出系列学习-format 0/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/04/17/Protostar-栈溢出系列学习-format 0/Protostar-栈溢出系列学习-format 0/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            0x00 序
从现在开始我们先结束stack类型的漏洞，来学习一些format类型的漏洞，非常有趣。但也确实让我想了很久。

0x01 C语言源代码1234567891011121314151617181920#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;int target;void vuln(char *string)&amp;#123;  printf(string);    if(target) &amp;#123;      printf(&quot;you have modified the target :)\n&quot;);  &amp;#125;&amp;#125;int main(int argc, char **argv)&amp;#123;  vuln(argv[1]);&amp;#125;
0x02 疑惑&amp;amp;分析&amp;amp;思考拿到这题，我和大家一样，哪里有可以利用的漏洞？？？就将一个命令行参数打印出来，很明显是让我们修改全局变量target的值。但好像除了printf()函数，就没有其他可疑的地方了。what fuck？ 一个printf()函数怎么会有漏洞？
但仔细观察可以发现这次printf的用法有点奇怪，直接打印一个字符串地址，很少会这样用，会不会就是这里？？？
0x03 测试其他不说，先运行下程序试试再试着输入格式字符试试很奇怪，我们貌似得到一些栈中的值，再多打印一些试试可以看到后面打印出来了%x本身&amp;lt;—20782520，通过linux stack layout可得知后面的确保存着参数字符串
123456789101112131415161718...local variables of mainsaved registers of mainr
          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/04/17/Protostar-栈溢出系列学习-format 0/Protostar-栈溢出系列学习-format 0/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/04/16/Protostar-栈溢出系列学习-Stack 3/Protostar-栈溢出系列学习-Stack 3/">Protostar-栈溢出学习-ROP执行shellcode</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-04-16T03:12:19.000Z">2017-04-16</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/" target="_blank">4chendy</a>

                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/04/16/Protostar-栈溢出系列学习-Stack 3/Protostar-栈溢出系列学习-Stack 3/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/04/16/Protostar-栈溢出系列学习-Stack 3/Protostar-栈溢出系列学习-Stack 3/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            0x00 序
 和前面的栈溢出系列，我们覆盖了返回地址，通过ret控制eip使其执行我们在栈上存放的shellcode。这次，我们做了一些栈上的限制，比如现在的操作体系都会有DSP，ASLR等保护。本文就借此来学习一些ROP的知识。

0x01 stack3123456789101112131415161718192021222324252627282930#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;void getpath()&amp;#123;  char buffer[64];  unsigned int ret;  printf(&quot;input path please: &quot;); fflush(stdout);  gets(buffer);  ret = __builtin_return_address(0);  if((ret &amp;amp; 0xbf000000) == 0xbf000000) &amp;#123;      printf(&quot;bzzzt (%p)\n&quot;, ret);      _exit(1);  &amp;#125;  printf(&quot;got path %s\n&quot;, buffer);&amp;#125;int main(int argc, char **argv)&amp;#123;  getpath();&amp;#125;
0x02 思路&amp;amp;分析整体上和前面的没太大区别，现在有个问题在于__builtin_return_address()会返回当前的返回地址值，然后后面ret &amp;amp; 0xbf000000) == 0xbf000000对其返回地址进行了限制–返回地址不能是0xbf为前缀，正好是栈的前缀。这样的话就不能像之前那样直接返回
          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/04/16/Protostar-栈溢出系列学习-Stack 3/Protostar-栈溢出系列学习-Stack 3/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/04/15/Protostar-栈溢出系列学习-Stack 2/Protostar-栈溢出系列学习-Stack 2/">Protostar-栈溢出学习-ret跳转到自定义shellcode</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-04-15T03:12:19.000Z">2017-04-15</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/" target="_blank">4chendy</a>

                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/04/15/Protostar-栈溢出系列学习-Stack 2/Protostar-栈溢出系列学习-Stack 2/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/04/15/Protostar-栈溢出系列学习-Stack 2/Protostar-栈溢出系列学习-Stack 2/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            0x00 序
 经过前面的学习，我们已经了解了简单的栈溢出利用手段，建议看本文章前先看下前面的分析。这次我们来做点有趣的事，我们引入shellcode。

0x01 C语言源代码Stack5 is a standard buffer overflow, this time introducing shellcode.
This level is at /opt/protostar/bin/stack5
Hints:At this point in time, it might be easier to use someone elses shellcodeIf debugging the shellcode, use \xcc (int3) to stop the program executing and return to the debuggerremove the int3s once your shellcode is done.
1234567891011#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;int main(int argc, char **argv)&amp;#123;  char buffer[64];  gets(buffer);&amp;#125;
0x02 思路&amp;amp;分析和前面的一样，我们可以通过覆盖返回地址然后由ret指令跳转到目标地址，但这次我们没有了win()函数，那我们应该跳转到哪里呢？没错，还是跳到栈上。要达到执行代码的目的，所以我们需要在栈上写入shellcode。Here we go！
0x03 调试&amp;amp;hack
对应汇编，我们在0x080483da &amp;lt;main+22&amp;gt;: 
          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/04/15/Protostar-栈溢出系列学习-Stack 2/Protostar-栈溢出系列学习-Stack 2/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/04/13/Protostar-栈溢出系列学习-Stack 1/Protostar-栈溢出系列学习-Stack 1/">Protostar-栈溢出学习-覆盖栈函数指针和ret指令控制eip</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-04-13T03:12:19.000Z">2017-04-13</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/" target="_blank">4chendy</a>

                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/04/13/Protostar-栈溢出系列学习-Stack 1/Protostar-栈溢出系列学习-Stack 1/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/04/13/Protostar-栈溢出系列学习-Stack 1/Protostar-栈溢出系列学习-Stack 1/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            0x00 序
 接着之前的系列，下面研究两种控制eip的方式

0x01 C语言源代码Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP)
Hints:both gdb and objdump is your friend you determining where the win() function lies in memory.
123456789101112131415161718192021222324#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;void win()&amp;#123;  printf(&quot;code flow successfully changed\n&quot;);&amp;#125;int main(int argc, char **argv)&amp;#123;  volatile int (*fp)();  char buffer[64];  fp = 0;  gets(buffer);  if(fp) &amp;#123;      printf(&quot;calling function pointer, jumping to 0x%08x\n&quot;, fp);      fp();  &amp;#125;&amp;#125;

在main函数下断点，分析可知，1处为fp的地址，2处为fp()的调用，我们需要覆盖掉esp+0x5c处所存的函数指针值，使其跳转到win()函数

利用Pyth
          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/04/13/Protostar-栈溢出系列学习-Stack 1/Protostar-栈溢出系列学习-Stack 1/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/04/11/Protostar-栈溢出系列学习-Stack 0/Protostar-栈溢出系列学习-Stack 0/">Protostar-栈溢出学习-简单栈溢出修改局部变量值</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-04-11T03:12:19.000Z">2017-04-11</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/" target="_blank">4chendy</a>

                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/04/11/Protostar-栈溢出系列学习-Stack 0/Protostar-栈溢出系列学习-Stack 0/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/04/11/Protostar-栈溢出系列学习-Stack 0/Protostar-栈溢出系列学习-Stack 0/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            0x01 序
 为了加强自己在漏洞利用方面的能力，准备做一个栈溢出和堆溢出利用的系列学习，从最简单的栈溢出学习开始，学习平台是本地搭建的一个基于linux系统的Protostar学习虚拟机环境，里面有从易到难的示例溢出漏洞程序。那就开始吧！

0x01 Protostar虚拟机环境搭建虚拟机下载地址
虚拟机环境搭建视频教程
默认用户名和密码:

user:user 
root:godmode

虚拟机启动后，输入bash进入终端界面
漏洞程序在/opt/protostar/bin目录下
0x01 C语言源代码This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution.
This level is at /opt/protostar/bin/stack0
123456789101112131415161718#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;int main(int argc, char **argv)&amp;#123;  volatile int modified;  char buffer[64];  modified = 0;  gets(buffer);  if(modified != 0) &amp;#123;      printf(&quot;you have changed the &#39;modified&#39; vari
          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/04/11/Protostar-栈溢出系列学习-Stack 0/Protostar-栈溢出系列学习-Stack 0/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Siguiente</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright"><div class="padding">
	
	  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" autocomplete="off" name="q" maxlength="20" results="0" placeholder="Buscar">
    <input type="hidden" name="q" value="site:github.com/NULL-ME/NULL-ME.github.io.git">
  </form>
</div>
	
	  
	
	  
<div class="widget recent-post">
  <h3 class="title">Entradas Recientes</h3>
  <ul class="entry">
    
      <li>
        <a href="/2017/04/26/Protostar-堆溢出系列学习-heap 3/Protostar-堆溢出系列学习-heap 3/">Protostar-堆溢出学习-滥用堆metadata重定向程序执行</a>
      </li>
    
      <li>
        <a href="/2017/04/23/Linux堆分配器-DLMalloc/Linux堆分配器-DLMalloc/">深入理解Linux堆分配器-DLMalloc</a>
      </li>
    
      <li>
        <a href="/2017/04/21/Protostar-堆溢出系列学习-heap 2/Protostar-堆溢出系列学习-heap 2/">Protostar-堆溢出学习-UAF(use after free)</a>
      </li>
    
      <li>
        <a href="/2017/04/19/Protostar-堆溢出系列学习-heap 1/Protostar-堆溢出系列学习-heap 1/">Protostar-堆溢出学习-strcpy堆指针造成任意地址GOT表写</a>
      </li>
    
      <li>
        <a href="/2017/04/18/Protostar-堆溢出系列学习-heap 0/Protostar-堆溢出系列学习-heap 0/">Protostar-堆溢出学习-覆盖堆函数指针劫持代码流</a>
      </li>
    
  </ul>
</div>

	
	  
<div class="widget tagcloud">
  <h3 class="title">Nube de Etiquetas</h3>
  <div class="entry">
    <a href="tags/BSD/" style="font-size: 10px;">BSD</a> <a href="tags/C/" style="font-size: 10px;">C++</a> <a href="tags/Crackme/" style="font-size: 10px;">Crackme</a> <a href="tags/DLMalloc/" style="font-size: 10px;">DLMalloc</a> <a href="tags/GOT表/" style="font-size: 10px;">GOT表</a> <a href="tags/IPC/" style="font-size: 10px;">IPC</a> <a href="tags/Linux/" style="font-size: 20px;">Linux</a> <a href="tags/Protostar/" style="font-size: 20px;">Protostar</a> <a href="tags/UAF/" style="font-size: 10px;">UAF</a> <a href="tags/cve/" style="font-size: 10px;">cve</a> <a href="tags/dyld/" style="font-size: 10px;">dyld</a> <a href="tags/format/" style="font-size: 10px;">format</a> <a href="tags/free/" style="font-size: 10px;">free</a> <a href="tags/gdb/" style="font-size: 10px;">gdb</a> <a href="tags/heap/" style="font-size: 10px;">heap</a> <a href="tags/iOS/" style="font-size: 10px;">iOS</a> <a href="tags/linux/" style="font-size: 13.33px;">linux</a> <a href="tags/macOS内核/" style="font-size: 10px;">macOS内核</a> <a href="tags/mach/" style="font-size: 10px;">mach</a> <a href="tags/mach-o/" style="font-size: 10px;">mach-o</a> <a href="tags/macos内核/" style="font-size: 10px;">macos内核</a> <a href="tags/malloc/" style="font-size: 10px;">malloc</a> <a href="tags/metadata/" style="font-size: 10px;">metadata</a> <a href="tags/printf/" style="font-size: 10px;">printf</a> <a href="tags/strcpy/" style="font-size: 10px;">strcpy</a> <a href="tags/stub/" style="font-size: 10px;">stub</a> <a href="tags/vm/" style="font-size: 13.33px;">vm</a> <a href="tags/vtable/" style="font-size: 10px;">vtable</a> <a href="tags/xnu/" style="font-size: 10px;">xnu</a> <a href="tags/堆溢出/" style="font-size: 16.67px;">堆溢出</a> <a href="tags/栈溢出/" style="font-size: 16.67px;">栈溢出</a> <a href="tags/看雪/" style="font-size: 10px;">看雪</a> <a href="tags/调试/" style="font-size: 10px;">调试</a>
  </div>
</div>

	
	  <iframe width="100%" height="120" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=10&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=5594792135&verifier=676ff25e&dpc=1"></iframe>
	
	  <div class="widget category">
	<h3 class="title">Link</h3>
	<ul class="entry">
		
        	<li><a href="https://www.google.com/">Google</a></li>
      	
        	<li><a href="https://github.com/">Github</a></li>
      	
        	<li><a href="https://null-me.github.io/">4ch12dy</a></li>
      	
	</ul>
</div>
	
</div></aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="padding">
	<div class="alignleft">
	  
	  Copyright&copy;2013-2017 <a href=" / ">4chendy</a>
	  
	  | Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  and Theme by <a href="https://github.com/hijiangtao/dark-tech/" target="_blank">Dark-Tech</a> | <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000257487'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1000257487' type='text/javascript'%3E%3C/script%3E"));</script>
	</div>

	<div class="alignright">
		
		
			<a href="https://github.com/https://github.com/NULL-ME" target="_blank" title="4chendy Github"><i class="fa fa-github-square"></i></a>	
		
		
			<a href="https://twitter.com/https://twitter.com/4chendy" target="_blank" title="4chendy Twitter"><i class="fa fa-twitter-square"></i></a>	
		
		
			<a href="http://www.weibo.com/http://weibo.com/hijiangtao" target="_blank" title="4chendy Weibo"><i class="fa fa-weibo"></i></a>	
		
		
		
		
			<a href="/dark-tech/atom.xml" target="_blank" title="4chendy RSS"><i class="fa fa-rss-square"></i></a>
		
	</div>

	<div class="clearfix"></div>
</div>

<div class="scroll-top"><i class="fa fa-arrow-circle-up"></i></div>
</footer>
  

<script type="text/javascript">
var duoshuoQuery = {short_name:"datablog"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>



<script src="//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/3.0.4/jquery.imagesloaded.js"></script>
<script src="/js/gallery.js"></script>



<script type="text/javascript">
$(window).scroll(function() {

    if($(this).scrollTop() > 400) {
        $('.scroll-top').fadeIn(200);
    } else {
        $('.scroll-top').fadeOut(200);
    }
});

$('.scroll-top').bind('click', function(e) {
    e.preventDefault();
    $('body,html').animate({scrollTop:0},200);
});
</script>

</body>
</html>
